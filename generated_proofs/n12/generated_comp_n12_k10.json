{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 4,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "41d3d96b6b3d0a267bb09893b5f851d658234ad7",
        "torch_seed": 77
    },

    "projects": {
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold is_group in H0.\napply H0.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H0; trivial.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  apply H0.\n  apply H0.\n  assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nrewrite H.\napply H0.\napply H1.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold is_group in H0.\nelim H0; intros x0 y0; elim H1; intros x1 y0; elim H2; intros H3 H4.\nrewrite H4.\nrewrite H5.\nrewrite H5.\nrewrite H6.\nrewrite H2.\nrewrite H6.\nrewrite H4.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nrewrite H5.\nrewrite H6.\nrewrite H6.\nrewrite <- H7.\nrewrite <- H6.\nrewrite <- H7.\nrewrite H6.\nrewrite H7.\nrewrite <- H7.\nrewrite <- H7.\nrewrite H8.\nrewrite <- H7.\nrewrite <- H7.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- H8.\nrewrite <- HQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  unfold is_group in H0.\n  elim H0; intros.\n  unfold G in H2.\n  elim H2; intros.\n  unfold G in H3.\n  elim H3; intros.\n  unfold G in H4.\n  elim H3; intros.\n  unfold G in H4.\n  elim H4; intros.\n  unfold G in H4.\n  elim H5; intros.\n  unfold G in H5.\n  elim H5; intros.\n  apply H5; assumption.\n  unfold G in H4.\n  elim H5; intros.\n  unfold G in H4.\n  elim H5; intros.\n  unfold G in H4.\n  elim H5; intros.\n  unfold G in H5.\n  elim H6; intros.\n  unfold G in H6.\n  elim H6; intros.\n  unfold G in H7.\n  elim H7; intros.\n  unfold G in H8.\n  elim H8; intros.\n  unfold G in H8.\n  elim H9; intros.\n  unfold G in H8.\n  elim H9; intros.\n  unfold G in H8.\n  elim H8; intros.\n  unfold GQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold G in |- *.\napply (Build_group_eq (S:=fun x : S => ~ S x)).\napply (Build_group_eq (S:=fun x : S => ~ S x)).\nexact (H (S:=fun x : S => ~ S x)).\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros z y z; rewrite <- (H z); reflexivity.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nrewrite H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H0.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- HQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold is_group in H0.\napply H0.\napply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H4; intros; elim H4; clear H4 H5 H7.\nintros.\nrewrite (Ropp_involutive y1 H1) in H3.\nrewrite (Ropp_involutive y1 H2) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in H3.\nrewrite (Ropp_involutive y1 H3) in HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; clear H4 H5.\n(* use of neutral *)\nelim (H3 (Add x1 y1)); intros; elim H5; intros; elim H6; intros;\n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H9; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nclear H4 H5 H7 H8 H10 H11.\nrewrite <- H1; rewrite <- H2; rewrite <- H3; rewrite <- H4;\n rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4;\n rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4;\n rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4;\n rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4;\n rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4;\n rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4;\n rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; rewrite <- H4;\n rewrite <- H4; rewrite <-Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H4; intros; elim H4; intros; elim H4;\n clear H4 H5 H6 H7 H8 H9 H10 H11.\n(* use of sign *)\nelim (H2 (Add (Add x1 y1) (Add (Add x1 y1) (Add (Add x1 y2) (Add x1 y2) (Add x1 y2) H)).\nintro; elim H3; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; apply H5; split; apply (Add_intro x1 y1 H3 H4);\n auto with sets.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros.\nclear H3 H5 H7 H10 H11.\nrewrite (Ropp_involutive (Add x1 y1) (Add x2 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2)).\nrewrite (Ropp_involutive (Add x1 y1)); rewrite (Ropp_involutive (Add x1 y2Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H0; intros; elim H3; clear H3; intros; elim H3; clear H3; intros;\n elim H3; clear H3; intros; elim H4; clear H4 H5 H6;\n elim (H6 (Add x1 y1)); intros; elim H6; clear H6; intros;\n elim H6; clear H7; intros; elim H7; clear H8; \n elim (H7 x H3); intros; elim H7; clear H8; \n elim (H7 x H3); intros; elim H7; clear H7; \n elim (H8 x H3); intros; elim H8; clear H8; \n elim (H8 x H3); intros; elim H8; clear H8; \n elim (H8 x H4); intros; elim H8; clear H8; \n elim (H9 x H4); intros; elim H8; clear H8; \n elim (H8 x H4); intros; elim H8; clear H8; \n elim (H9 x H3); intros; elim H8; clear H8; \n elim (H8Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H5; clear H5.\nelim (H1 y H1); intros; elim H5; clear H5.\nelim (H1 y H1); intros; elim H5; clear H5.\nelim (H1 y H2); intros; elim H6; clear H6.\nelim (H2 y H3); intros; elim H6; clear H7.\nelim (H2 y H3); intros; elim H6; clear H7.\nelim (H3 y H3); intros; elim H6; clear H7.\nelim (H4 y H3); intros; elim H6; clear H7.\nelim (H4 y H5); intros; elim H6; clear H7.\nelim (H5 y H6); intros; elim H6; clear H6.\nelim (H5 y H6); intros; elim H6; clear H6.\nelim (H6 y H6); intros; elim H7; clear H7.\nelim (H6 y H7); intros; elim H8; clear H8.\nelim (H7 y H8Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\napply add_comm.\napply add_reg_l with (x := x1) (y := y1); assumption.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros.\nclear H3 H4 H6 H8 H10.\nrewrite (add_comm x1 y1); rewrite (add_comm y2 y2); rewrite (add_comm y1); rewrite (add_comm y1);\n rewrite (add_comm y2 y1); rewrite (add_comm y1); rewrite (add_comm y2); rewrite (add_comm y1);\n rewrite (add_comm y2 y1); rewrite (add_comm y1); rewrite (add_comm y2);\n rewrite (add_comm y1 y2); rewrite (add_comm y1); rewrite (add_comm y1);\n rewrite (add_comm y1 y2); rewrite (add_comm y1); rewrite (add_comm y2);\n rewrite (add_comm y2 y1); rewrite (add_comm y1); rewrite (add_comm y2);\n rewrite (add_comm y1); rewrite (add_comm y2); rewrite (add_comm y1);\n rewrite (add_comm y1); rewrite (add_commQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H11; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H11; \n intros; elim H10; intros; elim H10; intros; \n elim H10Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n clear H3 H3 H4 H5 H6 H7 H8 H9 H10 H11.\nrewrite <- (Ropp_involutive (Add x1 y1) (Add y1 y2));\n rewrite (Ropp_involutive (Add x1 y1) (Add y1 y2)); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H10; \n intros; elim H9; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nclear H4 H5 H6 H7.\nrewrite (ring_add (S x) (S y) (S y)); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H9; \n intros; elim H10; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nclear H0.\nrewrite (plus_comm x1 y1); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (add_comm x).\nrewrite (add_comm x).\nrewrite (add_comm y).\nrewrite (add_comm x).\nrewrite (add_comm y).\nrewrite (add_assoc x).\nrewrite (add_assoc x).\nrewrite (add_assoc y).\nrewrite (add_comm y).\nrewrite (add_assoc x).\nrewrite (add_assoc x).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewrite (add_assoc y).\nrewriteQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (add_comm x y); rewrite (add_comm y x); rewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm x y); rewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm y x); rewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm y x); rewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm x y); rewrite (add_comm y x);rewrite (add_comm y x).\nrewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm y x); rewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm y x); rewrite (add_comm y x); rewrite (add_comm y x).\nrewrite (add_comm y x);rewrite (add_comm y x);rewrite (add_comm y x).\nrewrite (add_comm y xQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n clear H3 H4 H5 H6 H7 H8 H9 H10.\nrewrite <- (mult_comm (S x0)) (S x0) (S y0); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; clear H2.\nelim (H1 y H1); intros; elim H3; clear H3.\nelim (H3 y H1); intros; elim H5; clear H5 H6.\nelim (H4 y H1); intros; elim H5; clear H5 H6.\nrewrite (add_comm (S x1) (S y2)); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutiveQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\ncase (Rle_dec x 0); intro.\nrewrite H; rewrite H; rewrite H0; reflexivity.\n(* [0=(-x)=x] *)\nelim H0; intros; rewrite H; clear H0.\nrewrite <- H0; rewrite H0; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)); rewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv y)).\nrewrite (inj_eq (Inv x) (Inv x)).\nrewrite (inj_eq (Inv x) (Inv y)).\nrewrite (inj_eq (Inv x) (Inv xQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H0; intros.\nrewrite H; rewrite H0; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive y); rewrite (opp_involutive x).\nrewrite (opp_involutive y); rewrite (opp_involutive x).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive x).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive x); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive x).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive x); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (oppQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros; elim H; auto with *.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (Build_R (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => y) (fun x y => x) (fun y x y => x) (fun x y => x) (fun x y => y) (fun x y => x) (fun x y y => x) (fun x y => y) (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => x) (fun x y => x) (fun y y => x) (fun x y => x) (fun x y y) (fun x y => x) (fun x y => x) (fun x y y => x) (fun x y => x) (fun x y y => x) (fun x y y) (fun x y => x) (fun x y y => x) (fun x y => x) (fun x y y => x) (funQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (add_comm (x:=x)); rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (x:=x)); rewrite (opp_involutive (x:=x));\n rewrite (opp_involutive (xQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; rewrite H; clear H2 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11.\n(* [0=(x)=0] *)\nelim H1; intros; rewrite H; clear H0 H1 H3 H4 H6 H7.\n(* [0=(x)=x] *)\nelim H4; intros; rewrite H; clear H0 H4 H4 H6 H7 H8 H9 H10.\n(* [x=0] *)\nelim H4; intros; rewrite H; clear H0 H4 H5 H6 H7 H10.\n(* [0=(x)=x] *)\nelim H4; intros; rewrite H; clear H0 H4 H6 H7 H8 H9 H10.\n(* [0=(x)=x] *)\nelim H4; intros; rewrite H; clear H0 H4 H5 H6 H7 H8 H9.\n(* [x+y=x] *)\nelim H4; intros; rewrite H; clear HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply is_group_is_group.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": ". \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Equivalence x) (Equivalence y) (Equivalence y)); auto.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H0; intros; elim H2; intros; auto.\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y);Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_transitive H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add x y)).\nunfold is_group in |- *; intros.\napply (opp_transitive H (Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H6; \n clear H4 H6 H7; intros; elim H8; intros; elim H8; \n clear H8; intros; elim H8; \n clear H8; intros; elim H8; \n clear H8; intros; elim H8; clear H8; intros; elim H8; \n clear H8; intros; elim H8; clear H8; intros; elim H8; \n clear H8; intros; elim H8; clear H8; intros; elim H8; \n clear H9; intros; elim H8; clear H8; \n intros; elim H8; clear H9; intros; elim H9; \n clear H9; intros; elim H8; clear H9; intros; elim H9; \n clear H9; intros; elim H9; \n clear H9Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) (Add y x)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Add x y) (Add y x)).\nunfold is_linear in |- *; split.\napply (opp_unicity H (Add x y) (Add y x)).\napply (opp_unicity H (Add x y) (Add y x)).\napply (opp_unicity H (Add x y) (Add y x)).\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H7; intros; elim H8; intros; elim H8; intros;\n elim H8; intros; elim H9; intros; elim H9; intros; elim H9; \n clear H9; intros; elim H9; intros; elim H9; \n clear H10; intros; elim H9; intros; elim H10; \n clear H10; intros; elim H9; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H10; \n clear H10; intros; elim H10; \n clear H10; intros; elim H10; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H0; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H5; intros; clear H4 H5 H6 H7;\n elim H8; intros; elim H7; intros; elim H8; intros; clear H8 H9;\n elim H9; intros; elim H8; intros; clear H8 H9;\n elim H9; intros; elim H8; intros; clear H9; \n elim H9; intros; elim H9; clear H9; intros; elim H9; \n clear H9; intros; elim H9; intros; clear H9; \n elim H9; intros; elim H9; clear H9; \n clear H9; intros; elim H9; intros; clear H9; \n elim H9; clear H9; intros; elim H10; clear H9; \n clear H9; intros; elim H9; intros; elim H10; \n clear H10; intros; elim H9; clear H10; \n clear H10;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H4; intros; clear H2 H3 H4 H5 H6 H7 H8 H8 H9 H10.\nrewrite <- (Ropp_involutive x); rewrite <- (Ropp_involutive y); rewrite <- (Ropp_involutive y);\n rewrite <- (Ropp_involutive x); rewrite <- (Ropp_involutive y); rewrite <- (Ropp_involutive y);\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply Ropp_involutive; apply Ropp_involutive; apply Ropp_involutive;\n apply RoppQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_loop (Add (Add x y) (Add y (Add x y))).\napply (opp_morph (Add (Add x y) (Add x y) (Add x y))).\napply (opp_morph (Add x y) (Add (Add y y) (Add (Add x y) (Add x y)))).\napply (opp_morph (Add x y) (Add (Add x y) (Add x y))).\napply (opp_morph (Add x y) (Add (Add x y) (Add (Add x y) (Add x y)))).\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) (Ropp_div y x)).\nunfold is_group in |- *; split.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; clear H4 H5 H6.\nelim H3; intros; elim H4; intros; elim H4; intros; clear H4 H5 H6.\nelim H4; intros; elim H4; intros; elim H5; intros; clear H5 H6.\nelim H5; intros; elim H5; intros; elim H6; intros; clear H5 H6.\nelim H6; intros; elim H6; intros; clear H6 H7.\nelim H6; intros; elim H6; intros; clear H6 H7.\nelim H7; intros; elim H7; intros; clear H7.\nelim H7; intros; elim H8; intros; elim H8; intros; clear H8 H9.\nelim H8; intros; elim H8; intros; elim H8; intros; clear H8 H9.\nelim H8; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_unicity H (Add O H) (Add (Opp (A:=A) (opp_morphism A) H)).\nunfold is_group in |- *; simpl in |- *; intros.\nrewrite H.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutive.\napply opp_involutiveQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_unicity H (Opp 0 H) (Opp 0 H)).\nunfold is_group in |- *; simpl in |- *; unfold Opp in |- *;\n simpl in |- *; intros; ring.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros; apply (opp_unicity H (Opp m)).\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_unicity H (Opp (O:=O) H)).\nunfold is_group in |- *; unfold is_group in |- *; unfold is_group in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *; \n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_set in |- *; unfold group_set in |- *;\n unfold group_set in |- *; unfold group_Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold is_group; intros.\nsplit.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim (H3 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2 (Ar2Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros.\napply (opp_transitive H (Ar O)).\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n",
                "context_tokens": 44,
                "proof_start_offset": 215,
                "proof_end_offset": 725,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hab Hab.\n destruct Hab as [Hc| Hd].\n (* b<>0 *)\n destruct Hd as [Hc| Hd].\n (* b<>0 *)\n destruct Hd as [Hc| Hd].\n (* b<>0 *)\n destruct Hd as [Hc| Hd].\n (* d<>0 *)\n rewrite Hd in Hd.\n rewrite Hc in Hd.\n assert (H : (0 < Z.sgn c)%Z).\n apply Z_lt_gt; assumption.\n apply Z.lt_gt; assumption.\n apply Z.lt_gt; assumption.\n apply Z.lt_gt; assumption.\n (* d<>0 *)\n rewrite Hd in Hd.\n assert (H : (0 < Z.sgn c)%Z).\n apply Z.lt_gt; assumption.\n apply Z.lt_gt; assumption.\n apply Z.lt_gt; assumption.\n (* d<>0 *)\n rewrite Hd in Hd.\n assert (H : (0 < Z.sgn c)%Z).\n apply Z_lt_gt; assumption.\n apply Z.lt_gt; assumption.\n apply Z.lt_gt; assumption.\n (* dQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n   intros.\n   destruct (Z_eq_dec a b) as [Ha|Ha].\n   (* b<>0 *)\n   apply Z.lt_le_trans with (b := (c - d)%Z).\n   rewrite Zmult_comm.\n   rewrite Zmult_comm.\n   rewrite Zmult_comm.\n   rewrite Zmult_assoc.\n   rewrite Zmult_assoc.\n   rewrite (Zplus_comm b).\n   rewrite Zmult_assoc.\n   rewrite (Zmult_comm c d).\n   rewrite Zmult_assoc.\n   rewrite (Zplus_comm b).\n   rewrite (Zmult_comm b).\n   rewrite Zmult_assoc.\n   rewrite Zmult_assoc.\n   rewrite (Zmult_comm b).\n   rewrite Zmult_assoc.\n   rewrite (Zplus_comm b).\n   rewrite (Zmult_comm b).\n   rewrite (Zmult_comm b).\n   rewrite Zmult_assoc.\n   rewrite (Zmult_comm b).\n   rewrite Zmult_assoc.\n   rewrite (Zmult_comm b).\n   rewrite Zmult_assoc.\n   rewrite (Zmult_comm b).\n   rewrite Zmult_assoc.\n   rewrite Zmult_assoc.\n   rewrite (Zmult_comm b).\n   rewrite Zmult_assoc.\n   rewrite Zmult_assoc.\n   rewrite (Zmult_comm b).Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hab Hcd Hab.\n destruct (Z_lt_gt_dec 0 a) as [H|H].\n (* b = c *)\n rewrite (Z.sgn_pos_neg_neg a) in Hab.\n rewrite Hab.\n apply Z.sgn_pos.\n (* b > 0 *)\n destruct (Z_lt_gt_dec 0 b) as [H|H].\n (* b > 0 *)\n rewrite (Z.sgn_pos_neg a) in Hab.\n rewrite Hab.\n rewrite Hab.\n apply Z.sgn_neg.\n (* b > 0 *)\n rewrite (Z.sgn_pos_neg a) in Hab.\n rewrite Hab.\n apply Z.sgn_neg.\n (* b > 0 *)\n apply Z.sgn_pos.\n (* b > 0 *)\n rewrite (Z.sgn_neg_neg a) in Hab.\n rewrite Hab.\n rewrite Hab.\n apply Z.sgn_neg.\n (* b > 0 *)\n rewrite (Z.sgn_neg_neg a) in Hab.\n rewrite Hab.\n apply Z.sgn_neg.\n (* b > 0 *)\n rewrite (ZQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hab Hab.\n destruct (Z_eq_dec c d) as [H|H];\n  [ rewrite H; rewrite H | rewrite H ];\n  [ rewrite H | rewrite H | rewrite H | rewrite H ];\n  [ rewrite H | rewrite H | rewrite H ];\n  [ rewrite H | rewrite H | rewrite H ];\n  [ rewrite H | rewrite H | rewrite H ];\n  [ rewrite H | rewrite H | rewrite H ];\n  [ rewrite H | rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];\n  [ rewrite H | rewrite H ];Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hab Hcd Hab.\n destruct (Z_lt_gt_dec c d) as [H|H]; [discriminate | idtac ];\n  [ apply Z.lt_gt_cases; apply Z.lt_gt_cases; assumption | idtac];\n  [ apply Z.lt_gt_cases; assumption | idtac ];\n  [ apply Z.lt_gt_cases; assumption | idtac ];\n  [ apply Z.le_lt_gt_cases; assumption | idtac];\n  [ apply Z.lt_le_trans with (S (S (S (S (S a))); [apply Z.le_succ_l | idtac ];\n  apply Z.lt_le_trans with (S (S (S (S a))); [apply Z.le_succ_l | idtac ];\n  apply Z.le_lt_trans with (S (S (S a))); [apply Z.le_succ_l | idtac ];\n  apply Z.le_lt_trans with (S (S a)); [ apply Z.le_succ_l | idtac ];\n  apply Z.lt_le_trans with (S (S (S (S a))); [apply ZQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hb Hc Hc.\n destruct (Z_div_eucl_eq a b c d) as [H|H];\n  [ apply Z.le_lt_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.le_lt_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.le_lt_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.lt_le_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.gt_lt; apply Z.lt_le_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.ge_le_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.le_ge_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.le_lt_trans with (m := b) | apply Z.gt_lt];\n  [ apply Z.le_ge_trans with (m := b) | apply Z.gt_ltQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros.\n destruct (Z_le_gt_dec 0 a) as [H|H].\n left. apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.ltQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hb Hc Hc.\n destruct (Z_lt_ge_dec c d).\n left.\n assert (Z.pos b > 0)%Z. omega.\n apply Z.pos_gt_0_lt_reg_l with b.\n rewrite Zmult_comm.\n rewrite (Z_div_mod a b c d).\n rewrite (Z_div_mod b d).\n rewrite (Z_div_mod b d).\n rewrite (Z_div_mod b d).\n rewrite (Z_div_mod b d).\n rewrite (Z_div_mod d d).\n rewrite Z_div_mod.\n rewrite Z_div_mod.\n rewrite Z_div_mod.\n rewrite Z_div_mod.\n rewrite Z_div_mod.\n rewrite Z_div_mod.\n rewrite Z_mod_eq.\n rewrite Z.div_mod.\n rewrite Z_mod_eq.\n rewrite Z_mod_eq.\n rewrite Z_mod_eq.\n rewrite Z_mod_eq.\n rewrite Z_mod_eq.\n rewrite Z_mod_eq.\n rewrite Z_mod_eq.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hab Hab Hab.\n case (Z_zerop b); intro Hb.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.gt_lt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n apply Z.lt_gt_0.\n applyQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hab Hab.\n destruct Hab as [Hc| Hd].\n (* b = c *)\n destruct Hab as [Hc| Hd].\n (* b <> c *)\n rewrite Hd.\n rewrite Hc.\n rewrite Hc.\n rewrite Hc.\n rewrite Hc.\n rewrite Hc.\n rewrite Hc.\n rewrite Hc.\n rewrite Hd.\n rewrite Hc.\n rewrite Hc.\n rewrite Hd.\n rewrite Hd.\n rewrite Hc.\n rewrite Hc.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hc.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hc.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n rewrite Hd.\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\nLemma gcd_unicity_apart_sign :\n forall a b c d : Z,\n is_gcd Z IdZ Zmult 0%Z a b c ->\n is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\n",
                "context_tokens": 238,
                "proof_start_offset": 727,
                "proof_end_offset": 1860,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (Z_le_gt_dec 0 b); intros.\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nintros; exact H0.\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nright.\nsplit; auto with zarith.\nexists (-1)%Z; split.\nexact I.\nauto with zarith.\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (- x)%Z.\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nrewrite abs_inj_abs_Z; rewrite abs_inj_abs_Z; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (gcd_divisors a b); intros.\n elim (inversibleZ a b); intros.\n elim (inv0OneibleZ b); intros.\n elim (inv00ibleZ a b); intros.\n apply Z.lt_le_trans with (m := (- a)%Z).\n apply Z.lt_le_trans with (m := (- a)%Z).\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n apply Z.gt_le_trans with (m := (- a)%Z).\n replace (- a)%Z with (- a)%Z.\n replace (- a)%Z with (- a)%Z.\n apply Z.gt_le_trans with (m := (- a)%Z).\n replace (- a)%Z with (- a)%ZQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\ndestruct b; simpl; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim H; intros.\n right. elim H1; intros; elim H4; intros. rewrite H6. rewrite H7; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n case (Z_zerop b); auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n rewrite <- (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_eq (Z_to_Z_Z_to_eq (Z_to_eq (Z_to_eq (Z_to_Z_eq (Z_to_eq (Z_to_Z_to_eq (Z_to_eq (Z_to_eq (Z_to_Z (Z_to_eq (Z_to_Z (Z_to_eq (Z_to_eq (Z_to_Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (gcd_divisors a b c d); auto.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim H.\nintros; elim H.\nintros; elim H0.\nintros; elim H1; intros. rewrite H6.\nrewrite H1; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros; unfold is_gcd in |- *; intros.\nelim (gcd_divisors a b); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H7. rewrite H2; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n apply gcd_bezout_remainder; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 2271,
                "proof_end_offset": 2745,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros.\ncase (Z_zerop n); intro.\nunfold P in |- *.\nintro.\nsplit with (Zabs b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (Zdiv_eucl_extended n0 b).\nintro p; elim p; intros q r H0; elim H0; clear p H0; intros.\ncut (Zabs r < Zabs n)%Z; intros.\nelim (H r H2 n).\nintros.\nsplit with x.\napply gcd_mod with q r; trivial.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n Hn.\n apply (f_equal (fun m : Z => (Zabs m < Zabs n)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs n)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs m)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs m)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs n)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs m)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs m)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs n)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs m)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs m)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < Zabs m)%Z)).\n apply (f_equal (fun m : Z => (Zabs m < ZabsQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n.\n apply (Build_le_wf (fun m : Z => m < Zabs n)%Z); auto with zarith.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n; elim H; auto.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n.\ninduction n.\nsimpl in |- *.\nauto with zarith.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros m IH; case m.\nintros mQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros.\n apply (well_founded_ind (fun m n => Z.pos m) (fun m => Z.pos m * P n)).\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n.\n case (P n); intros.\n simpl in |- *.\n rewrite <- (Zabs_eq n).\n rewrite <- H0.\n rewrite (Zabs_eq n).\n rewrite <- H0.\n rewrite H1.\n rewrite <- H1.\n rewrite <- H1.\n apply (fun m n => (Zabs m < Zabs n)%Z).\n rewrite <- H1.\n apply (fun m n => (Zabs m > Zabs n)%Z).\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n induction n.\n intros.\n simpl in H.\n apply (H m).\n intros m H0.\n rewrite (H m).\n apply (H m).\n intros m H1.\n rewrite (H m).\n apply (H m).\n apply (H m).\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n; elim n; auto.\n intros m H' n H'0; elim H'0; intros m H'1; elim H'1; intros m H'2;\n elim H'2; intros m H'3; elim H'3; intros m H'4; elim H'4; intros m H'5; \n clear H'4.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n.\n elim H; intros.\n elim H0; intros.\n rewrite <- (Zabs_eq n0).\n rewrite H1.\n rewrite <- (Zabs_eq n0).\n rewrite <- H1.\n reflexivity.\n apply sym_not_eq.\n apply lt_le_weak.\n apply lt_le_weak.\n assumption.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n induction n.\n simpl in |- *.\n intros.\n elim H; auto with zarith.\n intros.\n rewrite (H0 (Zabs m)).\n apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Qed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2747,
                "proof_end_offset": 2841,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  elim (Z_lt_le_dec a b); intros.\n  elim (Z_le_gt_dec b a); intros.\n  elim (H0 q); auto with zarith.\n  apply (H1 (Zabs_nat r)); auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_zerop a); intro.\n  apply Z.le_refl.\n  apply Z.le_refl.\n  apply Z.le_refl.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold gcdZ in |- *.\n  intros.\n  elim (Z_lt_gt_dec (Zabs b) 0).\n  intros.\n  elim H0; intros.\n  assumption.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold gcdZ in |- *.\n  intros.\n  elim H.\n  intros.\n  apply H1.\n  intros.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  elim (Z_le_gt_dec b 0).\n  intros.\n  elim H0; intros.\n  assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  case (Z_zerop a); intro.\n  split with (Zabs b).\n  rewrite e.\n  rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout b).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n  unfold Z.le in |- *; rewrite e.\n  apply (gcd_bezout a).\n Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros a b; elim (Z_le_gt_dec a b).\n  intros.\n  apply Z.le_refl.\n  apply Z.le_refl.\n  apply Z.le_refl.\n  apply Z.le_refl.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold gcdZ in |- *. intros.\n  elim H; intros.\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply (H1 (Zabs_nat a)).\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold gcdZ in |- *; intros.\n  case (Z_zerop a); intro.\n  elim H0; intros. \n  apply gcd_sym.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2843,
                "proof_end_offset": 3586,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros.\nelim H.\nintros.\napply (gcd_OZ_absZ b0).\nclear H a b d; intros.\nunfold is_gcd in |- *.\nelim H3; clear H3; intros.\nelim H4; clear H4; intros.\nsplit.\nexact H4.\nsplit.\nrewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4.\nexact I.\nexact H3.\nintros.\napply (H5 q0).\ncut (r = (a - b * q)%Z); intros.\nrewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  case (Z_zerop a); intro.\n  unfold Z.sgn in |- *.\n  rewrite e.\n  apply (euclid_Z_bound_eq a b).\n  apply (euclid_Z_bound_eq a b).\n  apply (euclid_Z_bound_eq a b).\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite abs_inj.\n  rewrite absQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop d); intro.\n  apply (rel_induction (Z_zerop d) (Z_of_P d)); trivial.\n  apply (rel_induction (Z_of_P d) (Z_of_P d)); trivial.\n  apply (rel_induction (Z_of_P d) (Z_of_P d)); trivial.\n  apply (rel_induction (Z_of_P d) (Z_of_P d)); trivial.\n  apply (rel_induction (Z_of_P d)); trivial.\n  apply (rel_induction (Z_of_P d) (Z_of_P d)); trivial.\n  apply (rel_induction (Z_of_P d)); trivial.\n  apply (rel_induction (Z_of_P d) (Z_of_P d)); trivial.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop b); intro.\n  elim H; intro.\n  assumption.\n  intros. elim H1; intro.\n  assumption.\n  intros.\n  elim H2; intro.\n  assumption.\n  intros.\n  elim H3; intro.\n  apply gcd_sym; assumption.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros a b d H; case (Z_zerop a); intro.\n  unfold gcd in |- *; intros.\n  elim H0; clear H0; intros.\n  split with (Zabs b).\n  rewrite e. apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  apply gcd_Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  case (Z_zerop d); intro.\n  apply (H1 n).\n  rewrite H1.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply (Z_mod_eq a b).\n  apply Z.le_refl.\n  apply gcd_sym.\n  apply Z.le_refl.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  case (Z_zerop a); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop d); intro.\n  apply Z.lt_le_trans with (Zabs b).\n  rewrite Z.mul_comm.\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq b).\n  rewrite <- (Zabs_eq bQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  case (Z_zerop a); intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n  intro.\n  case (Z_zerop d).\n Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop d); intro.\n  unfold Z.abs in |- *. intro.\n  cut (exists r : Z, (Zpos r < Z.sgn d)%Z).\n  intro.\n  rewrite (H0 H0).\n  apply gcd_sym.\n  apply (Z_lt_gt_0_dec (Zpos d)).\n  apply Z_div_pos; assumption.\n  rewrite <- H0.\n  apply (is_gcd_mult_full_l b); trivial.\n  rewrite <- H0.\n  apply (is_gcd_mult_full_l b); trivial.\n  apply (is_gcd_mult_full_l b); trivial.\n  apply (is_gcd_mult_full_l b); trivial.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros a b d.\n  case (Z_zerop a); intro.\n  case (Z_zerop a); intro.\n  apply (Z_le_gt_0_dec b).\n  rewrite e.\n  apply (gcd_sym a b).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos b) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  apply (Z_le_lt_trans (Zpos a) (Zpos d)).\n  applyQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  elim (Z_zerop a); intro.\n  unfold Z.pos in |- *.\n  rewrite <- H.\n  rewrite <- H0.\n  apply gcd_sym.\n  apply Z.lt_le_trans with (Zabs b).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3657,
                "proof_end_offset": 3793,
                "proof": "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd a b)).\napply (rel_prime Z_inf (Z_of_gcd aQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\ncase (gcd_spec Z a b); intros.\nexists a; exists (Z_of_nat b).\nrewrite e.\nrewrite <- (Zabs_eq b).\napply (Z_div_pos b a b).\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros; unfold gcdZ in |- *.\nexists (Zabs a b); auto with zarith.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\ncase (Z_zerop a); intro.\nelim H0.\napply (divide_0_l (Z_of_nat a) (Z_of_nat b)).\napply (Z_of_nat_complete b).\nunfold Z_of_nat in |- *.\nrewrite Zmult_comm.\nrewrite <- Zmult_assoc.\nrewrite Zmult_comm.\nrewrite (Zmult_comm (Z_of_nat a) (Zabs_nat b)).\nrewrite <- Zmult_assoc.\napply (Z_of_nat_complete b).\nunfold Z_of_nat in |- *.\nrewrite Zmult_comm.\nrewrite <- (Zmult_comm (Z_of_nat a) (Zabs_nat b)).\nrewrite <- Zmult_assoc.\napply (Z_of_nat_complete b).\nunfold Z_of_nat in |- *.\nrewrite Zmult_comm.\nrewrite <- (Zmult_comm (Z_of_nat a) (Zabs_nat b)).\nrewrite <- Zmult_assoc.\napply (Z_of_nat_complete b).\nunfold Z_of_nat in |- *.\nrewrite Zmult_comm.\nrewrite <-Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros a b; case (Z_zerop a); intros.\nexists 0%Z; auto with zarith.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply (rel_prime_abs_rec Z_of_nat (Zabs_nat a) (Zabs_nat b));\n auto with zarith.\napply (rel_prime_abs_rec Z_of_nat (Zabs_nat a) (Zabs_nat b));\n auto with zarith.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros a b.\ngeneralize (Z_div_mod a b).\ncase (Z_zerop a); intro.\nunfold gcdZ in |- *; rewrite H0; rewrite H1.\nrewrite <- H0; auto with zarith.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nrewrite <- (gcd_sym a b).\napply gcdZ_is_gcd.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nunfold gcdZ in |- *.\ngeneralize (Z_div_mod a b); case (gcdZ a b); auto with zarith.\nintros.\ncut (exists r : Z, a = r).\nintros.\nelim H0; intros.\nexists r; auto.\nintros.\nrewrite H1; auto.\napply (div_plus_one a b d).\nrewrite H1; auto.\napply (div_opp a b d).\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros; unfold gcdZ in |- *; unfold gcdZ in |- *; unfold gcdZ in |- *;\n unfold gcdZ in |- *; unfold gcdZ in |- *; \n unfold gcdZ in |- *;\n unfold gcdZ in |- *;\n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfold gcdZ in |- *; \n unfoldQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": ",\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3795,
                "proof_end_offset": 3912,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H H0.\ncase (le_or_lt 0 a); intros.\nrewrite H1; auto with zarith.\napply (lt_le_trans (Zabs b * (Zabs b * (Zabs b * (Zabs b * (Zabs b)))).\nrewrite H1; auto with zarith.\nrewrite H2; auto with zarith.\napply (lt_le_trans (Zabs b * (Zabs b * (Zabs b * (Zabs b * (Zabs b)))).\nrewrite H1; auto with zarith.\napply (lt_le_trans (Zabs b * (Zabs b * (Zabs b * (Zabs b)))).\nrewrite H2; auto with zarith.\napply (lt_le_trans (Zabs b * (Zabs b * (Zabs b * (Zabs b)))).\nrewrite H1; auto with zarith.\napply (lt_le_trans (Zabs b * (Zabs b * (Zabs b * (Zabs b)))).\nrewrite H1; auto with zarith.\napply (lt_le_trans (Zabs b * (Zabs b * (Zabs b * (Zabs b)))).\nrewrite H2; auto with zarith.\nrewrite H1; auto withQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d; case (Z_zerop a); intro.\nunfold gcd in |- *.\nelim H3; clear H3; intros.\nunfold gcd in |- *.\nelim H3; clear H3; intros.\nelim H4; clear H4; intros.\nunfold gcd in |- *.\nelim H4; clear H4; intros.\nelim H5; clear H5; intros.\ncut (Zabs b = 0).\nauto with zarith.\napply (H4 0%Z); auto with zarith.\napply (H5 0%Z); auto with zarith.\napply (H5 0%Z); auto with zarith.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H; elim H; intros.\nexists 0%Z.\nsplit; [ apply gcdZ_is_gcdZ_for_gcd | apply gcdZ_is_gcd ];\n auto with zarith.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply (fun a b : Z => (a - b)%Z (a - d)%Z).\napply (fun a b : Z => (a - b)%Z (a - d))%Z).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\nelim H.\nintros.\napply (H (Zabs_nat a * b * b * b)%Z).\ngeneralize (Zabs_nat a * b * b)%Z.\ncase (Zabs_nat b * b)%Z; intros.\napply (H3 (Zabs_nat a * b)%Z).\nrewrite Zabs_Zmult.\nrewrite Zabs_Zmult.\nrewrite Zmult_comm.\napply (fun a b : Z => (- a * b)%Z (a * b))%Z).\ncase (Zabs_nat b * b)%Z; intros.\napply (H (Zabs_nat a * b)%Z).\nrewrite Zabs_Zmult.\nrewrite Zabs_Zmult.\nrewrite Zmult_comm.\napply (fun a b : Z => (- a * b)%Z (a * b))%Z).\ngeneralize (Zabs_nat a * b)%Z.\ncase (Zabs_nat a * b)%Z; intros.\napply (H3 (Zabs_nat b * b)%Z).\nrewrite Zabs_Zmult.\nrewrite Zabs_Zmult.\nrewrite Zabs_Zmult.\nrewrite Zabs_Zmult.\napply (fun a b : Z =>Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\nassert (H0 : (0 < d)%Z); [ apply Z_gt_le | apply lt_le_trans with d].\napply (Z_le_lt_trans _ _ H0).\napply (Z_le_lt_trans _ _ H0).\napply (Z_le_lt_trans _ _ H).\napply (Z_le_lt_trans _ _ H0).\napply (Z_le_lt_trans _ _ H0).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H.\napply (H (fun a b : Z => (- a)%Z (b - a)%Z (d - a)).\napply (fun a b : Z => (- a)%Z (b - a)).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H H0.\ncase (Z_zerop d); intro.\nelim H1; intros.\nexists 0%Z; auto with zarith.\napply H1; auto with zarith.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d; case (Z_zerop d); intros.\nunfold rel in |- *; intros.\nsplit with (Zabs b).\nrewrite <- (Zabs_eq b); auto with zarith.\nreplace (Zabs b) with (Zabs (Zabs b)).\nrewrite H1.\napply (H1 (Zabs_eq b)).\napply (H1 (Zabs_eq b)).\napply (H2 (Zabs_eq b)).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H.\ncase (Z_zerop a); intro.\napply (H (Zabs_eq (Z_of_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_of_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_natQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 3914,
                "proof_end_offset": 4352,
                "proof": "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H1 H2; elim H2; intros.\nrewrite <- (Zabs_eq a b).\napply (Z_lt_gt 0).\napply (Z_lt_gt 0).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq b).\nrewrite <- (Zabs_eq bQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H H0; elim H0; intros.\nunfold is_gcd in |- *.\nrewrite H0.\nrewrite H1.\napply (H0 (Z_of_nat (S p)) (S q)).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq b c).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq b c).\napply (is_gcd_Z_eq b c).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq b c).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq b c).\napply (is_gcd_Z_eq a b).\napply (is_gcd_Z_eq a b).\napply (is_Qed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H H0; elim H0; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 4354,
                "proof_end_offset": 4506,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; intros.\nelim (gcd_transitive_bezout a b c d (gcdZ_is_gcd a b c H)).\nintros; rewrite H0; auto with zarith.\nintros; apply (H0 (H1 (H2 (H3 (H4 (H4 (H4 (H4 (H5 (H6 H6 H7))))))).\ngeneralize (gcdZ_is_gcdZ a b c H0 H1 H2 H3 H4).\ngeneralize (gcdZ_is_gcdZ b c H0 H1 H2 H3 H4).\nrewrite <- H3.\ngeneralize (gcdZ_is_gcdZ a b c H0 H1 H2 H4).\nrewrite <- H3.\ngeneralize (gcdZ_is_gcdZ b c H0 H1 H2 H3).\nrewrite <- H3.\ngeneralize (gcdZ_is_gcdZ a b c H0 H1 H2 H4).\nrewrite <- H3.\ngeneralize (gcdZ_is_gcdZ b c H0 H2 H4).\nrewrite <- H3.\ngeneralize (gcdZ_is_gcdQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply gcdZ_is_gcdZ with (a := b) (a := b) (c := b) (c := d) (d := d).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H0; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nrewrite <- H0; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\ncase (gcd_unicity_bezout a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d)).\nintros; apply (gcd_unicity_bezout a b c d (gcdZ_is_gcd a b c H)).\nintros; apply (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H)).\nintros; apply (gcd_unicity_bezout a b c d (gcdZ_is_gcd a b c H)).\nintros; apply (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H)).\nintros; apply (gcd_unicity_bezout a b c d (gcdZ_is_gcd a b c H)).\nintros; apply (gcd_unicity_bezout a b c d (gcdZ_is_gcd a b c H)).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H0; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (fun a b c d : Z => a = 0%Z \\/ c = 0%Z \\/ d = 0%Z).\napply (fun a b c d : Z => a = 0%Z \\/ d = 0%Z).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H)).\nintros; exact H1.\nintros.\napply (gcd_bezout_absZ a b c d (gcdZ_is_gcd a b c H)).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 4508,
                "proof_end_offset": 4744,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H H0 H1 H2; generalize (div_modZ a b c d H0 H2); clear H H2.\nintros.\ncut (a * q + r < b * r)%Z; auto with zarith.\napply (H1 r).\napply divide_trans with (r * r + r)%Z.\napply (H1 r).\nrewrite H1; auto with zarith.\nrewrite H2; auto with zarith.\nrewrite H2; auto with zarith.\nrewrite H2; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (unique_eq (gcdZ_is_gcdZ a b c d (gcdZ_of_nat a b c H)).\napply gcdZ_for_euclid2; auto.\nintros.\ncut (d > 0)%Z; [ intros | apply gcdZ_1; auto ].\napply gcd_sym; auto with zarith.\napply gcd_sym; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2 H3.\napply gcd_bound_for_euclid with (a := b) (a := b) (b := b) (d := b) (d := b) (d := b) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (fun a b c d : Z => (a * q + b * q + a * q + b * q + b * q + b * q + a * q + b * q + b * q)%Z);\n auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\ngeneralize (div_mod_Z a b q H1 H2).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + r)%Z q).\nrewrite <- (gcd_sym (a * q + rQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\napply (rel_comp_Z_eq a b q r); auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nassert (Hb : b <> 0%Z).\napply (well_founded_induction_type (fun a b : Z => a * b)%Z (b * q)%Z (b * q)%Z (b * q)%Z); auto with zarith.\napply (fun a b : Z => a * b)%Z (b * q)%Z (b * q)%Z (b * q)%Z (b * q)%Z q).\ngeneralize (Z_div_mod_eq a b q (a * q) (b * q)%Z (c * q)%Z (c * q)%Z q H0);\n auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\ngeneralize (Z_div_mod_eq a b q H0 H1); case (gcdZ_is_gcd a b q); auto.\nintros.\ncut (r = (a * q + r)%Z); auto with zarith.\nrewrite H3; auto with zarith.\nrewrite H3; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H0 H1 H2 H3.\napply (gcd_unique a b q r H0 H1 H2).\napply (gcd_unique a b q r H0 H3).\napply (gcd_unique a b q r H1 H3).\napply (gcd_trans a b q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H3).\napply (gcd_trans a q r H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H1 H3).\napply (gcd_trans a q r H3).\napply (gcd_trans a q r H1 H3).Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\napply (fun s r => (a * q + r)%Z).\napply (fun s r => (a * q + r)%Z).\nintros; rewrite H2; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4939,
                "proof_end_offset": 5677,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros q f.\nelim (Z_zerop q); intro e.\nunfold Q in |- *; intro b.\nsplit with 1%Z (Zsgn b).\nrewrite e.\nsimpl in |- *.\nrewrite (Zsgn_Zabs b).\napply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (Zdiv_eucl_extended e b).\nintro p; elim p; clear p.\nintros div r; intros.\ncut (Zabs r < Zabs q)%Z; intros.\nelim (f r H q).\nintros.\nsplit with (v + - (div * u))%Z u.\nelim p.\nintros.\nelim H1.\nintros.\nintros.\npattern b at 1 in |- *.\nrewrite H0; auto with zarith.\nrewrite <- (gcd_modZ b q div r); auto with zarith.\nrewrite <- e0.\nring.\nelim p; intros; elim H0; intros.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H1 H2; elim H1; auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\ninduction n.\nintros m H H0; apply H; auto with zarith.\nintros m H0; apply H0; auto with zarith.\nintros m H0; apply H; auto with zarith.\nintros m H H0; apply H0; auto with zarith.\nintros m H0; apply H0; auto with zarith.\nintros m H H0; apply H; auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H1 H2; elim H2; auto with zarith.\nintros m H3; elim H3; auto with zarith.\nintros m H4; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H6; elim H6; auto with zarith.\nintros m H6; elim H7; auto with zarith.\nintros m H7; elim H7; auto with zarith.\nintros m H6; elim H7; auto with zarith.\nintros m H6; elim H7; auto with zarith.\nintros m H7; elim H8; auto with zarith.\nintros m H7; elim H7; auto with zarith.\nintros m H7; elim H7; auto with zarith.\nintros m H7; elim H8; auto with zarith.\nintros m H7; elim H8; auto with zarithQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H1 H2 H3; elim H3; auto with zarith.\nintros m H3; elim H3; auto with zarith.\nintros m H4; elim H4; auto with zarith.\nintros m H4; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H5; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H6; elim H6; auto with zarith.\nintros m H5; elim H6; auto with zarith.\nintros m H5; elim H6; autoQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\ninduction n; simpl; auto.\nintros m IH.\napply IH.\nintros m IH; elim IH.\nintros m IH.\napply IH.\nintros m IH.\napply IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintros m IH; elim IH.\nintrosQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n.\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m <= Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m <= Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m n => forall mQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H1 H2; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros m IH; elim H2; auto with zarith.\nintros mQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\ndestruct n.\napply (fun m n => proj1_sig (m * n)%Z).\napply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun m n => proj1_sig (m * n)%Z).\nintros.\napply (fun m n => proj1_sig (m * n)%Z).\nintros.\napply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun m n => proj1_sig (m * n)%Z).\nintros.\napply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun m n => proj1_sig (m * n)%Z).\nintros; apply (fun mQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H.\ncase (gcd_unique (Zabs_nat n) n); auto.\nintros m IH.\napply (H m).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H1 H2 H3; elim H3; auto.\nintros n H3; elim H3; auto.\nintros m H4; elim H4; intros m H4; elim H4; auto.\nintros m H5; elim H5; intros m H5; elim H5; auto.\nintros m H5; elim H6; intros m H6; elim H6; intros m H7; elim H7; intros m H7;\n elim H7; intros m H8; elim H8; intros m H8; elim H9; \n intros m H9; elim H9; intros m H10; elim H9; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; \n intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros mQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5679,
                "proof_end_offset": 5780,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; case b; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  elim (Zpower_pos a (gcdZ a b)) (gcdZ_is_gcd a b)).\n  intros.\n  elim (Z_zerop a).\n  elim (Zpower_pos b (gcdZ a b)).\n  intros.\n  elim (prime_correct_abs_nat a b).\n  intros.\n  elim (Zle_lt_or_eq b a); intros.\n  elim H3. intros.\n  apply H3.\n  rewrite Zabs_eq; auto with zarith.\n  apply Z_div_pos; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nintros a b.\nexists (a * b)%Z.\nexists (b * b)%Z.\nsplit.\nrewrite e.\nrewrite e.\nrewrite (Zmult_comm a b).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm a b).\nrewrite (Zmult_comm a b).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm a b).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm a b).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm a b).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm a b).\nrewrite (Zmult_comm b a).\nrewrite (Zmult_comm b a).\nrewrite (Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; elim (Z_zerop q); intros.\n  elim (Z_zerop q); intros.\n  elim (Z_zerop q).\n  intros.\n  elim (Z_zerop q).\n  intros.\n  elim (Z_zerop q).\n  intros.\n  elim (Z_zerop q).\n  intros.\n  elim (Z_zerop q).\n  intros.\n  elim (Z_zerop q).\n  intros.\n  elim H1. intros.\n  apply H4.\n  split with (Zabs q).\n  split.\n  elim (Z_zerop q).\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H3.\n  intros.\n  elim (Z_zerop q).\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  elim H5.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H7.\n  introsQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nunfold Q in |- *.\nintros a b H; elim H; clear H; intros.\nexists (Zabs b).\nexists (Zabs b).\nexists (Zabs b).\nsplit.\napply gcd_is_gcdZ; auto.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; elim (rel_prime_eq a b); intros; elim H; clear H; intros.\n  elim H1; clear H1.\n  elim H2; clear H2.\n  elim H3; auto.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; elim (is_gcd_is_gcdZ a b); intros; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; case b; case b; case b; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; case b; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros a b; case b; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 5858,
                "proof_end_offset": 6105,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x; elim (Z_zerop x); intro e. unfold Z in |- *; intro x; unfold Z in |- *;\n  apply Zmult_1_r.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intro; elim (Z_zerop x); auto with zarith.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ x).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x; case (Z_zerop x); intros.\n  elim (mult_integral_r x y).\n  apply (Zmult_sym (Z.mul_comm x)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  elim (Z_zerop x).\n  intro.\n  elim (Z_zerop x).\n  intro.\n  elim H.\n  intros.\n  cut (x * 0)%Z.\n  intro.\n  elim (Z_zerop x).\n  intro.\n  elim (Z_zerop x).\n  intro.\n  elim (Z_zerop x).\n  intro.\n  elim H1.\n  intros.\n  rewrite <- H1 in H1.\n  rewrite H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in HQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  elim (Z_zerop x); intros.\n  elim (Z_zerop x); intros.\n  elim H0.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  elim H5.\n  intros.\n  elim H5.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H7.\n  intros.\n  elim H7.\n  intros.\n  elim H7.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H9.\n  intros.\n  elim H10.\n  intros.\n  elim H9.\n  intros.\n  elim H10.\n  intros.\n  elim H10.\n  intros.\n  elim H10.\n  intros.\n  elim H10.\n  intros.\n  elim H10.\n  intros.\n  elim H10.\n  intros.\n  elim H10.\n  intros.\n  elim H10.\n Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intro; elim (Z_zerop x); intro e. unfold Z in |- *; intro.\n  elim (mult_integral_Z x 0).\n  intro p; elim p; clear p.\n  intros div r; elim (mult_integral_Z x 0).\n  intro p; elim p.\n  intros.\n  elim H1. intros.\n  cut (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (nextblock (Zabs (Zabs (Zabs (Zabs (Zabs (Zabs (nextblock (Zabs (Zabs (Zabs (Zabs (nextblock m))))))))) x))).\n  apply gcd_compQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  unfold Zop; intros.\n  elim (Z_zerop x).\n  intro.\n  elim H0.\n  intro.\n  elim H1.\n  intro.\n  elim H2.\n  intro.\n  elim H4.\n  intro.\n  elim H4.\n  intro.\n  elim H5.\n  intro.\n  cut (Zabs x <= Zabs z)%Z; [ intros | apply lt_O_Sn ].\n  rewrite H5; auto with zarith.\n  rewrite H5; auto with zarith.\n  rewrite H5; auto with zarith.\n  rewrite H5; auto with zarith.\n  rewrite H5; auto with zarith.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ (Z_of_nat x)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\nLemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (Z_zerop x); intros. left; exact a.\nright; split. exact b. exists 1%Z. split. exact I. auto with zarith.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6107,
                "proof_end_offset": 7147,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (x * (b * v) + y * (a * u))%Z.\nunfold congruentZ in |- *; split.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - x)%Z with (a * (u * (y - x)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop a); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (u * (y - x))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (b * v)%Z with (1 + - (a * u))%Z; auto with zarith.\nring.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - y)%Z with (b * (v * (x - y)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (v * (x - y))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (a * u)%Z with (1 + - (b * v))%Z; auto with zarith.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\ngeneralize (Z_zerop_pos a); case (Z_zerop a); intro.\nleft.\nexists (a * b)%Z.\nsplit.\nrewrite Zmult_1_r.\nreplace (a * b)%Z with (a * b)%Z.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_l.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napply Zmult_le_compat_r.\napplyQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcdZ in |- *.\n  elim (Z_zerop x); intros.\n  elim (Z_zerop y). intros. right. apply Z.le_refl.\n  right. apply Z.lt_trans with (m - x)%Z. apply le_Z_of_nat.\n  apply Z.le_refl.\n  apply Z.lt_trans with (m - x)%Z. apply le_Z_of_nat.\n  apply Z.le_refl.\n  apply Z.lt_trans with (m - x)%Z. apply le_Z_of_nat.\n  apply Z.le_refl.\n  apply Z.le_refl.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nunfold gcdZ in |- *.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\nrewrite absZ_is_gcd.\napply absZ_eq; apply absZ_eq; exact absZ_eq; exact absZ_eq; exact absZ_eq; exact absZ_eqQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros.\napply (Z_div_pos (a * b) (x * y) b).\n rewrite (Zmult_comm x).\n rewrite (Zmult_comm y).\n rewrite (Zmult_comm (a * y)).\n rewrite <- (Zmult_assoc a b).\n rewrite (Zmult_comm (a * y)).\n rewrite (Zmult_comm (a * y)).\n rewrite (Zmult_assoc b (a * y)).\n rewrite (Zmult_comm (a * y)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * y)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * y)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_assoc b (a * z)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * z)).\n rewrite (Zmult_comm (a * z)).\n rewrite (ZmultQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\ncase (Z_zerop y); intros.\nelim (Z_zerop z).\nintros.\nelim H1; clear H1; intros.\nexists 0%Z.\nsplit; [ idtac | split ].\ngeneralize (Z_div_mod (Z_mod_eq a b) (Z_div_mod_eq a b) (Z_div_mod_eq a b) (Z_div_mod_eq a b) H0);\n case (Z_zerop a); intros.\nelim H1; clear H1; intros.\nexists (- a)%Z.\nsplit; [ idtac | split ].\ngeneralize (Z_div_mod_eq a b (Z_div_mod_eq a b) (Z_div_mod_eq a b) (Z_div_mod_eq a b) H0);\n case (Z_zerop a); intros.\nelim H1; clear H1; intros.\nexists (a * b)%Z.\nsplit; [ idtac | split ].\ngeneralize (Z_div_mod_eq a b (Z_div_mod_eq a b) (Z_div_modQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros a b x y.\ncase (Z_zerop x); intros.\nleft.\napply (Z_lt_le_trans _ _ (Z_le_lt_trans _ _ H)).\ndestruct (Z.div_eucl_least (Zabs a) y) as [H|H].\nexists (Zabs a).\nrewrite H; ring.\nrewrite <- H; ring.\nrewrite <- H; ring.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\ndestruct (Z_zerop x).\ndestruct (Z_zerop y).\nexists (Z_of_nat x).\nsplit.\nexact (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\napply (Z_div_pos _ z).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\napply (Z_lt_abs_rec _ _ _ H).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  elim (Z_zerop x); intros.\n  elim (Z_zerop x); intros.\n  elim H1. intros.\n  elim (Z_zerop y).\n  intros.\n  elim H1. intros.\n  elim H2. intros.\n  elim H3. intros.\n  elim H4. intros.\n  elim H5. intros.\n  elim H5. intros.\n  elim H6. intros.\n  elim H6. intros.\n  elim H7. intros.\n  elim H8. intros.\n  elim H8. intros.\n  elim H8. intros.\n  elim H8. intros.\n  elim H8. intros.\n  elim H9. intros.\n  elim H9. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elim H10. intros.\n  elimQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nrewrite <- Z_div_modZ; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nsimpl in |- *.\nauto with algebra.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\napply Z_group_eq_reg_r with (Z_of_nat 0); auto with *.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z_group at 1 in |- *; simpl in |- *.\nintros x; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z; unfold Z_group in |- *; simpl in |- *.\nintros x y z;Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nsimpl in |- *.\nintros x; red in |- *.\napply Z_group_eq.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z, Z, Z, Z in |- *.\nintros x.\nunfold Z, Z, Z, Z in |- *.\nsimpl in |- *.\napply Z.gt_eq.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.\nunfold Z_group in |- *.\nintros x y; try assumption.Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.opp, Z.opp, Z.opp.\nintros.\napply Z.mul_1_l.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  exact Z_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nred in |- *.\nintros x; red in |- *.\napply Trans with (Z_of_nat (nat_of_P x)).\napply Z_group_nat_fun_pos; auto with algebra.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nnow intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; simpl in |- *.\napply Z_group_inverse.\nintros x H'; elim H'; intros.\ncut (x = 0%Z); auto with zarith.\nrewrite H'; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit; red in |- *; auto with zarith.\nintros a b c d H H0; elim H; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit; red in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nred in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit; red in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nunfold IdZ in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; intros; apply Z_unit_for_left_inverse_inverse_inverse_inverse_inverse.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\napply Z_unitary_inverse_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nintros p q H H0.\napply Z_unit_for_left_inverse_inverse_inverse_inverse_inverse_inverse_inverse_inverse_inverse_inverse.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nintros.\napply Zle_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_trans with (Zabs_nat (Zpos (vNum b))).\napply Zle_lt_Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold IdZ in |- *; simpl in |- *.\nintros.\napply Z_one_group; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nintros p1 p2.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napply Zeq_bool_intro.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_char in |- *.\napply Z_normal_l.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_scalar in |- *.\nintros.\napply Zle_refl.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z, Z, Z, Z, Z, Z, Z in |- *.\nintros x; red in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_char in |- *.\napply Z_one_linear_ring.\nsplit.\napply Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nsplit.\nexact Z_one_linear_ring.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_char in |- *.\nsplit.\nexact Z_ring.\nsplit.\nexact Z_one_div_one_div_one_div_one.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_scalar in |- *.\nsplit.\nred in |- *; auto with zarith.\napply Z_one_bound_zero_l.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nsplit.\nred in |- *; auto with zarith.\napply Z_unit_for_goal_ring.\napply Z_unit_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\napply Z_one_for_goal_ring.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_power in |- *.\nintros x.\ncase (Z_eq_dec (Z_of_nat x) 0); intro.\napply False_ind; auto with zarith.\napply Z_of_nat_o_plus_morphism; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; case (Z_eq_dec x 0); trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; split.\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_div_eq_full x).\napply (Z_one_divQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H.\ncase (Zle_or_lt 0 x); intros H1.\nrewrite H1 in H1.\ninversion H1.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; inversion H.\nintros; right; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold is_unit in |- *.\nintros x H; split.\nexact H.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; case x.\nintros; right.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_right; auto with zarith.\nintros; left.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_right; auto with zarith.\nintros; right.\nrewrite Z_unit_for_right; auto with zarith.\nintros; right.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_right; auto with zarith.\nintros; right.\nrewrite Z_unit_for_left; auto with zarith.\nintros; right.\nrewrite Z_unit_for_right; auto withQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; right.\nrewrite H; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; case x.\n(* precision *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; elim Hx; clear Hx.\nsplit.\nintros H; left; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; simpl in |- *; intros; inversion H; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n",
                "context_tokens": 187,
                "proof_start_offset": 546,
                "proof_end_offset": 679,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold Add; intros x y z; elim z; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\n  intros x y z; pattern z, z, (Add x y z) at 1; rewrite <- (Add_add x z);\n    rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n      rewrite <- (Add_add x z); rewrite <- (Add_add y z);\n        rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n          rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n            rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n            rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n            rewrite <- (Add_add x z); rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n            rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n            rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n              rewrite <- (Add_add x z); rewrite <- (Add_add x z); rewrite <- (Add_add x z);\n              rewrite <- (Add_add x z); rewrite <- (Add_addQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\n  intros x y z.\n  apply (O_S x y z).\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold AS; simpl; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold ID.\nintros x y z.\nrewrite <- (Add_add O y z).\nrewrite (Add_add O y z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_add O z).\nrewrite (Add_addQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\n  intros x y z; unfold Add at 2.\n  apply (Req_dec x z); auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\n  intros x y z.\n  apply (f_equal (fun x : S => S x /\\ S y = x /\\ Add x O = x /\\ Add y O = x)).\n  apply (f_equal (fun x : S => S x /\\ S y = x)).\n  apply (f_equal (fun x : S => S x /\\ S y = x /\\ Add x O = x)).\n  apply (f_equal (fun x : S => S x /\\ S y = x /\\ Add x S = y)).\n  apply (f_equal (fun x : S => S x /\\ S y = x)).\n  apply (f_equal (fun x : S => S x)).\n  apply (f_equal (fun x : S => S x /\\ S y = x /\\ Add x S = y)).\n  apply (f_equal (fun x : S => S x /\\ S y = x)).\n  apply (f_equal (fun x : S => S x /\\ S y = x)).\n  apply (f_equal (fun x : S => S x /\\ S y = x)).\n  apply (f_equal (fun x : S => S x /\\ S y = x /\\ Add xQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold AS, Add. intros x y z; apply (op_eq_compat x z); auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros x y z.\napply (fun x y z => (fun x => (x + y + z) = (x + y + z)).\nrewrite (plus_comm x z); auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\n  intros x y z; pattern z, z; apply (O_S_ind x y z); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\nLemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n",
                "context_tokens": 267,
                "proof_start_offset": 760,
                "proof_end_offset": 981,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y Hx Hy.\nelim Hx; intros; elim Hy; intros; elim Hy; intros; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; apply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\napply is_Odd_intro; intros.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; intros; elim (H1 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H1; intros; elim H2; intros; elim H3; intros; auto with sets.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H'; elim H'; intros; elim H'; intros; elim H'0; intros; elim H'0;\n intros; elim H'0; intros; elim H'0; intros; clear H'0.\nelim (H'0 x); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H'; elim H'.\nintros; elim H'.\nintros; elim H'.\nintros x y H'0 H'1; elim H'0.\nintros x y H'1; elim H'1.\nintros x y H'2; elim H'2.\nintros x y H'3; elim H'3.\nintros x' y H'4; elim H'4.\nintros x' y' H'5; elim H'5.\nintros x' y'6 H'6; elim H'6.\nintros x'7 H'7 H'8; elim H'7.\nintros x'9 H'9 H'10; elim H'10.\nintros x'10 H'10; elim H'10.\nintros x'10 H'11; elim H'11.\nintros x'10 H'11; elim H'10.\nintros x'11 H'12; elim H'12.\nintros x'11 H'13; elim H'13.\nintros x'13 H'14; elim H'15.\nintros x'13 H'14; elim H'14.Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; red in |- *; intros.\napply H; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim H0; intros; auto with *.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim (H3 O H3); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H0; intros; elim H1; intros; elim (H2 O H0); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n",
                "context_tokens": 114,
                "proof_start_offset": 397,
                "proof_end_offset": 1206,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; elim H'; auto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x Hx.\nunfold A in |- *.\napply Trans with (S x).\nauto with algebra.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nunfold is_ring in |- *.\nsplit.\napply O_inj.\napply A_inj.\napply O_inj.\napply O_inj.\napply A_inj.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nunfold is_ring in |- *.\napply Trans with (A := S) (B := S) (B := A).\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x Hx.\nunfold is_ring in |- *.\nsplit.\napply mult_O_eq.\nauto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nunfold is_ring in H.\nelim H; intros.\nexists x0; trivial.\nexists x0; trivial.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nunfold is_ring in H.\nelim H; intros.\nelim H0; intros.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nrewrite H1.\nrewrite H4.\nrewrite H3.\nrewrite H4.\nring.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nelim H0; intros.\nelim H0.\nintros.\nelim H1.\nintros.\napply H1.\nintros.\napply H2.\napply H1.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nunfold is_ring in |- *.\napply sum_is_strong.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\napply O_ind.\napply S_n; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n",
                "context_tokens": 463,
                "proof_start_offset": 1208,
                "proof_end_offset": 1952,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; \n elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H7; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10; intros; elim H11; intros. \nclear H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H16 H17 H17 H19 H20 H19 H20 H20 H20 H21 H22 H24 H25 H25 H26 H27 H27 H27 H27 H29 H29 H30 H31 H32 H33 H33 H34 H38 H40 H40 H40 H41 H42 H43 H43 H44Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; \n elim H2; intros; elim H3; intros; elim H4; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H10; intros; elim H9; intros; elim H10; \n intros; elim H10; intros; elim H11; intros; elim H11; \n intros; elim H11; intros; elim H12; intros; \n elim H12; intros; elim H13; intros; elim H13; intros; \n elim H13; intros; elim H13; intros; \n elim H13; intros; elim H13; intros; elim H13; \n intros; elim H14; intros; elim H14; intros; elim H14; intros; \n elim H15; intros; elim H14; intros; elim H15; intros; \n elim H16; intros; elim H15;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elimQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elimQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n",
                "context_tokens": 721,
                "proof_start_offset": 1954,
                "proof_end_offset": 2696,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; clear H4; elim H4; intros;\n elim H4; intros; clear H4; elim H4; intros; \n elim H4; intros; clear H4; elim H4; intros; \n clear H4; elim H4; intros; clear H4; elim H5; intros; \n clear H5; elim H6; intros; \n elim H7; intros; clear H7; elim H8; intros; \n clear H7; elim H8; intros; clear H8; elim H8; intros; \n clear H8; elim H8; intros; clear H8; elim H9; \n clear H9; intros; elim H8; intros; clear H9; elim H9; \n clear H9; intros; elim H9; intros; clear H9; elim H9; \n clear H9; intros; elim H10; clear H10; \n intros; elim H10; intros; clear H10; elim H10; \n clear H10; intros; elim H10; intros; clear H10; elim H10; \n clear H10Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; clear H2;\n elim H3; intros; elim H4; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H4; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H4; clear H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; clear H4; \n elim H4; intros; clear H4; \n elim H4; intros; elim H4; intros; clear H4; \n elim H4; intros; clear H4; \n elim H4; intros; elim H4; clear H4; intros; \n elim H4; intros; clear H4; \n elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; clear H2;\n elim H2; intros; elim H3; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H4; clear H4; intros; elim H4; clear H4; \n clear H4; intros; elim H4; clear H4; \n clear H4; intros; elim H4; clear H4; intros; elim H4; clear H4; \n clear H4; intros; elim H4; clear H4; \n clear H4; intros; elim H4; clear H4; intros; elim H4; clear H4; \n clear H4; intros; elim H4; clear H4; intros; elim H4; clear H4; \n clear H4; intros; elim H4; clear H4; intros; elim H4; clear H4; \n clear H4; intros; elim H4Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H4; intros; elim H4; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; introsQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros.\nelim H7; intros; elim H8; intros.\nelim H8; intros; elim H8; intros.\nclear H8 H8 H9 H10 H10 H11 H12 H13 H14 H15 H16 H16 H16 H17 H17 H19.\napply (mult_reg_l (A:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H4; intros; elim H4; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H10; \n intros; elim H9; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H4; intros.\nelim H4; intros; elim H5; intros.\nelim H5; intros; elim H6; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H13; intros.\nelim H13; intros.\nelim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H4; intros; elim H5; intros; elim H5; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H7; intros.\nelim H6; intros; elim H8; intros; elim H8; intros.\nelim H7; intros; elim H8; intros; elim H8; intros.\nelim H8; intros; elim H8; intros; elim H8; intros.\nelim H8; intros; elim H9; intros; elim H9; intros.\nelim H9; intros; elim H10; intros.\nelim H10; intros; elim H10; intros.\nelim H10; intros; elim H10; intros.\nclear H10; elim H10; intros.\nclear H10; elim H10; intros; elim H10; intros.\nclear H10; elim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; introsQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; clear H4;\n elim H5; intros; elim H5; intros; clear H5;\n elim H6; intros; elim H6; intros; clear H6;\n elim H6; intros; elim H7; clear H7; intros.\nelim H7; intros; elim H8; intros; elim H9; clear H8; \n intros.\nelim H8; intros; elim H9; intros; elim H9; intros; clear H9;\n elim H9; intros; elim H10; intros; clear H9;\n elim H9; intros; elim H10; clear H10; intros.\nclear H9 H10 H10 H11 H12 H13 H14 H15 H16 H17 H18 H20.\nsplit.\nexact (H10 x (Ap x y)); assumption.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H4; intros; elim H5; intros; clear H4;\n elim H6; intros; elim H6; intros; clear H6;\n elim H6; intros; elim H6; intros; clear H6; \n elim (H6 x (Opp y x0 H)); intros; \n rewrite H4; clear H5.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2698,
                "proof_end_offset": 3190,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H6; intros; clear H6 H7;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H16 H17 H18 H19.\napply (opp_transitive S A (Add x y));\n auto with arith.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; \n intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H8; intros; elim H9; intros; elim H9; \n intros; elim H10; intros; elim H9; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n elim H5; intros; elim H5; intros.\nelim H5; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H8; intros; elim H8; intros;\n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; \n intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H9; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; \n elim H10; intros; elim H11; intros; \n elim H11; intros; elim H12; intros; \n elim H12; intros; \n elim H13; intros; elim H13; intros; \n elim H14; intros; elim H12; intros; \n elim H13; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; clear H4;\n elim H6; intros; elim H6; intros; elim H6; intros; clear H6;\n elim H7; intros; elim H7; intros; elim H7; intros; clear H7;\n elim H8; intros; elim H8; intros; elim H8; intros; clear H8;\n elim H9; intros; elim H9; intros; elim H9; intros; clear H9; \n elim H9; intros; elim H9; intros; clear H9; \n elim H9; intros; elim H9; intros; elim H9; intros; clear H9; \n elim H9; intros; elim H10; clear H9; \n elim H10; intros; elim H9; intros; clear H10; \n elim H10; intros; elim H10; intros; clear H10; \n elim H10; intros; elim H9; intros; clear H10; \n elim H10; intros; clear H10; elim H10; \n intros; elim H10; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros.\nelim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H7; intros;\n elim H7; intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H10; intros; elim H9; intros; \n elim H10; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; clear H5;\n elim H6; intros; elim H6; intros; clear H6;\n elim H6; intros; elim H6; intros; clear H6;\n elim H7; intros; elim H8; intros; clear H7;\n elim H9; intros; elim H9; intros; clear H9;\n elim H9; intros; elim H10; intros; clear H9;\n elim H9; intros; elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; clear HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; clear H4;\n elim H5; intros; elim H6; intros; clear H5; \n elim H6; intros; elim H7; intros; elim H7; intros; clear H7; \n clear H5 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19.\napply (opp_unicity S A (Ap x y));\n auto with arith.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; clear H5; clear H5.\nelim H5; intros; elim H6; intros; clear H5; clear H6.\nelim H6; intros; elim H6; intros; clear H6; clear H6.\nelim H6; intros; elim H6; intros; elim H7; intros.\nelim H7; intros; elim H7; intros; clear H8; clear H8.\nelim H8; intros; elim H8; intros; clear H8; clear H9.\nelim H8; intros; elim H8; intros; clear H8; clear H8.\nelim H8; intros; elim H8; intros; clear H8; clear H9.\nelim H8; intros; elim H8; intros; clear H8; clear H8.\nelim H8; intros; elim H8; intros; clear H8; clear H8.\nelim H8; intros; elim H8; intros; clear H8; clearQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; clear H6 H7;\n elim H7; intros; elim H7; intros; elim H8; intros;\n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; clear H9; \n elim H9; intros; elim H9; intros; clear H10; \n elim H10; intros; clear H10; \n elim H9; intros; elim H9; intros; clear H10; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; clear H10; \n elim H10; intros; clear H10; \n elim H10; intros; elim H10; clear H10; \n clear H10; elim H10; intros; clear H10; \n elim H10; intros; clear H10; elim H10; intros; \n elim H10; introsQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H4; intros; elim H5; intros; elim H6; intros.\nelim H8; intros; elim H8; intros.\nclear H3 H4 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18.\napply (opp_unicity S A (x:=A) (B:=A)).\nunfold is_any in |- *; simpl in |- *.\nrewrite H0; rewrite H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3490,
                "proof_end_offset": 3729,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold not in |- *; intros.\nsplit; [ intros H1 | intros [H1 | H1] | intros [H1 | H1] ]; auto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\napply div_O_O_O.\napply div_O_O.\napply div_O_O.\napply div_O_O.\napply div_O_O.\napply div_O_O.\napply div_O_O.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_unit', is_unit' in |- *; auto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold is_inverse in |- *; auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\napply mult_O_O.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold is_unit, div, div, mult in |- *; simpl in |- *; auto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_char in |- *; intros.\napply div_O_O; auto with *.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold is_unit >->numadherent in |- *; intros.\nelim H; intros; elim H0; intros.\nleft; exists O.\nexists O.\nexists O.\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists (S O).\nexists O.\nexists (S O).\nexists (S O).\nexists (S O).\nexists O.\nexists (S O).\nexists (S O).\nexists O.\nexists (S O).\nexists O.\nexists (S O).\nexists (S O).\nexists O.\nexists O.\nexists OQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\napply (Build_law_group (fun a b => a = S (S (S a))).\nexact (fun a b => a = S (S a + S b)).\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold opp in |- *; intros.\nelim H; intros; auto with arith.\nelim H0; intros; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3731,
                "proof_end_offset": 4957,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1 H2; elim H0; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros.\nsplit; exact H9.\nsplit. exact H1.\nsplit. exact H1.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\ncase H; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nelim H7; intros; elim H8; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nelim H7; intros.\nelim H8; intros.\nsplit.\nexact H8.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0.\ncase (mult_O_O a b); auto.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1.\napply div_O_O; auto.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1; apply div_O_O; assumption.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1 H2; elim H0; intros; elim H3; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H1.\nsplit.\nexact H2.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0; elim H0; intros; elim H1; intros; elim H2; intros; clear H2;\n elim H3; intros; elim H4; intros.\nelim H8; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H9.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0.\ncase (plus_assoc_l a b); auto.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d d).\nrewrite (mult_comm dQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\n(* [A d] *)\nelim H0; trivial.\nsplit.\n(* [A (a+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 4959,
                "proof_end_offset": 5659,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0.\ncase (mult_assoc_sym_reverse a b d H0); intros.\nelim H0; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; \n clear H4 H4 H6.\nelim H0; intros; elim H4; intros; elim H5; intros; clear H4 H5.\nelim H0; intros; elim H5; intros; clear H5.\nelim H5; intros; elim H6; intros; elim H6; intros; \n clear H6 H7.\nelim H6; intros; elim H6; intros; elim H6; intros; clear H6 H7.\nelim H7; intros; elim H7; intros; elim H7; intros; \n clear H7 H8.\nelim H7; intros; elim H8; intros; elim H8; intros; clear H8 H9.\nelim H8; intros; elim H9; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H9; intros; elim H9; intros;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H4; intros; elim H5; intros.\nsplit.\nexact H3.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H3; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; clear H4; \n apply H4; assumption.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\ncase (Z_zerop b); trivial.\nintros.\nexists (S a).\nexists (S b).\nexists (S b).\nexists (S b).\nsplit.\napply H0.\napply le_O_n.\napply H0.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div, div, div, div in |- *; intros a b d H H0 H1.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; clear H3.\nelim H1; intros; elim H3; intros; clear H3.\nelim H1; intros; elim H4; intros; elim H5; intros; clear H5.\nsplit.\nelim H0; intros; apply H5; assumption.\nsplit.\nelim H0; intros; apply H6; assumption.\nsplit.\nelim H0; intros; apply H6; assumption.\nsplit.\nelim H0; intros; assumption.\nsplit.\nelim H1; intros; assumption.\nsplit.\nelim H1; intros; assumption.\nsplit.\nelim H1; intros; assumption.\nsplit.\nelim H1; intros; assumption.\nsplit.\nelim H1; intros; assumption.\nsplit.\nelim H1; intros; assumption.\nsplit.\nelim H1; intros; assumption.\nsplit.\nelim H2; intros; assumption.\nsplit.\nelim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H4; intros; \n elim H5; intros; clear H5 H6.\nelim H5; intros; elim H6; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H9; \n intros; elim H10; intros; elim H9; intros; elim H9; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H9; intros; elim H10; \n clear H9; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1; intros.\nunfold is_zero in |- *.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H12; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H13; intros.\nelim H13; intros.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\napply div_reg_l with (a := b).\nexact (fun a b => a * b).\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold not in |- *; intros.\nelim H; intros; elim H1; intros.\nelim H0; intros; elim H1; intros.\nsplit.\nexact (H2 b H1).\nsplit.\nexact (H2 b H1).\nsplit.\nexact (H2 b H1).\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H3; intros; elim H4; intros; clear H3.\nexists (S n); split.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H3.\napply le_plus_r.\nexact H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 5661,
                "proof_end_offset": 6477,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold gcd in |- *; intros.\nelim H; intros; elim H2; intros.\nelim H2; intros.\nsplit. exact (H7 a b H1).\nexact (H2 b d H1).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nsplit. exact H2. clear H2.\n(* *)\nelim H1; intros.\nelim H3; intros.\nsplit. exact (H6 a b H1).\nsplit.\nexact (H6 a b H1).\nexact (H6 b d H1).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros.\nrewrite <- (mult_comm a).\nrewrite <- (mult_comm a).\nrewrite <- (mult_comm b).\nrewrite <- (mult_comm a).\nrewrite <- (mult_comm b).\nrewrite <- (mult_comm b).\nrewrite <- (mult_comm b).\nrewrite <- (mult_comm b).\nrewrite <- (mult_comm a).\nrewrite <- (mult_comm a).\nrewrite <- (mult_comm b).\nrewrite (mult_comm b).\nrewrite <- (mult_comm a).\nrewrite <- (mult_comm b).\nrewrite <- (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm a).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (multQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H1; intros; clear H1; intros.\nsplit. exact (H3 b H H1).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H; intros.\nsplit. exact (H1 (S d)).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nsplit.\nexact (S d).\nexact (S d).\nsplit.\nexact (S d).\nexact (S d).\nsplit.\nexact (S d).\nexact (S d).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H; elim H; intros.\nelim (mult_reg_l a b H0); intros.\nelim H0; intros.\nelim H1; intros.\nsplit.\nexact (sym_eq (S a) (S b)).\nexact (sym_eq (S b) (S b)).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nsplit.\nexact (H1 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S(S (S (S(S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a b d H H0 H1.\nrewrite (mult_comm a b).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm d (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (mult_comm (S d)).\nrewrite (multQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros.\nsplit.\nexact H0. clear H0.\n(* [b = 0] *)\nelim H; intros.\nsplit.\nexact H0. clear H0.\n(* [b = 0] *)\nelim H; intros.\nsplit.\nexact H0. clear H0.\n(* [b = 0] *)\nelim H; intros.\nsplit.\nexact H0. clear H0.\n(* [d = 0] *)\nelim H; intros.\nsplit.\nexact (H0 d).\nexact (H1 d).\nexact (H2 d).\nexact (H1 d).\nexact (H1 d).\nexact (H1 d).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6601,
                "proof_end_offset": 6974,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros.\nsplit.\nexact (gcd_0_l a b d H0 H1).\nsplit.\nexact (gcd_sym a b d H2).\nsplit.\nexact (gcd_sym a b d H1).\nsplit.\nexact (gcd_sym b c d H1).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros.\nsplit; try assumption.\nsplit; try assumption.\nsplit; try assumption.\nsplit.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto with *.\napply gcd_sym_l with (m := m); auto.\napply gcd_sym_l with (m :=Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\napply H2.\nsplit.\nexact (H1 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nsplit.\nexact (H2 b).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nelim H; intros.\nsplit.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nrewrite H4.\nrewrite H2.\nring.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\ncase (gcd_neg a b); intros.\nsplit.\nexact (H1 a b H0).\nsplit.\nrewrite (mult_comm a b).\nrewrite H.\nelim H; intros.\nsplit.\nexact (H0 b H1).\nsplit.\nexact (H2 b H1).\nsplit.\nexact (H2 b H2).\nsplit.\nexact (H2 b H2).\nsplit.\nexact (H2 b H2).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nsplit; try assumption.\nsplit.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_1.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_1.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\napply gcd_0.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\napply gcd_intro with (S a); assumption.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros.\nsplit; auto.\nsplit.\napply gcd_intro.\nsplit.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_intro.\napply gcd_introQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\ncase (div_prime a b).\nintros H; elim H; intros.\nelim H; intros.\nsplit.\nexact (H1 (S p)).\nelim H; intros.\nsplit.\nexact (H1 (S p)).\nexact (H2 (S p)).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim H; intros.\nsplit.\napply divide_antisym.\napply H.\napply gcd_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6976,
                "proof_end_offset": 7247,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros.\nsplit.\nexact (H0 (S p)).\nexact (H1 (S p)).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros.\nelim H4; intros.\nelim H5; intros; elim H5; intros.\nsplit. exact (H6 a b d H H0 H1).\nclear H3 H4 H5 H6 H7 H8 H9 H10 H11.\nelim H1; intros.\nelim H5; intros.\nsplit. exact (H6 b d H H0 H1).\nexact (H7 b d H H0 H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nsplit. exact (H1 d H1).\nsplit.\nexact (H2 d H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros; elim H1; intros; elim H8; intros; \n elim H8; intros.\nsplit. exact H1. clear H H2 H3 H4 H5 H6 H7 H8.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros; elim H1; intros.\nelim (H1 a H3); intros.\nelim H3; intros.\nsplit. exact (H2 a H3).\nelim H3; intros.\nsplit. exact (H3 a H4).\nelim H4; intros; elim H4; intros.\nsplit. exact (H4 a H4).\nelim H4; intros.\nsplit. exact (H5 a H4).\nelim H4; intros; split. exact (H5 a H4).\nexact (H4 a H4).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit. exact (H3 b d H H0).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H; intros.\nelim H1; intros.\nsplit. exact (H0 d H1).\nsplit. exact (H1 d H1).\nsplit. exact (H1 d H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H; intros.\nelim H1; intros.\nsplit.\nexact (sym_sym_eq (S q) (S q)).\nexact (sym_eq (S q) (S q)).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros; elim H1; intros; elim H3; intros.\nsplit. exact (H1 H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\n unfold gcd in |- *; intros.\nelim H0; intros; elim H1; intros; elim H3; intros.\nsplit. apply H0.\n rewrite H1; rewrite H3; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 7249,
                "proof_end_offset": 8153,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_compl in |- *.\nintros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\napply (H2 0%nat a (S (S (S (S n))).\napply le_minus.\napply le_O_n.\napply le_plus_l.\napply le_plus_l.\nexact H.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\ncase H; intros.\nelim H0; intros; elim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H5; intros.\nelim H7; intros.\nelim (H5 a (div_O_z H)); intros; elim H8; intros.\nelim H8; intros.\nelim (H5 a (div_O_z H)); intros; elim H8; intros.\nelim (H5 a (div_O_z H)); intros; elim H8; intros.\nelim (H6 a (div_O_z H)); intros; elim H8; intros.\nelim (H7 a (div_O_z H)); intros; elim H8; intros.\nelim (H7 a (div_O_z H)); intros; elim H8; intros.\nelim (H6 a (div_O_z H)); intros; elim H8; intros.\nelim H8; intros.\nelim (H7 a (div_O_z H)); intros; elim H8; intros.\nelim (H8 a (div_O_z HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_inv in |- *; intros.\nelim H0; intros; elim H1; intros; elim H2; intros.\nelim H3; intros.\nelim (H4 (S x) (S x)).\nelim H3; intros.\nsplit; try assumption.\nelim (H5 (S x) (S x)).\nelim H4; intros.\nsplit; try assumption.\nelim (H5 (S x) (S x)).\nelim H4; intros.\nsplit; try assumption.\nelim (H5 (S x) (S x)).\nelim H4; intros.\nsplit; try assumption.\nelim (H6 (S x) (S x)).\nelim H4; intros.\nsplit; try assumption.\nelim (H6 (S x) (S x)).\nelim H4; intros.\nsplit; try assumption.\nelim (H6 (S x) (S x)).\nelim H4; intros.\nsplit; try assumption.\nelim (H6 (S x) (S x)).\nelim H4; intros.\nsplit; try assumption.\nelim (H6 (S x)Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_compl, div in |- *; intros.\nelim H0; intros; elim H1; intros.\nelim (H2 a H3); intros; elim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim (H5 (div_O_S H) (div_O_O H)); intros; elim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim (H6 (div_O_S H) (div_O_O_Sn H)); intros; elim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim (H5 (div_O_Sn H) (div_O_Sn H)); intros; elim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim (H8 (div_O_Sn H) (div_O_Sn H)); intros; elimQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_compl, A, B, C, D in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H1; intros.\nelim H2; intros; rewrite H3 in H2.\nelim H2; intros.\nelim H3; intros; elim H4; intros.\nsplit. \nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_div in |- *.\nintros.\nelim H0; intros.\nelim H1; intros; elim H2; intros.\nelim H4; intros.\nelim H6; intros.\nelim (H5 a (div_O_n H)); intros; elim H6; intros.\nelim H7; intros.\nrewrite H9; rewrite H9; rewrite H10; rewrite H10; assumption.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_compl in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nelim (H4 a x0); intros; elim H3; intros.\nelim H3; intros; elim H5; intros.\nsplit.\nexact H2.\nexact H2.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_compl, A, A, B in |- *; intros.\nelim H0; intros; elim H0; intros; elim H1; intros.\nelim H1; intros; elim H3; intros.\nelim H4; intros.\nsplit. \nelim H8; intros.\nelim (H8 a H8); intros.\nsplit.\nelim H8; intros.\nelim (H8 a H8); intros.\nsplit.\nelim H8; intros.\nelim (H9 a H8); intros.\nsplit.\nelim H8; intros.\nelim (H9 a H8); intros.\nelim (H8 a H8); intros.\nsplit.\nelim H8; intros.\nelim (H8 a H8); intros.\nsplit.\nelim H8; intros.\nelim (H9 a H8); intros.\nelim (H8 a H8); intros.\nsplit.\nelim H8; intros.\nelim (H8 a H8); intros.\nsplit.\nelim H8; intros.\nelim (H8 a H8); intros.\nelim (H9 a HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_div in |- *; intros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nsplit.\nexact H.\nelim H7; intros.\nelim H8; intros.\nsplit.\nexact H8.\nelim H8; intros.\nelim H8; intros.\nsplit.\nexact H8.\nelim H8; intros.\nsplit.\nexact H8.\nelim H8; intros.\nsplit.\nexact H8.\nelim H8; intros.\nsplit.\nexact H8.\nelim H8; intros.\nsplit.\nexact H8.\nelim H8; intros.\nsplit.\nexact H8.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nunfold is_compl in |- *.\nelim H0; intros; elim H1; intros.\nelim H1; intros.\nsplit.\nexact H1.\nelim H2; intros.\nsplit.\nexact H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "rewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n",
                "context_tokens": 684,
                "proof_start_offset": 8155,
                "proof_end_offset": 9563,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nexists x0.\nrewrite H7.\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_comm x H7).\nrewrite (mult_Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim H0; intros; elim H3; intros.\nelim H4; intros; elim H4; intros.\nexists x0; exists x1; split; trivial.\napply inv_ers_l with (d := d0); assumption.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros.\nelim H4; intros.\nexists x0; exists x0; split; [ assumption | assumption ].\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros.\nelim H3; intros.\nelim H4; intros.\napply (opp_correct S A (div_O_le (S (S (S n))) (div_O_eq (S (S n))) (div_O_eq (S (S n)));\n auto with arith.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S (S n)))).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S (S n))).\napply le_n_S.\napply le_n_S.\napply le_Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros; elim H0; intros.\nexists x0.\nsplit.\nunfold inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I, inv_fraction_I.\nsplit.\nrewrite (mult_comm (S a)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (SQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H3; intros.\nelim H4; intros.\nsplit; trivial.\nexists x0; split; trivial.\nexists x; split; trivial.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H3; intros; elim H4; intros.\nelim H5; intros; elim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nclear H10.\nelim H12; intros.\nelim H13; intros.\nelim H12; intros.\nelim H14; intros.\nelim H14; intros.\nelim H13; intros.\nelim H13; intros.\nelim H14; intros.\nelim H14; intros.\nelim H14; intros.\nelim H14; intros.\nelim H14; intros.\nelim H15; intros.\nelim H14; intros.\nelim H15; intros.\nelim H14; intros.\nelim H15; intros.\nelim H15; intros.\nelim H15; intros.\nelim H15;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros; elim H0; intros.\nelim H1; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; introsQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros; elim H0; intros; elim H0; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* [d2 = O] *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* [d2 <> 0] *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* [d1 <> 0] *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 9565,
                "proof_end_offset": 9774,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nunfold is_R in |- *.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros.\nelim (H6 d1 x H1); intros.\nelim H3; intros.\nexists x0.\nsplit; [ rewrite H3; rewrite H4; reflexivity | assumption ].\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x H.\nelim H; intros; elim H; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H2; intros.\nelim (H3 d1 H4); intros; elim H4; intros.\nelim (H5 d1 H4); intros; elim H5; intros.\nexists x; split; [ assumption | split; [ assumption | assumption ] ].\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H.\nintros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros.\nelim (H6 d1 x H H7); intros.\nelim H6; intros; elim H6; intros.\nelim (H6 d1 x H7); intros.\nelim H6; intros; elim H7; intros.\nsplit. exists x0; split; [ idtac | split ].\nreplace (S x0 * S x0 * S x0 * S x0) with (S x0 * S x0 * S x0).\nreplace (S x0 * S x0 * S x0 * S x0) with (S x0 * S x0 * S x0).\nrewrite (S_n (S x0 * S x0 * S x0) H7).\nring.\napply le_mult_reg_l with (S x0 * S x0 * S x0 * S x0).\nreplace (S x0 * S x0 * S x0 * S x0) with (S x0 * S xQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\napply div_O_opp; auto.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x Hx.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\napply opp_O_eq.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros.\nelim (H3 d1 x H H6); intros; elim H4; intros; elim H5; intros;\n elim H5; intros.\nelim (H5 d1 x H6); intros; elim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim (H6 d1 x H7); intros; elim H7; intros.\nsplit.\nexists I.\nsplit.\nunfold D_x, A, B, C in |- *.\napply (H12 d1 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H.\nintros.\nelim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; clear H4;\n elim H5; intros; elim H6; intros; elim H7; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; clear H8; \n elim H8; intros; clear H8; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; intros; clear H8; \n elim H8; intros; elim H8; intros; clear H8; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; intros; clear H8; \n elim H8; intros; elim H8; intros; elim H8; intros; clear H8; \n elim H8; intros; elim H8; intros;Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\napply (Build_Map (Ap:=fun x : S => x)).\napply H0.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x H1; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H8; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; elim H11; intros; \n elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H13; intros; \n elim H13; intros; elim H13; intros; \n elim H13; intros; elim H14; intros;Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x H; elim H.\nintros; elim H.\nintros; elim H0; intros; elim H0; intros.\nelim H1; intros; apply H1.\nrewrite H2.\nrewrite (plus_comm x H1).\nrewrite (mult_comm x H1).\nrewrite (mult_comm x H1).\nrewrite (mult_comm x H1).\nrewrite (mult_comm x H2).\nrewrite (mult_comm x H1).\nrewrite (mult_comm x H2).\nrewrite (mult_comm x H2).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H2).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H2).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x H3).\nrewrite (mult_comm x HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P Q.\n  destruct (P (fun x => P x)).\n  intros x H.\n  case (P (fun x => P x)).\n  intro H.\n  apply (H x).\n  apply H.\n  apply H.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P HP x.\nexact (Build_Prop (A:=A)).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP x.\n  apply P.\n  apply (H x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros.\napply (Build_Setoid (A:=A) (R:=A)).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP.\n  apply (Build_extensionality (fun x : A => P x)).\n  intro x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intro x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intro x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intro x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.\n  apply (Build_extensionality (fun x : A => P x)).\n  intros x.Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x.\n  induction H.\n  right.\n  assumption.\n  right.\n  apply H.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP.\n  apply (Build_extensionality A P HP).\n  intros x y.\n  apply (Build_extensionality A P HP).\n  intros x y.\n  apply (Build_extensionality A P HP).\n  intros x y.\n  apply (Build_extensionality A P HP).\n  intros x y.\n  apply (Build_extensionality A P HP).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intro A P.\n  apply (Build_R A (fun x : A => x)).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P P H x; exact (H x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP.\n  apply P.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p.\nsimple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple induction p.\n simple inductionQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n simple induction p.\n simpl in |- *. intros.\nauto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversionQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2.\nintros.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; apply inv_h.\nelim H; intros; apply inv_h.\nelim H; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim H0; intros; apply inv_h.\nelim HQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists x; auto with arith.\nexists y0; auto with arith.\nexists y0; auto with arith.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; trivial.\ninversion H0.\ninversion H1.\ninversion H2.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (S x0).\nexists (S x0).\nexists (S x0).\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plusQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H3.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H6.\ninversion H5.\ninversion H5.\ninversion H6.\ninversion H5.\ninversion H6.\ninversion H6.\ninversion H6.\ninversion H7.\ninversionQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (S x0); trivial.\nexists (S x0); trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H0.\ninversion H1.\ninversion H2.\nexists x; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2; intros.\ninversion H0.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nexists (S x0).\nelim H1; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim HQed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\n",
                "context_tokens": 200,
                "proof_start_offset": 1664,
                "proof_end_offset": 2222,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H0.\napply H1.\nassumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold is_group in H1.\nelim H1; intros x H2.\nelim H2; intros H3 H4.\nexists x; exists x0; auto.\nelim H3; intros x0 H5.\nexists x0; auto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold G in H0.\napply (H0 (S x)).\nassumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold G in |- *.\napply Trans with (G x).\napply Trans with (G y); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H0.\napply H1; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; auto.\nintros x y z H H'0; elim H'0; auto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; intros.\nunfold is_group in H0.\ncut (G x = G0).\nauto.\napply H1.\napply H2.\napply H0.\napply Trans with (G0 x).\napply Trans with (G0 x); auto with *.\napply Trans with (G1 x); auto with *.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H.\nintros.\napply H0.\nintros.\napply H1.\nintros.\napply H0.\nintros.\napply H1.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\ncut (G x /\\ G y /\\ G x /\\ G y /\\ G y /\\ G x = z).\n2: auto.\n2: auto.\n2: apply H1.\n2: apply H2.\n2: apply H0.\n2: assumption.\n2: apply H1.\n2: apply H2.\n2: assumption.\n2: assumption.\n2: apply H1.\n2: apply H2.\n2: apply H1.\n2: apply H2.\n2: apply H1.\n2: assumption.\n2: apply H1.\n2: apply H2.\n2: apply H1.\n2: assumption.\n2: apply H2.\n2: apply H2.\n2: apply H1.\n2: apply H2.\n2: apply H1.\n2: apply H1.\n2: apply H2.\n2: apply H1.\n2: apply H2.\n2: apply H2.\n2: apply H1.\n2: apply H1.\n2: apply H1.\n2: apply H2.\n2: apply H1Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H.\nintros x H'; elim H'; intros H'0 H'1; elim H'0.\nintros x0 H'1; elim H'1; intros H'2 H'3; elim H'3; intros H'4 H'5.\nelim H'5; intros H'5 H'6; elim H'6; intros H'7 H'7;\n elim H'7; intros H'8 H'9; elim H'10; intros H'10 H'10;\n elim H'10; intros H'11 H'11; elim H'11; intros H'12 H'13;\n elim H'12; intros H'13 H'14; elim H'14; intros H'14 H'15;\n elim H'15; intros H'15 H'16; elim H'16; intros H'16 H'17;\n elim H'16; intros H'15 H'16; elim H'17; intros H'15 H'16;\n elim H'16; intros H'16 H'17; elim H'16; intros H'17 H'18;\n elim H'16Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 434,
                "proof_start_offset": 2239,
                "proof_end_offset": 2567,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H0; intros; elim H3; intros; elim H3; intros; elim H4;\n clear H4 H5 H7 H8 H9 H10.\nrewrite (tech1 (Add x1 y1) (Add x2 y1) (Add x2 y2) (Add x1 y2) H0).\nelim H3; intros; elim H4; clear H4 H5 H7; intros.\ncut (x1 = x2); [ intro | apply H4; rewrite H5; assumption ].\nrewrite H1.\nrewrite (tech1 (Add x1 y1) (Add x2 y1) (Add x1 y2) H1).\nelim H3; intros; elim H4; clear H4 H5 H7; intros.\ncut (x1 = x2); [ intro | apply H4; rewrite H5; assumption ].\nrewrite H2.\nrewrite (tech1 (Add x1 y1) (Add x2 y1) (Add x2 y2) H).\nelim H3; intros; elim H4; clear H4 H5 H6; intros.\ncutQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros;\n clear H; elim H; intros; elim H; intros; elim H; \n clear H; intros; elim H; intros; elim H; intros;\n clear H; intros; elim H; intros; elim H; \n clear H; intros; elim H; intros; elim H; intros; \n clear H; elim H; intros; elim H; \n clear H; intros; elim H; intros; elim H; \n clear H; intros; elim H; intros; elim H; intros; \n clear H; elim H; intros; elim H; intros; \nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n clear H H0.\nelim (H3 x1); intros; elim H; intros; elim H; intros; elim H;\n clear H H0.\nelim (H4 x2); intros; elim H; intros; elim H; intros; elim H;\n clear H H0.\nelim (H4 x2); intros; elim H; intros; elim H; intros; elim H;\n clear H0.\nelim (H5 x1); intros; elim H; intros; elim H; intros; elim H;\n clear H H0.\nelim (H5 x2); intros; elim H; intros; elim H;\n clear H0.\nelim (H5 x2); intros; elim H; intros; elim H; intros; elim H;\n clear H H0.\nelim (H5 x1); intros; elim H; intros; elim H; intros;\n elim H; clear H0.\nelim (H6 x1); intros; elim H; intros; elim H; intros;\n elim H; clearQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2;\n clear H3 H4 H6.\nelim H3; clear H3 H4 H5 H6.\nelim H3; clear H3 H4 H6.\nelim H3; clear H3 H4 H6.\nelim H3; clear H3 H4 H6.\nelim H3; clear H3 H4 H6 H7 H8 H9 H10.\n(* use of col *)\nelim (H1 (Add (Add x1 y1) (Add x2 y1) (Add x2 y2) H3));\n intros; elim H3; clear H3 H4 H6.\nelim (H3 x1 y1); intros; elim H3; clear H3 H4 H6.\nelim H3; clear H3 H4 H6.\nelim H3; clear H3 H4 H6 H7 H8 H9 H10.\nelim H3; clear H3 H4 H5 H6 H7 H8 H9 H10.\nelim H3;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nunfold is_group, not in |- *; intros.\nelim (H1 (Add (Add x1 y1) (Add x1 y2) (Add x2 y2));\n auto with sets.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nsimple induction 1; intros; elim H0; intros; elim H1; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H4; \n clear H4 H5 H6 H7 H8 H9.\n(* use of transitivity *)\nelim (H6 (Add (Add x1 y1) (Add x2 y2) (Add x2 y1) (Add (Add x1 y2) (Add x1 y2) (Add x1 y2) (Add x1 y2) (Add x1 y2) (Add x2 y1) (Add x1 y2) (Add x1 y2) (Add x2 y1) (Add x2 y1) (Add x2 y1) (Add x2 y2) (Add x1 y1) (Add x2 y2) (Add x2 y1) (Add x2 y2) (Add x2 y2) (Add x2 y1) (Add x2 y2) (Add x2 y2) (Add x2 y2) (Add x2 y2) (Add x2 y2Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H;\n intros; clear H; elim H; intros; elim H; intros; clear H; \n elim H; intros; clear H; elim H; intros.\nclear H3 H4 H7 H9 H10.\n(* use of sign *)\nelim (H4 x H3); intros; elim H5; clear H5 H6 H7 H8 H9.\nelim H5; intros; elim H5; clear H5 H5 H7 H8 H9.\nelim H5; intros; elim H5; clear H5 H6 H7 H9.\nelim H5; intros; elim H5; clear H5 H7 H8 H9.\nelim H5; intros; elim H6; clear H6 H7 H9.\nelim H5; intros; elim H6; clear H5 H7 H8 H9.\nelim H5; intros; elim H6; clear H5 H7 H8 H9.\nelim H5; intros; elim H6; clear H5 H7 H9.\nelim H5; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5; \n clear H5 H7 H10 H11.\nelim (H6 (Add (Add x1 y1) (Add (Add x1 y1) (Add (Add x1 y1) (Add (Add x1 y1) (Add x1 y2) H3)));\n intros; elim H3; intros; elim H4; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\nelim (H7 x H3); intros; elim H5; clear H5 H6 H7 H8 H9 H10.\nelim (H8 x H3); intros; elim H5; clear H5 H6 H7 H8 H9 H10.\nelim (H8 x H3); intros; elim H5; clear H5 H6 H7 H9 H10.\nelim (H7 x H3); intros; elim H5; clear H5 H6 H7 H8 H9 H10Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; clear H3 H4; intros; elim H4; clear H4 H4; \n clear H3 H4 H5 H6 H7 H8 H9 H10.\nelim H3; intros; elim H3; clear H3 H4; intros; elim H4; clear H4 H5 H7; \n clear H3 H4 H5 H6 H7 H8 H9 H10.\nelim H3; intros; elim H4; clear H4 H5 H6; intros; elim H4; clear H4 H5 H7; \n clear H3 H4 H5 H6 H7 H8 H10 H10.\nelim H3; intros; elim H4; clear H4 H5 H7; intros; elim H4; clear H5 H7; \n clear H5 H7 H8 H9 H10 H11.\nelim H3; intros; elim H4; clear H4 H5 H7; intros; elim H4; clear H5 H6; \n clear H5 HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5; \n intros; elim H5; intros; elim H6; intros; elim H7; \n intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; \n intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "                                                  *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 549,
                "proof_start_offset": 2588,
                "proof_end_offset": 3197,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros. \nclear H3.\nrewrite (add_comm x2 y1) in H2.\nrewrite (add_comm x2 y2) in H2.\nrewrite (add_comm x1 y1) in H2.\nrewrite (add_comm y1 y2) in H2.\nrewrite (add_comm x1 y2) in H2.\nrewrite (add_comm y1 y2) in H2.\nrewrite (add_comm y1 y2) in H2.\nrewrite (add_comm y1 y2) in H2.\nrewrite (add_comm y2 y1) in H2.\nrewrite (add_comm y1 y2) in H2.\nrewrite (add_comm y1 y2) in H2.\nrewrite (add_comm y2 y2) in H2.\nrewrite (add_comm x2 y2) in H2.\nrewrite (add_comm y1 y2) in H2.\nrewrite (add_comm x1 y2) in H2.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H5; \n clear H5 H6 H7 H8 H9 H10 H11.\n(* use of neutral *)\nelim (H3 (Opp x1 y1) x1 y1); intros; elim H5; clear H5 H6.\nelim (H1 (Ap x1 y1) x2 y2); intros; elim H5; clear H5 H7 H8 H9.\nrewrite <- (plus_n_O x1 y1); elim (minus_n_O y1 H6);\n auto with arith.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_injective.\napply opp_Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; \n intros; elim H4; intros; elim H4; intros; elim H4; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H10; intros; elim H9; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; \n clear H4 H4 H5 H7 H8 H9 H10 H11.\nrewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H8; rewrite <- H8; rewrite <- H8;\n rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H8; rewrite <- H8;\n rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H8; rewrite <- H7;\n rewrite <- H7; rewrite <- H7; rewrite <- H8; rewrite <- H7; rewrite <- H8;\n rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H7;\n rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- H7;\n rewrite <- H7; rewrite <- H7; rewrite <- H7; rewrite <- HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; \n elim H8; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H11; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; clear H1.\nclear H3 H4 H5 H6 H7 H8 H9 H10 H11.\nrewrite <- (inv H0 x1); rewrite (inv H0 x2); rewrite (inv H0 y1); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2;\n clear H2 H3; intros; elim H3; intros; elim H4;\n clear H4 H5 H6 H7 H8 H9 H10.\nrewrite (assoc (S x1) (S x2) (S y2) (S y2) (S y2)); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H7; intros;\n elim H8; intros; elim H8; intros; elim H8; intros;\n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H10; intros;\n elim H8; intros; elim H9; intros; elim H10; intros;\n elim H10; intros; elim H10; intros; elim H10; intros;\n elim H10; intros; elim H10; intros; elim H11; intros; \n elim H10; intros; elim H11; intros; \n elim H12; intros; elim H12; intros; \n elim H13; intros; elim H13; intros; \n elim H13;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": " Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\n",
                "context_tokens": 733,
                "proof_start_offset": 3214,
                "proof_end_offset": 3568,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; rewrite H; clear H; rewrite <- H; clear H.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutive x); rewrite (opp_involutive x).\nrewrite (opp_involutiveQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply H.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; rewrite H4; rewrite H4; rewrite H5; rewrite H6; ring.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H0; intros; elim H; intros; elim H; intros;\n elim H0; intros; elim H0; intros; elim H0; intros;\n elim H0; intros; elim H0; intros; elim H0; intros;\n elim H0; intros; elim H1; intros; elim H1; intros;\n elim H0; intros; elim H1; intros; elim H2; intros;\n elim H1; intros; elim H3; intros; elim H3; intros;\n elim H3; intros; elim H3; intros; elim H4; intros; \n elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros;\n elim H8; intros; elim H9; intros; elim H8; intros; elim H9; intros;\n elim H10; intros; elim H8; intros; elim H9;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; introsQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H6; intros; elim H7; intros; elim H8; intros;\n elim H7; intros; elim H8; intros; elim H8; intros;\n elim H9; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H9; intros;\n elim H10; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply opp_transitive.\nrewrite H; auto with *.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive x); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H7; intros;\n elim H8; intros; elim H8; intros; elim H8; intros;\n elim H8; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H10; intros; elim H9; intros;\n elim H9; intros; elim H10; intros; elim H10; intros;\n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\n",
                "context_tokens": 716,
                "proof_start_offset": 3585,
                "proof_end_offset": 4727,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nunfold is_group inQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; intros.\nrewrite H; reflexivity.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Ar x) (Ar x) (Ar x) (Ar y) (Ar y) (Ar x) H).\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (plus_comm x y).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm x y).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm y x).\nrewrite (plus_comm yQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; simpl in |- *.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H7; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H11; intros; elim H12; \n intros; elim H13; intros; elim H13; intros; elim H12; \n intros; elim H13; intros; elim H14; intros; elim H15; \n intros; elim H15; intros; elim H15; intros; elim H16; intros; elim H16; \n intros; elim H16; intros; elim H16; intros; elim H18; \n introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H11; intros; \n elim H11; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; elim H11; \n intros; elim H12; intros; elim H12; intros; \n elim H10; intros; elim H12; intros; elim H12; \n intros; elim H13; intros; elim H13; intros; \n elim H14; intros; elim H14;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) y).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float y (Float y (Float z (Zpos (xO xH)))) (Zpos (xO xH)))).\nrewrite <- H0; unfold is_group in |- *; intros.\napply (opp_unicity H (Float z (Zpos (xO xH)))) (Zpos (xO xH))).\nrewrite <- H0; unfold is_group in |- *; intros.\napply (opp_unicity H (Float z (Zpos (xO xH)))) (Zpos (xO xH))).\nrewrite <- H0; unfold is_group in |- *; intros.\napply (opp_unicity H (Float z (Zpos (xO xH)))))) (Zpos (xO xHQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (inv_inv_r (Opp x y)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_r (Opp y x)).\nrewrite (inv_r (Opp x y)).\nrewrite (inv_rQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H11; \n clear H10; intros; elim H10; intros; elim H11; \n clear H10; intros; elim H10; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H10; \n clear H10; intros; elim H10; intros; elim H10Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H0; intros; elim H3; intros; auto with *.\nelim H0; intros; elim H3; intros; auto with *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\n\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* G (x+y) *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* G ((-x)+(-y)) *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* (x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0 *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* x+(-x) = 0 (-x)+x = 0 *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* y+(-y) = 0 (-y)+y = 0 *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* 0+0 = 0 *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n(****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 4748,
                "proof_end_offset": 4967,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros.\napply (opp_unicity H (Add (O:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (S:=O) (Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nunfold is_group in |- *; simpl in |- *; auto with *.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_inj.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_unicity H (Opp (Opp 1) H) (Opp (Opp 1 H) H)).\nunfold is_group in |- *; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; introsQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold is_group in |- *; intros.\nelim H; intros; elim H; intros; elim H; intros; clear H;\n elim H; intros; elim H; intros; elim H; intros; elim H0; intros; clear H;\n elim H0; intros; elim H; intros; elim H0; intros; clear H0;\n elim H0; intros; elim H0; intros; clear H0;\n elim H0; intros; elim H0; intros; clear H0;\n elim H1; intros; elim H0; intros; clear H0;\n elim H1; intros; elim H1; intros; elim H2; \n intros; clear H1; elim H3; intros; clear H3; \n elim H3; intros; elim H4; intros; clear H4; \n elim H4; intros; clear H5; clear H5 H6 H7.\nelim H4; intros; elim H5; intros; elim H5; intros; clear H5; \n elim H5; intros; elim H5; intros; clear H5; \n elim H5; intros; elim H5; intros; clear H6Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros.\napply (opp_transitive H (Add (Opp O) (Ar2 O) (Ar2 O))).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add (Opp O) (Ar2 O) (Ar2 O))).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Add (Opp O) (Ar2 O) (Ar2 O))).\nunfold is_group in |- *; intros.\napply (opp_transitive H (Add (Opp O) (Ar2 O) (Ar2 O) (Ar2 O)).\nunfold is_group in |- *; intros.\napply (opp_transitive H (Add (Opp O) (Ar2 O) (Ar2 O) (Ar2 O))).\nunfold is_group in |- *; intros.\napply (opp_transitive H (Add (Opp O) (Ar2 O) (Ar2 O))).\nunfold is_group in |- *; intros.\napply (opp_transitive H (Add (Opp O) (Ar2 O) (Ar2 O) (Ar2 O)))).\nunfold is_group in |- *; introsQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_unicity H (Add O) (Add (Add O) (Add (Add O) (Add (Add O) (Add (Add O) (Add (Add (Add (Add O) (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (Add (S (S O) (Add (Add (S O) (Add (Add (S O) (Add (Add (Add (Add (S (Add (S O) (Add (Add (Add (S (Add (S (Add (S (S O) (Add (Add (S (Add (Add (S O) (Add (Add (S (S (Add (S (S O) (Add (Add (S (S (S (S (S (S (S (S (S O) (Add (Add (S (S (S O) (S (S (S (S O) (Add (S O) (Add (S (S (S (S (S (S O) (Add (S (S (S (S (S O) (S (S O))))))))).\nunfold is_Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_unicity H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_unicity H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_unicity H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_transitive H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_unicity H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_transitive H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_transitive H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_transitive H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_transitive H (Opp x y) (Opp y x)).\nunfold is_any in |- *; intros.\napply (opp_transitive HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  case n.\n  reflexivity.\n  simpl.\n  caseQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  induction n.\n  reflexivity.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n.\n  simpl.\n  simple induction n.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n; simpl; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nsimple induction n.\nauto with *.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nsimple induction n.\n reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros.\n  induction n.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros.\n unfold multZ in |- *.\n rewrite (plus_comm n1).\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite (plus_comm n1).\n rewrite (plus_comm n1).\n rewrite (plus_comm (mult_comm n1)).\n rewrite (plus_comm n1).\n rewrite (plus_comm (mult_comm n1)).\n rewrite (plus_comm (mult_comm n1)).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (plus_comm (mult_comm (mult_comm n1))).\n rewrite (Qed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros n1 n2.\n destruct n1; simpl; auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_permute_r : forall x y : Z, multZ (Zneg x) y = multZ (pos x) y.\nProof mult_permute_r.\n\nLemma mult_permute_r : forall x y : Z, multZ (Zneg x) y = multZ (Zpos y) (Zpos y).\nProof mult_permute_r.\n\nLemma mult_permute_l : forall x y : Z, multZ (Zneg x) y = multZ (Zpos y) (Zpos y).\nProof mult_permute_l.\n\nLemma mult_permute_r : forall x y : Z, multZ (Zneg x) y = multZ (Zpos y) (Zpos y).\nProof mult_permute_r.\n\nLemma mult_permute_r : forall x y : Z, multZ (Zpos x) y = multZ (Zpos y) x.\nProof mult_permute_r.\n\nLemma mult_permute_r : forall x y : Z, multZ (Zneg x) y = multZ (Zpos y) (Zpos x).\nProof mult_permute_r.\n\nLemma mult_permuteQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_commutative : forall x y : Z, multZ (neg x) y = mult x y.\nProof mult_commutative.\n\nLemma mult_commutative : forall x y : Z, multZ (neg x) y = mult x y.\nProof mult_commutative.\nLemma mult_comm_r_reverse : forall x y : Z, multZ (neg x) y = mult x y.\nProof mult_commutative.\n\nLemma mult_comm_reverse : forall x y : Z, multZ (neg x) y = mult x y.\nProof mult_commutative.\n\nLemma mult_comm_reverse : forall x y : Z, multZ (neg x) y = mult x y.\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse : forall x y : Z, multZ (neg x) y = mult x y.\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse : forall x y : Z, multZ (neg x) y = mult x y.\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse : forall x y : ZQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq3.\n\nLemma mult_permute_r : forall x y : Z, multZ (posnatMult x y) y = x * y.\nProof mult_permute_r.\n\n(***********)\n\nLemma mult_permute_r : forall x y : Z, multZ (neg x) y = x * y.\nProof mult_permute_r.\n\nLemma mult_permute_r : forall x y : Z, multZ (Zneg x) y = x * y.\nProof mult_permute_r.\n\nLemma mult_permute_r : forall x y z : Z, multZ (Zneg x) y = multZ (Zpos y) z.\nProof mult_permute_r.\n\nLemma mult_permute_r : forall x y z : Z, multZ (Zpos x) y = multZ (Zpos y) z.\nProof plus_permute_r.\n\nLemma mult_permute_r : forall x y z : Z, multZ (Zpos x) y = multZ (Zpos y) z.\nProof plus_permute_r.\n\nLemma mult_permute_r : forall x y z : Z, multZQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_pyth_l : forall x y : Z, multZ (pos x) y = multZ (pos x) y.\nProof multZ_eq5.\nLemma mult_ Corporation : forall x y : Z, multZ (neg x) y = multZ (pos x) y.\nProof multZ_eq_6.\n\nLemma mult_comm : forall x y : Z, multZ (neg x) y = multZ (neg x) y.\nProof mult_comm.\nLemma mult_comm : forall x y : Z, multZ (neg x) y = multZ (neg y) x.\nProof mult_comm.\nLemma mult_comm : forall x y : Z, multZ (neg x) y = multZ (neg x) y.\nProof mult_comm.\nLemma mult_comm : forall x y : Z, multZ (neg x) y = multZ (pos x) y.\nProof mult_comm.\nLemma mult_comm : forall x y : Z, multZ (neg x) y = multZ (neg x) y.\nProof mult_comm.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_comm_reverse : forall x y : Z, multZ (Zneg x) y = multZ (Zpos y) (x + y).\nProof mult_comm_reverse.\n\nLemma mult_assoc_reverse : forall x y z : Z, multZ (Zpos x) y = multZ (Zpos y) (Zpos z).\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse : forall x y z : Z, multZ (Zpos x) y = multZ (Zpos y) (Zpos z).\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse : forall x y z : Z, multZ (Zneg x) y = multZ (Zpos y) (Zpos z).\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse : forall x y z : Z, multZ (Zneg x) y = multZ (Zpos y) (Zpos z).\nProof mult_comm_reverse.\n\nLemma mult_assoc_reverse : forall x y z : Z, multZ (Zpos x) y = multZ (Zpos y) (Zpos z).\nProof plus_Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_predZ_r : forall x y : Z, multZ (succZ x) y = multZ (neg x) y.\nProof multZ_eq5.\n\nLemma mult_Znat_eq5 :\n forall x y : Z, multZ (Zpos (xO x)) y = multZ (Zpos (xO x)) y.\nProof multZ_eq5.\n\nLemma mult_eq_compat_l :\n forall (x y : Z) (y : Z),\n multZ (Zpos (xO x)) y = multZ (Zpos (xO x)) y.\nProof multZ_eq_compat_l.\n\nLemma mult_eq_compat_r : forall x y z : Z,\n multZ (Zpos (xO x)) y = multZ (Zpos (xO y)) (Zpos (xO z)).\nProof mult_eq_compat_r.\n\nLemma mult_eq_compat_r : forall x y z : Z,\n multZ (Zpos (xO x)) y = multZ (Zpos (xO y)) (Zpos (xO z)).\nProof mult_eq_compat_r.\n\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_succZ_r : forall x y : Z, multZ (neg (S x)) y = multZ (pos x) y.\nProof multZ_eq5.\n\nLemma mult_lincomb_r : forall x y : Z, multZ (neg (S x)) y = multZ (pos x) y.\nProof multZ_eq5.\n\nLemma mult_Nle_r : forall x y : Z, multZ (Zneg (S x)) y = multZ (neg x) y.\nProof mult_ BDDmake.\n\nLemma mult_permute_reverse : forall x y : Z, multZ (Zneg (S x)) y = multZ (pos x) y.\nProof mult_commutative.\n\nLemma mult_permute_reverse : forall x y : Z, multZ (Zneg (S x)) y = multZ (Zpos (S y)) x.\nProof mult_commutative.\n\nLemma mult_permute_reverse : forall x y : Z, multZ (Zpos (S x)) y = multZ (Zpos (S y)) x.\nProof mult_skip.\n\nLemma mult_permuteQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_comm : forall x y : Z, multZ (neg x) y = multZ (neg x) y.\nProof multZ_eq5.\n\nLemma mult_comm : forall x y z : Z, multZ (neg x) y = multZ (neg y) z.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (neg x) y = multZ (neg x) z.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (neg x) y = multZ (neg x) z.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (neg x) y = multZ (neg x) z.\nProof mult_comm.\n\nLemma mult_comm : forall x y z : Z, multZ (neg x) y = multZ (neg x) z.\nProof plus_comm.\n\nLemma mult_assoc : forall x y z : Z, multZ (neg x) y = multZ (neg x) z.\nProof plus_Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_OZ_l : forall x y : Z, multZ (Zneg x) y = multZ (Zpos x) y.\nProof mult_genZ_l.\n\nLemma mult_OZ_r : forall x y : Z, multZ (Zneg x) y = multZ (Zpos x) y.\nProof mult_(**********_ring.\n\nLemma mult_comm : forall x y : Z, multZ (Zpos x) y = multZ (Zpos x) y.\nProof mult_:(?mod_def) (only parsing).\nLemma mult_comm : forall x y : Z, multZ (Zpos x) y = multZ (Zpos x) y.\nProof mult_comm.\nLemma mult_comm : forall x y : Z, multZ (Zpos x) y = multZ (Zpos x) y.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (Zneg x) y = multZ (Zpos y) z.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (Zpos x) y = multZ (ZposQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_OZ_r : forall x y : Z, multZ (neg x) y = oppZ x y.\nProof multZ_eq_5.\n\nLemma mult_integral_r : forall x y : Z, multZ (neg x) y = oppZ x y.\nProof multZ_eq_5.\n\nLemma mult_integral_r : forall x y : Z, multZ (neg x) y = oppZ x y.\nProof mult_integral_r.\n\nLemma mult_integral_r : forall x y : Z, multZ (neg x) y = oppZ x y.\nProof mult_integral_r.\n\nLemma mult_integral_r : forall x y : Z, multZ (neg x) y = oppZ x y.\nProof mult_integral_r.\n\nLemma mult_integral_r : forall x y : Z, x + -y = oppZ y.\nProof plus_integral_r.\n\nLemma mult_integral_r : forall x y : Z, x * -y = oppZ y.\nProof plus_integral_r.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* Rewrite mult_pyth_l; rewrite <- (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (multQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* lam n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* negQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* branch *)\nintros; unfold oppZ in |- *; rewrite (tech_mult_negZ x y).\nelim (addZ_integral (multZ x y) (plusZ (neg y) (oppZ y))).\nintros.\nelim (addZ_integral (multZ x y) (oppZ y) (oppZ y)).\nintros.\nelim (addZ_integral (multZ x y) (oppZ y) (oppZ y)).\nintros.\nelim (addZ_integral (multZ x y) (plusZ (neg y) (oppZ y))).\nintros.\nelim (addZ_integral (multZ x y) (plusZ (neg y) (oppZ y))).\nintros.\nelim (addZ_integral (multZ x y) (oppZ y) (oppZ y)).\nintros.\napply (add_reg_l (x + y) (y + - - - x)).\nrewrite (mult_comm x (x + y)).\nrewrite (mult_comm y (x + y)).\nrewrite (mult_comm (x + y)).\nrewrite (mult_comm (x + y)).Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq_4.\n\nLemma mult_predZ_r : forall x y : Z, multZ (predZ x) y = predZ (multZ x y) (oppZ y).\nProof mult_ Nonempty_eq_4.\n\nLemma mult_succZ_l : forall x y : Z, multZ (predZ x) y = predZ (multZ x y) (multZ x y).\nProof mult_ Nonempty_eq_4.\n\nLemma mult_ ifeq_r :\n forall x y z : Z, multZ (succZ x) y = predZ (multZ x y) (multZ y z).\nProof mult_Theory.\n\nLemma mult_monotonic_r :\n forall x y z : Z, multZ (predZ x) y = predZ (multZ x y) (multZ y z).\nProof mult_Theory.\n\nLemma mult_monotonic_r :\n forall x y z : Z, multZ (posnatMult x y) z = lnot (multZ x y) (multZ x z).\nProof mult_Theory.\n\nLemma mult_monotonic_r :\n forall x y z : Z, multZ (posnatMult x yQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq_5.\n\nLemma mult_predZ_r : forall x y : Z, multZ (zdrop x) y = predZ (multZ x y) (oppZ y).\nProof multZ_eq_6.\n\nLemma mult_addZ_posZ : forall x y : Z, multZ (predZ x) y = paire (multZ x y) (multZ x y).\nProof mult_comoid_l.\n\nLemma mult_permute_r :\n forall x y z : Z, multZ (succZ x) z = multZ (posnatMult x y) (multZ z y).\nProof mult_permute_r.\n\nLemma mult_permute_r :\n forall x y z : Z, multZ (zdrop x y) z = multZ (zdrop x y) (multZ z y).\nProof mult_permute_r.\n\nLemma mult_permute_r :\n forall x y z : Z, multZ (posnatMult x y) z = multZ (zdrop x y) (multZ z y).\nProof mult_permute_r.\n\nLemma mult_permute_r :\n forall x y z : Z, multQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* IZ *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* neg S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* neg S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* neg S n *)\nintros; elim n.\n(* neg S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* neg S n *)\nintros; elim n.\n(* neg S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* pos S n *)\nintros; elim n.\n(* neg S n *)\nintros; elim n.\n(* neg S nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* GG *)\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* GG *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof mult_DOMAIN_r.\n\n(**************)\nLemma mult_pyth_l : forall x y : Z, multZ (addZ x y) y = x * y.\nProof mult_ BDDmake.\n\nLemma mult_succZ_r : forall x y : Z, multZ (addZ x y) y = x * y.\nProof mult_ BDDmake.\n\nLemma mult_comm : forall x y z : Z, multZ x (gcdGI y z) = x * z + y * z.\nProof mult_Minus.\n\nLemma mult_reverse : forall x y z : Z, multZ x (Zshiftin y z) = x * z + y * z.\nProof mult_prepare.\nLemma mult_comm : forall x y z : Z, multZ x (Zshiftin y z) = y * x * z + z.\nProof mult_Minus.\n\nLemma mult_comm : forall x y z : Z, multZ x (Zshiftin y z) = x * z + y * z.\nProof mult_Minus.\n\nLemma mult_comm : forall x y z : Z, multZ x (Tarray y z) = y * x * z.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* branch *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* Inverse *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos (S n0) *)\nintros; rewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_mult_negZ n0 y).\nrewrite (tech_multQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* Idem *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nintros; elim n.\n(* abs n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elimQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* den *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; unfold Zminus in |- *; reflexivity.\n(* pos (S n0) *)\nintros; unfold Zminus in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; unfold Zminus in |- *; reflexivity.\n(* pos (S n0) *)\nintros; rewrite (tech_mult_negZ n0 y).\nelim (addZ_denominator (multZ (pos n0) y) (oppZ y) (oppZ y))).\nintros; reflexivity.\n(* pos (S n0) *)\nintros; unfold Zminus in |- *; reflexivity.\n(* pos (S n0) *)\nintros; unfold Zminus in |- *; reflexivity.\n(* neg (S n0) *)\nintros; unfold Zminus in |- *; reflexivity.\n(* pos (S n0) *)\nintros; unfold Zminus in |- *; reflexivity.Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof multZ.\n\nLemma mult_succZ_r : forall x y : Z, multZ (succZ x) y = OZ x y.\nProof multZ.\n\nLemma mult_predZ_r : forall x y : Z, multZ (predZ x) y = OZ x y.\nProof multZ.\n\nLemma mult_succZ_r : forall x y : Z, multZ (predZ x) y = OZ x y.\nProof multZ.\n\nLemma mult_succZ_r : forall x y : Z, multZ (predZ x) y = den x y.\nProof multZ.\n\nLemma mult_comoid_r : forall x y : Z, multZ (succZ x) y = den x y.\nProof mult_comoid.\n\nLemma mult_permute_l : forall x y : Z, multZ (zdrop x) y = den x y.\nProof mult_diag.\n\nLemma mult_permute_r : forall x y : Z, multZ (succZ x) y = den x y.\nProof mult_diag.\n\nLemma mult_permute_r : forall x y : Z, multZ (zdrop x y) y =Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nsimple induction x.\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n (* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 1 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nrewrite (add_mLEN x y); rewrite (add_myp x y); rewrite (add_myp x y).\nrewrite (mult_comm (-x) (-y)).\nrewrite (mult_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (plus_comm (-x) (-y)).\nrewrite (Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivityQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* negative *)\nreflexivity.\n(* negative *)\nreflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nsimple induction x.\nreflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nsimple induction x.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* neg 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.\n(* pos 0 *)\nintros; reflexivity.Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* negative *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg (S x) *)\nreflexivity.\n(* neg (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* neg (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* neg (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (SQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nsimple induction x.\n(* negative *)\nreflexivity.\n(* positive *)\nreflexivity.\n(* positive *)\nreflexivity.\n(* positive *)\nreflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* negative *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x; elim x.\n(* negative *)\nreflexivity.\n(* negative *)\nreflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; auto with arith.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nunfold oppZ, oppZ in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* neg 0 *)\nintros; unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *;\n unfold oppZ in |- *; rewrite Zplus_opp_r; rewrite Zplus_opp_r;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm;\n rewrite Zmult_comm; rewrite Zmult_comm; rewrite Zmult_comm; rewriteQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; unfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\nintros; rewrite (plus_comm x (Zneg p)).\nrewrite <- (plus_comm x (Zneg p)).\nrewrite <- (plus_comm (Zpos p)).\nrewrite <- (plus_comm (Zpos p)).\nrewrite <- (plus_assoc x (Zpos p)).\nrewrite <- (plus_assoc x (Zneg p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc x (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos p)).\nrewrite <- (plus_assoc (Zpos pQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nunfold multZ, oppZ in |- *; intros; rewrite (plus_comm x); reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nunfold multZ in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x; elim x.\n(* neg 0 *)\nintros; rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x); rewrite (tech_com x);\n rewrite (tech_com x); rewrite (tech_com xQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct y.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction m.\n(* pos n *)\nsimple induction m.\nsimple induction m.\n(* abs n *)\nsimple induction m.\nsimple induction m.\n(* abs n *)\nsimple induction m.\nsimple induction m.\n(* abs n *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* Rewrite (mult_comm 0 x); rewrite (mult_comm 0 x); rewrite (mult_comm 0 x); reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimpl in |- *; reflexivity.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction xQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct y.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* posQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple induction x.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* abs 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple induction n.\n (* pos 0 *)\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_mult_negZ x 0 H); reflexivity.\nintros; rewrite (tech_mult_negZ x 0 H); reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_mult_negZ x 0 H); reflexivity.\nintros; rewrite (tech_mult_negZ x 0 H); reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * y)).\nrewrite (mult_comm (x * yQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* pos (S x) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* neg 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple inductionQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\nintros; reflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction m.\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* abs n *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* pos n *)\nsimple induction m.\nsimple induction m.\n(* pos n *)\nsimple induction m.\nsimple induction m.\n(* pos n *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* n *)\nsimple induction mQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct y.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* negative *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nsimple induction m.\n(* neg O *)\nsimple induction n.\n(* pos O *)\nsimple induction m.\n(* pos O *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* neg O *)\nsimple induction m.\nsimple induction m.\n(* neg O *)\nsimple induction m.\nsimple induction m.\n(* pos O *)\nsimple induction m.\nsimple induction m.\n(* pos O *)\nsimple induction m.\nsimple induction m.\n(* pos O *)\nsimple induction m.\nsimple induction m.\n(* neg O *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* cond O *)\nsimple induction m.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction n.\n(* neg 0 *)\nsimple induction m.\nrewrite (plus_comm 0 1).\nrewrite (plus_comm 0 1).\nrewrite (plus_comm 0 1).\nrewrite (plus_comm (S (S (S m))).\nrewrite (plus_comm (S (S (S m)))).\nrewrite (plus_comm (S (S (S (S m)))).\nrewrite (plus_comm (S (S (S m)))).\nrewrite (plus_comm (S (S (S m)))).\nrewrite (plus_comm (S (S (S (S m)))).\nrewrite (plus_comm (S (S (S m)))).\nrewrite (plus_comm (S (S (S m)))).\nrewrite (plus_comm (S (S (S (S m)))))).\nrewrite (plus_comm (S (S (S (S m)))).\nrewrite (plus_comm (S (S (S (S m)))))).\nrewrite (plus_comm (S (S (S m)))).\nrewrite (plus_comm (S (S (S m)))).\nrewrite (plus_comm (S (Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* Empty *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimple induction m.\nsimpl in |- *.\nsimple induction n.\n(* m = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct y.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* negative *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction m.\nsimple induction n.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* neg 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* neg 0 *)\nsimple induction m.\nsimple induction m.\n(* neg 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Z y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 8247,
                "proof_end_offset": 8887,
                "proof": "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_IZ y).\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H.\nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (mult_mIZ y).\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H.\nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\nsimple induction m.\n(* abs n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\n(* n *)\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.\nsimple induction m.\n(* m *)\nsimple induction m.Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\n(* cond *)\nsimple induction n.\n(* cond 0 *)\nreflexivity.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nreflexivity.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple inductionQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction Z.\n (* 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_mult_posZ x (pos 0)); rewrite H; reflexivity.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nintros x H; rewrite (tech_mult_negZ x (pos 0)); rewrite H; reflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nintro x; elim x.\n(* pos (S x) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H; reflexivity.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\n\n(* First, it is a morphism *)\napply mult_nmn_plus_one_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_zero_eq_zero_eq_zero_eq_zero_zero_eq_zero_eq_zero_zero_eq_zero_eq_zero_zero.\n(* no inverse *)\napply mult_nmn_plus_one_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_eq_zero_zero_eq_one_eq_zero.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nexact mult_nbv.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction n.\n (* neg 0 *)\nreflexivity.\n(* neg 0 *)\nintros.\nelim (mult_comm (pos n) (pos n)).\n(* neg 0 *)\nintros n H; rewrite (tech_add_negZ n (neg n)).\nrewrite (add_comm (-neg n)) at 1; rewrite H. \napply mult_mix_pos.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros.\nelim (mult_comm (pos n) (pos n)).\n(* neg 0 *)\nintros n H; rewrite (tech_add_negZ n (neg n)).\nrewrite (add_comm (-neg n)) at 1; rewrite H. \napply plus_mix_pos.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nintros.\nelim (mult_comm (neg n) (neg n)).\n(* pos 0 *)\nintros n H; rewrite (tech_add_negZ n (neg n)).\nrewrite (mult_comm (-neg n)) at 1; rewrite H. \napply mult_mix_posQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction n.\n(* abs n *)\nreflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_posZ y (pos 0)).\nrewrite (mult_comm x y); reflexivity.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg 0 *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimpleQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple inductionQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8912,
                "proof_end_offset": 9098,
                "proof": "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nProof.\nunfold neutral in |- *.\nsplit.\nexact I.\nintros.\nsplit.\nelim (multZ_commutativity IZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nProof.\nunfold ZAxiomsMiniSig, Z IdZ, Zcar, Zcar, Zshiftr, Zneg, Zopp in |- *;\n intros; elim H.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z at 2 in |- *; intros; elim x.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm x y).\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple inductionQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold|})) in |- *; intros; elim x.\n(* pos n *)\nintros x y H; rewrite (tech_mult_posZ y (pos n)); rewrite H. \nelim (mult_bezout_l x (pos n)) y0); unfold squareZ in |- *; reflexivity.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z_div in |- *; intros; elim x.\n(* neg 0 *)\nintros; elim (mult_comm x 0); apply mult_n_Sm; assumption.\n(* neg 0 *)\nintros; elim (mult_comm x 0); apply mult_n_Sm; assumption.\n(* neg 0 *)\nintros; elim (mult_comm x 0); apply mult_n_Sm; assumption.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z_to_Z in |- *; intros; elim x.\n(* neg 0 *)\nintros y H; rewrite (tech_mult_negZ y0); rewrite H. \nelim (mult_OZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z, oppZ in |- *; intros; elim x.\n(* neg (S y0) *)\nintros y H; rewrite (tech_mult_posZ y0 y0); rewrite H. \nelim (mult_IZ x (pos y0)); unfold multZ in |- *; reflexivity.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z at 2 in |- *; intros; elim x.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple inductionQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Ceq in |- *; intros; elim x.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nProof.\nunfold InitialRing in |- *; intros; elim x.\n(* pos (S y) *)\nintros z H; rewrite (tech_mult_posZ y (pos z)); rewrite H; reflexivity.\n(* neg n *)\nintros z H; rewrite (tech_mult_posZ z (neg z)); rewrite H; reflexivity.\n(* neg n *)\nintros z H; rewrite (tech_mult_negZ z (neg z)); rewrite H; reflexivity.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold IZ, Z in |- *; intros; elim x.\n(* pos n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* neg n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nintros n; elim n.\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\n",
                "context_tokens": 743,
                "proof_start_offset": 9133,
                "proof_end_offset": 10783,
                "proof": "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nProof.\nunfold distributivity in |- *; intros; case x.\nsplit; reflexivity.\nsimple induction n.\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z).\nreflexivity.\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\nsimple induction n.\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z).\nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nintros y0 H.\nsplit.\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros.\nrewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim (add_add Z addZ addZ_commutativity addZ_associativity (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold ZAxiomsMiniSig, multZ in |- *; intros; elim x.\n(* with 0 *)\nelim (mult_zero_r 0); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zcri in |- *.\nintros; elim x.\n(* pos (S y) *)\nintros.\nrewrite (mult_comm (- y0)).\nunfold multZ in |- *; reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold ZZ in |- *; intros; elim x.\n(* 0 *)\nintros x H; rewrite (tech_mult_negZ y x); rewrite H. \nelim (mult_ cS x); reflexivity.\n(* 0 *)\nintros x H; rewrite (tech_mult_negZ x (neg 0)); rewrite H. \nelim (mult_EGAL_r x (pos y)); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zcri in |- *; intros; elim x.\n(* pos n *)\nintros z H; rewrite (tech_mult_posZ z (pos n)); rewrite H.\nelim (mult_comm z (pos n)); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zsth in |- *; intros; elim x.\n(* pos (S x) *)\nintros x H; rewrite (tech_add_posZ x (pos y)); rewrite H. \nelim (mult_predZ_r x (pos y)); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zminus in |- *; intros; elim x.\n(* neg O *)\nelim (mult_comm IZ x); reflexivity.\n(* pos n *)\nintros n H; elim H; intro H1; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1; clear H1.\nintros n H; elim H1;Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold cycZ in |- *; intros; elim x.\n(* pos n *)\nintros n H; elim H.\nunfold oppZ in |- *; apply le_refl.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Zshiftr in |- *.\nsplit. exact I.\nintros. \nsplit.\nexact I.\nintros. \nelim (mult_reg_absorb_pos_l 0 0); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold|})) in |- *.\nunfold Zminus in |- *.\nintros x y z H; elim z.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nintros n H; elim H; clear H; intros H0 H1; elim H1; clear H1;\n intros H0 H1; elim H1; clear H1; intros H1 H2; elim H2; clear H2;\n intros H H0 H1; elim H3; clear H3; intros H3 H4; elim H4; clear H4;\n intros H H0 H1; elim H4; clear H4; intros H5 H6; elim H6; clear H7;\n intros H1 H2; elim H1; clear H1; intros H2 H3 H4; elim H4; clear H4;\n intros H3 H4; elim H4; clear H4; intros H5 H6; elim H5; clear H5;\n intros H1 H2; elim H1; clear H1; intros H2 H3 H4; elim H2; clear H2;\n intros H3 H4; elim H4; clear H4Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold|})) in |- *; intros; elim x.\n(* the next line *)\nintros x y z H; rewrite (tech_mult_posZ z 0); rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\nTheorem mult_add_distributivity : distributivity Z addZ multZ.\n\nunfold distributivity in |- *; intros; case x.\n(* OZ *)\nsplit; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z). \nreflexivity.\n(* pos (S y0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 10804,
                "proof_end_offset": 11399,
                "proof": "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros; case x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) y) y I I).\nelim H; reflexivity.\nintros; elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite <- (mult_involutive x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm y y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (Qed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros; unfold multZ in |- *; rewrite mult_add_distr_r.\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm x y).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm x y).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_comm x y)).\nrewrite (mult_comm (mult_Qed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros.\nrewrite <- (oppZ_assoc (addZ x y)).\nrewrite (oppZ_oppZ (oppZ y)).\nrewrite (oppZ_oppZ (oppZ y)).\nrewrite (oppZ_oppZ (oppZ y)).\nrewrite (oppZ_oppZ (oppZ y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZ (- y)).\nrewrite (oppZ_oppZQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros; unfold multZ in |- *.\nrewrite tech_add_comm; rewrite oppZ_opp; reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros; case x.\n(* 0 *)\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; unfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; unfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; unfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros.\nrewrite <- plus_assoc.\nrewrite <- plus_assoc.\nrewrite <- plus_assoc.\nrewrite <- plus_assoc.\nrewrite <- plus_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite mult_comm.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nsimple induction x.\nsimple induction y.\nreflexivity.\nintros.\nrewrite <- (mult_involutive x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y z).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y z).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y z).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y z).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y z).\nrewrite (mult_comm y z).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewriteQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewriteQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nsimple induction x.\nauto with *.\nintros x y; rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm xQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros x y; unfold multZ in |- *; rewrite (plus_comm x y); rewrite (plus_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (multQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 11420,
                "proof_end_offset": 12246,
                "proof": "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nProof.\nsimple destruct y.\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\nintros; elim (multZ_commutativity (pos n) (oppZ x)).\nelim (multZ_commutativity (pos n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) x) x I I).\nintros; elim (multZ_commutativity (neg n) (oppZ x)).\nelim (multZ_commutativity (neg n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) x) (oppZ x) I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* compat *)\nreflexivity.\n(* no equality *)\nintros x y H; rewrite (tech_mult_posZ x y H); rewrite (tech_oppZ x y H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).\nrewrite (opp_add ZremZ y x H).Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* pos O *)\nreflexivity.\n(* pos (S x) *)\nintros x y H; do 2 rewrite (tech_mult_negZ x y).\nrewrite (opp_add Zrem_opp Z Id_opp Z_grouperie_symm\n    (multZ x (Zpos y)) (oppZ y) (oppZ y)).\nrewrite (opp_add Zrem_opp Zsup (Zpos y)).\nrewrite (opp_add Zrem_opp Z Id_opp Z_group HrecN_trans\n    (multZ x (Zpos y)) (oppZ y)).\nrewrite (opp_add Zrem_opp Z Id_opp Z_group Ncring_mult_pos_r y (Zpos y)).\nrewrite (opp_add Zquot_opp Zrem_opp Zrem_opp Z_grouperie_symm\n    (multZ x (Zpos y)) (oppZ y)).\nrewrite (opp_add Zrem_opp Zrem_opp Zquot_opp Z_group HrecN_trans\n    (mult_Z x (Zpos y)) (oppZ y)).\nrewrite (opp_add Zrem_opp Zquot_opp Zquot_opp Z_Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* neg 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nintros; elim n.Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* negative *)\nreflexivity.\n(* pos 0 *)\nintros.\nunfold oppZ in |- *.\nsimpl in |- *.\nrewrite ZL4.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZL6.\nsimpl in |- *.\nrewrite ZL5.\nsimpl in |- *.\nrewrite ZLQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* negative *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction m.\n(*Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* equality *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* zero *)\nreflexivity.\n(* zero *)\nintros.\nrewrite (tech_oppZ x y0); rewrite (Rplus_comm (-x)).\nrewrite (mul_oppZ x (-x)).\nrewrite (opp_add Z IdZ Rth) by (left; reflexivity).\nrewrite (opp_add Z ceZ nh) by (left; reflexivity).\nrewrite (opp_add Z hdZ nh) by (left; reflexivity).\nrewrite (opp_add Z ceZ nh) by (right; reflexivity).\nrewrite (opp_add Z df) by (right; reflexivity).\nrewrite (opp_add Z ceZ nh) by (right; reflexivity).\nrewrite (opp_add Z remZ nh) by (right; reflexivity).\nrewrite (opp_add Z ceZ nh) by (right; reflexivity).\nrewrite (opp_add Z remZ nh) by (right; reflexivity).\nrewrite (opp_add Z hdZ nh) by (right; reflexivity).\nrewrite (opp_add Z hdZ nh) by (right; reflexivity).\nrewrite (opp_add Z cmZ nh) by (right; reflexivity).\nrewrite (oppQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nProof.\nintros; case x.\n(* cond 0 *)\nreflexivity.\n(* cond 0 *)\nintros; rewrite <- H; rewrite <- H; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite <- H; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite <- H; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite <- H; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n apply opp_involutive; rewrite <- H; rewrite opp_involutive;\n apply opp_involutive; rewrite <- H; rewrite opp_involutive; rewrite opp_involutive;\n apply opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n apply opp_involutive; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite opp_involutive; rewrite <- H;\n apply opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n apply opp_involutive; rewrite opp_Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* zero *)\nreflexivity.\n(* sign *)\nsimple induction n.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nsimple induction m.\n(* pos O *)\nsimple induction m.\n(* pos S n *)\nsimple induction m.\n(* pos S n *)\nsimple induction m.\n(* pos S n *)\nsimple induction m.\n(* pos S n *)\nsimple induction m.\nsimple induction m.\n(* pos S n *)\nsimple induction m.\n(* pos S n *)\nsimple induction m.\n(* neg S n *)\nsimple induction m.\n(* pos S n *)\nsimple induction m.\n(* pos S n *)\nsimple induction m.\n(* pos S m *)\nsimple induction m.\nsimple induction m.\n(* pos S n *)\nsimple induction m.\nsimple induction m.\n(* neg S m *)\nsimple induction m.\n(* cond 0 *)\nsimple induction m.\nsimple induction m.\n(* cond 0 *)\nsimple induction m.\nsimple induction m.\n(* cond 0 *)\nsimple induction m.\nsimple induction m.\n(* cond 0 *)\nsimple induction m.\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12380,
                "proof_end_offset": 12674,
                "proof": "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; case n.\nsimpl; ring.\nintros n H; elim H; clear H; intros n0 H; rewrite H; ring.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nrewrite (mult_comm n).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + n)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + n)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + n)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + n)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + n)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + n)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_commQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (mult_comm (pos n)); rewrite (mult_comm (neg n)); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n simple induction n.\nreflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nintros m; simpl in |- *; rewrite minus_n_O.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nreflexivity.\nintros; simpl in |- *; rewrite (mult_comm (n + m)).\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite mult_assoc.\nrewrite (mult_comm (n + m)).\nrewrite (mult_comm (n + m)).\nrewrite mult_Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros n m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(* 0 *)\nintros m; simpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n simple induction n.\n simpl in |- *; reflexivity.\n simpl in |- *; reflexivity.\n simpl in |- *; reflexivity.\n simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite <- plus_n_O; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ").\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12702,
                "proof_end_offset": 13018,
                "proof": "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H; unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros n m H; rewrite (tech_mult_negZ y (pos m)); rewrite H.\nrewrite (tech_add_negZ y (y * m + (y + m)) m).\nelim (mult_0_r (y * m + (y + m)) (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + m)))))));\n reflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* S y *)\nintros n H; rewrite (tech_mult_posZ y (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + n)))))).\nrewrite H; rewrite (tech_mult_neg_Z y (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + n)))) m).\nrewrite H; rewrite (tech_mult_neg_Z y (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + n))))) m).\nring.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + m)))) m).\nelim H; reflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple destruct n.\n(* O *)\nreflexivity.\n(* S y *)\nintros n H; rewrite (tech_add_negZ y (pos n)); rewrite H.\nelim (mult_Z_comm (pos n) (neg m)); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\n intros; elim n.\n(* O *)\nreflexivity.\n(* O *)\nintros n m H; rewrite (tech_mult_negZ (x * m + (x * m)) m);\n rewrite H; rewrite (tech_add_pos_Z y (x * m + (x * m)) m).\nelim (mult_neg_posZ (x * m + (x * m)) m); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple destruct n.\nreflexivity.\nintro; reflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\nsimpl; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nintro; ring.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\n intros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m)))) +\n    (x * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m)))) +\n    (x * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m)))) +\n    (x * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m + (y * m +Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* O *)\nintros n m H; rewrite (tech_mult_negZ m (pos n)).\nrewrite (tech_add_negZ (neg n)) (neg m)).\nelim (multZ_comm (- (pos n)) 0); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13046,
                "proof_end_offset": 13355,
                "proof": "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros m H; rewrite (tech_mult_negZ n (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_mult_negZ (y * m + (y + m)) m).\nrewrite H; rewrite (tech_add_negZ (y * m + (y + m)) m).\nelim (techn #|'div_pos_pos_pos_pos_neg_Z (x * m + (y + m)) (x * m + (y + m)) 0);\n reflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros n H; rewrite (tech_mult_negZ n (neg m)); rewrite H;\n unfold oppZ in |- *; rewrite H; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\n unfold oppZ in |- *; rewrite <- H; rewrite <- H;\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n *)\nintros n m H; rewrite (tech_mult_negZ n m); rewrite H;\n unfold oppZ in |- *; rewrite <- H; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos n)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_mult_pos_Z (y * m + (y + n)) m).\nelim (mult_pos_posZ (y * m + (y + n)) 0); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (y * m + (y + m)) m); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_mult_pos_Z (y * m + (y + m)) m).\nelim (Rlt_irrefl (neg m)); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\n intros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros x y H; rewrite (tech_mult_negZ y (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_posZ (x * y)).\nrewrite H; rewrite (tech_add_pos_Z (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_pos_Z (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_addQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *; rewrite H; rewrite H; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros x y H; rewrite (tech_mult_negZ y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_mult_pos_negZ (y * m + (y + m)) m).\nelim (mult_pos_posZ (y * m + (y + m)) m); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros x y H; rewrite (tech_mult_negZ (x * y)).\nrewrite H; rewrite (tech_mult_negZ y (x * y)).\nrewrite H; rewrite (tech_mult_negZ (y * m + (y + (y + m))).\nrewrite H; rewrite (tech_add_negZ (y * m + (y + (y + m))).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (y * m + (y + m))).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (y * m + (y + m))).\nrewrite H; rewrite (tech_add_negZ (x * y)).\nrewrite H; rewrite (tech_add_negZ (y * m + (yQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros n H; rewrite (tech_mult_negZ n (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_mult_negZ n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\n rewrite (tech_add_pos_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\n rewrite (tech_add_pos_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\n rewrite (tech_addQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13383,
                "proof_end_offset": 13714,
                "proof": "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *; rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H.\nrewrite (tech_add_negZ y (y * m + (y + m)) m).\nelim (techn new_lemma y m); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H.\nrewrite (tech_mult_neg_Z y (pos m)); rewrite H.\nelim (technordered_lemma y (pos m)); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* S n *)\nintros n0 H; rewrite (tech_mult_negZ n0 (neg m)); rewrite H.\nrewrite (tech_mult_neg_negZ (y * m + (y + n0)) m).\nelim (techn new_lemma y m); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros x y H; rewrite (tech_mult_posZ y (pos n)); rewrite H.\nrewrite (tech_add_pos_Z (y * m + (y + n)) m).\nelim (techn new_lemma y m); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nsimple induction n.\nrewrite (tech_mult_neg_Z n m); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros n m H; rewrite (tech_mult_negZ n (pos m)); rewrite H.\nrewrite (tech_add_neg_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_neg_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z n (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z n (pos m)) in |- *.\nrewrite H; unfold oppZ in |- *.\nrewrite (tech_add_pos_Z n (pos m)) in |- *.\nrewrite H; unfold oppZ in |- *.\nrewrite (tech_add_pos_Z n (pos m)) in |- *.\nrewrite H; unfold oppZ in |- *.\nrewrite (tech_add_neg_Z n (pos m)) in |- *.\nrewrite H; unfold oppZ in |- *.\nrewrite (tech_add_neg_Z n (pos m)) in |- *.\nrewrite H;Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros m H; rewrite (tech_mult_negZ n (neg m)); rewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (y + m)) m).\nrewrite H.\nrewrite (tech_add_negZ (y * m + (yQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros n0 H; rewrite (tech_mult_posZ n0 (neg m)); rewrite H;\n unfold oppZ in |- *; rewrite H; rewrite H; rewrite H0;\n unfold oppZ in |- *; rewrite H; rewrite H0;\n unfold oppZ in |- *; rewrite H; rewrite H0;\n unfold oppZ in |- *; rewrite H; rewrite H0;\n unfold oppZ in |- *; rewrite H; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;\n unfold oppZ in |- *; rewrite H0; rewrite H0;Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* O *)\nintros n m; rewrite (tech_mult_negZ n (neg m)); rewrite H.\nrewrite (tech_add_neg_Z n (neg m)); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nsimple induction n.\nintro; reflexivity.\nintro; reflexivity.\nintros n m; rewrite (tech_mult_negZ n (neg m)); rewrite H.\nrewrite (tech_add_neg_posZ (n * m + (n + m)) m).\nelim (techn nested_lemma y m); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 13745,
                "proof_end_offset": 14428,
                "proof": "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nreflexivity.\nsimple induction n.\nunfold multZ in |- *; reflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros.\nelim H0.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_oppZ_l y z).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros.\nelim H0.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_associativity : associativity Z multZ.\n\nDefinition plusZ (n m : nat) : nat := n * m + n.\n\nDefinition minusZ (n m : nat) : nat := n * m + n.\n\nDefinition minusZ (n m : nat) : nat := n * m + n.\n\nDefinition le_plus_plus_distr_l (n m : nat) : nat := n * m + n.\n\nDefinition le_plus_minus_distr_r (n m : nat) : nat := n * m + n.\n\nLemma le_plus_minus_distr_r : forall n m : nat, n * m + n = m + n.\nProof.\n intros; elim n.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold multZ in |- *; reflexivity.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nexact Z.mul_1_l.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\napply Rmult_integral_r.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nexact Z multZ_th1.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nexact multZ_mod_posZ.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\napply Z_div_posZ.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\n\nLemma ZL4 : 1 * 2 * 2 * 2 = 2 * 2 * 2.\nProof.\nring.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\napply Zplus_le_reg_l with (nat_of_Z 0); assumption.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 739,
                "proof_start_offset": 14446,
                "proof_end_offset": 14693,
                "proof": "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold is_ring in |- *.\nsplit.\nexact addZ_commutativity.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit.\nexact multZ_associativity.\nexact mult_add_distributivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_ring in |- *; intros; elim (mult_comm 0 0).\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold Z_ring in |- *; intros; elim x.\n(* pos n *)\nunfold minusZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(* S x *)\nunfold multZ in |- *; reflexivity.\n(*Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_ring in |- *; intros; elim (Z_compare_spec (Z_compare_spec (Z_compare_spec (Z_compare_spec (Z_compare_spec (Z_compare_spec (Z_compare_spec (Z_Zopp_Z_Z_iff Z_compare_spec))))\n    Z_ring_posZ.\nunfold Z_ring in |- *; intros; elim H.\n(* 0 *)\nunfold Z_ring in |- *; intros; elim H.\n(* 0 *)\nintros z; rewrite (tech_add_posZ z (pos z)).\nrewrite H; elim (mult_oppZ z (pos z)).\nunfold Z_ring in |- *; intros; elim H.\nrewrite H; elim (mult_comm z (pos z)).\nunfold Z_ring in |- *; intros; elim H.\nrewrite H; elim (mult_comm z (pos z)).\nunfold Z_ring in |- *; intros; elim H.\nrewrite H; elim (mult_comm z (pos z)).\nunfold Z_ring in |- *; intros; elim H.\nrewrite H; elim (mult_comm z (pos z)).\nunfold Z_ringQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z in |- *; intros; elim H.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\napply Z_ring_cring.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_ring in |- *; intros; elim Z_compare_spec; intros; split; trivial.\n(* S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_ring in |- *; intros; elim H; assumption.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction m.\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\nsimple induction m.\n(* n *)\nsimple induction m.\n(* m *)\nsimple induction m.\n(* m *)\nsimple induction m.\n(* n *)\nsimple induction m.\nsimple induction m.\n(* n *)\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nred in |- *; intros; elim H.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivity.\n(*... *)\nunfold oppZ in |- *; reflexivityQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_ring, Z_ring in |- *; unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_ring in |- *;\n unfold Z_ring in |- *; unfold Z_mult in |- *;\n unfold Z_div in |- *; unfold Z_div in |- *;\n unfold Z_divQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\n",
                "context_tokens": 728,
                "proof_start_offset": 14731,
                "proof_end_offset": 14951,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nexact multZ_commutativity.\nexact multZ_neutral.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact juicyRestrict_comm.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_unit' in |- *.\nsplit. exact OZ_injective.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_unit' in |- *.\nintros; elim x.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\n(*... *)\nunfold multZ in |- *; reflexivity.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nsplit.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_unit' in |- *.\nunfold is_unit' in |- *.\nunfold eval_op in |- *.\nintros x y H; elim H.\nintros y H; elim H.\nintros y H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H; elim H.\nintros z H;Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_one, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit, Z_unit.\n\nTheorem Z_unit_divZ_one_eq : is_zero Z oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ.\nunfold is_opp, Z_unit, Z_unit, Z_opp, Z_unit, Z_unit_opp, Z_opp, Z_opp, Z_opp, Z_opp, Z_opp, Z_opp.\n(* *)\nTheorem Z_opp_plus_distr_r_r :\n forall x y z : Z,\n (- x + - y) * z = (- (x + - y) * z + (x + - y) * z + (- (x + - y) * z).\nintros x y z; rewrite (Rplus_commQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nsplit. exact Z_unit_for_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitfor_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_unit' in |- *.\nsplit. exact ZL_mult_pos_Z.\nexact Z_unitary_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_unit' in |- *.\nsplit. exact addZ_sym.\nsplit. exact Z_unit_for_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nsplit. exact Z_unit_for_ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15006,
                "proof_end_offset": 15394,
                "proof": "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x.\nrewrite H; apply Z_one_power_zero_r.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x; case n.\nintro H; apply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napply Z.div_posZ.\napplyQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nsimple induction n.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *;Qed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_trans with (m := x).\napply le_plus_Qed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x; elim n; simpl in |- *; auto.\nintros n0 H; elim (mult_comm n0); auto.\nintros n0 H; elim (mult_comm n0); auto.\nintros n0 H; elim (mult_comm n0); auto.\nintros n0 H; elim (mult_comm n0); auto.\nintros n1 H; elim (mult_comm n0); auto.\nintros n1 H; elim (mult_comm n0); auto.\nintros n2 H; elim (mult_comm n0); auto.\nintros n0 H; elim (mult_comm n0); auto.\nintros n1 H; elim (mult_comm n0); auto.\nintros n1 H; elim (mult_comm n0); auto.\nintros n0 H; elim (mult_comm n0); auto.\nintros n1 H; elim (mult_comm n0); auto.\nintros n2 H; elim (mult_comm n0); auto.\nintros n0 H; elim (mult_comm n0); auto.\nintros n0 H; elim (mult_comm n0); auto.\nintrosQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintro n; elim n.\nintro n; elim n.\nintro n; rewrite mult_n_O; reflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x; elim n.\nintro H; rewrite <- H.\napply Z_div_mult_pos_posZ.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x H; elim H.\nintros n0 H; elim H.\nintro n0.\nsimpl in |- *; reflexivity.\nintros n1 H; elim H.\nintro n1.\nsimpl in |- *; reflexivity.\nintros n1 H; elim H.\nintro n1.\nsimpl in |- *; reflexivity.\nintros n1 H; elim H.\nintro n2.\nsimpl in |- *; reflexivity.\nintros n1 H; elim H.\nintro n1.\nsimpl in |- *; reflexivity.\nintros n2 H; elim H.\nintro n2.\nsimpl in |- *; reflexivity.\nintros n3 H; elim H.\nintro n3.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nunfold Z in |- *; simpl in |- *; intros.\nelim H.\nintros; elim H0; intros; clear H0.\nrewrite H; clear H0.\nrewrite H; reflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nunfold not in |- *.\nintros n x H; elim H.\nintros x0 H; elim H.\nintros; unfold multZ in |- *; exact H.\nintros.\napply Z_mult_reg_l with (n := 0%Z); assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15419,
                "proof_end_offset": 15807,
                "proof": "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_Z n n0); intros.\ncut (neg (n0 * n0) = pos n0). discriminate. exact H.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* word *)\nintros n0; rewrite (tech_mult_neg_posZ n0); intros.\ncut (0 = n0 + (n0 + n0)); auto with arith.\napply tech_intad_negZ.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nunfold is_unitexistence in |- *.\nintros n x; elim x.\n(* shift *)\nintros n0; rewrite (tech_add_pos_posZ n n0); intros.\nabsurd (0 = 0); trivial.\napply H; trivial.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* Omega *)\nintros n0; rewrite (tech_exp_pos_posZ n0); intros.\ncut (0 = n0). clear H; elim H; clear H; intros;\n generalize (mult_neg_posZ n0); clear H; intro H1; rewrite H1 in H1;\n rewrite H2 in H1; rewrite H1 in H1; clear H1.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* negative *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (0 = 0); trivial.\nrewrite H; elim (mult_oppZ_l n0); trivial.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* word *)\nintros n0; rewrite (tech_mult_negZ n n0); intros.\nabsurd (neg (n0 * n0 + (n0 + n0)) = IZ). discriminate. exact H.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* negative *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n0); intros.\nabsurd (pos n0 = n0); auto. exact H.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros n0; rewrite (tech_mult_neg_Z n0); intros.\ncut (0 = n0). rewrite H; reflexivity.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold multZ in |- *; reflexivity.\n(* Omega *)\nunfold plusZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* contexte gauche *)\nreflexivity.\n(* Rewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Qed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 15829,
                "proof_end_offset": 16089,
                "proof": "Theorem integrityZ : integrity Z multZ OZ.\nProof.\nunfold integrity in |- *; intros a b; elim a.\nintros; left; reflexivity.\nintros; right; apply (tech_integ_posZ n b); exact H.\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold intad at 2 in |- *; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewrite ZL_exp_pos_Z; unfold Z.pow in |- *.\nrewriteQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\napply (Build_Z_on_eq Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_one_for_ring Z_unit_for_ring Z_unit_for_ring Z_one_for_ring Z_zero_for_ring Z_one_for_ring Z_one_for_ring Z_for_ring Z_one_for_ring Z_unit_for_ring Z_one_for_ring Z_one_for_ring Z_for_ring Z_one_for_ring Z_unit_for_ring Z_unit_for_ring Z_one_for_ring Z_zero_for_ring Z_unit_for_ring Z_zero_for_ring Z_one_for_ring Z_div :\n forall (n : nat) (Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold intadherent in |- *.\nintros n0; rewrite (tech_add_pos_Z n n0); intros.\ncut (0 = 0); [ rewrite H; auto | idtac ].\nrewrite H; rewrite H; rewrite H; rewrite H0; rewrite H; rewrite H0; reflexivity.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold is_zero in |- *.\nsplit.\nexact Hex.\nexact Hex.\nexact Hex.\nexact Hex.\nexact (ring_simplify_eq _ _ _).\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\napply intacerbenz_posZ.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold is_zero in |- *.\nsplit.\nexact zero_divZ.\nexact one_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact zero_divZ.\nexact one_divZ.\nexact zero_divZ.\nexact one_divZ.\nexact zero_divZ.\nexact one_divZ.\nexact one_divZ.\nexact zero_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.\nexact one_divZ.Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\napply Z_one_power_posZ.\napply Z_one_power_posZ.\napply Z_one_power_posZ.\napply Z_one_power_posZ.\napply Z_one_power_posZ.\napply Z_one_power_posZ.\napply Z_one_power_posZ.\napply Z_one_power_posZ.\napply Z_one_power_pos.\napply Z_one_power_posZ.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_power_pos.\napply Z_one_powerQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold Z in |- *.\nrewrite Z.mul_1_r; rewrite Z.mul_1_r; rewrite Z.mul_1_r; rewrite Z.mul_1_r; rewrite Z.mul_comm; reflexivity.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold intad at 1 in |- *; unfold intad at 1 in |- *;\n unfold Z_to_int, nat_to_int, nat_to_int, nat_to_int, nat_to_int, nat_to_int in |- *.\nintros n; rewrite (tech_mult_pos_posZ n n0); intros.\ncut (0 < n * n0 + (n + n0)) = 0). discriminate. exact H.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold intad at 2 in |- *.\napply Z_one_one_one_one_one_one_one_one_one_zero_zero_zero_zero :\n forall (n : nat) (x : Z), x = Z_one_one_one_one_one_zero (Z_one_one_one_one n x).\nProof.\nintros n x; elim x.\n(* sign *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\ncut (x = Z_one_one_one_one n0); trivial.\napply H.\nrewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\n",
                "context_tokens": 722,
                "proof_start_offset": 16118,
                "proof_end_offset": 16787,
                "proof": "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros; elim m.\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros.\nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)).\nrewrite (mult_neutr (S n)).\nunfold posOZ in |- *; reflexivity.\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)); elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(* var n *)\nintros n; rewrite (tech_mult_pos_negZ n m); intros.\nabsurd (neg (n * n0)) = neg (n * m + (n + n0)) * (n + m)).\nrewrite H; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(* cI *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; reflexivity.\n(* 0 *)\nintrosQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(*init sym *)\nreflexivity.\n(*init sym *)\nreflexivity.\n(*init sym *)\nreflexivity.\n(*init sym *)\nreflexivity.\n(*init sym *)\nreflexivity.\n(*init sym *)\nreflexivity.\n(*init sym *)\nreflexivity.\n(*init sym *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(*init pos n *)\nintros n; rewrite (tech_mult_pos_posZ n (pos m)).\nrewrite (tech_mult_pos_negZ n m (pos m)).\nrewrite (tech_mult_neg_positive n m (pos m)).\nrewrite (tech_mult_pos_negZ n (pos m)).\nrewrite (tech_mult_neg_positive n m (pos m)).\nrewrite (tech_mult_pos_posZ n (pos m)).\nrewrite (tech_mult_neg_positive n m (pos m)).\nrewrite (tech_mult_neg_positive n m (pos m)).\nrewrite (tech_mult_pos_negZ n m (pos m)).\nrewrite (tech_mult_neg_positive n m (pos m)).\nrewrite (tech_mult_neg_positive n m (pos m)).\nrewrite (tech_mult_pos_posZ n m (pos m)).\nrewrite (tech_mult_neg_positive n (pos m)).\nrewrite (tech_mult_neg_positive n m (pos m)).\nrewrite (tech_mult_neg_positive n m (Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(* Omega *)\nintros n0; rewrite (tech_mult_neg_posZ n0); intros.\nabsurd (0 = n0); trivial.\nrewrite H; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros n m; elim n.\n(* cond *)\nintros; rewrite (tech_mult_neg_negZ n m); intros.\nabsurd (neg (n * n0)) = pos (n * m) by ring.\nrewrite (tech_mult_neg_Z n m); intros.\ncut (0 <= m * n0 + (n + m0)) by ring.\nrewrite (tech_mult_neg_Z n m0); intros.\napply (tech_exp_pos_predZ n m); exact H.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\nrewrite (tech_mult_neg_positive n m); intros.\ncut (pos (n * m) = pos (n * m)). contradict H. exact H.\nrewrite H0; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\n(* 0 *)\nintros n; rewrite (tech_mult_neg_posZ n m); intros.\nabsurd (neg (n * m)) = pos n. discriminate. exact H.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(* IZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; right; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; right; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* neg n0 *)\nintros; left; reflexivity.\n(* neg n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0 *)\nintros; left; reflexivity.\n(* pos n0Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\napply sym_eq.\nrewrite <- (tech_mult_pos_succZ m n); intros.\ncut (0 < m). apply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_O_Sn.\napply lt_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\n",
                "context_tokens": 721,
                "proof_start_offset": 16816,
                "proof_end_offset": 17035,
                "proof": "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\nrewrite <- (tech_mult_pos_predZ2 n m); intros.\nabsurd (pos (n * m + (n + m)) = pos n). discriminate.\nrewrite H0.\nelim (mult_n_Sm (S n) (pos m)).\nrewrite (mult_comm (pos m)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos m)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos m)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewriteQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* O *)\nintros; rewrite (tech_mult_neg_negZ n m); reflexivity.\n(* n *)\nintros n0; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n m0); reflexivity.\n(* n *)\nintros; rewrite (tech_mult_neg_negZ n mQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros n m; elim n.\n(* O *)\nelim multZ_ne; intros; elim (H0 (pos n) I); intros. \nreplace (pos (S n)) with (S (S (n + 0))).\nrewrite H1.\nelim (mult_comm (pos n) (pos m)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewriteQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) (pos m)); intros. \nrewrite (tech_mult_neg_posZ n m); rewrite (tech_mult_neg_posZ n m);\n unfold neg in |- *; rewrite (tech_add_pos_negZ n m);\n unfold neg in |- *; rewrite (tech_add_pos_posZ n m);\n unfold neg in |- *; rewrite (tech_opp_posZ n m);\n unfold neg in |- *; rewrite (tech_opp_posZ n m);\n unfold neg in |- *; rewrite (tech_opp_posZ n m); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* O *)\nintros n0; rewrite (tech_mult_pos_negZ n (pos m)).\nunfold neg at 1 in |- *; rewrite (tech_add_pos_Z n0 (pos m)).\nunfold neg at 1 in |- *; rewrite (tech_add_pos_Z n0 (pos m)).\nrewrite (tech_mult_neg_Z n0 (pos m)).\nunfold neg at 1 in |- *; rewrite (tech_add_pos_Z n0 (pos m)).\nrewrite (tech_add_pos_Z n0 (pos m)).\nunfold neg at 1 in |- *; rewrite (tech_add_pos_Z n0 (pos m)).\nrewrite (tech_add_pos_Z n0 (pos m)).\nunfold neg at 1 in |- *; rewrite (tech_add_pos_Z n0 (pos m)).\nrewrite (tech_add_pos_Z n0 (pos m)).\n unfold neg at 1 in |- *; rewrite (tech_add_pos_Z n0 (pos m)).\nunfold neg at 1 in |- *; rewrite (tech_add_pos_Z n0 (pos m)).\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* O *)\nelim plusZ_neutral; intros; elim (H0 (pos n) (pos m)); intros. \nrewrite (tech_add_pos_posZ n m); rewrite (tech_add_pos_posZ n m);\n reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nsimple induction n.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nintros; rewrite (tech_mult_neg_posZ n m); simpl in |- *.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite (mult_comm n).\nrewrite (mult_comm n).\nrewrite (mult_comm n).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm n).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm n).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros n m; elim n.\nunfold multZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros; elim (mult_comm n m); elim (plus_comm n m); elim (mult_comm n m);\n elim (mult_comm n m); elim (mult_comm n m); elim (mult_comm n m);\n elim (mult_comm n m); elim (mult_comm n m); elim (mult_comm m m);\n elim (mult_comm n m); elim (mult_comm n m); elim (mult_comm n m);\n elim (mult_comm n m); elim (mult_comm m n); elim (mult_comm m n);\n elim (mult_comm m n); elim (mult_comm m n); elim (mult_comm m n);\n elim (mult_comm n m); elim (mult_comm m n); elim (mult_comm m n);\n elim (mult_comm m n); elim (mult_comm m n); elim (mult_comm m n);\n elim (mult_comm m n); elim (mult_comm m n);\n elim (mult_comm m n); elim (mult_comm m n); elim (mult_comm m n);\n elim (mult_comm m n);Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\nunfold multZ in |- *; rewrite plus_n_O; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 17054,
                "proof_end_offset": 17961,
                "proof": "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n q r; elim q.\nelim r.\nintros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *; reflexivity.\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n1 q r H; elim (mult_comm n m).\nrewrite (tech_mult_pos_succZ2 n0 q); rewrite (mult_comm n0);\n rewrite (mult_comm (n0 * (n0 * (n0 * (n0 * (n0 * (n0 * n0)))) (pos _)), H;\n rewrite (mult_comm (n0 * (n0 * (n0 * n0))));\n rewrite (mult_comm (n0 * (n0 * n0) + (n0 * (n0 * (n0 * n0)));\n rewrite (mult_comm (n0 * (n0 * (n0 * (n0 * n0)));\n rewrite (mult_comm (n0 * (n0 * n0) + (n0 * (n0 * n0)));\n rewrite (mult_comm (n0 * (n0 * (n0 * n0)));\n rewrite (mult_comm (n0 * n0) + (n0 * (n0 * n0)));\n rewrite (mult_comm (n0 * n0));\n rewrite (mult_comm (Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (mult_comm n0 n).\nrewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n);\n rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n);\n rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n);\n rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0);\n rewrite (mult_comm n0 n0); rewrite (mult_comm (n0 + n0)); rewrite (mult_comm n0 n0);\n rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0);\n rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0);\n rewrite (mult_comm (n0 + n0)); rewrite (mult_comm n0 n0); rewrite (mult_comm n0 n0);\n rewrite (mult_Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n1 q r H0; elim (mult_assoc n0 (pos n0) (pos q)).\nelim (mult_assoc n0 (pos q) (pos q)).\nelim (mult_assoc n0 (pos q) (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelim (mult_assoc n0 (pos q)).\nelimQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n0 n q r H H0; elim H0;\n [ intros H1; rewrite H1; rewrite H1; rewrite H2; ring | idtac ].\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n0 n1 q r H0 H1 H2; elim H1; clear H1 H2.\nrewrite (tech_mult_pos_succZ2 n0); trivial. \nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (mult_assoc n (pos n0)); elim (mult_assoc n (pos q));\n rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0)); reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nsimple induction n0; intros; simpl in |- *; auto with arith.\nintros n0 q r H; elim (mult_assoc n0 (S n0) (S q));\n reflexivity. \nintros n0 q r H; elim (mult_assoc n0 (S q) (S q));\n reflexivity. \nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nsimple induction n0.\nintros n0 n0 q r H; rewrite (tech_mult_neg_Z n0 n0 q); simpl in |- *;\n rewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_comm (n0 * n0 + q) (n0 * n0 + q)).\nrewrite (mult_Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nsimple induction n0; simpl in |- *; intros.\nrewrite (tech_mult_pos_negZ n0 n0); simpl in |- *; auto with arith.\nrewrite H1.\nelim (mult_comm n (S q)).\nrewrite (mult_comm n (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm n (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm n (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm n (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm n (S qQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\n(******************************************************)\n\nLemma tech_div2 : forall n m : nat, n = q * n + m -> n + q = n + q * m.\nProof.\n intros n m; elim n; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 17980,
                "proof_end_offset": 18420,
                "proof": "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nintros n0 n q; elim q.\nsimpl in |- *; intros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold negOZ in |- *.\nrewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros; elim n.\n(* O *)\nelim (mult_comm n q).\nrewrite (mult_comm n0 q).\nrewrite (mult_comm n q).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (mult_comm n q).\nrewrite (Qed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q; elim q.\nrewrite (mult_comm 0).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (Qed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q; elim n.\nintros; rewrite (plus_comm n0).\nrewrite (plus_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (plus_comm n0).\nrewrite (plus_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm (n0 + n)).\nrewrite (mult_comm n0).\nrewrite (mult_comm (n0 + n)).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm n0).\nrewrite (mult_comm (n0 + n)).\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n0 n q H; elim q.\n(* 0 *)\nelim r.\nintros; absurd (S n0 = 0). discriminate.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros; elim n.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate.\nexact H.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n0 n q; elim q.\n(* 0 *)\nelim q.\n(* 0 *)\nelim q.\nintros; absurd (S n0 = 0). discriminate.\n(* 0 *)\nintros n0 q0; elim q0.\n(* 0 *)\nelim q0.\nintros; absurd (S n0 = 0). discriminate.\n(* 0 *)\nintros n0 q0; elim q0.\nintros; absurd (S n0 = 0). discriminate.\n(* 0 *)\nintros n1 q0; elim q0.\nintros; cut (S n0 = 0). discriminate.\n(* 0 *)\nintros n1 q0; elim q0.\nintros; cut (S n0 = 0). discriminate.\n(* 0 *)\nintros n1 q0; elim q0.\nintros; cut (S n0 = 0). discriminate.\n(* 0 *)\nintros n1 q0; elim q0.\nintros; absurd (S n0 = 0). discriminate.\n(* 0 *)\nintros n1 q0; elim q0.\nintros; absurd (S n0 = 0). discriminate.\n(* 0 *)\nintros n1 q0Qed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros; elim n.\n(* O n *)\nelim (mult_comm 0 (S n)).\nrewrite (mult_comm 0 (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewrite (mult_comm (S n0)).\nrewriteQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n0 q; elim n0.\nintros; cut (S n0 = S n0). discriminate. exact H.\napply le_n_S.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q H; elim H; auto with arith.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n0 q H; elim q.\n(* O (S n) *)\nelim (mult_comm n0 (S n0) (S n0)); intros; apply (mult_comm n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\n apply (mult_assoc n0 (S n0) (S n0));\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 711,
                "proof_start_offset": 18440,
                "proof_end_offset": 19318,
                "proof": "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros; elim q.\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)).\ncut (IZ = pos 0); intros.\nelim H.\nrewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity.\nreflexivity.\nintros y H; unfold posOZ in |- *; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y) (pos n)) (pos n) I I).\nelim (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0).\nrewrite mult_n_O; rewrite mult_n_O; rewrite mult_n_O; reflexivity.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0).\nrewrite mult_n_O; rewrite mult_n_O; rewrite mult_n_O; reflexivity.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(* O *)\nunfold oppZ in |- *; rewrite (inj_S _ _ H).\napply plus_comm.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* O *)\nsimpl in |- *; intros; cut (S n = 0). intro; rewrite (eq_add_S n 0).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (plus_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (plus_comm n).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm n).\nrewrite (mult_comm (n + 0)).\nrewrite (plus_comm n).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (mult_comm (n + 0)).\nrewrite (multQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nLemma tech_div31 : forall n : nat, n = q * n -> oppZ (pos n) = oppZ (pos n).\nintros n; elim q.\nunfold oppZ in |- *; rewrite (mult_comm n).\nrewrite <- (mult_assoc n).\nrewrite <- (mult_assoc n).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc n).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).Qed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nLemma tech_div31 : forall n : nat, q * n = q * n.\nintros; elim n.\nintros; rewrite (mult_comm n (S n0)).\napply tech_div31.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nLemma tech_div3 : forall n : nat, IZ n = n -> n = 1.\nintros n; elim n.\nunfold oppZ in |- *; intros; reflexivity.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nLemma tech_div3 : forall n : nat, addZ (oppZ (pos n)) (pos n) = abs (minusZ (pos n)).\nProof.\nintros n; elim n; simpl in |- *; auto.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nunfold oppZ in |- *; unfold oppZ in |- *; rewrite (Rplus_comm (n + 0)).\nunfold mult_Z in |- *; rewrite (Rplus_comm (n + 0)).\nrewrite (Rplus_comm (n + 0)).\nrewrite (Rplus_comm (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nrewrite (mult_comm n (n + 0)).\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\n(******************************************************)\n\nLemma tech_div4 : forall n : nat, Prime n -> 0 = n.\nintros n; elim n; auto with arith.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nLemma tech_div31 : forall n : nat, Divides (oppZ (oppZ n)) (pos n) = oppZ (pos n).\n\nProof.\nintros n; elim n.\nsimpl in |- *; auto.\nsimpl in |- *; auto.\nsimpl in |- *; auto.\nsimpl in |- *; auto.\nsimpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 719,
                "proof_start_offset": 19338,
                "proof_end_offset": 19708,
                "proof": "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim r.\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n)); elim (minus_n_O n).\nreflexivity.\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry in |- *.\nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros n q r; elim q.\n(* O *)\nunfold neg in |- *; rewrite (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (posQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim q.\n(* O *)\nunfold neg in |- *; rewrite (mult_comm n); rewrite (plus_comm n); rewrite (plus_comm n);\n rewrite (plus_comm (n - q) (n - q)); rewrite (plus_comm (n - q) (n - q));\n rewrite (plus_comm (n - q) (n - q)); rewrite (mult_comm n);\n rewrite (plus_comm (n - q) (n - q)); rewrite (mult_comm (n - q) (n - q));\n rewrite (mult_comm (n - q) (n - q)); rewrite (mult_comm (n - q) (n - q));\n rewrite (mult_comm n (n - q) (n - q)); rewrite (mult_comm (n - q) (n - q));\n rewrite (mult_comm (n - q) (n - q)); rewrite (mult_comm (n - q) (n - q));\n rewrite (mult_comm (n - q) (n - q)); rewrite (mult_comm (n - q) (n - q));\n rewrite (mult_comm n (nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim n.\n(* O *)\nunfold neg in |- *; rewrite (mult_pyth (pos n)).\napply H.\napply H.\napply H.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros n q r; elim q.\n(* O *)\nunfold neg in |- *; rewrite (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (posQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim n.\n(* O *)\nunfold neg in |- *; rewrite (mult_comm (pos n)).\napply tech_div4.\n(* O *)\nunfold neg in |- *; rewrite (mult_comm (pos n)).\napply tech_div4.\n(* S *)\nunfold neg in |- *; rewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim n.\n(* O *)\nunfold neg at 1 in |- *; rewrite (mult_comm (pos n)).\npattern (pos n) at 1 in |- *; rewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim n.\n(* O *)\nunfold oppZ in |- *; rewrite (mult_comm (S n)).\nrewrite (plus_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).\nrewrite (mult_comm (S n)).Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros n q r; elim q.\nunfold gt in |- *; rewrite (mult_comm n); rewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm n).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm n).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm n).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm n).\nrewrite (mult_comm n).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm n).\nrewrite (mult_comm n).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm n).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm n).\nrewrite (mult_comm n).\nrewrite (mult_Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros n q r; elim r.\n(* O *)\nunfold pos at 1 in |- *; rewrite <- (mult_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim n.\n(* O *)\nunfold neg in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *; rewrite (mult_comm (pos n)).\nunfold square in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 19727,
                "proof_end_offset": 20249,
                "proof": "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r))) .\nrewrite (tech_div31 n q).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n1 n2 q r H1 H2;\n generalize q; clear q; elim n1.\n(* S n *)\nunfold pos in |- *; unfold oppZ in |- *; rewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (multQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n1 n2 q r H;\n generalize (mult_eq_pos_pos n1 (pos n2) (pos n2) (pos n1) (pos n2));\n clear H; intro H; rewrite (lt_S_n_O n1); auto with arith.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros n0 n q r; elim r.\n(* O *)\nunfold pos HrecN in |- *; unfold multZ in |- *; rewrite (mult_comm (n - r)).\nrewrite H; reflexivity.\n(* S y *)\nunfold plus in |- *; apply mult_comm; auto with arith.\n(* S y *)\nunfold plus in |- *; apply mult_comm; auto with arith.\n(* S y *)\nunfold mult in |- *; apply mult_comm; auto with arith.\n(* S y *)\nunfold plus in |- *; apply mult_comm; auto with arith.\n(* S y *)\nunfold mult in |- *; apply mult_comm; auto with arith.\n(* S y *)\nunfold mult in |- *; apply mult_comm; auto with arith.\n(* S y *)\nunfold mult in |- *; apply mult_comm; auto with arith.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros n0 n1 n2 q r H0; rewrite H0; reflexivity.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n0 n1 q r; elim q.\n(* O *)\nunfold plus in |- *; unfold plus in |- *; unfold mult in |- *;\n rewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_commQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n1 q r H; elim H; intros; elim H; intros.\napply (plus_n_O_n n1).\napply (plus_n_O_n n0).\napply (plus_n_O_n n0).\napply (mult_comm (pos n0) (pos (n - r))); simpl in |- *;\n apply (plus_n_Sm n0).\nrewrite (mult_comm (pos n0)).\napply (plus_n_O_n n1).\napply (plus_n_O_n n0).\napply (plus_n_O_n n1).\napply (plus_n_Sm n0).\napply (plus_n_O_n n0).\napply (plus_n_Sm n0).\napply (plus_n_Sm n0).\napply (plus_n_Sm n0).\napply (plus_n_Sm n0).\napply (plus_n_Sm n0).\napply (plus_n_Sm n0).\napply (plus_n_Sm n0).\napply (plus_n_Sm n0).\napplyQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n1 n2 q r H; elim H; intros; unfold lt in |- *;\n apply le_n_S; assumption.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n q r; elim r.\n(* 0 *)\nunfold plus in |- *; rewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (n0 - r)).\nrewrite (mult_comm (nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n0 n1 n2 q r H1 H2 H3.\nrewrite (mult_comm n0 n1 q).\nrewrite (mult_comm n0 n1 q).\nrewrite (mult_comm n0 n2).\nrewrite (mult_comm n0 n1 q).\nrewrite (mult_comm n0 n1 q).\nrewrite (mult_comm n0 n1 q).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm n0 n1).\nrewrite (mult_comm n0 n1).\nrewrite (mult_comm n0 n2).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm n0 n1).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm n0 n2).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm (n + n1)).\nrewrite (mult_comm (n + n1)).\nrewrite (Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n1 n2 q r; elim r.\nunfold lt in |- *; unfold plusZ in |- *; rewrite (mult_comm (n - r)).\nelim (mult_comm n (n - r)); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 20268,
                "proof_end_offset": 20706,
                "proof": "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n0 n1 q r H; elim H; intros; unfold gt in |- *;\n rewrite (mult_comm n0); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (neg n0) (pos q)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (neg n0) (neg q)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (neg n0) (pos q));Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros n0 n q r H; elim r.\nreflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n0 n1 n2 q r H; elim r; simpl in |- *; auto.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n1 n2 q r H; elim r; auto with arith.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n1 n2 q r H; elim r.\nrewrite (mult_comm n); rewrite (mult_comm n1); rewrite (mult_comm n1);\n rewrite (mult_comm n1); rewrite (mult_comm n1);\n rewrite (mult_comm n2); rewrite (mult_comm n1); rewrite (mult_comm n2);\n rewrite (mult_comm n1); rewrite (mult_comm n1); rewrite (mult_comm n2);\n rewrite (mult_comm n1); rewrite (mult_comm n1); rewrite (mult_comm n1);\n rewrite (mult_comm n1); rewrite (mult_comm n1); rewrite (mult_comm n2);\n rewrite (mult_comm n1); rewrite (mult_comm n1); rewrite (mult_comm n1);\n rewrite (mult_comm n1); rewrite (mult_comm n2); rewrite (mult_comm n1);\n rewrite (mult_comm n1); rewrite (mult_comm n1); rewrite (mult_comm n2);\n rewrite (mult_comm n1); rewrite (mult_comm n2); rewrite (mult_comm n1);Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n1 n2 q r H0; elim r.\nrewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n0 q r H; elim H.\nrewrite H; rewrite H0; rewrite H0; rewrite H0; reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros n0 n1 n2 q r H; elim r.\nreflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros; elim (mult_integral_r (pos n) (pos q)).\nintros;Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_div3 n0 n0 q r H0); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 20725,
                "proof_end_offset": 21054,
                "proof": "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; cut (posOZ q = oppZ (negOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (neg n0) (pos HrecN q)); [ intros H3| intros H4].\napply (plus_n_Sm n0 q).\nrewrite (mult_comm (pos n0) (posdichotomy_converse (pos n0) (pos HrecN q)));\n rewrite (mult_comm (pos n0) (pos ); rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos _)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos _)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos _)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (pos n0) (pos _)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos _)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (pos n0) (pos)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0) (pos (Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim n; auto with arith.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (neg n0) (neg q)) = multZ (neg n0) (pos q)); \n intros.\nrewrite H0; intros.\nrewrite H; intros.\nrewrite H; intros.\nrewrite H0; intros.\nrewrite H; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H0; intros.\nrewrite H; intros.\nrewrite H0; intros.\nrewrite H0; introsQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (pos n0) (pos General q)); [ intros H1 | idtac ].\napply (tech_div3 n0 n q r H).\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (neg n0) (pos Tf q) = (multZ (neg n) (pos Tf q))); \n intros.\nelim (mult_comm Z (pos n0) (pos _)), (mult_comm (neg n) (pos Tf q)).\nelim (mult_comm Z (pos n) (pos Tf q)).\nelim (mult_comm Z (pos n0) (pos Tf q)).\nelim (mult_comm Z (pos n) (posProgram q)).\nelim (mult_comm Z (pos n0) (posProgram q)).\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (neg n) (neg q)) = multZ (neg n0) (pos _)), (multZ (neg n) (pos General q)).\nrewrite H; intros.\nelim (mult_comm (pos n) (pos q)); reflexivity.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros n0 n q H; elim H; intros.\napply le_n_S.\nreplace (S n0) with (S n0); auto with arith.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros n0 n q; elim q; auto.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros n0 n q; elim n.\nintros; rewrite <- (mult_comm (S n0)); rewrite <- (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0));\n rewrite (mult_comm (S n0)); rewrite (mult_comm (S n0)); rewrite (multQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros n0 n q H; rewrite H; intros; rewrite H; intros; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 21073,
                "proof_end_offset": 21415,
                "proof": "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros n0 n1 n2 q r H H0 H1 H2.\nrewrite H0; intros.\ncut (pos HrecN q = up (plusZ (neg n0) (pos HrecN q))); intros.\nrewrite H1; intros.\nrewrite H2; rewrite H3; apply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\napply le_trans with (pos n1); assumption.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (pos alph < r); [ intros H4; rewrite H4; clear H4 | intros;\n    generalize (mult_plus_distr_pos_pos_Z n0 (pos q) (pos q) H4); clear H4 | intros; clear H4 | intros;\n    generalize (mult_plus_distr_pos_pos_Z n0 (pos q) (pos q) H4); clear H4 | intros; clear H4 ].\nelim (mult_comm (- S n0) (pos q)).\nelim (mult_comm (- S n0) (pos q)).\nelim (mult_comm (- S n0) (pos q)).\nelim (mult_comm (- S n0) (pos q)).\nelim (mult_comm (- S n0) (pos q)).\nrewrite (mult_comm (- S n0) (pos q)).\nrewrite (mult_comm (- S n0) (pos q)).\nrewrite (mult_comm (- S n0) (pos q)).\nrewrite (mult_comm (- S n0) (pos q)).\nrewrite (mult_comm (- S n0) (pos q)).\nrewrite (mult_Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros; cut (neg HrecN q = 0); intros.\nrewrite H0; intros; exact (tech_div3 n0 n r H).\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros; cut (pos HrecN q = (pos n0)).\nrewrite H0; intros; exact (tech_div2 n0 n q r H).\nelim (tech_div3 n0 n q r H); reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros; cut (pos HrecN q = (1 * S n + r)); intro.\nrewrite H0; intros; exact (tech_div6 n0 n q H).\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros n0 n1 n2 q r H0 H1 H2 H3.\nrewrite H0; intros; apply H1; rewrite H2; clear H2.\nchange (pos q * S n0 = q * S n0 + r * S n0 + r * S n0) in |- *.\nrewrite H1; intros; rewrite H3; clear H3.\nchange (pos (n0 + r * S n0) = q * S n0 + r * S n0) in |- *.\nrewrite H2; intros; apply H1; rewrite H3; clear H3.\nchange (pos (n0 + r * S n0) = q * S n0 + r * S n0) in |- *.\nrewrite H3; intros; apply H1; rewrite H3; clear H3.\nreplace (pos (n0 + r * S n0) * S n0 + r * S n0) with (S n0 + r * S n0) in |- *.\nrewrite H3; intros; apply H1; rewrite H3; clear H3.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros; cut (pos HrecN q = 0); intros.\nrewrite H0; clear H0; unfold multZ in |- *; rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (pos n0)); rewrite (mult_comm (neg n0)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (neg n0)); rewrite (mult_comm (pos n0)); rewrite (mult_comm (neg n0));\n rewrite (mult_comm (neg n0)); rewrite (mult_comm (neg n0)); rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0)); rewrite (mult_comm (neg n0Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nLemma tech_div6 : forall n m p q r : nat, n > q -> S n > q -> S n > q -> r * q = r.\nintros; cut (pos Tf * q = r * S n); intros.\nrewrite H0; intros; ring.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (multZ (pos n0) (pos q) = multZ (pos n0) (pos q));\n [ intro H1; rewrite H1; reflexivity | ring ].\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (multZ (pos n0) (pos n0) = (n0 + r)).\napply plus_eq_reg_l with (pos n0); auto with arith.\nrewrite H0; intros; exact (tech_div3 n0 n q r H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 21436,
                "proof_end_offset": 22829,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nsimple destruct x.\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\nsimple induction n.\nintros; left; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (pos (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\nsimple induction n.\nright; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (neg (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim (tech_inv00 Z divZ); intros; elim H1.\nrewrite H0; intros; exact (tech_div2 n0 n0 H).\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim (tech_inv00 x); intros; elim H0.\nrewrite (mult_comm x x); rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x)); rewrite (mult_comm x (pos x));\n rewrite (mult_comm x (pos x));Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; cut (0 = oppZ (pos x)); intros.\nrewrite H0; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H0; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H0; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H0; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelim (Rlt_irrefl 0).\nrewrite <- H1; intros.\nelimQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros x Hx.\nassert (0 <= x)%Z.\napply lt_inv_Z_neg_Z_neg.\nrewrite <- H0; intros; exact (proj1 H).\napply lt_inv_Z_neg_Z_neg.\nrewrite <- H0; intros; exact (proj1 H).\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\napply (inv00stableZ); assumption.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\ndestruct (Rle_dec x 0) as [H|H].\nelim H; intro; apply H; apply opp_pos_neg.\nrewrite (plus_comm 0 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S (S (S (S (S (S(S (SQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nrewrite H.\nrewrite H.\nrewrite <- H0; intros; exact (tech_div3 n0 n0 n0 H).\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nelim (tech_inv00 Z Plt_eq_dec x 0).\nintros; elim H1.\nrewrite (mult_comm x 0).\nrewrite (plus_comm x 0).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_comm (- x)).\nrewrite (plus_Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim (tech_inv00 Z divZ); intros; elim H1.\nrewrite (plus_comm x (pos x) (pos x)); rewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (- x)).\nrewrite (mult_comm (-Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros x H.\ncut (0 = oppZ (pos x)); intros.\nrewrite H0.\nelim (tech_opp_pos_posZ x); intros; elim H1.\nrewrite (inv00anceZ); assumption.\nrewrite (inv00anceZ); assumption.\nrewrite (inv00anceZ); assumption.\nrewrite (inv00stableZ); assumption.\nrewrite (inv00stableZ); assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\nLemma inversibleZ :\n forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\n\nsimple destruct x.\n(* OZ *)\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nintros; left; reflexivity.\n(* pos (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (pos (S y))). discriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\n(* neg n *) \nsimple induction n.\n(* neg O *)\nright; reflexivity.\n(* neg (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (neg (S y))). discriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.\n\n(************)\n",
                "context_tokens": 734,
                "proof_start_offset": 22846,
                "proof_end_offset": 23040,
                "proof": "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple destruct x.\nreflexivity.\nintros; exact (mult_IZ (pos n)).\nintros; exact (mult_mIZ (neg n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple induction x.\nsimple induction x.\nintro; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple destruct x.\nsimple induction x.\nsimpl in |- *.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nrewrite abs_inj.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nintros; elim (Z_zerop x); intros; elim H.\nrewrite (Z.abs_neq_Z x); rewrite H0; reflexivity.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nintros.\nelim (Z_dec_inf x 0); intros; elim H; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H2; intros; elim H3; intros;\n elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H8; intros;\n elim H8; intros; elim H9; intros; elim H8; intros;\n elim H8; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nintros.\nelim (Z_dec_points x); intro H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite (plus_comm (x + 0)).\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite (plus_comm (x + 0)).\nrewrite <- H.\nrewrite (plus_commQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nunfold not in |- *; intros; elim H; auto with zarith.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple destruct x.\nrewrite (plus_comm x).\nrewrite (plus_comm x).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm x).\nrewrite (plus_comm x).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S y)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S y)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S y)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S x)).\nrewrite (plus_comm (S xQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple induction x.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_n_O.\nsimpl in |- *.\nrewrite <- plus_Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple induction x.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nsimpl in |- *; auto with arith.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nintros.\nrewrite <- H.\napply absZ_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\n",
                "context_tokens": 307,
                "proof_start_offset": 1870,
                "proof_end_offset": 2140,
                "proof": "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  simple induction x.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nunfoldpoint in |- *; simpl in |- *; auto.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  intro x.\n  induction x as [ | x IH]; simpl.\n  reflexivity.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction x.\nauto.\nsimple induction x.\nintros.\nsimple induction xQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nsimple induction x.\nauto with arith.\nintros x0.\nrewrite (H0 x0).\nrewrite (H0 x0).\nrewrite (H1 x0).\nrewrite (H1 x0).\nrewrite (H2 x0).\nrewrite (H1 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H3 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H3 x0).\nrewrite (H2 x0).\nrewrite (H3 x0).\nrewrite (H2 x0).\nrewrite (H3 x).\nrewrite (H2 x0).\nrewrite (H3 x0).\nrewrite (H2 x0).\nrewrite (H3 x0).\nrewrite (H2 x0).\nrewrite (H2 x0).\nrewrite (H3 x0Qed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimpleQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  intros.\n  unfold \n                Zshiftin in |- *.  reflexivity.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nunfold IZ; simpl.\nunfold succZ; trivial.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nintros.\nelim (eq_nat_dec x 0); intro.\nelim (eq_nat_dec x 0); intro.\nrewrite H1.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H4.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2160,
                "proof_end_offset": 2430,
                "proof": "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\napply pred_succZ; assumption.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nsimple induction x; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\n(* sign *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* negQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\n(* true *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* true *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.\n(* false *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nsimple induction x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple inductionQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* var n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* var n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl in |- *; reflexivity.\n(* var n *)\nsimpl inQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl inQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nsimple induction x; auto.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "******************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 471,
                "proof_start_offset": 2460,
                "proof_end_offset": 2604,
                "proof": "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nunfold succZ, succZ in |- *; elim x.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* sign *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x; simple induction x.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0.\nsimpl in |- *; reflexivity.\nsimple induction x0; simple induction x0Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* true *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* negQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* word *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* GG *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x.\nsimpl in |- *; reflexivity.\n(* succ n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                    *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\n",
                "context_tokens": 513,
                "proof_start_offset": 2627,
                "proof_end_offset": 2801,
                "proof": "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro; elim n; intro.\nelim (lt_n_O 0); exact H.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; intros.\nsimpl in |- *; reflexivity.\nsimple induction 1; simpl in |- *; reflexivity.\nsimple induction 1; simpl in |- *; reflexivity.\nsimple induction 2; simpl in |- *; reflexivity.\nsimple induction 1; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 2; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 4; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 4; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 4; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |- *; reflexivity.\nsimple induction 3; simpl in |-Qed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimple induction 1; simpl in |- *; auto with arith.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple inductionQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nreflexivity.\nreflexivity.\nintro; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                  INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\nLemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\n\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H. intros; simpl in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 566,
                "proof_start_offset": 2826,
                "proof_end_offset": 2975,
                "proof": "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; elim n; simpl in |- *; reflexivity; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n.\nintros; reflexivity.\nintros; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n.\nreflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H. intros; simpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\n",
                "context_tokens": 158,
                "proof_start_offset": 1436,
                "proof_end_offset": 1965,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nexact (mult_IZ d1).\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros.\nunfold gcd in |- *.\nintro.\ncut (Z_of_nat (Z_of_nat (nat_of_P p)) (nat_of_P p)).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nintro.\ncut (nat_of_P p > 0).\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nsimple induction 1; intros.\nelim H0; intros.\nelim H1; intros.\ncut (a = b); auto.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b d1 d2 H0.\nelim H0.\nintros.\ninversion H0.\nintros.\ninversion H0.\ninversion H0.\ninversion H0.\napply H1.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nsimple induction a; simpl in |- *; intros.\nelim H0; elim H1; elim H2; elim H3; elim H4;\n auto.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nsimple induction 1; simpl in |- *; auto.\nintros a b d1 d2 H.\ncut (a = b \\/ d1 = d2).\nintro H1; elim H1; auto.\nintro H2.\ncut (b = b \\/ d1 = d2).\nintro H2; elim H2; auto.\nintro H3.\ncut (b = d1 \\/ d1 = d2).\nintro H4; elim H4; auto.\nintro H5.\ncut (b = b \\/ d1 = d2).\nintro H5; elim H5; auto.\nintro H6.\ncut (b = b \\/ d1 = d2).\nintro H5; elim H5; auto.\nintro H7.\ncut (b = b \\/ d1 = d2).\nintro H7; elim H8; auto.\nintro H8.\ncut (b = d1 \\/ d1 = d2).\nintro H8; elim H8; auto.\nintro H8.\ncut (b = b \\/ d1 = d2).\nintro H8; elim H8; auto.\nintro HQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros.\ncut (exists d : Z, a = b /\\ d = d /\\ d2 = d).\nintro.\nelim H0.\nintros.\nsplit.\nrewrite H4.\napply H.\nassumption.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros.\nunfold is_gcd in H.\ncut (Zinf d1 > 0).\nintro.\nelim H; auto.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b d1 d2 H1 H2 H3 H4.\nelim H3; auto.\nelim H4; auto.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nsimple induction 1; intros a b d1 IH1 IH2.\nleft.\napply IH1; trivial.\nright.\napply IH2; trivial.\napply IH2; trivial.\napply IH2; trivial.\napply IH1; trivial.\napply IH2; trivial.\napply IH1; trivial.\napply IH2; trivial.\napply IH2; trivial.\napply IH1; trivial.\napply IH2; trivial.\napply IH2; trivial.\napply IH2; trivial.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nsimple induction 1; intros.\nleft.\ntrivial.\nleft.\ntrivial.\nright.\ntrivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\nLemma gcd_unicity_apart_sign :\n forall a b d1 d2 : Z,\n is_gcd Z IdZ multZ OZ a b d1 ->\n is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\n\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ\n    Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2. \nexact (mult_IZ d1).\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\n",
                "context_tokens": 373,
                "proof_start_offset": 1981,
                "proof_end_offset": 3327,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (abs_eq_or_oppZ b); intro y.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ b).\nintros; exact H0.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split.\nexact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry in |- *; exact (mult_IZ b).\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (oppZ x).\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nsymmetry in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintro.\nelim (gcd_divisors_bezout b (absZ b) (absZ b)); trivial.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (invOne (headZ b)).\nauto with arith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (invOne (absZ b) (absZ b)); intros.\nright. elim H1; intros; elim H4; intros.\nrewrite H5; rewrite H6.\nsimpl in |- *; auto with arith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (invhead (head (absZ b))).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invhead (absZ b)).\nintros.\nelim (invQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nunfold is_gcd in |- *.\nintros.\nelim H0; intros.\nleft.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nleft.\nelim H3; intros.\nelim H4; intros.\nright.\nelim H4; intros.\nelim H5; intros.\napply H5; assumption.\nelim H5; intros.\napply H5; assumption.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nsimple induction b; simpl in |- *; auto with zarith.\nintros.\napply Z_div_pos.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (inversExpZ x); intros.\nleft. elim H1; intros.\nleft. elim H2; intros; elim H4; intros.\nrewrite H6.\nrewrite H4.\nsimpl in |- *; exact (mult_comm (absZ b) (absZ b)).\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (invnn b); intros.\nleft. elim H1; intros.\nright. elim H1; intros.\napply H; apply H0; apply H1; apply H2; apply H4;\n exact (mult_mn b).\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintro.\nelim (inversExpZ x); intros.\nright. elim H1; intros.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite <- H3.\nsimpl in |- *; auto.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nunfold is_gcd in |- *.\nintros.\nelim (invhead zero); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H5.\napply Zle_refl.\napply Zle_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\n\nintros. elim (abs_eq_or_oppZ b); intro y.\n(* |b|=b *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3865,
                "proof_end_offset": 4332,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros.\ncase (eq_OZ_dec n); intro.\nunfold P in |- *.\nintro.\nsplit with (absZ b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (divZ b n).\nintros.\ncut (lt_absZ r n); intros.\nelim (H r H0 n).\nintros.\nsplit with x.\napply gcd_mod with (2 := i); trivial.\ninversion i.\ndecompose [and] H1.\nunfold lt_absZ in |- *.\nrewrite (tech_le_pos_abs r H2).\nexact H4.\nexact n0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\ninduction n.\nintros.\nsimpl in |- *.\napply le_n_O.\nintros.\napply lt_n_n.\nintros.\napply lt_n_O.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintros.\napply lt_n_Sn.\nintrosQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nunfold P in |- *; intros n H H0.\ncase (le_gt_dec n m); intro H1.\nleft; elim H1; intro H2.\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply lt_le_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_lt_trans with (m := n).\napply le_trans with (m := n).\napply le_lt_trans with (Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros n.\n intro.\n cut (forall m : Z, lt_absZ m n -> P m).\n intro.\n apply (H (fun m : Z => lt_absZ m n)).\n apply H0.\n apply le_n_S.\n assumption.\n intro.\n cut (forall m : Z, lt_absZ m n -> P m).\n intro.\n apply (H m).\n apply (H m).\n assumption.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nunfold P in |- *.\nintros n H; elim H.\nintros m H0.\nrewrite <- H0.\nunfold Z_div in |- *; rewrite <- H0.\nrewrite (mult_comm n m); rewrite <- H0.\nrewrite <- (mult_comm m n); rewrite <- H0.\napply (fun m n H0 : Z => le_plus_one n m); trivial.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nsimple induction n.\nintro m.\napply le_ind.\napply (mult_reg_l n m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm n).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm n).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm n).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewrite <- (mult_comm m).\nrewriteQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nsimple induction n.\nintro.\napply le_0_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_OQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros n Hn.\n case Hn; auto with *.\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hn).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nintros m IH.\napply (lt_trans _ _ Hm).\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros.\ndestruct n.\nunfold gcdZ in |- *; simpl in |- *; auto.\nintros m Hm.\nrewrite <- Hm.\napply lt_n_S.\napply le_S_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nunfold P in |- *.\nintros n Hn.\nunfold gcdZ_i in |- *.\nsplit.\napply le_n_O.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n H.\napply (H (Zabs_nat n)).\napply (H (Zabs_nat n)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4334,
                "proof_end_offset": 4420,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (recZ P acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_negn (absZ b)). intro.\n  case (eq_negn (absZ b)). intro.\n  left. apply abs_eq_absZ.\n  assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold gcdZ in |- *. intros. case (eq_Nle_dec a b); intro.\n  rewrite (gcd_bezout a b). rewrite (gcd_bezout b a). rewrite (gcd_bezout a b).\n  unfold gcdZ in |- *; intro. elim (divZ b n). intros.\n  elim (gcd_bezout a b a). intros.\n  elim (gcd_bezout a b a). intros.\n  elim (gcd_bezout a b a). intros.\n  elim (gcd_bezout b a). intros.\n  elim (gcd_bezout a b a). intros.\n  elim (gcd_bezout a b a). intros.\n  elim H3. intros.\n  split with x.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  simple induction a.\n  unfold gcdZ in |- *. intros.\n  apply gcd_div_pos.\n  assumption.\n  unfold gcdZ in |- *. intros.\n  elim (gcd_bezout a b). intros. cut (gcdZ a b). intro.\n  elim (gcd_bezout a b). intros.\n  elim (gcd_bezout a b). intros.\n  elim H2. intros. split with x.\n  apply gcd_div_pos.\n  assumption.\n  unfold gcdZ in |- *. intros.\n  elim (gcd_bezout a b). intros.\n  elim H3. intros. split with x.\n  apply gcd_div_pos.\n  assumption.\n  unfold gcdZ in |- *. intros.\n  elim H1; intros.\n  elim H4; intros.\n  split with x.\n  apply gcd_div_pos.\n  assumption.\n  unfold gcdZ in |- *. intros.\n  elim H2; intros.\n  split with x.\n  apply gcd_div_pos.\n  assumption.\n  unfold gcdZ in |- *. intros.\n  elim H4; intros.\n  split with x.\n  apply gcd_div_pos.\n  assumption.\n  unfold gcdZ in |- *. intros.\n Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_decidable a b); trivial.\n  intros. absurd (forall a b : Z, a = 0 -> b = 0 -> b = 0 -> a = 0).\n  intro. elim H4. intros. elim H5. intros.\n  apply H6. assumption.\n  assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros a b. case (eq_trichotomy a b); intro. unfold P in |- *. intro.\n  elim (gcd_bezout_dec a b). intros. absurd (a = b). rewrite e. apply gcd_sym.\n  unfold gt in |- *. rewrite (gcd_bezout a b). rewrite (gcd_bezout a b).\n  rewrite (gcd_bezout a b). rewrite (gcd_bezout a b). reflexivity.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold gcdZ in |- *. intros. case (eq_Irreflexive n).\n  intros. rewrite e. rewrite e. apply (gcd_bezout a).\n  unfold gcdZ in |- *. rewrite e. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcd_mod.\n  unfold gcdZ in |- *. rewrite abs_1. apply gcdQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_irreflexive_dec a b). intro. unfold P in |- *. intro.\n  elim (divZ_dec a b). intros. absurd (a = b).\n   rewrite e. apply (gcd_bezout b). assumption. assumption.\n  assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_irreflexive_dec a b); intro. unfold P in |- *. intro.\n  elim (divZ_div_eucl a b). intros. cut (a = 0). intro. unfold P in |- *. intro. discriminate.\n  exact (sym_not_eq (Z.abs_nat b)).\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_irreflexive_dec a b); intro.\n  elim H0.\n  apply H0.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_Rat_dec a b); trivial.\n  elim H; clear H.\n  apply (pos_inf a).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "rewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\n",
                "context_tokens": 721,
                "proof_start_offset": 4441,
                "proof_end_offset": 5553,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\nintros.\nelim H; intros.\napply (gcd_OZ_absZ b0).\nunfold is_gcd in |- *.\nsplit.\nelim H3; intros; elim H5; intros; exact H6.\nsplit.\nelim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros.\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros.\nelim H3; intros; elim H7; intros.\napply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros.\nrewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros.\nelim H17; intros.\nelim H19; intros.\nrewrite H20.\nsymmetry in |- *.\nexact (add_OZ r).\nexact H4.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros.\n  elim (lt_or_lt a b).\n  intro.\n  elim H1; intro.\n  elim H2; intro.\n  elim H4; intro.\n  elim H5; intro.\n  cut (a + b = 0).\n  intro; elim (divZ a b). intros.\n  elim (divZ b a). intros.\n  elim H5; intro.\n  elim H6; intro.\n  elim H7; intro.\n  elim H7; intro.\n  rewrite H7.\n  replace (Z.pos b * 1) with (Z.pos b * 1).\n  rewrite H8.\n  ring.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_bezout_dec a b).\n  intros. cut (exists b : Z, a = b /\\ d = b).\n  intro.\n  elim (H0 (a * b)); intros.\n  elim H2.\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  elim H4.\n  intros.\n  elim H5.\n  intros.\n  elim H5.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H7.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H9.\n  intros.\n  elim H8.\n  intros.\n  elim H8.\n  intros.\n  elim H9.\n  intros.\n  elim H8.\n  intros.\n  elim H9.\n  intros.\n  elim H9.\n  intros.\n  elim H10.\n  introsQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros a b d H; case (eq_Irreflexive d).\n  intro. unfold P in |- *. intro. elim H0; intros.\n  elim H1; intros.\n  assumption.\n  intros.\n  elim H1; intros.\n  assumption.\n  intros.\n  elim H1; intros.\n  assumption.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  assumption.\n  intros.\n  elim H1; intros.\n  assumption.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_Irreflexive d).\n  unfold Bezout in |- *; intros.\n  elim H2.\n  apply (gcd_bezout a b).\n  unfold Bezout in |- *; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  split with x.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros.\n  case (eq_decidable_inf Z_inf Z_inf Z_inf Z_inf Z_inf Z_inf Z_inf Z_inf Z_inf Z_inf Z_inf Z_inf_Z_Z a b d).\n  intro.\n  elim H0.\n  intros.\n  elim H2.\n  intros.\n  apply H3.\n  unfold Z.abs at 2 in |- *.\n  rewrite (Zplus_comm a b) in H0.\n  rewrite (Zplus_comm b d) in H0.\n  rewrite (Zplus_comm d d) in H0.\n  rewrite (Zplus_comm d d) in H0.\n  rewrite (Zplus_comm d d) in H0.\n  rewrite (Zplus_comm d d) in H0.\n  rewrite (Zplus_comm d d) in H0.\n  rewrite (Zplus_comm b d) in H0.\n  rewrite (Zplus_assoc d d d) in H0.\n  rewrite (Zplus_comm a b) in H0.\n  rewrite (Zplus_comm b d) in H0.\n  rewrite (Zplus_assoc d d d) in H0.\n  rewrite (Zplus_commQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_decidable_gcdZ a b d); intro.\n  rewrite e.\n  rewrite H0.\n  apply gcd_pos_pos.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_is_gcd Z a b d); trivial.\n  intros.\n  unfold gcdZ in |- *. exists (gcd a b).\n  unfold gcd in |- *.  intros.\n  elim (divZ_is_gcd a b d); trivial.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (eq_pointsH a); intro.\n  apply (pos_is_gcdZ a b d).\n  unfold P in |- *. intros. elim H2. intros.\n  elim H3. intros.\n  split with x.\n  apply gcd_is_gcdZ; trivial.\n  apply gcd_sym.\n  assumption.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros.\n  case (le_or_eq (Z.gcd a b) (Z.gcd b d)); intros.\n  apply H0.\n  apply gcd_is_gcd.\n  unfold Bezout in |- *; intros.\n  elim (divZ a b d). intros.\n  elim H2. intros. split with x.\n  apply gcd_div_pos with (2 := j); trivial. inversion i.\n  unfold gcd in |- *; intros.\n  elim H2. intros. split with x.\n  apply gcd_div_pos with (2 := j); trivial. inversion i.\n  unfold gcd in |- *; intros.\n  elim H2. intros. split with x.\n  apply gcd_div_pos with (2 := j); trivial. inversion i.\n  unfold gcd in |- *; intros.\n  elim H2. intros. split with x.\n  apply gcd_div_pos with (2 := j); trivial. inversion i.\n  unfold gcd in |- *; intros.\n  elim H2. intros. split with x.\n  apply gcd_div_pos with (2 := j); trivial. inversion i.\n  unfold gcd in |- *; intros.\n  elim H2. intros. split withQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_is_gcd Z a b d); trivial.\n  intros. elim H1. intros. absurd (a * b * d).\n   intro. elim H2. intros. split with x. split.\n   apply gcd_sym. assumption. assumption.\n   intro. elim H4. intros. split with x. split.\n   apply gcd_sym. assumption. assumption. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 5810,
                "proof_end_offset": 5941,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros; elim H; intros.\napply (sign_absZ b0).\nexact H3.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nsimple induction 1; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d.\napply (relZ_is_gcdZ a b d).\napply (relZ_is_gcdZ a b d).\napply (relZ_is_gcdZ a b d).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d.\nelim (prime_correct a b); auto.\nintros.\nelim H4; intros; elim H5; intros; elim H6; intros; clear H6.\ncut (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_nat (Z_of_nat (Z_nat (Z_of_nat (Z_of_nat (Z_nat (Z_of_nat (Z_nat (Z_of_nat (Z_of_nat (Z_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_nat (Z_of_nat (Z_of_nat (Z_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (ZQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nsimple induction 1; intros.\napply (gcd_bezout_pos a b d d).\napply (gcd_bezout_pos a b d d).\nelim H1; intros.\napply (gcd_bezout_pos a b d d).\nrewrite <- H1.\napply gcd_antisym.\napply gcd_trans with (a * b + d * d * d * d).\nreplace (a * b + d * d * d) with (a * b + d * d * d).\nrewrite (mul_comm a b d).\nrewrite (mul_comm a b d).\nrewrite (mul_comm a b d).\nrewrite (mul_comm b d).\nrewrite (mul_comm b d).\nrewrite (mul_comm b d).\nrewrite (mul_comm a b).\nrewrite (mul_assoc b d).\nrewrite (mul_comm d b).\nrewrite (mul_comm d b).\nrewrite (mul_comm b d).\nrewrite (mul_comm b d).\nrewrite (mul_assoc b d).\nrewrite (mul_comm d b).\nrewrite (mul_comm b d).\nrewrite (mul_commQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  simple induction 1. \n(* base *)\n  intros.  elim H0; intros.\n  split with 0; trivial.\n  intros.  elim H1; intros.  split with 0; trivial.\n  intros.  elim H1; intros.  elim H2; intros.\n  split with 0; trivial.\n  intros.  elim H3; intros.  elim H4; intros.  elim H5; intros.\n  split with 0; trivial.\n  intros.  elim H5; intros.  elim H5; intros.\n  split with 0; trivial.\n  intros.  elim H5; intros.  elim H5; intros.\n  split with 0; trivial.\n  intros.  elim H5; intros.  elim H6; intros.  elim H6; intros.\n  split with 0; trivial.\n  intros.  elim H6; intros.  elim H7; intros.  elim H8; intros.\n  split with 0; trivial.\n  intros.  elim H7; intros.  elim H8; intros.  elim H8; intros.\n  split with 0; trivial.\n  intros.  elim H7; intros.  elim HQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  simple induction 1; intro.\n  (* base *)\n  intro.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H5; intros.\n  elim H6; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H6; intros.\n  elim H6; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H6; intros.\n  elim H7; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H7; intros.\n  elim H8; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H8; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H9; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H9; intros.\n  elim H9; intros.\n  assumption.\n  (* base *)\n  intro.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elimQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  simple induction a.\n  simple induction 1; simpl in |- *; trivial.\n  intros.\n  elim (prime_irreflexive d).\n  intros.\n  case (Z.div2 a d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  case (Z.div2 b d).\n  intro.\n  caseQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nsimple induction 1; simpl in |- *; intros; auto with zarith.\nintros a b H H0 H1; red in |- *; intros.\ninversion H1.\napply (H1 b).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros.\n  apply gcdZ_is_gcdZ; auto.\n  apply gcdZ_is_gcdZ; auto.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintro.\ncut (forall a b : Z, a = b -> gcdZ a b d).\nintro.\napply (H (Z_div_pos a b d (gcdZ a b d (gcdZ a b d (gcdZ a b d)))).\napply (H0 (Z_div_pos b d (gcdZ a b d (gcdZ a b d))).\napply gcdZ_is_gcdZ.\napply gcdZ_is_gcdZ.\napply gcdZ_is_gcdZ.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\n",
                "context_tokens": 714,
                "proof_start_offset": 5966,
                "proof_end_offset": 6284,
                "proof": "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H) (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros; apply (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0) (positive_is_gcdZ a b d1 H)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros. apply (triangle_is_gcdZ a b d1 H0).\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\n  simple induction 1; intros.\n  apply (gcd_Z_is_gcdZ a b d1 d2 H0 H1).\n  intros; case H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10;Qed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros.\napply (gcd_bezout_pos Z_is_gcdZ a b d1 d2 H0).\napply gcdZ_intro; apply (gcd_bezout_pos Z_is_gcdZ a b d1 d2 H0).\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nsimple induction 1; intros.\napply (gcd_bezout_is_gcdZ a b d1 d2 H H0).\napply gcd_sym; trivial.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nsimple induction 1; simpl in |- *; intros; trivial.\nelim H0; intros.\nelim H1; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H12; intros.\nelimQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\n  intros; elim H; intros.\n  apply (gcd_bezout_absZ a b d1 d2 H H0).\n  apply (gcd_bezout_pos a b d1 d2 H0).\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros a b d1 d2 H1 H2; elim H1; intros.\napply (mul_sym (Z.mul_comm a b) (Z.mul_comm b d1).\nrewrite <- (Zmult_comm a b).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm a b).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewrite <- (Zmult_comm (Z.mul_comm b d1)).\nrewriteQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nsimple induction 1; intros.\nelim H0; intros.\nrewrite <- (absZ_eq_abs a b d1 d2 d3 H0 H1).\nrewrite <- (absZ_eq_abs a b d1 d2 d3 H0 H1).\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros a b d d1 d2 H1 H2.\ncut (exists d : Z, a = b /\\ d = d1).\nintros; elim H1; intros.\nexists d; split; [ assumption | assumption ].\nelim H2; intros.\nexists d; split; [ assumption | assumption ].\nelim H4; intros.\nexists d; split; [ assumption | assumption ].\nelim H4; intros.\nexists d; split; [ assumption | assumption ].\nelim H4; intros.\nexists d; split; [ assumption | assumption ].\nelim H4; intros.\nexists d; split; [ assumption | assumption ].\nelim H4; intros.\nexists d; split; [ assumption | assumption ].\nelim H4; intros.\nexists d; split; [ assumption | assumption ].\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\n  intros; elim H; intros.\n  apply (gcd_bezout_is_gcdZ a b d1 d2 H0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 6306,
                "proof_end_offset": 6452,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d H; elim H; intros.\napply (gcd_bezout_is_gcdZ a b d (gcdZ_is_gcd a b d H)).\napply gcdZ_is_gcdZ; trivial.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d H; elim H; intros.\nrewrite H0; rewrite H1; rewrite H2; rewrite H3; ring.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; intros.\napply gcdZ_is_gcdZ; trivial.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d.\nelim (gcd_unicity_bezout a b d (gcdZ_is_gcd a b d)).\nintros; elim H; intros. \napply (gcd_bezout_sym a b d H0).\nrewrite (gcd_sym a b).\napply gcdZ_is_gcdZ; auto.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d H H0; elim H0; intros.\napply (mul_bezout_sym a b d H0 (sym_eq H0)).\nrewrite <- (abs_inj a b) in H; trivial.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros; elim H; intros.\napply (gcd_bezout_pos a b d (gcdZ_is_gcd a b d H)).\napply gcdZ_is_gcdZ; trivial.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d H; elim H; intros.\napply gcdZ_is_gcdZ; auto.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d.\nrewrite <- (absZ_abs_nat a b) at 1.\nrewrite (absZ_abs_nat b (abs b)) at 1.\nrewrite (absZ_abs_nat b (abs b)) at 1.\nrewrite (absZ_abs_nat b (abs b)) at 1.\nrewrite abs_Z_abs.\nrewrite abs_Z_is_gcdZ; trivial.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nsimple induction a; simpl in |- *; auto with zarith.\nintros; rewrite gcdZ_eq; auto with zarith.\nintros; rewrite gcdZ_eq; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros; elim H; intros.\napply (gcd_bezout_sym (Z_of_nat a) (Z_of_nat b)).\napply gcdZ_is_gcdZ; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\n",
                "context_tokens": 719,
                "proof_start_offset": 6470,
                "proof_end_offset": 6674,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nsimple induction 1; intros.\napply gcd_sym_divisors with (p := p); trivial.\napply gcd_sym_divisors with (p := p); trivial.\napply gcd_sym_divisors with (p := p); trivial.\napply gcd_sym_divisors with (p := p); trivial.\napply gcd_sym_divisors with (p := p); trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H H0 H1 H2 H3.\nrewrite <- (abs_abs_eq a b) in H2.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) in H3.\nrewrite <- (abs_eq b a) inQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\napply (rel_eq_trans (gcdZ a b) (gcdZ_is_gcd a b q r)).\napply gcd_sym; assumption.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2; elim H2; intros.\napply (gcd_bezout a b d q r H2); trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2 H3 H4.\napply (rel_irreflexive_prime Z_is_gcdZ a b q r H2 H4).\napply gcd_trans with (a := b); auto.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H H0.\nelim H0; intros.\napply gcdZ_is_gcdZ; auto.\napply gcdZ_is_gcdZ; auto.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcd_bezout a b q r H).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H0 H1 H2.\napply gcd_unique with (r := (-a)); trivial.\nrewrite <- (gcd_sym a b).\napply gcd_unique with (r := (-b)); trivial.\nrewrite <- (gcd_sym b a).\napply gcd_unique with (r := (-a)); trivial.\nrewrite <- (gcd_sym a b).\napply gcd_unique_strong; trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nintros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\napply gcd_sym with (q := r); auto with zarith.\nrewrite <- H0; rewrite <- H1; rewrite <- H2; rewrite H4.\nrewrite <- H0; rewrite <- H1; rewrite <- H2; rewrite H4.\napply gcd_sym.\nrewrite <- H0; rewrite <- H2; rewrite <- H4; rewrite <- H4.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim H; intros.\napply gcdZ_sym.\napply gcdZ_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ")) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6945,
                "proof_end_offset": 8358,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros q f.\ncase (eq_OZ_dec q); intro.\nunfold Q in |- *; intro b.\nsplit with IZ (sgnZ b).\nrewrite e.\nsimpl in |- *.\nrewrite (sgn_abs b).\napply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (divZ b q).\nintros div rem; intros.\ncut (lt_absZ rem q); intros.\nelim (f rem H q).\nintros.\nsplit with (addZ v (oppZ (multZ div u))) u.\nelim i.\nintros.\nelim H1.\nintros.\nelim H3.\nintros.\npattern b at 1 in |- *.\nrewrite H5.\nelim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\nrewrite H7.\nelim (mult_add_distributivity (multZ q div) rem u); intros.\nrewrite H8.\nrewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\nelim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\nrewrite (add_add Z addZ addZ_commutativity addZ_associativity (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u) (multZ (multZ q div) u)).\nelim (addZ_commutativity (multZ rem u) (multZ q v)).\nrewrite e.\nelim (multZ_associativity q div u).\nelim (addZ_opposite (multZ q (multZ div u)) I); intros.\nelim H11; intros; elim H13; intros.\nrewrite H15.\nrewrite (add_OZ (gcdZ rem q)).\nexact (gcd_modZ b q div rem n i).\nunfold lt_absZ in |- *.\nelim i; intros; elim H0; intros.\nrewrite (tech_le_pos_abs rem H1).\nelim H2; trivial.\nexact n.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros.\napply (well_founded_induction_type (Q n)).\nintros; constructor.\nexact (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros; constructor.\nexact (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_induction_type (Q n)).\nintros.\napply (Build_founded_inductionQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros n H.\napply (Build_gcd_is_gcdZ a n (le_0_n _ _ H)).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros n H.\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\napply (Build_law_induction n m (le_n_O _ H)).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nunfold Q in |- *.\nintros n H.\nelim H.\nintros.\napply (H (Z_of_nat n)).\napply (H (Z_of_nat n)).\napply (H (Z_of_nat n)).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\ninduction n; simpl; auto.\nintros m H; elim H; intros.\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\napply (H m).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nunfold Q in |- *.\nintros n H H0.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H12; intros.\nelim H13; intros.\nelim H14; intros.\nelimQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nunfold Q in |- *; auto with *.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nunfold Q in |- *; intros n H1; elim H1; clear H1; intros.\nrewrite <- H1; apply (lt_n_O 0).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros; elim H; intros.\napply (H0 (multZ_of_nat n)).\napply (H1 (multZ_of_nat n)).\napply (H1 (multZ_of_nat n)).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nunfold Q; intros n; elim n.\nintros.\napply (H (mult_0_l n m) (mult_0_l n m) (mult_0_l m) n (mult_1_l n m) (mult_1_l m) n (mult_1_l m) n (mult_1_l m) n (mult_1_l n m).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ".\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 8360,
                "proof_end_offset": 8453,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (recZ Q acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec b a); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  case (eq_addZ_dec a b); intro.\n  caseQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec b a).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidable_dec a b).\n  elim (eq_decidableQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; case (is_gcdZ a b); trivial.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intro a; case (gcdZ_is_gcdZ a b).\n  intro a. elim (gcdZ_is_gcdZ a b).\n  intro a'. elim (gcdZ_is_gcdZ a b).\n  intro a'. elim (gcdZ_is_gcdZ a b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim (gcdZ_is_gcdZ a' b).\n  intro a'. elim H3. intros. elim H4. intros. elim H5. intros. rewrite (H1 a').\n  apply H2.\n  apply HQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (Z_is_gcdZ a b (gcdZ a b)).\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold gen_induction in |- *.\n  intros.\n  apply (Build_gcd_prime Z a b (gcdZ a b)).\n  elim (divZ b a (gcdZ b a)).\n  intro. elim H1. intros. exists (Z b).\n  apply (gcdZ_is_gcd Z a b (gcdZ a b)).\n  elim (divZ b a (gcdZ b a)).\n  intro. elim H2. intros. exists (Z b).\n  apply (gcdZ_is_gcd Z a b (gcdZ a b)).\n  elim H1. intros. elim H3. intros. exists (Z b).\n  apply (gcdZ_is_gcd Z a b (gcdZ a b)).\n  elim H3. intros. rewrite H4. rewrite (gcdZ_is_gcd Z a b).\n  elim (divZ b a). intros. rewrite H5. rewrite (gcdZ_is_gcd Z a b).\n  elim H3. intros. rewrite H4. rewrite (gcdZ_is_gcd Z a b).\n  elim H3. intros. rewrite H4. rewrite (gcdZ_is_gcd Z a b).\n  elim H3Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; elim (even_odd_odd_even_even_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd).\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  elim (odd_odd_odd_odd_even_odd_odd a b).\n  intro.\n  elim (even_odd_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (even_odd_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (even_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (odd_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (odd_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (odd_odd_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (odd_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (odd_odd_odd_odd_odd_odd_odd a b).\n  intro.\n  elim (odd_odd_odd_odd_odd a b).\n  intro.\n  elim (even_odd_odd_odd_odd a b).\n  intro.\n  elim (odd_odd_odd_odd_odd a b).\n  intro.\n  elim (oddQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold gen in |- *.\n  intros.\n  elim (odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd_odd a b).\n  elim (odd_odd_odd_odd_odd_odd_odd_odd_odd_odd a b).\n  elim b. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (odd_odd_odd_odd_odd_odd_odd_odd_odd a b).\n  elim b. intros. elim H5. intros. exists (div1 a). rewrite H5. elim (divZ b (div2 a))).\n  elim b. intros. rewrite (div2_odd_odd_odd_odd_odd_odd a b).\n  elim b. intros. elim H5. intros. exists (div2 a). rewrite H5. elim (div2_odd_odd_odd_odd_odd_odd_odd a b).\n  elim b. intros. rewrite (div2_odd_odd_odd_odd_odd_odd_odd_odd_odd a b).\n  elim b. intros. elim H6. intros. existsQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros.\n  elim (is_gcd_Z a b (gcdZ a b)).\n  elim (is_gcd_Z a b (gcdZ a b)).\n  intros. elim H1. intros. exists (gcdZ a b).\n  rewrite H3. rewrite H4. rewrite H4. rewrite H4. reflexivity.\n  elim (modZ_mod_Z a b (gcdZ a b)).\n  intro. elim H1. intros. exists (gcdZ a b).\n  rewrite H3. rewrite H4. rewrite H5. reflexivity.\n  elim (modZ_mod_Z a b (gcdZ a b)).\n  intro. elim H1. intros. exists (gcdZ a b).\n  rewrite H5. rewrite H5. rewrite H5. reflexivity.\n  elim (modZ_mod_Z a b (gcdZ a b)).\n  intro. elim H1. intros. exists (gcdZ b a).\n  rewrite H4. rewrite H5. rewrite H5. rewrite H6. reflexivity.\n  elim (modZ_mod_Z a b (gcdZ a b)).\n  intro. elim H1. intros. exists (gcdZ b a).\n  rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "Lemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\n",
                "context_tokens": 736,
                "proof_start_offset": 8579,
                "proof_end_offset": 8840,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (fun x y => multZ x y).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (gcdZ_is_gcd Z x).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (divide_is_gcdZ x (oppZ x)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  unfold ModZ in |- *; intros; elim H; trivial.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros x.\n  elim (dec_eq_Rat x 0).\n  intros.\n  elim H1. intros.\n  elim H2. intros.\n  elim H3. intros.\n  elim H4. intros.\n  split with x0.\n  split.\n  apply prime_mult_l.\n  assumption.\n  apply abs_mult_l.\n  assumption.\n  apply abs_mult_l.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  elim (plus_integral Z x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x))))) x)).\n  apply divide_impZ_Exp. exact (Zle_refl (conjZ_modZ x)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  elim (gcd_sym Z x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x))))) 0)).\n  intro. apply (mulZ_div_pos _ x y n).\n  apply (divide_refl (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x))))) 0)).\n  intro. apply (mulZ_div_pos _ x y n).\n  apply (divide_refl (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x))))) 0)).\n  intro. apply (mulZ_div_pos _ x y n).\n  apply (Zle_trans (Z.gcd (x * y) (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x (mulZ x))))) 0Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (fun x => (fun y : Z => (x + y)%Z) (Z_of_nat x)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  unfold ModZ in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.  unfold Z in |- *.  unfold Z in |- *.\n  unfold Z in |- *.Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (fun x y => multZ x (ZmultZ x y)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\nLemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\n\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec x); intros. left; exact a.\nright; split. exact b. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ x).\nQed.\n\n(**********************************)\n",
                "context_tokens": 717,
                "proof_start_offset": 8879,
                "proof_end_offset": 12106,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (addZ (multZ x (multZ b v)) (multZ y (multZ a u))).\nunfold congruentZ in |- *; split.\nreplace (multZ b v) with (addZ IZ (oppZ (multZ a u))).\nelim (mult_add_distributivity x IZ (oppZ (multZ a u))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ x).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring a u I I).\nrewrite (multZ_associativity x a (oppZ u)).\nelim (multZ_commutativity a x).\nelim (multZ_associativity a x (oppZ u)).\nrewrite (multZ_associativity y a u).\nelim (multZ_commutativity a y).\nelim (multZ_associativity a y u).\nelim (addZ_associativity x (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))).\nelim (addZ_commutativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x).\nelim (addZ_associativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x (oppZ x)).\nelim (addZ_opposite x I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)) a).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ x (oppZ u)) a (divide_selfZ a) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ y u) a (divide_selfZ a) I).\nelim H.\nelim e.\nelim (addZ_commutativity (multZ b v) (multZ a u)).\nelim (addZ_associativity (multZ b v) (multZ a u) (oppZ (multZ a u))).\nelim (addZ_opposite (multZ a u) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nexact (add_OZ (multZ b v)).\ncut (multZ a u = addZ IZ (oppZ (multZ b v))); intros.\nrewrite H0; clear H0.\nelim (mult_add_distributivity y IZ (oppZ (multZ b v))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ y).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring b v I I).\nrewrite (multZ_associativity y b (oppZ v)).\nelim (multZ_commutativity b y).\nelim (multZ_associativity b y (oppZ v)).\nrewrite (multZ_associativity x b v).\nelim (multZ_commutativity b x).\nelim (multZ_associativity b x v).\nelim (addZ_commutativity (multZ b (multZ y (oppZ v))) y).\nrewrite (addZ_associativity (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) y) .\nelim (addZ_associativity (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v)))) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) b).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ x v) b (divide_selfZ b) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ y (oppZ v)) b (divide_selfZ b) I).\nelim H.\nelim e.\nelim (addZ_associativity (multZ a u) (multZ b v) (oppZ (multZ b v))).\nelim (addZ_opposite (multZ b v) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nsymmetry in |- *; exact (add_OZ (multZ a u)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  elim (prime_total_prime_divisors a b); intros.\n  elim (prime_total_prime_divisors a b); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim (prime_total_prime_divisors b a); intros.\n  elim H1; trivial.\n  apply H3.\n  right; split; trivial.\n  elim (prime_total_prime_divisors b a); intros.\n  elim H3; trivial.\n  elim (prime_total_prime_divisors b a); intros.\n  elim H3; trivial.\n  elim H3; trivial.\n  elim H3; trivial.\n  elim H3; trivial.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  case (Z_eq_relflag_dec a b); intros.\n  elim (Z_eq_relflag_dec a b); intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  apply H6; assumption.\n  apply H7; assumption.\n  apply H7; assumption.\n  apply H7; assumption.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  elim (divZ a b); trivial.\n  elim (divZ b a); trivial.\n  elim (divZ a b); trivial.\n  elim (divZ b a); trivial.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y. case (gcdZ a b); trivial.\n  elim (mult_case_strong0 a b x y); trivial.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y z.\n  case (gcdZ_dec a b); case (gcdZ_dec a b); intros.\n  left; exists z; split. exact I.\n  right; split. exact I.\n  right; split. exact I.\n  right; split. exact I.\n  right; split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y z; elim z.\n  intros; elim H.\n  intros.\n  elim H0.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  elim H5.\n  intros.\n  elim H5.\n  intros.\n  elim H5.\n  intros.\n  elim H5.\n  intros.\n  elim H5.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  elim (plus_integral_Zle x y z). intros.\n  elim H; intro.\n  elim (plus_integral_Zle x z). intros. elim H0; trivial.\n  intro. elim (mult_integral_Zle x z). intros.\n  elim H0; trivial.\n  intro. elim (mult_integral_Zle x z). intros.\n  elim (mult_integral_Zle x z). intros.\n  elim H0; trivial.\n  intro. elim (mult_integral_Zle x z). intros.\n  elim H0; trivial.\n  intro. elim (mult_integral_Zle x z). intros.\n  elim H0; trivial.\n  intro. elim (mult_integral_Zle x z). intros.\n  elim H0; trivial.\n  intro. elim (mult_integral_Zle x z). intros.\n  elim (mult_integral_Zle x z). intros.\n  elim H0; trivial.\n  intro. elim (mult_integral_Zle x z). intros.\n  elim (mult_integral_Zle x z). intros.\n  elim H0; trivial.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  elim (eq_Irreflexive x).\n    intros. left. exact (Z_div_pos b x).\n    exact (Z_div_pos b y).\n  intros. left. exact (Z_div_pos b y).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  elim (eq_Nle_dec a b).\n  elim (Z_mod_divide_pos_dec a b).\n  elim (Z_mod_divide_pos_dec b a).\n  elim (Z_mod_divide_pos_dec a b).\n  elim (Z_mod_divide_pos_dec b a); intros.\n  elim H0. intros. exists 0. rewrite Zmult_comm. rewrite Zplus_comm.\n  rewrite (Zmult_comm (a * (a * b) * (a * b)).\n  rewrite (Zmult_assoc (a * (b * b) * (b * a))).\n  rewrite (Zmult_assoc (a * (b * b) * (b * a))).\n  rewrite (Zmult_assoc (a * (b * b) * (b * a))).\n  rewrite (Zmult_assoc (a * (b * b) * (b * a))).\n  rewrite (Zmult_assoc (a * b)).\n  rewrite (Zmult_assoc (a * b)).\n  rewrite (Zmult_assoc (a * b)).\n  rewrite (Zmult_assoc (a * b)).\n  rewrite (Zmult_assoc (a * b)).\n  rewriteQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold gcdZ in |- *. intros.\n  elim (eq_Irreflexive x). intro. left; exact (divZ_div_mod a b).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\n",
                "context_tokens": 134,
                "proof_start_offset": 1314,
                "proof_end_offset": 1558,
                "proof": "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros.\nelim (le_gt_dec m 0).\nintro.\nelim (le_gt_dec m 0).\nintro.\nelim H.\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim H.\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim H.\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim H0.\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim H0.\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim H0.\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim (le_gt_eq_dec m 0).\nintro.\nelim H0Qed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintro.\ncut (forall n m : nat, n <= m -> m <= n).\nintro.\ncut (forall n m : nat, m < n -> m <= n).\nintro.\napply le_n_O.\napply le_n_O.\napply lt_O_n.\napply lt_O_n.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros m; elim (le_or_lt m 0); auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction m.\nintros.\nelim H.\nintros.\nelim H.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H3.\nintros.\nelim H3.\nintros.\nelim H4.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\napply H7.\nintros.\napply H8.\nintros.\napply H8.\nintros.\nelim H9.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nelim H11.\nintros.\nelimQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros m; elim (le_or_lt m 0); auto.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction m.\nsimple induction m.\nintros.\napply le_trans with m; auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nauto.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nintros.\nsimple induction m.\nintros.\napply H.\napply H.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros.\nelim (le_gt_dec m 0).\nauto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction m.\nintros.\nelim (le_or_lt 0 m).\nintros.\nelim H1.\nintros.\napply le_S_n.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_S_n.\napply le_trans with (S (pred (S m))).\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_trans with (pred (S (pred (S m)))).\napply le_n_S.\napply le_trans with (pred (S (pred (S m)))).\napply le_n_S.\napply le_trans with (pred (S (pred (S m)))).\napply le_n_S.\napply le_n_S.\napply le_trans with (pred (S (pred (S m)))).\napply le_n_S.\napply le_trans with (pred (S (pred (S m))).\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_Qed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction m.\nsimple induction m.\nintros.\nrewrite (H m).\nrewrite (H m).\nrewrite (H m).\napply le_n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\n",
                "context_tokens": 219,
                "proof_start_offset": 1573,
                "proof_end_offset": 1786,
                "proof": "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H.\nelim H; intros.\ncut (P n).\nelim H0; intros.\nrewrite H1.\nreplace (n + 0) with (n + 0).\nrewrite mult_n_O.\nrewrite <- H1.\nrewrite mult_n_O.\napply le_n.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H H0; elim H; intros n H1.\nelim (H2 n).\nintros m H3; elim H3; intros m H4.\nelim H4; intros m H5.\nelim H5; intros m H6.\nelim H5; intros m H6.\nelim H5; intros m H7.\nelim H7; intros m H8.\nelim H8; intros m H8.\nelim H8; intros m H9.\nelim H8; intros m H9.\nelim H8; intros m H9.\nelim H9; intros m H10.\nelim H9; intros m H10.\nelim H10; intros m1 H10.\nelim H10; intros m1 H10.\nelim H10; intros m1 H10.\nelim H10; intros m1 H10.\nelim H10; intros m1 H10.\nelim H11; intros m1 H10.\nelim H11; intros m2 H10.\nelim H11; intros m2 H10.\nelim H10; intros m2 H10.\nelim H11; intros m3 H10Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H.\nelim H; intros; elim H0; intros; assumption.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H; elim H; clear H.\nintros; elim H0; clear H0.\nintros m H1; elim H1; clear H1.\nintros m H2; elim H2; clear H2.\nintros m H2; elim H2; clear H2.\nintros m H2; elim H2; clear H2.\nintros m H2; elim H2; clear H2.\nintros m H3; elim H3; clear H3.\nintros m H3; elim H4; clear H4.\nintros m H4; elim H5; clear H5.\nintros m H5; elim H6; clear H6.\nintros m H5; elim H6; clear H7.\nintros m H6; elim H6; clear H7.\nintros m H6; elim H7; clear H7.\nintros m H7; elim H7; clear H7.\nintros m H7; elim H8; clear H7.\nintros m H7; elim H8; clear H8.\nintros m H7; elim H8; clear H8.\nintros m H8; elim H8;Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H; elim H.\nintros; apply (H (pos n) H0).\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H; elim H; intros m H0; elim H0; intros m H1; elim H0; intros m H2; elim H2;\n intros m H3; elim H3; intros m H4; elim H4;\n intros m H5; elim H5; intros m H5; elim H6; intros m H6; elim H7;\n intros m H7; elim H8; intros m H7; elim H8; intros m H8; elim H9;\n intros m H10; elim H9; intros m H10; elim H10; intros m H10; elim H10;\n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros H10 H11; elim H10;\n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H11; \n intros mQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H.\nelim H.\nintros m H0.\nelim H0.\nintros m H1.\nelim H1.\nintros m H2.\nelim H2.\nintros m H3.\nelim H3.\nintros m H4.\nelim H4.\nintros m H5.\nelim H5.\nintros m H6.\nelim H6.\nintros m H7.\nelim H6.\nintros m H7.\nelim H7.\nintros m H8.\nelim H8.\nintros m H8.\nelim H8.\nintros m H8.\nelim H8.\nintros m H8.\nelim H8.\nintros m H8.\nelim H8.\nintros m H9.\nelim H8.\nintros m H9.\nelim H9.\nintros m H9.\nelim H9.\nintros m H9.\nelim H9.\nintros m H9.\nelim H10.\nintros m H9.\nelim H9.\nintros m H10.\nelim H9.\nintros m H10.\nelim H9.\nintros m H9Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H.\napply (H (pos n) (pos n)).\nelim H.\nintros m H0; elim H0.\nintros m H1; elim H1; intros m H2; elim H2.\nintros m H2; elim H2; intros m H3; elim H4.\nintros m H4; elim H5; intros m H5.\nelim H5; intros m H6.\nelim H6; intros m H6.\nelim H7; intros m H7.\nelim H7; intros m H7.\nelim H7; intros m H8.\nelim H8; intros m H9.\nelim H9; intros m H10.\nelim H9; intros m H10.\nelim H10; intros m H10.\nelim H9; intros m H10.\nelim H10; intros m H10.\nelim H10; intros m H10.\nelim H10; intros m H10.\nelim H10; intros m H10.\nelim H10; intros m H10.\nelim H10; intros m H10.\nelim H10; intros m H10.\nelimQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H.\nelim H; intros.\napply (lt_irrefl (S n)).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_O_n n).\napply (lt_Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H.\nelim H.\nintros m H1; elim H1.\nintros m H2.\nelim H2.\nintros m H3.\nelim H4.\nintros m H4.\nelim H5.\nintros m H5.\nelim H6.\nintros m H5.\nelim H6.\nintros m H6.\nelim H7.\nintros m0 H6.\nelim H7.\nintros m1 H7.\nelim H8.\nintros m2 H8.\nelim H8.\nintros m3 H8.\nelim H8.\nintros m3 H8.\nelim H9.\nintros m3 H9.\nelim H9.\nintros m3 H9.\nelim H9.\nintros m3 H9.\nelim H9.\nintros m3 H10.\nelim H10.\nintros m3 H10.\nelim H10.\nintros m3 H10.\nelim H10.\nintros m3 H10.\nelim H10.\nintros m3 H10.\nelim H11.\nintros m4 H10.\nelim H10.\nintros mQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\n",
                "context_tokens": 413,
                "proof_start_offset": 2085,
                "proof_end_offset": 2498,
                "proof": "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\nelim (le_n_O_eq n H0).\napply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros.\napply H; assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold and_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold and_set_set_set_set_set_i.\nunfold and_recZ in |- *; unfold not in |- *; simpl in |- *.\nintros.\nelim H1; intros; assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold and_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold and_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros P H; unfold and_set_set_set_set_i in |- *; intros P H; elim H; clear H;\n intros m H0; elim H0; clear H0; intros m H1; elim H1; clear H1;\n intros m H1; elim H1; clear H1; intros m H2; elim H2; clear H2;\n intros m H2; elim H2; clear H2; intros m H3; elim H3; clear H3;\n intros m H4; elim H4; clear H4; intros m H4; elim H5; clear H4;\n intros m H5; elim H5; clear H5; intros m H5;\n elim H5; clear H5; intros m H5; elim H6; clear H5;\n intros m H6; elim H6; clear H6; intros m H6; elim H6; clear H6;\n intros m H7; elim H7; clear H7; intros m H7; elim H8; clear H8;\n intros m H8; elim H8; clear H9; intros m H9; elim H9;Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros P H.\napply (H 0); elim H; intros; assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold not in |- *; intros P H0; elim H0; intros.\nelim (H0 n H1); intros.\napply H2; assumption.\nelim H1; intros.\nelim (H0 n H2); intros.\nelim (H2 n H2); intros.\nelim (H3 n H4); intros.\nelim H4; intros.\nelim (H4 n H5); intros.\nelim H5; intros.\nelim (H5 n H6); intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim (H5 n H6); intros.\nelim H5; intros.\nelim H5; intros.\nelim (H5 n H6); intros.\nelim H6; intros.\nelim H7; intros.\nelim (H7 n H7); intros.\nelim (H7 n H7); intros.\nelim (H7 n H7); intros.\nelim H7; intros.\nelim (H7 n H7); intros.\nelim (H7 n H7); intros.\nelim (H7 n H7); intros.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold and_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold and_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_set_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "                                                                        *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\n",
                "context_tokens": 562,
                "proof_start_offset": 2513,
                "proof_end_offset": 3508,
                "proof": "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nsplit.\nelim (lt_succ n p H1); intros.\nelim (H0 n a); intros; trivial with arith.\nrewrite b.\napply (H (neg (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nelim (lt_succ n p H1); intros.\nelim (H0 n); intros; trivial with arith.\nrewrite b.\napply (H (pos (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H0; elim H; intros m H1; elim H1; intros m H2; elim H2; intros m H3; elim H3;\n intros m H4; elim H4; intros m H5; elim H5; intros m H6; elim H7;\n intros m H5; elim H7; intros m H6; elim H7; intros m H7; elim H7; \n intros m H7; elim H7; intros m H8; elim H7; \n intros m H9; elim H7; intros m H10; elim H7; \n intros m H10; elim H7; intros m H10; elim H8; \n intros m H10; elim H8; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim H10; intros m H10; elim H10; \n intros m H10; elim HQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p; elim p; intros.\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_predZ m).\n apply (H (pos 0)); intros.\nrewrite (tech_le_abs_succZ m).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_predZ m).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_predZ m).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_predZ m).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_predZ m).\napply (H (pos (S m))); intros.\nrewrite (tech_le_abs_succZ m).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_predZ m).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_predZ m).\napply (H (pos (S m))); intros.\nrewrite (tech_le_abs_succZ m).\napply (H (Qed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H1 H2; cut (forall n : Z, (forall m : Z, (m <= n)%Z -> P m) -> P n).\n intro H3; generalize H3; clear H3.\nelim H3; intros.\nelim H3; clear H3; intros.\napply H3; rewrite <- H1; assumption.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nsimple induction p.\nintros m H0; rewrite H0.\napply le_n_O_eq; assumption.\nintros m H1; rewrite H0.\napply le_n_O_eq; assumption.\nintros m H1; rewrite H0.\napply le_n_O_eq; assumption.\nintros m H1; rewrite H0.\napply le_n_O_eq; assumption.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H0 H1; generalize (H1 H2); clear H1 H2.\nelim (le_n_O_eq n H1).\napply (H2 (pos 0)); intros.\nrewrite (tech_le_abs_predZ m).\napply (H2 (pos 0)); intros.\nelim (le_n_O_eq n H0).\napply (H2 (pos 0)); intros.\nelim (le_n_O_eq n H0).\napply (H2 (pos 0)); intros.\nelim (le_n_O_eq n H0).\napply (H2 (pos 0)); intros.\nelim (le_n_O_eq n H0).\napply (H2 (pos 0)); intros.\nelim (le_n_O_eq n H0).\napply (H2 (pos 0)); intros.\nelim (le_n_O_eq n H1).\napply (H2 (pos 0)); intros.\nelim (le_n_O_eq n H0).\napply (H2 (pos (S n))); intros.\nelim (le_nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nunfold and_recZ in |- *; intros; apply and_set_set_i.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros; apply (H One); intros.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H0 H1; cut (p < p); [ intros | apply H1 ].\nelim H1; clear H1; intros m H2; elim H2; clear H2; intros m H3;\n elim H3; clear H3; intros m H4; elim H4; clear H4; intros m H4;\n elim H4; clear H4; intros m H5; elim H4; clear H4; intros m H5;\n elim H5; clear H5; intros m H6; elim H6; clear H6;\n intros m H6; elim H6; clear H5; intros m H6;\n elim H6; clear H5; intros m H7; elim H7; clear H7; intros m H7;\n elim H7; clear H7; intros m H7; elim H7; clear H7; intros m H8;\n elim H8; clear H8; intros m H8; elim H8; clear H8; intros m H8;\n elim H8; clear H8; intros m H9; elim H9; clear H9; intros m H9;\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H0; elim H; intros.\nelim H0; intros.\nunfold not in |- *; simpl in |- *; intros; apply H.\nunfold not in |- *; simpl in |- *; intros; apply H.\nunfold not in |- *; simpl in |- *; intros; apply H.\nunfold not in |- *; simpl in |- *; intros; apply H.\nunfold not in |- *; simpl in |- *; intros; apply H.\nunfold not in |- *; simpl in |- *; intros; apply H.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros P p H0; elim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H8; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": " -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\n",
                "context_tokens": 707,
                "proof_start_offset": 3526,
                "proof_end_offset": 3740,
                "proof": "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros; elim p.\nexact (Zrec2 P H).\nintros; apply Zrec3; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P p H; elim H; intros.\napply H; apply H0; apply lt_O_n_n.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P p; elim (le_n_O_eq n p); intros.\nelim (le_n_O_eq n p); intros.\nelim (le_n_O_eq n p); intros.\nelim (le_n_O_eq p n H0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0); intros.\nelim (le_n_O_eq p n0);Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nsimple induction P; intros; apply (H (pos n)).\napply (H (pos n)).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos n)).\n(* P (pos n) *)\nelim (le_n_O_eq n H0).\napply (H (pos n)).\n(* P (pos n) *)\nelim (le_n_O_eq n H0).\napply (H (pos (S n)).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos n)).\n(* P (pos n) *)\nelim (le_n_O_eq n H0).\napply (H (pos n)).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos n)).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos n)).\n(* P (pos n) *)\nelim (le_n_O_eq nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros P p.\nelim (le_or_lt p p); intros.\nelim (le_or_lt p p); intros.\napply (H (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (pos p)).\nrewrite (H0 (posQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P p; elim (le_n_O_eq n H); intros.\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (neg n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (H0 (pos n)).\nrewrite (Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P p.\nelim (le_n_O_eq n H0).\napply (H (pos (S p))) (P (pos (S p)))).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos (S p))).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos (S p))).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos (S p))).\n(* P (neg n) *)\nelim (le_n_O_eq n H0).\napply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold lt_Z in |- *; unfold lt_Z in |- *;\n unfold Contradict H0; unfold lt_Z in |- *;\n unfold Contradict H0; unfold lt_Z in |- *;\n unfold gt_absZ in |- *; unfold Qpositive in |- *; unfold gt in |- *;\n unfold Qpositive in |- *; unfold gtQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P p; elim (le_n_O p); auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P p H0; elim H; auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P p; elim p; intros.\nunfold le_absZ in |- *; unfold lt_absZ in |- *; unfold lt_abs_Z in |- *;\n unfold Contradict H; intros.\nelim (le_n_O_eq n p H0); intros.\nelim (H0 n m); auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros P p; elim (le_n_O_eq n p); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\nTheorem Zrec4 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n forall p : nat, and_recZ p P.\n\nintros; elim p. \nexact (Zrec2 P H). \nintros; apply Zrec3; trivial with arith.\nQed.\n\n(************)\n",
                "context_tokens": 711,
                "proof_start_offset": 3757,
                "proof_end_offset": 4149,
                "proof": "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p.\nexact (Zrec1 P H).\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim H; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim HQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p; simpl in |- *; auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P p; elim p. \nintros; elim H; intros.\napply (H1 (pos p)).\nunfold lt_absZ in |- *; unfold lt_Z in |- *; unfold gt_Z in |- *;\n unfold Z in |- *; unfold gt_Z in |- *;\n unfold lt_le_lt_eq_dec in |- *;\n repeat split; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun m : Z => forall m : Z, (m <= n)%Z -> P m).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun m : Z => forall m : Z, (m < p)%Z -> P m).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun m : Z => forall m : Z, (m <= n)%Z -> P m).\nintros; elim H; intros; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun n : Z => forall m : Z, (forall m : Z, (m <= n)%Z -> P m) -> P p.\nintros; elim p. \nexact (fun m : Z => forall m : Z, (m <= n)%Z -> P m).\nintros; elim H0. \nintros; apply H1; assumption.\nintros m; elim H1; intros; apply H2; assumption.\nintros; apply H1; assumption.\nintros; apply H1; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim H; auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P p; elim p. \nintros; apply P_Z_le_compat.\napply P_Z_le_compat; assumption.\nintros; apply P_Z_le_compat; assumption.\nintros; apply P_Z_le_compat; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim H; intros.\napply H; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold ringQuotType, addpos; intros; rewrite (addpos_eq1 y); reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  unfold addZ.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec y x); intro.\n  case (Z.eq_dec y x); intro.\n  case (Z.eq_dec y x); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec y x); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); intro.\n  case (Z.eq_dec x y); introQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfold sBD, addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addpos.\nunfold addposQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros; destruct y; reflexivity || fail.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold fvar, addpos.\n  intros.\n  case (eq_nat_dec y x); intro H; case (eq_nat_dec y x2); intro H;\n    [ left; apply neg_eq1 | right ]; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof. auto. Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfold Qcabs, addneg.\nintros.\nrewrite (addneg x1).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg y2).\nrewrite (addneg yQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros; unfold addZ, addneg;\n  case (Z.compare_spec x y); reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nunfold addZ, addpos.\ninduction y.\nsimpl; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nsimple destruct x.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nsimple induction x; destruct y; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; exact (pred_addZ_l (pos n0) (neg (pos n0))).\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\n(* abs n *)\nsimple destruct nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* true *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\nsimple destruct n.\n (* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 730,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofannel_eq4.\n\n(***************)\n(* This theorem works for the same structure *)\n(* theorem with the same type *)\n(* lemma, and one *)\n(* theorem, and one *)\n(* and one *)\n(* and one *)\n(* and one *)\n(* and one *)\n(* and one *)\n(* and one *)\n(*  (pred_predZ one) *)\n(*  (pred_predZ one) *)\n(*  (pred_succZ one) *)\n(*  (pred_succZ one) *)\n(*  (pred_predZ one) *)\n(*  (pred_succZ one) *)\n(*  (pred_succZ one) *)\n(*  (pred_succZ one) *)\n(*  (pred_injgauche one) *)\n(*  (pred_succZ one) *)\n(*  (pred_envsubst one) *)\n(*  (pred_inference one) *)\n(*  (pred_succZ one) *)\n(*  (pred_succZ one) *)\n(*  (pred_OZ one) *)\n(*  (pred_envsubst one) *)\n(*  (pred_succZ one) *)\n(*  (pred_predZ one) *)\n(* Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof paire_eq4.\n\n(***************)\n(**************)\n\nLemma pred_addZ_pos : forall x y : Z, addZ (pos x) y = succZ (addZ x y).\nProof(*****************************************)\nintros; elim x.\n(* contexte droit *)\nreflexivity.\n(* || *)\nreflexivity.\n(* || *)\nreflexivity.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof asFunc_eq_6.\n\n(**************)\n\n(**************)\n\nLemma tech_add_pos_predZ : forall x y : Z, addZ (neg x) y = succZ (addZ x y).\nProofenumerate_eq_0.\n\nLemma tech_add_pos_succZ : forall x y : Z, addZ (neg x) y = succZ (addZ x y).\nProof virtual_eq_0.\nLemma tech_add_pos_predZ : forall x y : Z, addZ (neg x) y = succZ (addZ x y).\nProof Supporting_eq_0.\nLemma tech_add_neg_predZ : forall x y : Z, addZ (neg x) y = succZ (addZ x y).\nProofenumerate_eq_0.\nLemma tech_add_pos_predZ : forall x y : Z, addZ (neg x) y = succZ (addZ x y).\nProof(*****************************************)_eq_0.\nLemma tech_add_neg_succZ : forall x y : Z, addZ (neg x) y = succZ (addZ x y).\nProof                                                                  _eq_0.\nLemma tech_opp_neg_predZ :Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof(*****************************************)\nsimple induction x.\nreflexivity.\nsimpl in |- *; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof                                                                  _eq4.\n\nLemma tech_add_neg_predZ :\n forall (x y : Z) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof MSUBST_eq4.\n\n(**************)\n(*eval de la relation *)\n(**************)\n\nLemma succ_predZ : forall x : Z, squareZ x = succZ (addZ x).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof(*****************************************)\nintros; elim x.\n(* rvarlift *)\nreflexivity.\n(* negative *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof nodoubles_eq4.\n\n(**************)\nLemma tech_opp_pos_predZ : forall x y : Z, oppZ (pos x) (neg y) = succZ (addZ x y).\nProof Qcabs_eq4.\n\nLemma tech_opp_pos_predZ : forall x y : Z, oppZ (pos x) (neg y) = succZ (addZ x y).\nProof HCs_eq4.\n\nLemma tech_opp_pos_predZ : forall x y : Z, oppZ (neg x) (neg y) = succZ (addZ x y).\nProof sZP_eq4.\n\nLemma tech_opp_pos_succZ : forall x y : Z, oppZ (neg x) (neg y) = succZ (addZ x y).\nProof LKSPEC_eq4.\n\nLemma tech_opp_pos_predZ : forall x y : Z, oppZ (neg x) (neg y) = succZ (addZ x y).\nProof ptc_eq4.\n\nLemma tech_opp_pos_succZ : forall x y : Z, oppZ (neg x) (neg y) = succZ (addZ x y).\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof addZ_eq4.\n\nLemma tech_add_pos_predZ :\n forall (x y : Z) (y : Z), addZ (pos (S x)) y = succZ (addZ x y).\nProof nodoubles_eq4.\n\nLemma tech_add_pos_predZ :\n forall (x y : Z) (z : Z), addZ (pos (S x)) y = succZ (addZ x y).\nProof MSUBST_eq4.\n\nLemma tech_add_neg_predZ : forall (x : nat) (z : Z), addZ (pos (S x)) z = succZ (addZ x z).\nProof UnionPlus_eq4.\n\nLemma tech_add_neg_predZ : forall (x : nat) (z : Z), addZ (pos (S x)) z = succZ (addZ x z).\nProof ZDivides_eq4.\n\nLemma tech_add_neg_predZ :\n forall (x : nat) (z : Z), Apart (pos (S x)) z = succZ (addZ x z).\nProof NG_eq4.\n\nLemma tech_add_pos_predZ : forall (x : nat) (zQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof(****************************)\nintros; elim x.\n(* Rewrite pred_succZ; trivial. *)\nintros; rewrite succ_addZ_r; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof UnionPlus_eq_5.\n\n(*******************************************************)\n(*simple induction on Z *)\nreflexivity.\n(* contexte gauche *)\nreflexivity.\n(* contexte droit *)\nreflexivity.\n(* contexte gauche *)\nreflexivity.\n(* contexte droit *)\nreflexivity.\n(* contexte droit *)\nreflexivity.\n(* contexte droit *)\nreflexivity.\n(* contexte droit *)\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof(*****************************************)\nintros; elim x.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nsimple induction m.\n(* n *)\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProofIrrel_eq_3.\n\n(**************)\nLemma pred_addZ_r : forall x y : Z, addZ (neg x) y = succZ (addZ x y).\nProofIrrel_eq_3.\n\n(**************)\nLemma pred_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofIrrel_eq_3.\n\n(**************)\nLemma pred_addZ_r : forall x y : Z, addZ x (addZ x y) = succZ (addZ x y).\nProofIrrel_eq_4.\n\n(**************)\nLemma pred_addZ_r : forall x y : Z, addZ x (addZ y y) = succZ (addZ x y).\nProofIrrel_eq_4.\n\n(**************)\nLemma pred_addZ_l : forall x y : Z, predZ x y = succZ (addZ x y).\nProof.\nIrrel_eq_4.\n\n(**************)\nLemma pred_addZ_r : forall x y : Z, addZ x y = succZ (addZ x y).\nProof.\nprogress induction x.\n(* neg x *)\nreflexivity.\n(*Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof addZ_eq4.\n\n(**************)\n(*   On of the above *)\n(*  |  x  |  |  *)\nreflexivity.\n(* . . .  *)\nreflexivity.\n(* . . .  *)\nreflexivity.\n(* . .  *)\nreflexivity.\n(* . .  *)\nreflexivity.\n(* . .  *)\nreflexivity.\n(* . .  *)\nreflexivity.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof addZ_eq3.\n\n(**************)\n(* Base, ring *)\nintros; elim (succ_addZ_r x y); intros; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple inductionQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof addZ_eq3.\n\n(**************)\n(* neg n *)\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nintros.\napply pred_pos_pred; assumption.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(*Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof paire_eq3.\n\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.\n(* var 0 *)\nsimple induction n.Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof NG_eq_4.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x y = succZ (addZ x y).\nProofIrrel_eq_4.\n\n(**************)\n(*  End *)\n(************)\n\nLemma pred_addZ_r : forall x y : Z, addZ x y = succZ (addZ x y).\nProof.\nintros; elim x.\n(* Base *)\nunfold pred_addZ, succZ in |- *.\nintros; rewrite pred_addZ_r; reflexivity.\n(* S *)\nunfold pred_addZ, succZ in |- *.\nintros; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof addZ_eq3.\n\n(**************)\n(* Simplification properties of equality *)\n(**************)\n\nLemma eq_addZ_l : forall x y : Z, ~ eqlong x y = succZ (addZ x y).\nProof.\nintros; elim x.\n(* Simplification *)\nunfold eq_addZ in |- *.\nrewrite (tech_add_neg_succZ x y H).\nrewrite H.\nrewrite (tech_add_neg_succZ x y H).\nrewrite H.\nrewrite (tech_add_neg_predZ y H).\nrewrite H.\nrewrite H.\nrewrite (tech_add_neg_succZ y H).\nrewrite H.\nrewrite (tech_add_neg_succZ y H).\nrewrite H.\nrewrite (tech_add_neg_predZ y H).\nrewrite H.\nrewrite (tech_add_neg_predZ y H).\nrewrite H.\nrewrite (tech_add_neg_predZ y H).\nrewrite H.\nrewrite (tech_add_neg_predZ y H).\nrewrite H.\nrewrite (tech_add_neg_predZ y H).\nrewrite H.\nrewrite (tech_add_neg_succZ yQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof sZP_eq4.\n\n(**************)\n(* The next n is n-thasn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tn'tnasn'tn'tnasnasn'tn'tnasnasn'tnasnasnasnasn'tnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnasnQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof HCs_eq4.\n\n(**************)\nLemma pred_addZ_r : forall x y : Z, addZ x y = predZ (addZ x y).\nProof(****************************)\nintros; elim x.\n(* IZ *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* lam n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* abs n *)\nsimple inductionQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 741,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\n(* neg S *)\nsimple induction n.\n(* abs S *)\nsimple induction n.\n(* pos S *)\nreflexivity.\n(* pos S n *)\nsimple induction n.\n(* abs S *)\nsimple induction n.\n(* abs S *)\nsimple induction n.\n(* abs S *)\nsimple induction n.\n(* app *)\nsimple induction n.\n(* app *)\nsimple induction n.\n(* app *)\nsimple induction m.\nsimple induction m.\n(* app *)\nsimple induction m.\nsimple induction m.\n(* app *)\nsimple induction m.\n(* app *)\nsimple induction m.\nsimple induction m.\n(* app *)\nsimple induction m.\nsimple induction m.\n(* app *)\nsimple induction m.\n(* app *)\nsimple induction m.\nsimple induction m.\n(* app *)\nsimple induction m.\n(* app *)\nsimple induction m.\n(* app *)\nsimple induction m.\nsimple induction m.\n(* app *)\nsimple induction m.\n(* app *)\nsimple induction m.\n(* app *)\nsimple induction m.\nsimple induction m.\n(* app *)\nsimple induction m.\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* Rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_succZ.\n(* neg (S y) *)\nsimple induction n.\n(* - n = 0 *)\nintros.\nrewrite (tech_add_neg_predZ n0).\nrewrite H; apply succ_pred_succZ.\n(* - n = S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\nsimple induction x.\n(* neg 0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimpleQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* var 0 *)\nsimple induction n.\n(* abs 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* GG *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos O) *)\nsimple induction n.\n(* (pos O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (pos O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 1 *)\nsimple induction m.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ") y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nsimple induction x.\nreflexivity.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H;Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple inductionQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nsimple induction n.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivityQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros;Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple inductionQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\n(* pos O *)\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 4952,
                "proof_end_offset": 5141,
                "proof": "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros.\ncut (predZ OZ = neg 0); intros.\nelim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nrewrite (add_comm x OZ); rewrite (add_comm x Vide); reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\nreflexivity.\n(* neg 0 *)\nsimple induction m.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\nintros; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_succZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_succZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_succZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nintro; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivityQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\n(* equality *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nassumption.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\ntauto.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\nreflexivity.\n(* False *)\nsimple induction x.\ntautoQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\nreflexivity.\nsimple induction x.\nreflexivity.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 5171,
                "proof_end_offset": 5905,
                "proof": "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nsimpl in |- *; symmetry in |- *; exact (add_OZ y).\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_IZ_succZ y).\nintros; rewrite (tech_add_pos_succZ n0 y).\nrewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros.\nelim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros; rewrite (tech_add_neg_predZ n0 y).\nrewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros.\nelim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\n(* equality *)\nreflexivity.\nintros.\nrewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\napply sym_mMB_injective_l with (Z := Z) (Z := Z) (Z := Z);\n (apply Z_of_addZ_r with (Z := Z) (Z := Z);\n (apply Z_of_addZ_r with (Z := Z) (Z := Z) (Z := Z);\n (apply Z_of_addZ_r with (Z := Z) (Z := Z);\n (apply Z_of_addZ_r with (Z := Z) (Z := Z);\n (apply Z_of_addZ_l with (Z := Z) (Z := Z);\n (apply Z_of_addZ_l with (Z := Z) (Z := Z) (Z := Z);\n (apply Z_of_addZ_l with (Z := Z) (Z := Z);\n (apply Z_of_addZ_r with (Z := Z) (Z := Z) (Z := Z);\n (apply Z_of_addZ_r with (Z := Z) (Z := Z);\n (apply Z_of_addZ_l with (Z := Z) (Z := Z) (ZQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\n(* neg 0 *)\nreflexivity.\n(* neg 0 *)\nsimple induction x.\n(* pos 0 *)\nreflexivity.\n(* neg 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\nsimple induction x.\n(* neg 0 *)\nsimple induction x.\nsimple induction x.\nsimpleQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nreflexivity.\n(*... *)\nassumption.\n(*... *)\nreflexivity.\n(*... *)\nassumption.\n(*... *)\nreflexivity.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nreflexivity.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*... *)\nassumption.\n(*...Qed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nunfold IZ, neg, oppZ in |- *; simpl in |- *; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\n(* neg n *)\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nunfold addZ, oppZ, oppZ, oppZ, oppZ in |- *; simpl in |- *;\n auto with *.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nsimple induction x.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\nsimple induction m.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction n.\n(* 2 *)\nsimple induction m.\n(* 2 *)\nsimple induction m.\nsimple induction m.\n(* 2 *)\nsimple induction m.\n(* 2 *)\nsimple induction m.\nsimple induction m.\n(*Qed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\napply add_mixO.\n(*... *)\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "intros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 710,
                "proof_start_offset": 5935,
                "proof_end_offset": 6461,
                "proof": "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nProof.\nsimple induction n2.\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nassert (H := lt_minus_neg_neg_neg_neg_neg n1).\nrewrite H; exact H.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nunfold neg in |- *; elim n1.\n(* neg (S x0) *)\nsimple induction n1.\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimple induction n2.\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* neg n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\n(* abs n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n3.Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut ( posnP n1 = n2); intros. elim H0.\nrewrite (succ_addZ_r (pos n1) (pos n1)); reflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nsimple induction n1.\n(* neg n1 *)\nsimple induction n2.\n(* pos n1 *)\nsimple induction n1.\n(* pos n2 *)\nsimple induction n2.\n(* neg n2 *)\nsimple induction n2.\nsimple induction n3.\n(* pos n1 *)\nsimple induction n3.\n(* pos n2 *)\nsimple induction n1.\n(* pos n2 *)\nsimple induction n1.\nsimple induction n3.\n(* pos n2 *)\nsimple induction n1.\nsimple induction n3.\n(* pos n2 *)\nsimple induction n1.\nsimple induction n2.\nsimple induction n3.\n(* pos n1 *)\nsimple induction n3.\nsimple induction n1.\nsimple induction n3.\nsimple induction n3.\n(* lt n2 *)\nsimple induction n1.\nsimple induction n3.\nsimple induction n3.\n(* cond n2 *)\nsimple induction n3.\nsimple induction n3.\n(* n1 *)\nsimple induction n2.\nsimple induction n3.\nsimple induction n3.\n(* n2 *)\nsimple induction n3.\nsimple induction n3.Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nProof.\nsimple induction n1.\n(* neg 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\nsimple induction n2.Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nsimple induction n1; intros.\nreflexivity.\nrewrite (pred_addZ_r x (pos n1)); reflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (predZ (pos n1) = pos (n1 - S n2)); intros.\nelim H.\nrewrite (succ_addZ_r n1 (pos n2)); rewrite (add_comm (pos n2)); reflexivity.\nrewrite H; apply pred_addZ_r.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nProof.\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* - 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 1 *)\nsimple induction n2.\nsimple induction n2.\n(* 0 *)\nsimple induction n2.Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimpl in |- *; apply pred_addZ_r.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n1.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction n2.\n(* 0 *)\nsimple induction nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (neg (neg n1) = pos (n1 - n2)); intros.\nelim H.\nrewrite (succ_addZ_r n1 (pos n2)); rewrite (add_comm (pos n2)); reflexivity.\nrewrite H; rewrite (succ_addZ_r n1 (neg n2)); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "reflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 6491,
                "proof_end_offset": 7092,
                "proof": "Theorem addZ_associativity : associativity Z addZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nunfold addZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (succ_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (pred_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold hereditary in |- *; intros; elim H.\napply tech_add_pos_negZ; trivial.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nProof.\nunfold hereditary in |- *; intros; elim (tech_plus_pos_posZ (pos n1)).\nrewrite H; auto with arith.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nProof.\nsimple induction n.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\n(* 0 *)\nintros; elim (addZ_commutativity (neg 0) (neg n1)).\nrewrite H; auto with arith.\n(* 0 *)\nintros; elim (addZ_commutativity (neg 0) (neg n1)).\nrewrite H; auto with arith.\n(* 0 *)\nintros; elim (addZ_commutativity (neg 0) (neg n1)).\nrewrite H; auto with arith.\n(* 0 *)\nintros; elim (addZ_commutativity (neg 0) (neg n1)).\nrewrite H; auto with arith.\n(* 0 *)\nintros; elim (addZ_commutativity (neg n1) (neg n2)).\nrewrite H; auto with arith.\n(* 0 *)\nintros; elim (addZ_commutativity (neg n1) (neg n1)).\nrewrite H; auto with arith.\n(* 0 *)\nintros; elim (addZ_commutativity (neg n1) (neg n2)).\nrewrite H; auto with arith.\n(* 0 *)\nintros; elim (addZ_commutativity (neg n1) (neg n1Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Admitted.\n\nTheorem tech_add_posZ :\n forall n : nat, n <> 0 -> {n : nat | n = n}.\nProof.\nintro n; elim n.\nintro n; elim n.\nintro n; elim n.\nintro n; elim n.\nintro n; elim n.\nintro n0; elim n0.\nintro n1; elim n0.\nintro n2; elim n0.\nintro n3; elim n1.\nintro n3; elim n3.\nintro n3; elim n4.\nintro n4; elim n5.\nintro n4; elim n5.\nintro n5; elim n6.\nintro n5; elim n6.\nintro n5; elim n6.\nintro n6; elim n6.\nintro n7; elim n7.\nintro n7; elim n7.\nintro n8; elim n9.\nintro n8; elim n8.\nintro n8; elim n9.\nintro n8; elim n9.\nintro n9; elim n8.\nintro n9; elim n8.\nintro n9;Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nProof.\napply tech_add_pos_posZ; trivial.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nProof.\nunfold hereditary in |- *; intros; elim H.\nrewrite (tech_add_pos_negZ (pos (S n0)) (pos (S n0)) (pos n0)).\nrewrite tech_add_neg_negZ.\nelim (mult_comm (pos (S n0)) (pos n0)).\nrewrite H; auto with arith.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nProof.\nunfold Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Admitted.\n\nTheorem tech_add_posZ :\n forall n m p : nat, n <= m -> 0 < p -> m < p -> n * p <= m * p.\nintros n m p H1 H2.\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZ n m p).\napply (tech_add_posZQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold         in |- *; intros; elim H.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nProof.\n\nDefinition neg (x : Z) := ~ FV (Z_of_nat x).\n\nTheorem pos_eq_pos_eq_posZ : forall x : Z, neg x = neg x.\nProof.\nunfold neg, neg, neg, neg, neg; intros.\ncase (Z_eq_dec x 0).\nintro; rewrite (eq_sym x).\nrewrite (eq_sym x).\nrewrite (eq_sym x).\nrewrite neg_eq_neg_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.\nrewrite neg_eq_neg.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ".\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\n",
                "context_tokens": 745,
                "proof_start_offset": 7164,
                "proof_end_offset": 7330,
                "proof": "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nProof.\nunfold neutral in |- *; intros.\nsplit.\nexact I.\nintros.\nsplit.\nexact (add_OZ x).\nunfold addZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z in |- *; unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; \n unfold Z inQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z contraNneq, Ztrichotomy in |- *; unfold Z Hrec, Z at 1 in |- *;\n unfold Zax, Zax, Zax in |- *; unfold Zax, Zax, Zax in |- *;\n unfold Zax, Zax, Zax in |- *; unfold Zax, Zax in |- *;\n unfold Zax, Zax, Zax in |- *; unfold Zax, Zax in |- *;\n unfold Zax, Zax, Zax in |- *; unfold Zax, Zax in |- *;\n unfold Zax, Zax, Zax in |- *; unfold Zax in |- *;\n unfold Zax, Zax, Zax in |- *; unfold Zax, Zax in |- *;\n unfold Zax, Zax, Zax in |- *; unfold Zax, Zax in |- *;\n unfold Zax, Zax in |- *; unfold Zax, Zax in |- *; \n unfold Zax, Zax, Zax in |- *; \n unfold Zax, Zax in |- *; unfold Zax, Zax in |- *; \n unfold Zax, Zax, Zax in |- *; \n unfold Zax, Zax, Zax in |- *; unfold Zax, ZQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold Zodd in |- *;\n unfold Zodd in |- *; unfold Zodd in |- *; unfold ZQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Zshiftr, Zshiftr, Zshiftr, Zshiftr, Zshiftr in |- *;\n auto with zarith.\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z in |- *; unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; apply Z0;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; apply Z0;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; apply False_ind; \n repeat (apply Z.opp_involutive); apply Z.opp_involutive);\n assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_addZ_l 0Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Zodd in |- *; intros; elim x.\n(* abs 0 *)\nunfold renfZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold opp in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold IZZ in |- *; reflexivity.\n(* abs 0 *)\nunfold opp in |- *; reflexivity.\n(* abs 0 *)\nunfold opp in |- *; reflexivity.\n(* abs 0 *)\nunfold opp in |- *; reflexivity.\n(* abs 0 *)\nunfold opp in |- *; reflexivity.\n(* abs 0 *)\nunfold opp in |- *;Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z in |- *; simpl in |- *; auto with arith.\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z in |- *; intros; elim x.\n(* pos (S x) *)\nunfold IZZ in |- *; rewrite (H0 (Z_div2 x)).\nrewrite H; auto with arith.\n(* pos (S x) *)\nunfold IZZ in |- *; rewrite (H0 (Z_div2 x)).\nrewrite H; auto with arith.\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_neg.\napply Z_of_Z_negZ.\napply Z_of_Z_negZ.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_of_Z_neg.\napply Z_Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold oppZ in |- *; simpl in |- *; auto with *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7528,
                "proof_end_offset": 7725,
                "proof": "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nintros; reflexivity.\nsimple destruct n; intros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\napply succ_inj.\napply abs_inj.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\napply oppZ.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\nrewrite H.\nrewrite opp_involutive.\nrewrite H.\nunfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\nrewrite (opp_addZ_l x); reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros.\nunfold oppZ in |- *.\nrewrite <- oppZ_opp.\nrewrite oppZ_opp.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite oppQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n simpl in |- *; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\nsplit.\nexact I.\nintros.\nunfold oppZ in |- *.\nrewrite opp_IPR; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\n",
                "context_tokens": 733,
                "proof_start_offset": 7743,
                "proof_end_offset": 7940,
                "proof": "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nsimple destruct n; intros; reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nreflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nunfold oppZ in |- *; intros.\nrewrite (opp_involutive x).\napply opp_predZ.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nreflexivity.\n(* negative n *)\nintros; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nreflexivity.\n(* pos n *)\nsimple destruct n; reflexivity.\n(* pos n *)\nsimple destruct n; reflexivity.\n(* pos n *)\nsimple destruct n; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nreflexivity.\n(* negative n *)\nsimple destruct n; reflexivity.\n(* negative n *)\nsimple destruct n; reflexivity.\n(* negative n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* negative n *)\nsimple destruct n; reflexivity.\n(* negative n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* negative n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* positive n *)\nsimple destruct n; reflexivity.\n(* natural n *)\nsimple destructQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nreflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nunfold oppZ in |- *; intros.\nrewrite opp_succZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_succZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_succZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_OZ.\nrewrite opp_succZ.\nrewrite opp_succZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_succZ.\nrewrite opp_phiNword.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_addZ_l.\nrewrite opp_predZ.\nrewrite opp_succZ.\nrewrite opp_succZ.\nrewrite opp_predZ.\nrewrite opp_succZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_predZ.\nrewrite opp_succZ.\nrewrite opp_succZ.\nrewrite opp_predZ.\nrewrite opp_predZQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct x.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\n simple destruct z.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nintros; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 7966,
                "proof_end_offset": 8159,
                "proof": "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nreflexivity.\n(* lam (S n) *)\nsimple destruct n; intros; reflexivity.\n(* abs n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity.\n(* neg n *)\nsimpleQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\n simple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; introsQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nunfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nsimple destruct n; simpl in |- *; reflexivity. \nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* abs n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nsimple destructQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 8185,
                "proof_end_offset": 8340,
                "proof": "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nProof.\nintros; elim (addZ_commutativity (pos n) (neg n)); exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nunfold oppZ in |- *; intros n; reflexivity. \nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* O *)\nreflexivity.\n(* S x *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; rewrite (tech_add_pos_negZ n0).\nelim succ_addZ_r; reflexivity.\nintros; rewrite (tech_add_pos_negZ n0).\nelim succ_addZ_r; reflexivity.\nintros; rewrite (tech_add_neg_posZ n0).\nelim succ_addZ_r; reflexivity.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl in |- *; reflexivity.\nsimple induction m.\nsimpl inQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nintros; reflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nassumption.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S n *)\nsimple destruct n.\nreflexivity.\n(* S nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite (tech_add_neg_posZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\nsimple induction n.\n(* 0 *)\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8366,
                "proof_end_offset": 8577,
                "proof": "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* m *)\nreflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim pred_addZ_r; reflexivity.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (pos m));\n exact (tech_add_pos_posZ n).\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (neg m));\n exact (tech_add_neg_negZ m).\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (neg m));\n elim (addZ_commutativity (pos n) (pos m));\n elim (addZ_commutativity (neg n) (pos m));\n elim (addZ_commutativity (neg n) (pos m));\n elim (addZ_commutativity (neg n) (pos m));\n elim (addZ_commutativity (neg n) (pos m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (pos m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (pos m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (neg m));\n elim (addZ_commutativity (neg n) (neg m));\n elimQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\nsimple induction m; simpl in |- *; auto with arith.\nintros m; rewrite (tech_add_neg_negZ n0).\nrewrite (pos_eq_Z m); auto with arith.\nintros m; rewrite (tech_add_neg_posZ n0).\nrewrite (pos_eq_Z m); auto with arith.\nintros m; rewrite (tech_add_neg_posZ m).\nrewrite (pos_eq_Z m); auto with arith.\nintros m; rewrite (tech_add_pos_posZ m).\nrewrite (pos_eq_Z m); auto with arith.\nintros m; rewrite (tech_add_neg_posZ m).\nrewrite (pos_eq_Z m); auto with arith.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\nsimple induction m.\nsimpl in |- *.\nintros; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (neg m));\n exact (tech_add_pos_negZ n).\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (pos m));\n exact (tech_add_pos_posZ n).\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (neg m));\n clear n; intros m; rewrite (tech_add_neg_posZ m); reflexivity.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (neg m));\n exact (tech_add_neg_negZ m).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8603,
                "proof_end_offset": 8818,
                "proof": "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintro; reflexivity.\nintro; reflexivity.\nintro; reflexivity.\nintro; reflexivity.\nintro; reflexivity.\nintro; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_ZnegZ n0 (neg m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_posZ n0).\nelim succ_addZ_r; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_posZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_negZ n0 (neg m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nreflexivity.\n(* S n0 *)\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* S n0 *)\nsimple destruct n; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; intros; reflexivity. \n(* S n0 *)\nsimple destruct n0; introsQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; reflexivity.\n(* S n0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 *)\nsimple induction n0.\nreflexivity.\n(* n0 *)\nsimple induction n0.\nreflexivity.\n(* m = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(* S n0 = 0 *)\nsimple induction n0.\nreflexivity.\n(*Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_posZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nrewrite <- (tech_add_neg_posZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (neg m));\n rewrite (tech_add_neg_posZ n0 (neg m)); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8843,
                "proof_end_offset": 9198,
                "proof": "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nProof.\nrepeat split; trivial.\ncase x.\nreflexivity.\nintros; exact (tech_add_pos_negZ n).\nintros; exact (tech_add_neg_posZ n).\ncase x.\nreflexivity.\nintros; exact (tech_add_neg_posZ n).\nintros; exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *.\nintros; elim n.\n(* S n0 *)\nintros; rewrite (tech_add_pos_posZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; intros.\napply tech_add_pos_posZ; assumption.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; intros.\napply tech_add_pos_negZ.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold IZ in |- *; intros.\napply (inj_eq_cases n0); intro H; rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; intros.\napply tech_add_pos_negZ.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; intros.\nsplit.\nexact (add_opp CRmorph).\nexact (add_opp CRmorph).\nexact (add_opp CRmorph).\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nProof.\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite <- opp_involutive, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n rewrite opp_involutive, oppQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; intros.\nelim plus_comm; assumption.\n(* S n0 *)\nintros; rewrite (tech_add_pos_negZ n0 (pos n0)); rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nProof.\nunfold oppZ in |- *; intros.\napply (add_predZ_posZ n0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\n",
                "context_tokens": 741,
                "proof_start_offset": 9217,
                "proof_end_offset": 9379,
                "proof": "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nexact addZ_associativity.\nsplit.\nexact addZ_neutral.\nexact addZ_opposite.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\napply Z_group_of_Z; auto.\n(* for the same type *)\nsplit; trivial.\n(* ~ *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)\nintros; exact (H2 (Z_of_nat n)).\n(* O *)\nintros; exact (H1 (Z_of_nat n)).\n(* O *)Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z, oppZ in |- *; unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold oppZ, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold Z, oppZ in |- *;\n unfold oppZ in |- *; unfold Z, oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold Z, oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *;Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |-Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |- *;\n unfold Z_group in |- *; unfold Z_group in |- *; unfold Z_group in |-Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z in |- *; unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *;\n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; \n unfold Z in |- *; unfold Z in |- *; apply le_left.\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\napply Z_group_of_group_of_group_of_group_of_group_of_group_of_group_of_group_of_group_of_group_of_group_of_group_of_group_of_group_nat.\n(* *)\n\nLemma Z_group_plus :\n forall x y : Z,\n Equal x y -> Equal (Z_group_group_group (ring_mult x y) (Z_group_group_group (ring_mult x y))).\nsimple induction x.\n(* x=0 *)\nintros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H4; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim HQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z, oppZ, oppZ, oppZ, oppZ in |- *;\n unfold Z, oppZ, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z, oppZ in |- *;\n unfold Z, oppZ in |- *; unfold Z in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nintros; elim Z_group; simpl in |- *; intros; exact (Z.eq_dec n0);\n apply Z.eq_dec.\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z, Z, Z in |- *; simpl in |- *; intros; case (Z_eq_dec n 0);\n intro H; rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_negZ n0 (pos n0)) in H; rewrite H; reflexivity.\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z, Z, Z, Z in |- *; intros.\napply (Z_group_complete Z); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\n",
                "context_tokens": 725,
                "proof_start_offset": 9404,
                "proof_end_offset": 9518,
                "proof": "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nProof.\nsimple destruct x; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros.\nrewrite <- opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_inj_opp.\nrewrite opp_Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim (abs_eq_or_oppZ x).\nintro H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x) in H.\nrewrite (abs_eq_or_oppZ x)Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nsimple destruct x.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x; simpl in |- *; auto with *.\nintros; rewrite neg_eq_or_oppZ; trivial.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; rewrite (tech_add_neg_posZ x (absZ x)); reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim (Z_group_complete _ _).\nintros; reflexivity.\n(* neg n *)\nintros; rewrite (tech_add_neg_posZ n).\nelim abs_eq_or_oppZ; intros; reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim (archimed_eq_or_oppZ x 0); trivial.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nintros; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\nTheorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\n\nsimple destruct x; auto with arith.\nQed.\n\n(*********************)\n",
                "context_tokens": 722,
                "proof_start_offset": 9544,
                "proof_end_offset": 9675,
                "proof": "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n.\nintros; elim (tech_opp_posZ n).\nintros; elim (tech_opp_posZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_posZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elim (tech_opp_negZ n).\nintros; elimQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n; auto with arith.\nintros; rewrite opp_involutive; auto with arith.\nintros; rewrite opp_involutive; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n; auto with arith.\nintros; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; auto.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n.\nintro; left; auto with arith.\nintro; right; apply opp_involutive_nonneg_negZ.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n; auto with arith.\nintro; elim (plus_integral_eq (pos n) 0 (neg n)); intro H1.\nrewrite H1; apply opp_involutive; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n; auto with arith.\nintros; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim (tech_opp_posZ n); intro H; elim H; clear H; intros.\nrewrite (tech_opp_pos_negZ n) in H0; elim H0; clear H0; intros.\nrewrite (tech_opp_neg_negZ n) in H0; elim H0; clear H0; intros.\nrewrite (tech_opp_neg_negZ n) in H0; elim H0; clear H0; intros.\nrewrite (tech_opp_neg_negZ n) in H0; elim H0; clear H0; intros.\nrewrite (tech_opp_neg_Z n) in H0; elim H0; clear H0; intros.\nrewrite (tech_opp_neg_Z n) in H0; elim H0; clear H0; intros.\nrewrite (tech_opp_neg_Z n) in H0; elim H0; clear H0; intros.\nrewrite (tech_opp_neg_Z n) in H0; elim H0; clear H0; intros.\nrewrite (techQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\n",
                "context_tokens": 316,
                "proof_start_offset": 1992,
                "proof_end_offset": 2126,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold not in |- *; intro; apply H.\napply H0.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold Add in |- *; intros.\napply H0.\napply H1.\napply H2.\napply H3.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold same, O, O in |- *.\nintros x y z H' H'0; elim H'0; auto with sets.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nauto 6.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nauto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold Add in |- *; simpl in |- *; intros x y z H0; elim H0; intros H1 H2; elim H3; intros H3 H4;\n elim H4; intros H5 H6; elim H7; intros H7 H8; elim H8;\n intros H9 H10; elim H10; intros H10 H11.\nelim H10; intros H10 H11; elim H10; intros H10 H11.\nelim H10; intros H11; elim H11; intros H10 H11.\nelim H11; intros H11 H12; elim H12; intros H12.\nelim H12; intros H13 H13; elim H14; intros H14 H15; elim H14;\n intros H15 H15; elim H15; intros H15 H16; elim H16;\n intros H15 H16; elim H16; intros H17 H17; elim H18;\n intros H19 H19; elim H19;\n intros H19 H20; elim H20; intros H20 H20; elim H20;\n intros H20 H20; elim H20; intros H20 H20; elim HQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold Empty at 2 in |- *.\nintros x y z H; elim H; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold complement in |- *.\nintros x y z H'; case (O x); auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold not in |- *; intros x y H'; elim H'; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold Or in |- *.\nunfold Add at 1 in |- *.\nunfold Add at 1 in |- *.\nintros x y z H1 H2 H3; elim H1; intros H3 H4; elim H4; intros H5 H6;\n elim H6; intros H6 H7; elim H7; intros H7; elim H7;\n intros H7 H8; elim H8; intros H9 H10; elim H9;\n intros H10 H10; elim H10; intros H11; elim H11;\n intros H11 H12; elim H11; intros H13; elim H13;\n intros H14 H15; elim H16; intros H15; elim H15;\n intros H16 H17; elim H19;\n intros H18 H18; elim H19; intros H18 H18; elim H19;\n intros H18 H19; elim H19; intros H18 H19; elim H19;\n intros H18 H20; elim H20; intros H19 H18; elim H19;\n intros H19 H20; elim H20; intros H19 H19; elim H19;\n intros H19 H20Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\nLemma neutral_add : neutral S G Add O -> O = Add O O.\n\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\n(********************)\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n(************)\n",
                "context_tokens": 403,
                "proof_start_offset": 2245,
                "proof_end_offset": 2466,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H.\nintros x y H1; elim H2.\nintros x y H2; elim H3; intros H4 H5.\napply H5; assumption.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H1 O H1); trivial.\nelim H1; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nelim H0; intros.\nrewrite H0; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nunfold is_opposite, is_injective in |- *; intros.\nelim H0; intros; elim H1; intros; elim H2; clear H2;\n intros; elim H3; intros; clear H3.\nelim H3; intros; elim H4; intros; clear H5.\nelim H4; intros; clear H4.\nelim H5; intros; clear H5.\nelim H6; intros; elim H7; intros; clear H7.\nelim H7; intros; clear H7.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; intros; clear H8.\nelim H8; introsQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H y H'; elim H'.\nintros; elim H'.\nintros; elim (H' O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nunfold is_injective in |- *; intros.\nelim H0; intros.\napply H2; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H.\nintros x y H'; elim H'.\nintros x0 y0 H'0 H'1; elim H'0.\nintros y0 y1 H'2; elim H'2.\nintros y1 y2 H'3 H'4 H'5 H'6 H'7 H'8.\nrewrite <- (plus_n_O y1).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).\nrewrite <- (plus_n_O y2).Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H y H' H'0; elim H'0; intros; elim H'0; intros; elim H'0;\n intros; elim (H'0 y H'1); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; intros; elim H; intros.\nelim H0; intros; elim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\n",
                "context_tokens": 227,
                "proof_start_offset": 1772,
                "proof_end_offset": 2677,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; red in |- *; auto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nunfold is_ring in |- *.\napply O_O_O_O.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nunfold A in |- *.\nintros x H'; elim H'; auto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\napply (is_ring_mult_reg x).\napply (is_ring_mult_reg x).\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H; elim H; auto with sets.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\napply (is_group_inverse S x).\nauto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction 1; intros.\nleft; assumption.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nunfold is_ring in |- *.\ntauto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\napply (is_power_is_zero _ x).\nauto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\nelim H.\nintros x H'; elim H'.\nintros x H'0 H'1.\nrewrite H'0.\nrewrite H'1.\nrewrite <- (mult_comm (S x)).\nrewrite <- (mult_comm (S x)).\nrewrite <- (mult_comm (S x)).\nrewrite H'; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "              *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 576,
                "proof_start_offset": 2697,
                "proof_end_offset": 3436,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H.\nintros; elim H; intros; elim H0.\nintros; elim H1; intros; elim H2.\nintros; elim H2.\nintros; elim H3.\nintros; elim H4.\nintros; elim H4.\nintros; elim H5.\nintros; elim H5.\nintros; elim H6.\nintros; elim H6.\nintros; elim H8.\nintros; elim H8.\nintros; elim H9.\nintros; elim H9.\nintros; elim H9.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.\nintros; elim H10.Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H4; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elimQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; \n elim H9; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H5; intros; elim H6; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; introsQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim H; intros; elim H; intros; \n elim H; intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\n",
                "context_tokens": 721,
                "proof_start_offset": 3456,
                "proof_end_offset": 4193,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H3; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; clear H1.\nelim H1; intros; elim H2; intros; elim H3; intros; clear H3.\nelim H3; intros; elim H3; intros; clear H3.\nelim H4; intros; elim H5; intros; clear H4.\nelim H5; intros; elim H5; intros; clear H5.\nelim H6; intros; elim H6; intros; clear H5.\nelim H7; intros; elim H7; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H9.\nelim H8; intros; elim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H9; intros; elim H9; intros; clear H9.\nelim H8; intros; elim H8; intros; clear H9.\nelim H9; intros; elim H9; intros; clear H9.\nelim H9; intros; clear HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H5; intros; elim H5; intros; clear H5;\n elim H6; intros; elim H6; intros; clear H6;\n elim H6; intros; elim H7; intros; elim H8; intros; clear H8;\n elim H8; intros; elim H8; intros; clear H8; \n elim H9; intros; elim H8; intros; clear H8; \n elim H9; intros; elim H9; intros; clear H8; \n elim H9; intros; clear H9; \n elim H9; intros; elim H9; intros; clear H10; \n elim H9; intros; clear H9; \n elim H9; intros; clear H9; elim H9; intros; elim H9; \n clear H9; intros; elim H9; intros; clear H9; \n elim H10; intros; clear H9; \n elim H9; intros; elim H9; clear H9; \n elim H9; intros; elim H9; intros; clearQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; clear H6; \n elim H7; intros; elim H7; intros; clear H7; \n elim H8; intros; clear H8; \n elim H8; intros; elim H8; intros; clear H8; \n elim H8; intros; clear H8; \n elim H8; intros; clear H8; \n elim H8; intros; clear H8; elim H8; intros; \n elim H8; intros; clear H8; \n elim H8; intros; clear H8; elim H9; intros; \n clear H8; elim H9; intros; clear H9; \n elim H8; intros; clear H8; elim H8; intros; \n clear H8; elim H8; intros; clear H8; \n elim H8; intros; clear H9; elim H8; intros; \n clear H8; elim H8; intros;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; \n elim H10; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; clear H2.\nelim H3; intros; elim H3; intros; elim H4; intros; clear H4.\nelim H4; intros; elim H5; intros; clear H5.\nelim H5; intros; elim H5; intros; elim H6; intros; clear H6.\nelim H6; intros; elim H6; intros; clear H6.\nelim H6; intros; elim H7; intros; elim H7; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; clear H3;\n elim H3; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H5; intros; elim H6; intros; clear H5;\n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim (H6 x (Opp y x H0 H1)); intros; \n rewrite H5; clear H6 H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; clear H6Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H7; intros;\n elim H8; intros; elim H8; intros; elim H8; intros;\n elim H9; intros; elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H11; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; \n elim H10; intros; elim H11; intros; elim H11; intros; \n elim H11; intros; \n elim H11; intros; elim H11; intros; \n elim H12; intros; \n elim H12; intros; elim H12; intros; \n elim H12; intros; \n elim H12; intros; elim H13; intros; \n elim H13; intros; elim H14; intros; \n elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\n",
                "context_tokens": 720,
                "proof_start_offset": 4215,
                "proof_end_offset": 4702,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; clear H4;\n elim H4; intros; elim H4; intros; elim H5; intros; clear H5;\n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; elim H6; intros; clear H6; \n elim H6; intros; clear H6; elim H6; intros; clear H6; \n elim H6; intros; clear H6; elim H6; intros; \n clear H6 H7; elim H6; intros; elim H6; intros; clear H6 H7; \n elim H7; intros; elim H6; clear H6; \n elim H7; intros; elim H7; intros; clear H6 H7; \n elim H8; intros; elim HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; clear H5;\n elim H5; intros; elim H6; intros.\nelim H5; intros; elim H6; intros.\nelim H6; intros.\nelim H7; intros; elim H8; intros; elim H8; intros.\nelim H9; intros; elim H8; intros; elim H9; intros.\nclear H9; elim H10; intros; elim H9; intros.\nelim H10; intros; elim H10; intros.\nelim H10; intros; elim H10; intros.\nclear H10; elim H10; intros.\nclear H10; elim H10; intros.\nelim H10; intros.\nelim H10; intros; elim H10; intros.\nclear H10; elim H10; intros.\nelim H10; intros; elim H10; intros.\nclear H10; elim H10; intros.\nelim H10; intros.\nclear H10; elim H10; intros.\nelim H10; intros.\nclear H10; elim H10;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; \n intros; elim H9; intros; elim H10; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; clear H5.\nelim H3; intros; elim H4; intros; clear H5.\nelim H4; intros; elim H5; intros; clear H5.\nelim H5; intros; elim H5; intros; clear H5.\nelim H6; intros; elim H6; intros; clear H6.\nelim H7; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H10; intros; clear H9.\nelim H9; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H10; clear H9.\nelim H9; intros; elim H10; intros; clear H9.\nelim H10; intros; elim H9; clear H9.\nelim H9; intros; elimQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros.\nelim H6; intros; elim H6; intros.\nelim H7; intros; elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H10; intros.\nclear H8 H9 H10 H10 H11 H12 H14 H15 H16 H17 H17 H18.\napply (opp_unicity S AAdd (Opp x y) (Ar x y)).\napply (comp_opp_l (A:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=A) (B:=Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; clear H4.\nelim H4; intros; elim H5; intros; elim H6; intros; clear H5.\nelim H5; intros; elim H7; intros; elim H8; intros; clear H8.\nelim H7; intros; elim H8; intros; elim H9; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H9; intros; clear H9.\nelim H8; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H10; intros; clear H9.\nelim H9; intros; clear H9.\nelim H9; intros; elim H10; intros; elim H10; intros; clear H9.\nelim H9; intros; elim H10; intros; clear H9.\nelim H10; intros; elim H10; intros; elim H11; intros; clear H10.\nelim HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; clear H4.\nelim H4; intros; elim H5; intros; elim H6; intros; clear H5.\nelim H5; intros; elim H6; intros; elim H6; intros; clear H5.\nelim H7; intros; elim H8; intros; elim H9; intros; elim H9; \n clear H9.\nelim H8; intros; elim H9; intros; elim H10; intros; elim H10; \n clear H10.\nelim H8; intros; elim H10; intros; elim H10; intros; elim H10; \n clear H10.\nelim H9; intros; elim H10; intros; elim H10; intros; elim H10; \n clear H10.\nelim H10; intros; elim H10; intros; elim H10; intros; elim H10; \n clear H10.\nelim H10; intros; elim H10; intros; elim H10; clear H10.\nelim H10; intros; elim H10; intros; elim H10; introsQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; clear H6 H7; \n clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H15 H16 H16 H17 H18 H19.\napply (mult_reg_l (x + y) (x + y));\n [ idtac | ring ].\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; clear H4.\nelim H4; intros; elim H5; intros; clear H5.\nelim H6; intros; elim H6; intros; clear H6.\nelim H7; intros; elim H6; intros; clear H6.\nelim H7; intros; elim H7; intros; elim H8; intros.\nelim H8; intros; elim H8; intros; elim H9; intros; clear H7.\nelim H9; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H10; intros; clear H10.\nelim H9; intros; elim H10; intros; clear H10.\nelim H10; intros; elim H10; intros; clear H10.\nelim H10; intros; clear H10.\nelim H10; intros; clear H10.\nelim H10; intros; elim H10; clear H10.\nelim H10; intros; elim H10Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\n",
                "context_tokens": 742,
                "proof_start_offset": 5096,
                "proof_end_offset": 5330,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_unit, mult in |- *; intros.\nsplit; [ idtac | idtac ].\nsplit; [ idtac | idtac ].\nelim H1; intros; clear H1; intros.\nelim H1; intros; clear H1; intros.\nelim H2; intros; clear H2; intros.\nelim H3; intros; clear H3; intros.\nelim H4; intros; clear H4; intros.\nelim H4; intros; clear H4; intros.\nelim H5; intros; clear H5; intros.\nelim H5; intros; clear H5; intros.\nelim H6; intros; clear H6; intros.\nelim H7; intros.\nelim H8; intros; clear H8; intros.\nelim H8; intros; clear H8; intros.\nelim H8; intros; clear H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros; clear H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros; clear H9; intros.\nelim H9; intros.\nelim H9Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_unit, is_unit', is_unit' in |- *; simpl in |- *;\n auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_zero in |- *; auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_unit', is_unit' in |- *; auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_unit', mult in |- *.\nintros.\nelim H; intros.\nsplit; auto.\nsplit; auto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_zero, O in |- *.\nauto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros.\napply div_O_O_O.\napply div_O_O.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_unit, mult, div in |- *; intros.\nsplit.\nexact (fun a b : S => a = b \\/ a = S b).\nexact (fun a b : S => a = b \\/ a = S b).\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_char in |- *; auto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_unit', is_unit' in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": ".\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 5349,
                "proof_end_offset": 6556,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\napply div_S_n; assumption.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nsplit.\nexact H8.\nsplit. exact H9.\nsplit. exact H8.\nsplit. exact H8.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H9; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\ncase H; intros; elim H0; intros; elim H1; intros; clear H1;\n case (case (S b); auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\napply div_O_S.\napply le_trans with (S a + b).\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm a b).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm a b).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm d d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm a b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d bQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H; intros.\nelim H0; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; clear H5 H6 H7; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros.\nsplit.\nexact H7.\nsplit.\nexact H2.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0 H1.\nelim (mult_reg_l b d); intros; elim H1; intros; elim H2; intros; clear H2.\nelim (mult_reg_l b d); intros; elim H3; intros; elim H4; intros; clear H4.\nelim H3; intros; clear H3.\nelim H4; intros; elim H4; intros; clear H4.\nelim H4; intros; elim H5; intros; clear H5.\nelim H5; intros; elim H5; intros; elim H6; intros; clear H5.\nelim H6; intros; elim H6; intros; clear H6.\nelim H6; intros; elim H6; intros; clear H6.\nelim H7; intros; elim H6; intros; clear H7.\nelim H7; intros; elim H8; intros; clear H8.\nelim H8; intros; elim H9; intros; clear H9.\nelim H9; intros; elim H9; intros; clear H9.\nelim H10; intros; elim H10; clear H9.\nelimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nrewrite (mult_comm a b).\nrewrite (mult_comm b d).\nrewrite (mult_comm d a).\nrewrite (mult_comm d a).\nrewrite <- (mult_comm (a * b)).\nrewrite (mult_comm d b).\nrewrite <- (mult_comm a b).\nrewrite (mult_comm (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite <- (mult_comm (b * d)).\nrewrite <- (mult_assoc (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite <- (mult_assoc (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite <- (mult_comm (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite <- (mult_assoc (b * d)).\nrewrite (mult_comm (b * d)).\nrewrite (mult_comm (b * dQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nunfold div in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H8.\nsplit.\nexact H9.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\n\n\nunfold divide in |- *; intros.\nsplit.\n(* A d *)\nelim H0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 727,
                "proof_start_offset": 6576,
                "proof_end_offset": 7261,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1; auto.\nintro.\nelim H0; intros.\nelim H1; intros; elim H2; intros; elim H3; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H7; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; \n intros; elim H5; intros.\napply (H4 0%nat H5 H6 H7).\nexact (H5 a b H5 H7).\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1; intros.\n(* A d *)\nelim H0; intros; elim H1; intros.\nelim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H5; intros; elim H5; intros; elim H5; intros.\nelim H6; intros.\nelim H7; intros; elim H7; intros.\nsplit.\nexact (H3 a b H5).\n(* A b=0 *)\nelim H1; intros.\nelim H2; intros.\nelim H3; intros; elim H5; intros.\nelim H5; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1; intros.\nexists 0.\nrewrite H.\nelim H0; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H2; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H1; intros; assumption.\nelim H2; intros; assumption.\nelim H1; intros; assumption.\nelim H2; intros; assumption.\nelim H1; intros; assumption.\nelim H2; intros; assumption.\nelim H2; intros; assumption.\nelim H2; intros; assumption.\nelim H1; intros; assumption.\nelim H2; intros; assumption.\nelim H2; intros; assumption.\nelim H2; intros; assumption.\nelim H2; intros; assumption.\nelim H1; intros; assumption.\nelim H2Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1; intros.\napply le_n_O.\napply H.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1; intros.\nunfold is_zero in |- *.\nelim H; intros; elim H1; intros.\nelim H1; intros; elim H2; intros; elim H3; intros; clear H4.\nsplit.\nexact (H3 (S n)).\nexact (H3 (S n)).\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nsimple induction 1.\n (* 0 *)\nintros.\nelim H0; intros.\napply H1.\nrewrite H0.\nrewrite H2.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H4.\nrewrite H3.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H0.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; clear H2; \n clear H1 H3.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nrewrite H4; assumption.\nelim (H4 d H2); intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nrewrite H5; assumption.\nelim (H4 d H3); intros.\nelim H5; intros.\nrewrite H5; assumption.\nelim (H5 d H5); intros.\nelim H5; intros.\nrewrite H5; assumption.\nelim (H5 d H6); intros.\nelim H5; intros.\nrewrite H5; assumption.\nelim (H5 d H6); intros.\nrewrite H6; assumption.\nelim (H5 d H6); intros.\nelim H5; intros.\nrewrite H5; assumption.\nelim (H6 d H6); intros.\nelim H5; introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\napply H4; assumption.\napply H4; assumption.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact (H1 b d H4 H0 H1).\nexact (H2 b d H4 H1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 732,
                "proof_start_offset": 7280,
                "proof_end_offset": 8081,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nsimple induction 1; intros.\napply div_mult.\napply div_mult.\napply div_mult.\napply div_mult.\napply div_mult.\napply div_mult.\napply div_mult.\napply div_mult.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold gcd in |- *; intros.\nelim H; intros.\nsplit.\napply H0.\napply H1.\napply H2.\napply H1.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold is_left in |- *; intros.\napply div_mult.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\napply H.\nsplit.\napply H.\napply le_refl.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros.\nelim H0; intros.\nelim (plus_comm d a H1).\nelim H1; intros.\nelim H2; intros.\nsplit.\nexact (H3 a b H H1).\nexact (H3 a b H1).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold lt in |- *; intros.\nelim H; intros.\nelim H0; intros.\nsplit.\nexact (H0 (S a)).\nexact (sym_sym (S b)).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nsimple induction 1; intros.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nsimple induction 1; intros.\n (* 0 *)\nelim H0; intros.\nelim H0; intros.\nelim H0; intros.\nsplit.\nexact (H1 H0).\nexact (sym H0).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold divide in |- *; intros.\nelim H0; intros; elim H1; intros.\nsplit. exact (H2 a b H H0).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros.\nelim H; intros.\nsplit.\napply H0.\napply H.\napply H1.\napply H.\napply H.\napply H0.\napply H1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8240,
                "proof_end_offset": 8608,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit.\napply gcd_0_l with (S a).\napply gcd_0_l with (S b).\napply gcd_0_l with (S b).\napply gcd_0_l with (S b).\napply gcd_0_l with (S b).\napply gcd_0_l with (S b).\napply gcd_0_l with (S b).\napply gcd_0_l with (S b).\napply gcd_0_l.\napply gcd_0_l.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nsimple induction 1; intros.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b.\nunfold gcd in |- *.\nelim H; intros.\nsplit; auto with *.\nsplit; auto with *.\nintros.\napply gcd_intro with (S p * S q).\nrewrite H1.\nrewrite (mult_comm (S q * S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite (mult_comm (S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite <- (mult_assoc (S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite <- (mult_assoc (S q * S q)).\nrewrite <- (mult_assoc (S q)).\nrewrite <- (mult_assoc (S q)).\nrewrite <- (mult_assoc (S q)).\nrewrite <- (mult_assoc (S q)).\nrewrite <- (mult_assoc (S q)).\nrewriteQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\napply gcd_neg.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b.\ncase (non_gcd_eq a b); intros.\nsplit.\nexact (H1 (S b)).\nexact (H2 (S b)).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nelim H; intros.\napply gcd_opp.\napply gcd_opp.\napply gcd_opp.\napply gcd_opp.\napply gcd_opp.\napply gcd_opp.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nsimple induction 1; intros.\napply gcd_0_l with d; auto with arith.\napply gcd_0_l with d; auto with arith.\napply gcd_0_l with d; auto with arith.\napply gcd_0_l with d; auto with arith.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b.\ncase (div_opp a b O); intro.\nsplit.\nrewrite <- H0.\napply gcd_0_l with b; trivial.\nrewrite <- H0.\napply gcd_0_l with b; trivial.\nrewrite <- H1.\napply gcd_0_l with b; trivial.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim H; intros.\nsplit.\nunfold inv_0 in |- *.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.\napply divide_sym.Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim H; intros.\nsplit.\nexact H2.\nsplit.\nexact H1.\nsplit.\nexact H2.\nsplit.\nexact H2.\nexact H2.\nsplit.\nexact H3.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8628,
                "proof_end_offset": 8894,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold gcd in |- *; intros.\nelim H0; intros; elim H1; intros.\nelim (H3 a b H5); intros; elim H5; intros.\nsplit.\napply gcd_0_l with d; auto with arith.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros.\nsplit. exact (H2 H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H5; intros.\nelim H4; intros.\nelim H5; intros.\nsplit.\nexact (H1 H5).\nexact (H2 H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros; elim H2; intros; elim H3; intros.\nsplit. exact (H1 x).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nunfold gcd in |- *; intros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nsplit. exact (H3 x b d H1).\nelim H3; intros; split. exact (H3 x b d H H0).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H1; intros.\nsplit. exact H1.\nexact (eq_sym (S p) (S q)).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\n unfold is_gcd in |- *; intros.\nelim H0; intros; elim H1; intros; elim H3; intros.\nsplit.\nelim H1; intros; elim H3; intros.\nsplit.\nexact (H1 d H0).\nexact (H2 d H0).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros; elim H1; intros.\nelim H1; intros; elim H2; intros.\nsplit. exact H6.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nunfold gcd in |- *; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nsplit.\nelim H1; intros; elim H2; intros.\nsplit.\nelim H3; intros; elim H3; intros; elim H4; intros.\nsplit.\nelim H3; intros; elim H4; intros; elim H4; intros; split.\nelim H3; intros; elim H4; intros; elim H4; intros; split.\nelim H3; intros; elim H4; intros; split.\nelim H4; intros; split.\nelim H3; intros; elim H4; intros; split.\nelim H4; intros; elim H4; intros; split.\nelim H4; intros; elim H4; intros; elim H4; intros; split.\nelim H4; intros; split.\nelim H4; intros; elim H4; intros; split.\nelim H4; intros; split.\nelim H4; intros; elim H4; intros; split.\nelim H4; intros; elim H4; intros; split.\nelim H4Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H8; \n intros; elim H8; intros.\nsplit.\n elim (H2 a H3); intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H9; intros.\nsplit. \n elim (H2 a H3); intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros.\nsplit. \n elim (H2 a H3); intros; elim H9; intros; elim H9; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros.\nsplit. \n elim (H2 a H3); intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H10; intros.\nsplit. \n elim (H3 a H3); intros; elim H9; intros; elim H9; \n intros; elim H9Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\n",
                "context_tokens": 711,
                "proof_start_offset": 8928,
                "proof_end_offset": 9827,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H4 a H4); intros.\nelim (H4 a H5); intros.\nelim (H5 a H6); intros.\nelim (H6 a H6); intros.\nelim H7; intros.\nelim (H7 a H8); intros.\nelim (H7 a H8); intros.\nelim (H7 a H8); intros.\nelim (H7 a H8); intros.\nelim (H8 a H8); intros.\nelim (H7 a H8); intros.\nelim (H7 a H8); intros.\nelim (H8 a H8); intros.\nelim (H9 a H8); intros.\nelim (H8 a H8); intros.\nelim (H7 a H8); intros.\nelim (H8 a H9); intros.\nelim (H10 a H8); intros.\nelim (H10 a H8); intros.\nelim (H9 a H9); intros.\nelim (H10 a H9); intros.\nelimQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_scalar in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nsplit.\nexact H10.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_compl in |- *.\nintros.\nelim H0; intros; elim H1; intros.\nelim H1; intros; elim H2; intros.\nelim H3; intros.\nelim H4; intros.\nsplit.\nexact H5. clear H5.\nelim H4; intros.\nelim H4; intros.\nsplit.\nexact H6. clear H6.\nelim H4; intros.\nelim H5; intros.\nsplit.\nexact H6.\n clear H5.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nsplit.\nexact H7.\nclear H6.\nelim H8; intros.\nelim H8; intros.\nsplit.\nexact H9.\nexact H9.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nelim H; intros; elim H0; intros.\nelim H1; intros.\nelim H2; intros.\nrewrite H3.\nrewrite H4; auto with arith.\nrewrite H4; auto with arith.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nsimple induction 1; intros.\napply H0.\napply H2.\napply H1.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nelim H0; intros; elim H1; intros.\nelim H1; intros.\nelim H1; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H3.\nsimpl in |- *.\nrewrite H4; rewrite H4; auto with arith.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H0; intros; elim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H3 a x H3); intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim (H1 a H4); intros.\nelim (H3 a x H4); intros.\nelim H4; intros.\nelim H4; intros.\nelim (H4 a x H4); intros.\nelim H5; intros.\nelim (H5 a x H6); intros.\nelim (H6 a x H5); intros.\nelim H6; intros.\nelim (H6 a x H6); intros.\nelim (H7 a x H6); intros.\nelim (H7 a x H7); intros.\nelim (H8 a x H7); intros.\nelim (H6 a x H7); intros.\nelim (H7 a x H7); intros.\nelim (H7 a x H7); intros.\nelim (H7 a x H7); intros.\nelim (H7 a xQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_compl in |- *; intros.\nelim H; intros.\nelim H1; intros.\nelim (H1 a); intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H5; intros.\nelim (H5 a0); intros; elim H6; intros.\nelim H6; intros.\nelim (H7 a0 H6); intros; elim H6; intros.\nelim (H7 a0 H6); intros; elim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim (H8 a0 H8); intros; elim H10; intros.\nelim (H7 a0 H8); intros; elim H10; intros.\nelim (H7 a0 H8); intros; elim H10; intros.\nelim (H7 a0 H8); intros; elim H10; intros.\nelim (H8 a0 H10); intros; elim H10; intros.\nelim (H12 a0 H10); intros; elim H10; intros.\nelim (H9 a0 HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\ncase (strong_pt_op (S O) (S x) (S x)).\nintro.\nelim H0; intros.\nelim H1; intros; elim H2; intros.\nsplit; exact H6.\nelim H1; intros.\nelim H3; intros.\nelim H3; intros.\nsplit; exact H9.\nelim H3; intros.\nsplit; exact H9.\napply (H4 (S x)); auto with arith.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H4.\nrewrite H2.\nrewrite H4.\nrewrite H4.\nrewrite H2.\nrewrite H4.\nrewrite H2.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\n\n\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\n",
                "context_tokens": 684,
                "proof_start_offset": 9908,
                "proof_end_offset": 11305,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros; elim H0; intros.\nelim H1; intros.\nexists x; exists x0; auto.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H3; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; \n intros; elim H10; intros.\nelim H11; intros; elim H12; intros; elim H13; intros; elim H13; intros; \n elim H13; intros; elim H14; intros; elim H15; intros; \n elim H16; intros; elim H16; intros; elim H16; intros; \n elim H17; intros; elim H17; intros; elim H16; intros; \n elim H16; intros; elim H16; intros; elim H16Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros.\nelim H12; intros.\nelim H10; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H13;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros.\nelim H0; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; introsQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\napply inv_pq_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_euclid_for_euclid_euclid_for_euclid_euclid_for_euclid_euclid_for_euclid_euclid_for_euclid_euclid_for_euclid_euclid.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nexists x.\nrewrite (mult_comm (S x)); rewrite (mult_comm (S x)); rewrite (mult_comm (S x));\n rewrite (mult_comm (S x)); rewrite (mult_comm (S x)); rewrite (mult_comm (S x));\n rewrite (mult_comm (S x)); rewrite (mult_comm (S x)); rewrite (mult_comm (S x));\n rewrite (mult_comm (S x)); rewrite (mult_comm (S x)); rewrite (mult_comm (S x));\n rewrite (mult_comm (S x)); rewrite (mult_comm (S x)); rewrite (mult_comm (S x));\n rewrite (mult_comm (S x)); rewrite (mult_comm (S x)); rewrite (mult_comm (S x));\n rewrite (mult_comm (S x)); rewrite (mult_comm (S x));\n rewrite (mult_comm (S x));Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros.\nelim H3; intros.\nelim H4; intros.\nexists x; exists x; split.\napply le_trans with (S (S (S x))); auto with arith.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x); auto with arith.\nrewrite plus_comm.\napply le_trans with (S x);Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nsimple induction 1.\nintros a b c d d H0.\nexists (S a); split.\napply le_n_O.\nintros.\napply le_n_O.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_n_S.\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.\napply le_trans with (S a).\napply le_n_S.\nintros.Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros; elim H0; intros.\nelim H1; intros; elim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H12; intros.\nelim H13; intros.\nelim H10; intros.\nelim H13; intros.\nelim H13; intros.\nelim H14; intros.\nelim H13; intros.\nelim H14; intros.\nelim H14; intros.\nelim H14; intros.\nelim H14; intros.\nelim H15; intros.\nelim H14; intros.\nelim H14; intros.\nelim H15; intros.\nelim H14; intros.\nelim H15; intros.Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H0; intros; elim H1; intros.\nelim H1; intros.\nelim H2; intros; elim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\n\n\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* d2 = O *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* d2 <> 0 *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* d1 <> 0 *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n(**********)\n",
                "context_tokens": 731,
                "proof_start_offset": 11320,
                "proof_end_offset": 11524,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros.\nelim (H6 d1 x x0 H6); intros; elim H4; intros.\nexists x0.\nsplit; [ assumption | elim H4; intros; assumption ].\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nsimple induction 1.\nintros.\nrewrite H.\napply H.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; \n elim H5; intros; elim H6; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H8; intros; elim H10; intros; elim H8; intros; \n elim H9; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; \n elim H10; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; introsQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H.\nintros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros;\n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; elim H12; intros; \n elim H12; intros; elim H10; intros; elim H12; intros; \n elim H12; intros; elim H13; intros; elim H13; intros; \n elim H13; intros; elim H12; intros; elim H13; intros; \n elim H13; introsQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x H.\napply H.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\napply (opp_O_eq_compat x).\napply opp_O_eq_compat.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H2; intros.\nelim (H3 d1 H3); intros.\nelim (H3 d1 H4); intros.\nelim (H5 d1 H5); intros.\nelim (H6 d2 H7); intros.\nelim (H5 d2 H6); intros.\nelim (H6 d2 H7); intros.\nelim (H6 d2 H7); intros.\nelim (H6 d2 H8); intros.\nelim (H6 d2 H7); intros.\nelim (H6 d2 H8); intros.\nelim (H6 d2 H8); intros.\nelim (H6 d2 H7); intros.\nelim (H6 d2 H8); intros.\nelim (H6 d2 H8); intros.\nelim (H7 d2 H8); intros.\nelim (H7 d2 H8); intros.\nelim (H7 d2 H8); intros.\nelim (H7 d2 H8); intros.\nelim (H8 dQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H.\nintros; elim H0; intros; elim H1; intros; elim H2; intros; clear H2;\n elim H1; intros; elim H3; intros; clear H3;\n elim H4; intros; elim H4; intros; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; intros; clear H4; \n elim H4; intros; clear H4; elim H4; introsQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H; intros; elim H0; intros;\n elim H1; intros; elim H2; intros; clear H1; elim H3; intros;\n elim H3; intros; clear H3; elim H4; intros; clear H4; \n clear H3 H4 H5.\nelim (H3 x0); intros.\nelim H3; intros.\nelim (H3 x1 x0); intros.\nelim (H4 x1 x2); intros.\nelim (H5 x1 x2); intros.\nelim H5; intros.\nelim (H5 x1 x2); intros.\nelim (H5 x2 x3); intros.\nelim (H5 x1 x2); intros.\nelim (H6 x1 x2); intros.\nelim (H6 x1 x2); intros.\nelim (H6 x2 x3); intros.\nelim H6; intros.\nelim (H6 x1 x2); intros.\nelim (H7 x2 x3); intros.\nelim (H7 x2 x3); intros.\nelim (H7 x2 xQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros x H.\nelim H.\nintros; elim H; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros.\nelim (H2 d1 H4); intros; elim H4; intros; elim H5; intros; elim H6; intros;\n elim H6; intros.\nelim (H6 d1 x x H5); intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H9; intros.\nexists I.\nunfold opp in |- *; rewrite <- H8; rewrite H9; rewrite H10; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zdiv.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zdiv.v                                  *)\n(****************************************************************************)\nRequire Export Zbase.\nRequire Export Zadd.\nRequire Export Zmult.\nRequire Export Zle.\nRequire Export Euclid.\n\nUnset Standard Proposition Elimination Names.\n\n(********************)\nDefinition is_diveuclZ (a b q r : Z) :=\n  b <> OZ /\\ leZ OZ r /\\ ltZ r (absZ b) /\\ a = addZ (multZ b q) r.\n\n(***************************)\nInductive diveuclZ (a b : Z) : Set :=\n    divexZ : forall q r : Z, is_diveuclZ a b q r -> diveuclZ a b.\n\n(************************)\n",
                "context_tokens": 234,
                "proof_start_offset": 1632,
                "proof_end_offset": 3661,
                "proof": "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nintros a b; case b; intros.\nelim H; reflexivity.\ncase a; intros.\napply (divexZ OZ (pos n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (pos n)).\nreflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)).\nintros.\napply (divexZ (pos n0) (pos n) (posOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r).\nexact (gt_S_le r n g).\nexact (tech_div1 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (pos n) (negOZ q) OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (pos n) (negOZ q))).\napply (tech_div2 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (pos n) (neg q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div3 n0 n q r e g).\ncase a; intros.\napply (divexZ OZ (neg n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (neg n)); reflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\napply (divexZ (pos n0) (neg n) (negOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r); exact (gt_S_le r n g).\nexact (tech_div4 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (neg n) (posOZ q) OZ).\nunfold is_diveuclZ in |- *.\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (neg n) (posOZ q))).\napply (tech_div5 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (neg n) (pos q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div6 n0 n q r e g).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a.\nintros.\napply divexZ.\napply divexZ.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a.\nauto with arith.\nauto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a.\nintros q r H0.\ninversion H0.\nintros.\ninversion H0.\nintros.\ninversion H1.\nintros.\ninversion H2.\nintros.\ninversion H3.\nintros.\ninversion H3.\nintros.\ninversion H4.\nintros.\ninversion H5.\nintros.\ninversion H5.\nintros.\ninversion H5.\nintros.\ninversion H5.\nintros.\ninversion H5.\nintros.\ninversion H5.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H5.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\ninversion H6.\nintros.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple induction 1; intros; auto with zarith.\nsimple inductionQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction 1; intros.\nunfold base in |- *; apply divexZ.\napply (divide_refl (multZ a b)).\nauto with arith.\napply (divide_refl (multZ a b)).\nauto with arith.\napply (divide_trans (b * a)).\nauto with arith.\nauto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction 1; intros.\nleft; trivial.\nright; trivial.\nright; trivial.\nintros.\nright; trivial.\nintros.\napply (pos_pos a b); trivial.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nunfold modZ in |- *.\nintros.\nelim H0; intros.\nelim H1; intros.\nelim H3; intros.\nelim H3; intros.\napply H1; assumption.\nelim H3; intros.\nelim H4; intros.\napply H1; assumption.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a; simpl in |- *; intros.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napplyQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nintros.\napply b.\napply absZ.\napply absZ.\napply absZ.\napply absZ.\napply absZ.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\n",
                "context_tokens": 286,
                "proof_start_offset": 1694,
                "proof_end_offset": 1893,
                "proof": "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nintros.\nelim H1.\nsimple induction 1.\nsimpl in |- *.\nintros.\nelim H2.\nsimple induction 1.\nsimple induction 1.\nintros.\nelim H3.\nsimple induction 1.\nsimple induction 1.\nintros.\nelim H3.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nintros.\nelim H3.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nintro n.\nsimple induction n.\nsimple induction m.\nintros.\nsimpl in |- *.\napply H1.\nintros.\nsimpl in |- *.\napply H2.\napply pos_inj.\napply pos_inj.\napply pos_inj.\napply pos_inj.\napply pos_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.\napply neg_inj.Qed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n.\nsimple induction m.\nintros.\napply False_ind.\napply pos_not_neg_eq.\nrewrite <- H0.\nrewrite <- H1.\napply H.\nassumption.\nassumption.\nintros.\napply False_ind.\napply pos_not_neg_eq.\nrewrite <- H0.\nassumption.\nassumption.\nassumption.\nassumption.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n.\nsimple induction m.\nsimple induction 1.\nsimple induction 1.\n simple induction 1.\nauto with arith.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nintros.\nelim H.\nelim H0.\nintro.\nelim (lt_irrefl 0).\nintro.\nelim (lt_irrefl 0).\napply pos_not_posZ with (m := pos n).\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nassumption.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n  simple induction n.\n  intros.  rewrite (lt_eq_eq_dec n m).  auto.  simpl in |- *.  intros.  elim H0.\n  intros.  elim H1.  intros.  elim H2.  intros.  elim H3.  intros.  elim H5.\n  intros.  elim H5.  intros.  split.  assumption.  intros.  split.\n  assumption.  intros.  split.  assumption.  intros.  elim H3.  intros.\n  elim H5.  intros.  split.  assumption.  intros.  split.  assumption.  intros.\n  elim H5.  intros.  split.  assumption.  intros.  split.  assumption.  intros.\n  elim H5.  intros.  split.  assumption.  intros.  split.  assumption.  intros.  split.\n  assumption.  intros.  split.  assumption.  intros.  split.  assumption.  intros.  assumption.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n; simpl in |- *; auto with arith.\nintros n H H0; elim H; auto with arith.\nintros n H H0; elim H0; auto with arith.\nintros n H H0; elim H0; auto with arith.\nintros n H H0; elim H0; auto with arith.\nintros n H H0; elim H0; auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nsimple induction n.\nleft.\ntrivial.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n.\nintros.\ninversion H.\ninversion H.\napply pos_not_posZ.\napply pos_not_posZ.\napply pos_not_posZ.\napply pos_not_posZ.\napply pos_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_negZ.\napply neg_not_posZ.\napply neg_not_posZ.\napply neg_not_negZ.\napply neg_not_negZ.\napply neg_not_negZ.\napply neg_not_negZ.\napply neg_not_negZ.\napply neg_not_negZ.\napply neg_not_negZ.\napply neg_not_negZ.\napply neg_not_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\nLemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\n\n\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H. rewrite H0; simpl in |- *; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 362,
                "proof_start_offset": 1912,
                "proof_end_offset": 2065,
                "proof": "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nintros; elim x.\nleft; reflexivity.\nintros; right; discriminate.\nintros; right; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_negn (pos n) (pos m)).\nintro; elim H; intros.\nleft; elim H0; intros.\nleft; elim H1; intros.\nright; elim H2; intros.\nright; elim H3; intros.\nright; elim H3; intros.\nright; elim H4; intros.\nright; elim H5; intros.\nright; elim H5; intros.\nright; elim H6; intros.\nright; elim H6; intros.\nright; elim H6; intros.\nright; elim H6; intros.\nright; elim H6; intros.\nright; elim H7; intros.\nright; elim H7; intros.\nright; elim H8; intros.\nright; elim H8; intros.\nright; elim H8; intros.\nright; elim H8; intros.\nright; elim H8; intros.\nright; elim H8; intros.\nright; elim H8; intros.\nright; elim H9; intros.\nright; elim H8; intros.\nright; elim H9; intros.Qed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (not = x); trivial.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\nelim x.\nintro.\nrewrite (eq_irreflexive_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equality_dec x 0 H).\nrewrite (eq_equalityQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos n)).\nintro.\ncut (is_posn (pos n) (pos n)).\nintro.\ncut (is_posn (pos n) (pos n)).\nintro.\ncut (is_posn (pos n) (neg n)).\nintro.\ncut (is_negn (pos n) (pos n)).\nintro.\ncut (is_negn (pos n) (pos n)).\nintro.\ncut (is_negn (pos n) (pos n)).\nintro.\ncut (is_posn (pos n) (pos n)).\nintro.\ncut (is_negn (pos n) (neg n)).\nintro.\ncut (is_negn (pos n) (pos n)).\nintro.\ncut (is_negn (pos n) (pos n)).\nintro.\ncut (is_negn (pos n) (neg n)).\nintro.\ncut (is_negn (pos n) (neg n)).\nintro.\ncut (is_negn (pos n) (neg nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_negn (pos n) (pos n)).\nintro; elim H0.\nintro; elim H0.\nintros; elim H1.\nintros; elim H2.\nintro; elim H3.\nintro; elim H3.\nintro; elim H4.\nintro; elim H5.\napply H2.\napply H0.\napply H0.\napply H.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos n) = (pos n)).\nintro H0; elim H0.\nintros n0 H1; rewrite H1; simpl in |- *; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros x.\nunfold neg in |- *.\nelim (eq_nat_dec x 0); intros.\nleft.\nright.\nright.\nright.\nright.\nright.\nright.\nright.\nright.\nright.\nright.\nright.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nleft.\nintro.\nright.\nintro.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nright.\nintro.\nleft.\nintro.\nright.\nintro.\nrightQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (is_posn (pos n) (pos n)).\nintro.\nrewrite H.\nauto.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos x)).\nintro; elim (lt_eq_dec n 0); trivial.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (eq nat x).\nintro.\nrewrite H0.\ntrivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\n",
                "context_tokens": 156,
                "proof_start_offset": 1347,
                "proof_end_offset": 1460,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition ex2 : forall (A : Set) (P : A -> Prop), {x : A | P x} :=\n  forall x : A, P x x -> P x.\n\nDefinition ex3 : forall (A : Set) (P : A -> Prop), {x : A | P x} :=\n  forall x : A, P x -> P x.\n\nDefinition ex4 : forall (A : Set) (P : A -> Prop), {x : A | P x} :=\n  forall x : A, P x -> P x.\n\nDefinition ex4 : forall (A : Set) (P : A -> Prop), {x : A | P x} :=\n  forall x : A, P x -> P x.\n\nDefinition ex1 : forall (A : Set) (P : A -> Prop), {x : A | P x} :=\n  forall x : A, P x -> P x.\n\nDefinition ex4 : forall (A : Set) (P : A -> Prop), {x : A | P x} :=\n  forall x : A, P x -> P x.\n\nDefinition ex4 : forall (A : Set) (P :Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\n(* The following definition is a unique definition of the definition of the definitions of the definition of the\n\n the definition of the predicate [R] of the relation [R]. *)\n(* It is used as a special case of the relation [R] that are not in\n(* the definition of the predicate [R] and [R]. *)\n\nDefinition is_a_equivalence (R : A -> Prop) : Prop :=\n  forall x y : A, R x y -> R y x.\n\n(* The definition is a partial definition of the relation [R] *)\n\nDefinition is_a_equivalence (R : A -> Prop) (R : A -> A) : Prop :=\n  forall x y : A, R x y -> R x y.\n\n(* The definition is an axiom of the relation [R] *)\n\nDefinition is_a_equivalence (R : A -> Prop) : Prop :=\n  forall x y : A, R x y -> R y x.\n\n(* The definition is an axiom of the relation [R] *)\n\nDefinition is_a_equivalence (R : A -> Prop) : Prop :=\n  forall x y : A, R x y -> R y xDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nRecord R := {R : A -> A -> Prop | R_0 : R P}.\n\nRecord R_of (A : Set) (R : A -> A -> Prop) :=\n  {R_0 : R_of A R;\n   R_1 : R_of A R;\n   R_2_1 : R_of A R_of A R_0}.\n\nDefinition R_of_P (A : Set) (R : A -> Prop) :=\n  forall x : A, R x x -> {R_0 : R_of A R x}.\n\nDefinition R_of_P (A : Set) (R : A -> Prop) :=\n  forall x : A, R_of_P A R x.\n\nDefinition R_of_P (A : Set) (R : A -> Prop) :=\n  forall x : A, R_of_P A R x.\n\nDefinition R_of_P (A : Set) (R : A -> Prop) :=\n  forall x : A, R_of_P A R x.\n\nDefinition R_of_P (A : Set) (R : A -> Prop) :=Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition ex2 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H.\nelim H; intros x0 H1.\nelim H1; intros x1 H2.\nelim H2; intros x2 H3.\nexists x2; split; assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H; apply (H (fun x y : A => P x y /\\ P x y)).\nexact (fun x y : A => P x y /\\ P x y).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nsimple induction 1; auto with sets.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n(* \nDefinition delta2 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napply ex_intro.\napplyDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\n(*  Definition ex2 : forall (A : Set) (P : A -> Prop), {x : A | P x} + {x : A | P x}.\nintros A P H.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\napply H7; apply H7; apply H7; apply H7.\n\napply H7; apply H7; apply H7.\napply H7; apply H7; apply H7.\napply H7; apply H7; apply H7; apply HDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nunfold ex1 in |- *; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H.\nelim H.\nelim H.\nauto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\n",
                "context_tokens": 203,
                "proof_start_offset": 1485,
                "proof_end_offset": 1628,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p.\nauto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nunfold ex2 in |- *.\nintros x H.\nelim H; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p.\nauto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p.\nauto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nunfold ex1 in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\n\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\n(*******************)\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n(************)\n",
                "context_tokens": 313,
                "proof_start_offset": 1781,
                "proof_end_offset": 2050,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2; intros; simpl in |- *.\ninversion H0.\nexists x0; trivial.\ninversion H1.\nexists x0; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists x; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists x; exists y; auto.\nexists x; exists y; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; exists x0; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2.\nintros.\nexists (S x).\napply Exc.\napply Exc.\napply Exc.\napply Exc.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nelim H0.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H8; intros.\nelim HQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1.\nintros x y H H0; inversion H0.\nintros y0 H1; inversion H1.\nintros y0 H2; inversion H2.\nexists y0; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction 1; simple induction 1; intros.\nunfold Qpositive_absZ in |- *.\nelim (nat_of_P x); intro.\nelim (Z_of_P y); intro.\nabsurd (nat_of_P x > S (pred_nat y)); intro.\napply (pos_absZ x); assumption.\nintro.\ncut (nat_of_P x > S (pred_nat x)); intro.\napply (pos_absZ x); assumption.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nintros.\nelim H2.\nintros.\ncut (0 = 0).\nintro.\napply H1.\napply H2.\napply H0.\napply pos_0.\napply pos_0.\napply neg_0.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply neg_1.\napply negQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction 1; simpl in |- *; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nintros.\nunfold zero in |- *.\nelim H.\nintros.\nelim H.\nintros.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).\nsimpl in |- *.\napply (pos_pos n).Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  simple induction x.\n  simpl in |- *.\n  intros.\n  unfold prec_absZ in |- *.\n  elim (even x).\n  simpl in |- *.\n  intros.\n  elim (even y).\n  simpl in |- *.\n  intros.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absZ with 0.\n  apply abs_absQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction 1; auto with *.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nintros.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nintros.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nintros.\nelim (lt_eq_dec x 0).\nsimple induction 1.\nsimple induction 1.\nsimpl in |- *.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple inductionQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple inductionQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple inductionQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple inductionQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simple induction y; simple induction y; simpl in |- *; auto.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nintros; elim x.\nsimple induction x.\nsimpl in |- *.\nexact I.\nintros; elim H; intros; simpl in |- *.\nexact I.\nintros; elim H; intros; simpl in |- *.\nexact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl inQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x2.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x4.\nsimple induction x4.\nsimple induction x5.\nsimple induction x5.\nsimple induction x5.\nsimple induction x5.\nsimple induction x6.\nsimple induction x6.\nsimple induction x6.\nsimple induction x6.\nsimple induction x7.\nsimple induction x6.\nsimple induction x6.\nsimple induction x6.\nsimple induction x7.\nsimple induction x7.\nsimpleQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Id, absZ, absZ, absZ in |- *; simpl in |- *.\napply Z.pos_pos.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold paired in |- *.\nintros x y z; elim y.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Incident, oppZ in |- *; auto.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold IZ, absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro; elim x. \nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold eH in |- *; unfold not in |- *; intros.\nelim H.\napply H.\napply H.\napply H.\napply H.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold PE in |- *.\nelim x.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro; elim x. \nunfold absZ in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nunfold lt_absZ in |- *; intros x y; elim x.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x. \nunfold negZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; intros H0 H1; elim H1;\n intros H2; elim H2; intros H3; elim H4;\n intros H5; elim H5; intros H6; elim H7;\n intros H7; elim H8; intros H8; elim H8;\n intros H9; elim H9; intros H9; elim H9;\n intros H9; elim H9; intros H10; elim H10;\n intros H9; elim H10; intros H10; elim H10;\n intros H10; elim H10; intros H10; elim H10;\n intros H10; elim H10; intros H10; elim H10;\n intros H10; elim H10; intros H11; elim H10;\n intros H10; elim H10; intros H11; elim H10;\n intros H11; elim H10; intros H11; elim H10;\n intros H10; elim H10; intros H11; elim H10;\n intros H11; elim H10; intros H11; elim H11;\n intros H12; elim H10; intros H12; elimQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *.\nintros; elim (le_antisym n0 n H0); reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H.\nrewrite <- (Z_div_pos x).\napply Z.opp_inj_eq.\napply Z.opp_inj_eq.\napply Z.opp_inj_eq.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; clear H. \n(* (pos n) *)\nintros; elim H; clear H. \n(* (neg n) (pos n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros; elim H; clear H. \n(* (neg n) (neg n) *)\nintros;Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\nunfold lt_absZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\nunfold not in |- *; intros.\napply lt_O_n.\napply le_n_Sn.\napply le_n_Sn.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nintro H; elim H.\nintros; elim H0.\nintros; elim H1.\nintros; elim H2.\nintros; elim H3.\nintros; elim H3.\nintros; elim H4.\nintros; elim H4.\nintros; elim H5.\nintros; elim H5.\nintros; elim H6.\nintros; elim H6.\nintros; elim H7.\nintros; elim H7.\nintros; elim H7.\nintros; elim H7.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": " Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 737,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple inductionQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nunfold lt_absZ in |- *; unfold ltZ in |- *;\n unfold modulo in |- *; intros. \nelim (le_Sn_O n H).\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintro n; elim n.\nunfold lt_absZ in |- *; unfold absZ in |- *; simpl in |- *;\n unfold Divides in |- *; intros.\nelim H0.\nintro; elim (le_Sn_O n H).\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* var *)\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold ltZ in |- *;\n unfold IZ in |- *; intros. \nelim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold not in |- *; intro.  elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold not in |- *; intro.  elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold not in |- *; intro.  elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nunfold lt_absZ in |- *; unfold not in |- *; intro.  elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (pos n) *)\nunfold lt_absZ inQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nunfold lt_absZ in |- *; unfold ltZ in |- *;\n unfold OZ in |- *; intros. \nelim (le_Sn_O n H).\nintros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold POS in |- *; intros. \nelim (le_Sn_O n H0).\nintros; elim H1.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold modulo in |- *;\n unfold POS in |- *; intros. \nelim (le_Sn_O n H0).\nintros; elim H1.\n(* (neg n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold OZ in |- *; intros. \nelim (le_Sn_O n H0).\nintros; elim H1.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold FV in |- *; intros. \nelimQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* var *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold gtZ in |- *;\n unfold brs in |- *; simpl in |- *; intros.\nelim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold gtZ in |- *; unfold ltZ in |- *;\n unfold gt_absZ in |- *; simpl in |- *; intros.\nelim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold lt_Z in |- *; unfold lt_Z in |- *;\n unfold lt_absZ in |- *; unfold gt_absZ in |- *;\n unfold gt_absZ in |- *; unfold gt_absZ in |- *; \n unfold gt_absZ in |- *; simpl in |- *; \n unfold gt_absZ in |- *; unfold gt_absZ in |- *; \n unfold gt_absZ in |- *; \n unfold gt_absZ in |- *; simpl in |- *; \n unfold gt_absZ in |- *; simpl in |- *; \n unfold gt_absZ in |- *; unfold gt_absZ in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold oppZ in |- *; simpl in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nunfold le_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold IZ in |- *; intros. \nelim (le_Sn_O n H0).\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold oppZ in |- *;\n unfold gtZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* var *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; simpl in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* neg n *)\nunfold gt_absZ in |- *; unfold oppZ in |- *; unfold ltZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3529,
                "proof_end_offset": 3703,
                "proof": "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\nsimpl in |- *; intros; exact I.\nsimpl in |- *; intros; exact I.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* pos n *)\nunfold lt_absZ in |- *; unfold oppZ in |- *; simpl in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl inQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* var n *)\nunfold lt_absZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |-Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* empty *)\nunfold le_absZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ inQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\nsimpl in |- *; auto with arith.\nintros; exact I. simpl in |- *; auto with arith.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\nsimpl in |- *; unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |-Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* zero *)\nunfold le_absZ in |- *; unfold oppZ in |- *; simpl in |- *; intro; exact I. \n(* (succ x) *)\nunfold lt_absZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* zero *)\nunfold le_absZ in |- *; unfold absZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ inQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nintros; elim y.\nsimpl in |- *; intros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl in |- *.\nintros; exact I. simpl inQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* zero *)\nunfold le_absZ in |- *; unfold oppZ in |- *; intros. \nelim H0.\nsimpl in |- *; assumption.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold oppZ in |- *; unfold absZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |-Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* zero *)\nunfold lt_absZ in |- *; unfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 3722,
                "proof_end_offset": 3902,
                "proof": "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros.\napply (leZ_antisymmetric x OZ).\nrewrite H.\nexact (le_opp_OZ_l y H1).\nexact H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* here *)\nunfold le_absZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ inQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* Idem *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) (neg n) *)\nintros; elim H1.\n(* (neg n) (neg n) *)\nintros; elim H1.\n(* (neg n) (neg n) *)\nintros; elim H2.\n(* (neg n) (neg n) *)\nintros; elim H3.\n(* (neg n) (neg n) *)\nintros; elim H3.\n(* (neg n) (neg n) *)\nintros; elim H3.\n(* (neg n) (neg n) *)\nintros; elim H3.\n(* (neg n) (neg n) *)\nintros; elim H4.\n(* (neg n) (neg n) *)\nintros; elim H4.\n(* (neg n) (neg n) *)\nintros; elim H4.\n(* (neg n) (neg n) *)\nintros; elim H4Qed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* var n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; simpl in |- *.\nintros.  elim H0.\nintros. \napply le_trans with (pos y); assumption.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* negative *)\nunfold lt_absZ in |- *; unfold absZ in |- *; simpl in |- *.\nintros. \napply (le_refl (pos x) (pos y)).\nsimpl in |- *; intros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim H.\n(* (pos n) (neg n0) *)\nsimpl in |- *; intros; elim H.\n(* (pos n) (neg n0) *)\nsimpl in |- *; intros; elim H.\n(* (pos n) (neg n0) *)\nsimpl in |- *; intros; elim H.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim H.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim H.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim H.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim H.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim HQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold oppZ in |- *;\n unfold appl in |- *; intros. \nelim H0.\nintros; apply H0.\nintros; elim H0.\nintros; elim H0.\nintros; elim H0.\nintros; elim H1.\nintros; elim H1.\nintros; elim H2.\nintros; elim H3.\nintros; elim H4.\nintros; elim H5.\nintros; elim H5.\nintros; elim H5.\nintros; elim H5.\nintros; elim H6.\nintros; elim H6.\nintros; elim H7.\nintros; elim H7.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim H8.\nintros; elim HQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\nintro; elim x.\nunfold oppZ in |- *; unfold ltZ in |- *;\n unfold PE in |- *; intros. \nelim (le_Sn_O n H0).\nintro; elim H0.\nintro; elim H1.\nintro; elim H2.\nintro; elim H3.\nintro; elim H4.\nintro; elim H5.\nintro; elim H5.\nintro; elim H5.\nintro; elim H5.\nintro; elim H5.\nintro; elim H5.\nintro; elim H5.\nintro; elim H5.\nintro; elim H6.\nintro; elim H6.\nintro; elim H6.\nintro; elim H7.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim H8.\nintro; elim HQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* 0 *)\nunfold le_absZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; intros.\nelim (le_irrefl 0); reflexivity.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\nsimple induction y.\n(* abs n *)\nunfold le_absZ in |- *; unfold absZ in |- *; unfold oppZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *; unfold absZ in |- *; \n unfold absZ in |- *; unfold absZ in |- *; \n unfold absZ in |- *; unfold absZ in |- *; \n unfold absZ in |- *; unfold absZ in |- *; \n unfold absZ in |- *; unfold absZ in |-Qed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* the left and equal *)\nunfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; intros.\nelim H0.\nsimpl in |- *; intros; elim H1; intros; exact H1; clear H1; clear H1;\n elim H1; intros; elim H2; intros; clear H2; clear H2;\n elim H2; intros; clear H2; clear H2;\n elim H3; intros; elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;\n elim H4; intros; clear H4; clear H4;Qed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n (* neg n *)\nunfold lt_absZ in |- *; unfold oppZ in |- *; simpl in |- *.\nintros.  elim H0; reflexivity.\n(* (pos n) *)\nunfold le_absZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; simpl in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; simpl in |- *; \n unfold oppZ in |- *; simpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\nLemma le_opp_OZ :\n forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\n\nProof.\nintros. apply (leZ_antisymmetric x OZ). rewrite H. exact (le_opp_OZ_l y H1).\nexact H0.\nQed.\n\n(***************)\n",
                "context_tokens": 725,
                "proof_start_offset": 3922,
                "proof_end_offset": 4176,
                "proof": "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\nrewrite (le_opp_OZ x y H H0 H1).\nrewrite (opp_opp Z IdZ addZ OZ oppZ Z_group y I); elim H.\nrewrite (le_opp_OZ x y H H0 H1); simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nsimple induction x.\n(* Omega *)\nunfold lt_absZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ inQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nsimple induction x.\n(* neg n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold addZ in |- *; intros.\nelim H0.\nintros; apply lt_eq_opp; assumption.\nintros; elim H1.\nintros; apply lt_eq_opp; assumption.\nintros; apply lt_eq_opp; assumption.\nintros; elim H1.\nintros; apply lt_eq_opp; assumption.\nintros; elim H1.\nintros; elim H2.\nintros; apply lt_eq_opp; assumption.\nintros; elim H1.\nintros; elim H2.\nintros; apply lt_eq_opp; assumption.\nintros; elim H3.\nintros; apply lt_eq_opp; assumption.\nintros; elim H3.\nintros; apply lt_eq_opp; assumption.\nintros; elim H3.\nintros; apply lt_eq_opp; assumption.\nintros; elim H4.\nintros; elim H4.\nintros; apply lt_eq_opp; assumption.\nintros; elim H4.\nintros; apply lt_eq_opp; assumption.Qed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros. apply (leZ_antisymmetric x OZ). rewrite H. exact (le_opp_predZ_l y H1).\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nsimple induction x.\n(* negative *)\nunfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *; intros.\nelim H0.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros. apply (leZ_antisymmetric x OZ). rewrite H. exact (le_opp_predZ_l y H1).\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nsimple induction x.\nintros.\napply (lt_irrefl x H0 H1).\nintros.\napply (lt_irrefl x H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl x H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H2).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (le_trans y x H1).\nintros.\napply (lt_irrefl y H1).\nintros.\napply (le_trans y x H1).\nintros.\napply (lt_irrefl yQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros. apply (leZ_transitive y x H0).\nexact (le_opp_succZ_l y H0).\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros. apply (leZ_stable xtriangle y H0).\nexact H0.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\nrewrite (leZ_stable y); exact (le_opp_ Corporation y H1).\nexact H0.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros. apply (leZ_transitive xdisplay). rewrite H0; exact (le_opp_predZ2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\n",
                "context_tokens": 121,
                "proof_start_offset": 1253,
                "proof_end_offset": 1349,
                "proof": "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple destruct n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nintros n; elim (le_gt_dec n 0); auto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nintros n; elim (le_gt_dec n 0); auto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nintros.\nelim (even_odd_odd_odd n H); intros n H1.\nelim (even_odd_odd_odd n H1); intros n H2.\nabsurd (n = 0); auto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nsimple induction n.\nauto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nsimple induction n.\nintro.\nelim (eq_lt_eq_dec n 0).\nintro.\nauto with arith.\nintro.\nelim (eq_lt_eq_eq_dec n (S n)).\nintro.\nauto with arith.\nintro.\nelim (eq_lt_eq_eq_dec n (S n)).\nintro.\nauto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nintros n; elim n.\nintros; simpl in |- *; auto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nintro; discriminate.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nintros n.\nelim (lt_eq_dec n 0).\nintros.\napply False_ind.\nelim H.\nintro.\nelim H.\nintro.\nelim H.\nintro.\nelim H0.\nintro.\napply H1.\nelim (eq_not_eq (S n) 0).\nintro.\nelim H1.\nintro.\nelim H1.\nintro.\nelim H2.\nintro.\nelim H1.\nintro.\nelim H2.\nintro.\napply H1.\nintro.\nelim H3.\nintro.\napply H2.\nintro.\napply H3.\nintro.\napply H4.\nintro.\napply H5.\nelim (eq_not_eq (S n) (S n)).\nintro.\nelim H1.\nintro.\napply H2.\nintro.\napply H4.\nintro.\napply H2.\napply H2.\nintro.\napply H3.\nintro.\napply H4.\nelim (eq_not_eq (S n) (S n)).\nintro.\nelim H1.\nintro.Qed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\nintro; discriminate.\nintro; discriminate.\nintro; discriminate.\nintro.\nsimple induction 1; intro; discriminate.\nintro; discriminate.\nintro; discriminate.\nintro; discriminate.\nintro; discriminate.\nintro; discriminate.\nintro; discriminate.\nintro; discriminate.\nintro; discriminate.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nintro.\nsimple induction n.\nintro.\nright.\nelim (le_gt_dec n (S n) 0).\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\n",
                "context_tokens": 164,
                "proof_start_offset": 1370,
                "proof_end_offset": 1528,
                "proof": "Lemma mult_commut : forall n m : nat, n * m = m * n.\nProof.\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros n m; elim n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros; elim (plus_comm n m); auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros n m; elim (le_gt_dec n m); auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros; elim (plus_n_O _ H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 224,
                "proof_start_offset": 1548,
                "proof_end_offset": 1637,
                "proof": "Lemma mult_neutr : forall n : nat, 1 * n = n.\nProof.\nunfold mult in |- *; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\n",
                "context_tokens": 261,
                "proof_start_offset": 1662,
                "proof_end_offset": 1875,
                "proof": "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nProof.\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim m; simpl in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple induction y; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nunfold mult in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nintros; rewrite H; elim plus_n_Sm; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple induction y; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros.\napply plus_reg_l with (y := y); auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nintros n0 H; elim H; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim m; simpl in |- *.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\n",
                "context_tokens": 352,
                "proof_start_offset": 1894,
                "proof_end_offset": 2016,
                "proof": "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim (plus_comm m (y * m)); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim (plus_comm n m); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nintros; rewrite H0; elim plus_comm; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim (plus_comm n m); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; intros; elim (plus_comm m (y * m)); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim (plus_comm n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 400,
                "proof_start_offset": 2036,
                "proof_end_offset": 2173,
                "proof": "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros; elim (plus_comm m (n - m)); auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros; elim (lt_n_O_eq n m); auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros; elim (plus_comm m (n - m)); auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\nLemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\n\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(************)\n",
                "context_tokens": 456,
                "proof_start_offset": 2190,
                "proof_end_offset": 2319,
                "proof": "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nintros; elim (le_lt_eq_dec n (S m) H); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim (lt_n_O n); auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim (lt_n_O_eq _ H); auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nsimple induction n; intros; elim minus_n_O; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim minus_n_O; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_n_O; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim n.\nsimple induction m; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_n_O; auto with arith.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d.\n  destruct (b - a) eqn:Hb.\n  - apply Z.le_refl.\n  - apply Z.le_refl.\n  - apply Z.le_refl.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d.\napply (well_founded_induction_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (Build_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_founded_induction_type (A:=A)).\napply (well_Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nassert (H: forall x y, x<>y -> y<>y -> x<>y).\n destruct H.\napply H.\napply H0.\napply H0.\napply H.\napply H1.\napply H.\napply H2.\napply H0.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d.\ndestruct d as [ | d].\nsimpl.\ndestruct (IHVdec a b d).\ndestruct (IHVdec a d).\nrewrite <- (IHVdec _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\nrewrite <- (IHVdec _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1).\nrewrite <- (IHVdec _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros. apply Zis_gcd_sym. apply Z.mul_le_mono_l.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\napply (Z2R_le_compat_l (a - a) (b - d)).\napply Z2R_le_compat_r.\napply Z2R_le_compat_r.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2R_le_compat.\napply Z2Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H.\n  case (Z.leb_spec a b); intros.\n  (* Z.gcd *)\n  case (Z.leb_spec a b); intros.\n  (* Z.gcd *)\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0.\n  apply Z.gcd_lt in H0Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros.\n  assert (H0: forall (x y:Z), (x + y - x) = (a + y - b) + (b - d)).\n  {\n    intros.\n    replace (a - d - b) with (b - d - d) by ring.\n    apply Z.add_le_mono_l.\n    apply Z.add_le_mono_r.\n    apply Z.mul_le_mono_r.\n  }\n  assert (H1: forall (x y:Z), (x + y - x) = (a + y - b) + (b - d)).\n  {\n    intros.\n    replace (b - d - b) with (b - d) by ring.\n    apply Z.mul_le_mono_l.\n    apply Z.mul_le_mono_r.\n  }\n  assert (H2: forall (x y:Z), (x + y - x) = (a + y - b) + (b - d)).\n  {\n    intros.\n    replace (b - d - d) with (b - d) by ring.\n    apply Z.mul_le_mono_l.\n Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\napply (is_gcd_is_gcd a b d).\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\ninduction a; simpl; intros.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\n+ apply Z.le_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 732,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  apply Zneq_bool_true.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  apply Zneq_bool_true.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_true.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_true.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n  apply Zneq_bool_false.\n  intros.\n Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  generalize (Z_eq_bool_false_iff x y H0); intro.\n  generalize (Z_eq_bool_false y x H0); intro.\n  replace y with (Z.compare x y0)%Z.\n  auto with zarith.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y Hxy; case Hxy; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z.compare_spec x y); intro.\n  apply Z.lt_irrefl.\n  apply Z.lt_irrefl.\n  apply Z.le_refl.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n  intros.\n  case_eq (Z.eq_bool (x=y)).\n Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros; case (Z_le_gt_dec x y); auto with zarith.\n  apply Zneq_bool_true; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z_le_dec x y); intro.\n  subst; apply Z.lt_lt_trans with x; auto with zarith.\n  apply Z.lt_gt_trans with x; auto with zarith.\n  apply Z.le_lt_trans with x; auto with zarith.\n  apply Z.le_lt_trans with x; auto with zarith.\n  apply Z.le_lt_trans with x; auto with zarith.\n  apply Z.le_lt_trans with x; auto with zarith.\n  apply Z.le_lt_trans with x; auto with zarith.\n  apply Z.le_lt_trans with x; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z_eq_bool_spec x y); intros.\n  rewrite H; auto with zarith.\n  rewrite Zneq_bool_true; auto with zarith.\n  rewrite Zneq_bool_false; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H.\n  case (Z_eq_bool x y); intro.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro; subst; auto with zarith.\n  (* 0<=x *)\n  intro;Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros; subst; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?= y)%Z; auto;\n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?= y)%Z; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\n",
                "context_tokens": 702,
                "proof_start_offset": 4191,
                "proof_end_offset": 4728,
                "proof": "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\nintros x0 y0.\napply PHL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e'=> forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nintuition auto with zarith.\ncutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0; case (Z_eq_dec x0 y0); auto; intros; subst.\n  rewrite <- (Z.mul_comm x0 y0) in H0; discriminate.\n  rewrite <- (Z.mul_comm y0 x0) in H0; discriminate.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold Zneq_bool.\n case_eq (Ye x0); auto.\n intros; discriminate.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0; case (Z_eq_dec x0 y0); auto.\n  case (Z_eq_dec y0 y1); auto.\n  intros e1 e2; simpl; auto.\n  case (Z_eq_dec y1 y2); auto.\n  case (Z_eq_dec y1 y2); auto.\n  intros e1 e2; simpl; auto.\n  case (Z_eq_dec e1 e2); auto.\n  case (Z_eq_dec e2 e2); auto.\n  intros e1 e2; simpl; auto.\n  case (Z_eq_dec e1 e2); auto.\n  intros e e2; simpl; auto.\n  case (Z_eq_dec e1 e2); auto.\n  intros e e1 e2; simpl; auto.\n  case (Z_eq_dec e1 e2); auto.\n  intros e e1 e2; simpl; auto.\n  case (Z_eq_dec e1 e2); auto.\n  intros e e1 e2; simpl; auto.\n  case (Z_eq_dec e2 e2); auto.\n  intros eQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0; unfold Zneq_bool; case (Z_eq_bool x y0); auto; intros.\n  rewrite <- (FY_ok x0 y0) in H0.\n  generalize (Z_eq_bool_true x0 y0); case (Z_eq_bool x0 y0); auto.\n  apply Z_eq_true_iff in H0.\n  destruct H0 as [H0|H0]; [|rewrite H0; rewrite H1; auto].\n  apply Z_eq_true_iff in H0; destruct H0 as [H1|H1]; [|rewrite H1; auto].\n  apply Z_eq_false_iff in H0; destruct H0 as [H1|H1]; [|rewrite H1; auto].\n  apply Z_eq_true_iff in H0; destruct H0 as [H1|H1]; [|rewrite H1; auto].\n  apply Z_eq_true_iff in H0; destruct H0 as [H1|H1]; [|rewrite H1; auto].\n  apply Z_eq_true_iff in H0; destruct H0 as [HQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0; case (Pos.compare x0 y0); auto.\n  intros H H1; case (Pos.compare y0 y1); auto.\n  intros H H2; case (Pos.compare y0 y1); auto.\n  intros H H3; case (Pos.compare y0 y1); auto.\n  intros H4; case (Pos.compare y0 y1); auto.\n  intros H5; case (Pos.compare y0 y1); auto.\n  intros H5; case (Pos.compare y0 y1); auto.\n  intros H6; case (Pos.compare y0 y1); auto.\n  intros H7; case (Pos.compare y0 y2); auto.\n  intros H8; case (Pos.compare y0 y1); auto.\n  intros H8; case (Pos.compare y0 y2); auto.\n  intros H9; case (Pos.compare y0 y1); auto.\n  intros H8; case (Pos.compare y0 y2); auto.\n  intros H9; case (Pos.compare y0 y1); auto.\n  intros H9; case (Pos.compareQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; case (Z_eq_bool_spec x0); intro H1.\n subst.\n rewrite Z.eqb_eq in H.\n destruct (Z.eq_bool x0) as [H|H].\n rewrite Z.eqb_eq in H.\n rewrite Z.eqb_eq in H.\n rewrite Z.eqb_eq in H.\n rewrite Z.eqb_eq in H.\n rewrite Z.eqb_eq in H.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_eq in H. subst.\n apply Z.eqb_Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0.\n  case (Z_eq_dec (Zeq_bool x0 y0) (Z.gcd x0 y0)).\n  intros H1.\n  apply Z.gcd_eq_0; auto.\n  apply Z.gcd_eq_0; auto.\n  apply Z.gcd_eq_0; auto.\n  apply Z.gcd_eq_0; auto.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0.\n  case (Z.compare_spec x0 y0); intros.\n  subst.\n  rewrite Z.eqb_eq in H0.\n  apply Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  apply Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  discriminate.\n  apply Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  apply Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  apply Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_eq in H0.\n  rewrite Z.eqb_neq in H0.\n  apply Z.eqbQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0; case (Z_eq_dec x0 y0); auto.\n  intros H1; case (Z_eq_dec x1 y1); auto.\n  intros H2; case (Z_eq_dec x1 y2); auto.\n  intros H3; case (Z_eq_dec y1 z1); auto.\n  intros H4; case (Z_eq_dec y2 z2); auto.\n  intros H5; case (Z_eq_dec y2 z1); auto.\n  intros H5; case (Z_eq_dec y2 z2); auto.\n  intros H5; case (Z_eq_dec y1 z2); auto.\n  intros H6; case (Z_eq_dec y2 z2); auto.\n  intros H6; case (Z_eq_dec z2 z2); auto.\n  intros H8; case (Z_eq_dec y2 z2); auto.\n  intros H8; case (Z_eq_dec z1 z2); auto.\n  intros H9; case (Z_eq_dec z2 z2); auto.\n  intros H9Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0; case (Z_eq_dec x0 y0); auto.\n  intros; discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "var A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\nLemma gcd_partial_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) \n   |= gcd  {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\n",
                "context_tokens": 693,
                "proof_start_offset": 4775,
                "proof_end_offset": 6000,
                "proof": "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\nintros x0 y0.\napply THL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\ forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nconstructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\nconstructor 1.\napply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\nauto with datatypes.\nunfold Zwf; simpl; (intuition auto with zarith).\ncutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\ncut ((fst e')<=(snd e')); auto with zarith.\ncut ((fst e')<>(snd e')); auto with zarith.\ncut (~(fst e')<=(snd e')); auto with zarith.\nintros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n split; intros H1 H2; subst.\n rewrite <- (F_gcd _ _ H1 H2 H3 H4).\n split; intros H3; subst.\n rewrite <- (F_gcd _ _ H3 H3 H4).\n split; intros H3; subst.\n rewrite <- (F_gcd _ _ H3 H4).\n split; intros H4; subst.\n rewrite <- (F_gcd _ _ H4 H5).\n split; intros H5; subst.\n rewrite <- (F_gcd _ _ H5 H6).\n split; intros H6; subst.\n rewrite <- (F_gcd _ _ H6 H6).\n split; intros H8; subst.\n rewrite <- (F_gcd _ _ H5 H6).\n split; intros H9; subst.\n rewrite <- (F_gcd _ _ H6 H7).\n split; intros H10; subst.\n rewrite <- (F_gcd _ _ H6 H7).\n split; intros H11; subst.\n rewrite <- (F_gcd _ _ H11).\n split; intros H11; subst.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n assert (H:=gcd_stable x0 y0 H0).\n assert (H':=gcd_stable x0 y0 H1).\n destruct H; auto.\n destruct H0; auto.\n destruct H0; auto.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply Zeq_dec.\n rewrite <- (Zeq_eq_iff x0 y0).\n rewrite Z.add_comm. now destruct (VY e).\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n functional induction (Z_eq_bool 0 x0).\n left; split; intuition.\n right; apply Z.lt_0_le_0_iff in H; auto with zarith.\n apply Z.le_0_lt_0_iff in H; auto with zarith.\n apply Z.le_0_lt_iff in H; auto with zarith.\n apply Z.le_0_lt_iff in H; auto with zarith.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n case (Z_dec (VX e) (VY e)); auto.\n intro H1; subst.\n (* 0 *)\n destruct (VY e) as (x,(H1,H2)).\n exists x; exists e; split; auto.\n (* 0 *)\n destruct (VY e) as (x,(H1,H2)).\n exists x; exists e; split; auto.\n (* 0 *)\n destruct (VY e) as (x,(H1,H2)).\n exists x; exists e; split; auto.\n (* 0 *)\n destruct (VY e) as (x,(H1,H2)).\n exists x; exists e; split; auto.\n (* 0 *)\n destruct (VY e) as (x,(H1,H2)).\n exists x; exists e; split; auto.\n (* 0 *)\n destruct (VY e) as (x,(H1,H2)).\n exists x; exists e; split; auto.\n (* 0 *)\n destruct (VY e) as (x,(H1,H2)).\n exists x; exists e; splitQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n destruct (gcd_total_eq x0 y0) as [[H1|H1] | H1]; [left | right]; split; intuition.\n destruct (gcd_total_eq x0 y0) as [[H2|H2] | H2]; [left | right]; split; intuition.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply (well_founded_induction_type (VX e)); auto.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply (well_founded_induction_type (VX e) (VY e) (VY e)); simpl.\n intuition.\n destruct e; intuition.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n assert (H: forall e, (VX e)=x0 /\\ (VX e)=x0).\n  { intros; auto with zarith. }\n  assert (H: forall e, (VX e) = (VX e)).\n  { intros; auto with zarith. }\n  assert (H': forall e, (VX e)!x0 -> (VX e)!x0 = 0).\n  { intros; auto with zarith. }\n  assert (H': forall e, (VX e)!x0 = 0).\n  { intros; auto with zarith. }\n  assert (H': forall e, (VX e)!x0 = 0).\n  { intros; auto with zarith. }\n  assert (H': forall e, (VX e)!x0 = 0).\n  { intros; auto with zarith. }\n  assert (H': forall e, (VX e)!x0 = 0).\n  { intros; auto with zarith. }\n  assert (H': forall e, (VX e)!x0 = 0).\n  { intros; auto with zarith. }\n  assert (H': forall e, (VX e)!x0Qed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n case (Z_eq_dec x0 y0); intros.\n (* Z.pos *)\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.\n rewrite Z.pos_sub_0_r in H0.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "un e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\nLemma gcd_total_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0)\n  |= gcd  [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply THL.soundness.\n simpl.\n intros e; intuition subst.\n (** after simplification, I provide the invariant and then the variant *) \n constructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\\n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n constructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\n (** - proof that my variant is a well_founded relation *) \n constructor 1.\n apply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\n auto with datatypes.\n (** - other goals *)\n  unfold Zwf; simpl; (intuition auto with zarith).\n (** -- invariant => postcondition \n      --- gcd part like in partial correctness proof \n *)\n  cutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\n  (** --- new VY in branch \"then\" is positive *)\n  cut ((fst e')<=(snd e')); auto with zarith.\n  cut ((fst e')<>(snd e')); auto with zarith.\n  (** --- new VX in branch \"else\" is positive *)\n  cut (~(fst e')<=(snd e')); auto with zarith.\n  intros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\n  discriminate.\nQed.\n\n(** ** Another example: infinite loops in partial correctness.\n\nBasic Hoare logic is not well-suited for reasoning about non-terminating programs.\nIn total correctness, postconditions of non-terminating programs are not provable.\nIn partial correctness, a non-terminating program satisfies any (unsatisfiable) postcondition.\n\nFor example, in an informal \"meaning\", the program below enumerates all multiples of 3. But this meaning \ncan not be expressed here (even in partial correctness).\n*)\n\nDefinition enum_3N := \n  (Iseq (Iset VX (const 0))\n        (Iwhile (const true)\n                (Iset VX (PLUS VX (const 3))))).\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6625,
                "proof_end_offset": 6819,
                "proof": "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\napply PHL.soundness.\nsimpl.\nconstructor 1 with (x:=fun _:Env => True).\nintuition (discriminate || auto).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nassert (H:= fun e => True).\nunfold enum_3N.\nintros.\nassert (H':=fun e => False).\nunfold enum_3N in H.\napply H.\nunfold enum_3N in H.\ncontradict H.\nclear H.\nrevert H.\ninduction H.\ninv H0.\ninv H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nassert (H := @P_list (fun e => False) (fun e => True) (fun e => True) (fun e => True) (fun e => True) H).\nassert (H := @P_list (fun e => True) (fun e => True) H).\nassert (H0 := @P_list (fun e => True) (fun e => True) H).\nassert (H1 := @P_list (fun e => True) (fun e => True) H0).\nassert (H2 := @P_list (fun e => True) (fun e => True) H0).\nassert (H3 := @P_list (fun e => True) (fun e => True) H0).\nassert (H5 := @P_list (fun e => True) (fun e => True) H5).\nassert (H6 := @P_list (fun e => True) H5).\nassert (H6 := @P_list (fun e => True) H6).\nassert (H6 := @P_list (fun e => True) H6).\nassert (H7 := @PQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nsplit.\n- intros (x,e).\n  unfold enum_3N, enum_4N.\n  destruct e; simpl; auto.\n- intros (x,e).\n  unfold enum_4N, enum_4N; simpl; f_equal.\n  destruct e; simpl; auto.\n- intros (x,e).\n  unfold enum_4N, enum_4N; simpl; f_equal.\n  destruct e; simpl; auto.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\ninduction e.\n+ simpl.\n  intros e. simpl.\n  intros e. simpl.\n  intros e.\n  destruct e; simpl.\n  - intros e.\n    destruct e; simpl.\n    - intros e.\n      destruct e; simpl.\n      - intros e.\n        destruct e; simpl.\n        - intros e.\n        destruct e; simpl.\n        - intros e.\n        - intros e.\n        destruct e; simpl.\n        - intros e.\n        - intros e.\n        destruct e; simpl.\n          - intros e.\n          destruct e; simpl.\n          - intros e.\n          destruct e; simpl.\n          - intros e.\n            destruct e.\n            - intros e.\n            destruct e; simpl.\n            - intros e.\n            destruct e; simpl.\n              - intros e.\n              destruct e; simpl.\n              - intros e.\n              destruct e.\n              - intros e.\n              destruct e; simpl.\n              - intros e.\n              destruct e; simpl.\n              - intros e.\n              destruct e; simpl.\n              - intros e.\n              destruct e; simpl.\n              - intros e.\n              destruct e; simpl.\n              - intros e.\n              destruct e; simpl.\n              - intros e.\n              destruct eQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros e; revert e; induction e; simpl.\n- trivial.\n- destruct e. simpl. destruct e; try discriminate.\n  + destruct e; try discriminate.\n    destruct e; try discriminate.\n    + destruct e; try discriminate.\n    + destruct e; try discriminate.\n    + destruct e; try discriminate.\n      + destruct e; try discriminate.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintro; case e; simpl.\n- case e; simpl.\n  - reflexivity.\n  - case e; simpl.\n    + reflexivity.\n    + intro. apply e.\n    + intro. apply e.\n    + intro. apply e.\n    + intro. apply e.\n    + intro. apply e.\n    + intro. apply e.\n    + intro. apply e.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\nrewrite <- (Iseq_eq_length (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (S (Iseq (Iseq (S (Iseq (Iseq (Iseq (Iseq (Iseq (Iseq (S (S n))))))))).\nsimpl.\nintros e.\nrewrite (Iseq_eq_length (Iseq (Iseq (Iseq (Iseq (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nassert (H := interp_list_eq_enum_uniq _ _ _ H).\napply wf_map_eq_enum_uniq in H.\ndestruct H as [e' H].\nrevert e H; induction e'; simpl; intros.\ndestruct e'; simpl; auto.\ndestruct e'; simpl; auto.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nsplit; simpl; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nsplit.\n- apply wf_next_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_next_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_next_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_uniq.\n- apply wf_next_uniq.\n- apply wf_cat_uniq.\n- apply wf_cat_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "(** * Generation of Hoare proof obligations in total correctness\n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file gives a syntactic definition of the weakest precondition [wp]\n introduced in #<a href=hoarelogicsemantics.html>#[hoarelogicsemantics]#</a>#.\n We refine here the approach of  #<a href=partialhoarelogic.html>#[partialhoarelogic]#</a>#.\n*)\n\nGlobal Set Asymmetric Patterns.\nSet Implicit Arguments.\nRequire Export hoarelogicsemantics.\nRequire Wf.\n\nModule TotalHoareLogic (HD: HoareLogicDefs).\n\nExport HD.\nModule HLD:=HD.\n\nDefinition sem_wp := wp.\n\nExport Wf.\n\n(** * Syntactic definition of the weakest precondition.\n\n In the following, we show that this definition is logically\n equivalent to [wp].\n *)\nFixpoint synt_wp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n          ((E.eval cond e)=true -> (synt_wp p1 post e))\n       /\\ ((E.eval cond e)=false -> (synt_wp p2 post e))\n  | (Iseq p1 p2) => synt_wp p1 (synt_wp p2 post) e\n  | (Iwhile cond p) =>  \n        exists inv:Pred,\n        exists R:E.Env -> E.Env -> Prop,\n             (well_founded R)\n          /\\ (inv e)\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=false -> post e')\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=true -> synt_wp p inv e')\n          /\\ (forall e0, (inv e0)\n                  -> (E.eval cond e0)=true -> synt_wp p (fun e1 => R e1 e0) e0)\n  end.\n\n(** * Soundness *)\n\n(** Monotonicity is also trivially satisfied by [wp].\n    We need it here to prove the soundness.\n*)\n",
                "context_tokens": 530,
                "proof_start_offset": 1747,
                "proof_end_offset": 1962,
                "proof": "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\ninduction p; simpl; firstorder eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  induction p; simpl; intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st1 st2 e H.\n  induction H; intros.\n  + simpl.\n    inversion H.\n  + simpl.\n    inversion H.\n  + simpl.\n    inversion H.\n  + simpl.\n    inversion H.\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st1 st2 e.\n  induction p.\n  apply (proj1 (H _ _ H)).\n  intros.\n  apply (proj2 (H _ _ H)).\n  apply (proj2 (H _ _ H)).\n  apply (proj2 (H _ _ H)).\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st1 st2 e.\n  induction p; simpl; auto.\n  apply (leftTrans (G:=fun _ => C) (fun _ => C) (fun _ _ => C) (fun _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ _ => C) (fun _ _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ _ => C) (fun _ _ _ => C) (fun _ _ _ _ =>Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st1 st2.\n  induction p; simpl; intros; auto.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H5.\n  apply H1.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H6.\n  apply H5.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\n  apply H6.\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st1 st2 e.\n  induction p; intros.\n  (* E_inv *)\n  - (* E_inv *)\n    destruct H0 as [e0 [e1 [e2 [H3 H4]]]].\n    destruct (H0 e1) as [e1 [e2 [H4 H5]]]].\n    destruct (H1 e2) as [e2 [e3 [H5 H6]]].\n    destruct (H2 e3) as [e3 [e4 [H6 H7]]]].\n    destruct (H2 e3) as [e4 [H8 [H9 H8]].\n    destruct (H2 e3) as [e4 [H9 H9]].\n    destruct (H3 e4) as [e5 [H9 H9]].\n    destruct (H6 e5) as [e6 [e5 [H9 H9]].\n    destruct (H6 e6) as [e6 [e6 [H9 H9]].\n    destruct (H9 e7) as [e6 [e7 [H9 H9]].\n    destruct (H9 e7) as [e7 [e8 [H9 H9]].\n   Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  induction p; simpl; intros.\n  - apply (H e).\n    - apply (H e).\n    - apply (H0 e).\n    - apply (H0 e).\n    - apply (H0 e).\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  induction p; simpl; intros; auto.\n  destruct (ex_prim_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_no_expr_any_expr_no_expr_no_Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st1 st2 e.\n  induction p; simpl; intros.\n  inversion H.\n  destruct (H0 p).\n  destruct st1; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H0.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H0.\n  destruct (H0 p).\n  destruct st2; simpl in *.\n  inversion H.\n  destructQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st1 st2 e; induction p; simpl; intros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "dec2 H2 H.\n generalize Hinv.\n pattern e.\n (* -- here the proof proceeds by induction on the well-founded relation *)\n eapply well_founded_ind; eauto.\n clear Hinv e.\n intros e' X H'.\n set (b:=E.eval cond e').\n cut (E.eval cond e'=b); auto.\n case b; [ idtac | firstorder eauto with hoare ].\n intros H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\n",
                "context_tokens": 707,
                "proof_start_offset": 5789,
                "proof_end_offset": 5976,
                "proof": "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction 1; simpl; try ((firstorder eauto with hoare); fail).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nunfold update.\nintros.\nrevert H H0.\ninduction H0; intros.\nsimpl in H1.\ninversion H1.\ninversion H2.\ninversion H3.\ndestruct e; simpl in H1.\ninversion H1.\ninversion H2.\ndestruct e0; simpl in H1.\ninversion H1.\ndestruct e0; simpl in H1.\ninversion H1.\ninversion H3.\ninversion H3.\ninversion H3.\ndestruct e0; simpl in H1.\ninversion H1.\ndestruct e0; simpl in H1.\ninversion H1.\ninversion H2.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ndestruct e0; simpl in H1.\ninversion H1.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ndestruct e0; simpl in H1.\ninversion H1.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion HQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\napply functional_extensionality; intros; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ninduction H; intros; subst; auto.\nrewrite H in H0.\ninversion H0; subst; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl; auto.\n  apply (IHheap (e_no_EX_wlp (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_w_ts)).\n  apply (IHheap (e_no_EX_Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; intros; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ninduction H; auto.\ndestruct H0 as [st0 e1 e2].\nunfold exec in H0.\nrepeat constructor.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ngeneralize (exec_inversion H); intro.\ngeneralize (exec_inversion H0); intro.\ngeneralize (exec_inversion H1).\ngeneralize (exec_inversion H1).\nintros.\ngeneralize (exec_inversion H1).\ngeneralize (exec_inversion H1).\ngeneralize (exec_inversion H1).\nintros.\ngeneralize (exec_inversion H1).\ngeneralize (exec_inversion H1).\nintros.\ngeneralize (exec_inversion H1).\ngeneralize (exec_inversion H1).\nintros.\ngeneralize (exec_inversion H1).\nintros.\ngeneralize (exec_inversion H1).\ngeneralize (exec_inversion H1).\nintros.\ngeneralize (exec_inversion H2).\nintros.\ngeneralize (exec_inversion H1).\ngeneralize (exec_inversion H3).\nintros.\ngeneralize (exec_inversion H3).\nintros.\ngeneralize (exec_inversion H3).\nintros.\ngeneralize (exec_inversion H3).\ngeneralize (exec_inversion H3).\nintros.\ngeneralize (exec_inversion H3).\nintros.\ngeneralize (exec_inversion H3).\ngeneralize (execQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction 1; simpl; intros; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction 1; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\napply functional_induction; intros; auto.\napply H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\n",
                "context_tokens": 696,
                "proof_start_offset": 6074,
                "proof_end_offset": 6404,
                "proof": "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\nintros A x expr e e' H.\npattern e'; apply (exec_inversion H); simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  generalize (eval_eval_eq_ind _ _ _ _ _ _ _ H).\n  induction e; intros.\n  simpl.\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (E.beq (LState e e0)).\n  apply eval_eval_eq_ind with (EQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  case (H0 _ H1); intros.\n  case (H3 _ _ H2); intros.\n  apply H0 in H1.\n  apply H1 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in H2.\n  apply H2 in HQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros. apply exec_inversion.\n  apply exec_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversionQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  apply e.\n  apply e.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e'.\n  apply e.\n  apply e'.\n  apply e'.\n  apply e.\n  apply e'.\n  apply e'.\n  apply e'.\n Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  generalize (eval_inversion H). intro.\n  generalize (eval_inversion H0).\n  generalize (eval_inversion H1).\n  generalize (eval_inversion H2).\n  generalize (eval_inversion H1).\n  generalize (eval_inversion H2).\n  generalize (eval_inversion H1).\n  generalize (eval_inversion H2).\n  generalize (eval_inversion H2).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversion H3).\n  generalize (eval_inversionQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  apply functional_extensionality.\n  eapply (eval_test_inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  generalize (eval_extensionality_dep _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1).\n  intros.\n  generalize (eval_extensionality_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1).\n  intros.\n  generalize (eval_extensionality_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H2).\n  intros.\n  generalize (eval_extensionality_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H2 H3).\n  intros.\n  generalize (eval_extensionality_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H3).\n  intros.\n  generalize (eval_extensionality_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H3).\n  intros.\n  generalize (eval_extensionality_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H3).\n Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  destruct (H (E.eval expr e) e'); auto.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  auto.\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destruct (E.beq_nat x x0).\n  destructQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  inversion H.\n  apply (H0 (H1 H0)).\n  apply (H1 (H2 H0)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ct the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\nLemma exec_test_inversion:\n  forall A (x:E.Var A) expr e e',\n     (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x expr e e' H.\n  (** Here, try \"[inversion H]\" instead the tactic below. \n      The generated goal is not directly provable. *)\n  pattern e'; apply (exec_inversion H); simpl; auto.\nQed.\n \n(** Below, a little tactic to helps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\n",
                "context_tokens": 712,
                "proof_start_offset": 6917,
                "proof_end_offset": 7168,
                "proof": "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\ninduction 1; intros ef' X; exec_inversion X; eauto.\nintros e1 e2 X1 X2; assert (X3: e'=e1); auto.\nsubst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply (exec_inversion H); simpl; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply (eval_eval_eval_lvalue_steps _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H0).\n  intros.\n  apply (eval_eval_eval_lvalue_steps _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H0).\n  intros.\n  apply (eval_eval_eval_lvalue_steps _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H0).\n  auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  induction H.\n  - Case \"right\".\n    destruct (H0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  apply (eval_extensionality (eval expr e) (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (eval_extensionality (eval expr e) (eval expr e)).\n  apply (Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  (* FILL IN HERE *) Admitted.\n(** [] *)\n\n(** **** Exercise: 3 stars, optional (multi_deterministic)  *)\n(** Prove that the following lemma is equivalent to the [rein]\n    definition of [rein] with [rein] that we do not need to prove the\n    [rein] command to [rein] with [rein].  In other words, we can use this\n    definition, we don't need to use it to prove that the\n    [rein] statement of [rein] with the current goal.  For\n    [rein] (in the [rein] that, we need to prove [rein],\n    that we can use [rein] as it.  However, [rein] with the\n    [rein] with the current goal.\n\n    We can prove this (i.e., it is that [e] is equivalent to\n    [rein] with the same thing.  The [in] function\n    of [e] with the same as [e] that holds for\n    [e].  Therefore, [subst_to_lc_to_lc_to_lc_to_lc_Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply (eval_simple_dep_dep_dep_dep_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1 H2).\n  apply (eval_simple_dep_dep_dep _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p; apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  apply (divide_refl (eval expr e)); simpl; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_dep _ _ H); intro.\n  generalize (eval_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_extensionality_dep _ _ H); intro.\n  generalize (eval_dep _ _ H); intro.\n  generalize (eval_dep _ _ H); intro.\n  generalize (eval_depQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8653,
                "proof_end_offset": 8793,
                "proof": "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\ninduction 1; firstorder (eauto with hoare).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; econstructor; eauto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; subst; econstructor; eauto.\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_Oexists _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  destruct (updaten_OexistsQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; econstructor; eauto.\n  destruct (H H); eauto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; econstructor; eauto.\n  destruct H.\n  exists n. econstructor. econstructor. eauto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros.\n  exists (fun x => x).\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_IconsQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; econstructor; eauto.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  exists x. econstructor; eauto.\n  destruct H.\n  destruct H0.\n  econstructor; eauto.\n  destruct H.\n  destruct H0.\n  econstructor; eauto.\n  destruct H0.\n  econstructor; eauto.\n  destruct H.\n  econstructor; eauto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; econstructor; eauto.\n  destruct (H0 (S n)); econstructor; eauto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; destruct H; eauto.\n  destruct (H0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 _ _ _ _ _ _ _ _ _ _ _ _ _ H0 _ _ _ _ _ _ H0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 _ _ _ _ _ _ H0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; subst; eauto.\n  apply execn_Inil.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros.\n  exists (E.eval var n).\n  split.\n  simpl.\n  apply execn_Iempty.\n  apply execn_Iempty.\n  apply execn_Iempty.\n  apply execn_Icons.\n  apply execn_Iempty.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execn_Icons.\n  apply execQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\n",
                "context_tokens": 739,
                "proof_start_offset": 9000,
                "proof_end_offset": 9914,
                "proof": "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\nunfold well_founded.\nintros cond p e0; apply Acc_intro.\nintros e1 H; unfold reduces in H.\ndecompose [ex and] H; clear H.\nclear H2 H0 e0.\ncase (exec_execn H1).\nintros n.\ngeneralize cond p e1 x; clear cond p e1 x H1.\nelim n.\nintros cond p e0 e1 H; inversion_clear H.\nclear n; intros n HR cond p e0 e1 H.\ninversion_clear H.\ninversion_clear H0.\nset (b:=E.eval cond e0) in * |-.\ncut (E.eval cond e0=b); auto.\ngeneralize H; clear H; case b; simpl.\nintros H; inversion_clear H.\nintros; apply Acc_intro.\nintros e2 H3; unfold reduces in H3.\nintuition.\nrewrite (exec_deterministic H3 H0); eauto.\nintros H H0; apply Acc_intro.\nunfold reduces; rewrite H0.\nintuition.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  destruct (is_empty_or_source p e0).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destruct (is_empty_or_source p e).\n  destructQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; intros.\n  inv H.\n  destruct s.\n  simpl in H.\n  destruct (H (S n)).\n  inv H.\n  destruct (H2 (S n)).\n  inv H0.\n  destruct (H2 (S n)).\n  inv H0.\n  exists (S n).\n  intuition.\n  inv H1.\n  destruct (H2 (S n)).\n  inv H2.\n  destruct (H2 (S n)).\n  inv H2.\n  destruct (H2 (S n)).\n  inv H0.\n  destruct (H2 (S n)).\n  inv H2.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv H3.\n  destruct (H2 (S n)).\n  inv HQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  destruct (is_empty_or_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_no_empty_noQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_deterministic.\n  eapply step_Qed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction p; econstructor; eauto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; eauto with Forward.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  destruct (is_empty_or_value (update_noempty _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; eauto with hoare.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; eauto with infinite.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; intros; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "Prog -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\n",
                "context_tokens": 734,
                "proof_start_offset": 10044,
                "proof_end_offset": 11057,
                "proof": "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\nunfold wp.\nintros prog post e H; case H; clear H.\nintros e' H; case H; clear H.\ngeneralize post e e'; clear post e e'; elim prog; clear prog; simpl.\nintros post e e' H; exec_inversion H; auto.\nintros A v expr post e e' H; exec_inversion H; auto.\nintros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\ncase (E.eval cond e); simpl; firstorder auto || discriminate.\nintros p1 Hp1 p2 Hp2 post e e' H.\nexec_inversion H.\neauto.\nintros cond p Hp post e e' H H0.\nconstructor 1 with (x:=wp (Iwhile cond p) post).\nconstructor 1 with (x:=reduces cond p).\nunfold wp; (intuition eauto with hoare); dec2 e1 H1; case H1; clear H1; intros H1; exec_inversion H1; intros e2 H1; exec_inversion H1; rewrite H2; intros e3 H1; exec_inversion H1; unfold reduces; eauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  generalize (proj1_sig (step_to_or_or_eq (step_to_or_eq (step_to_or_eq (step_to_or_eq (step_to_eq_dec (step_to_eq_dec (step_dec sigma)))).\n  destruct (exec_parn_O 1 (step_to_or_eq (step_to_eq_dec sigma))).\n  destruct (exec_parn_O 2 (step_to_eq_dec (step_to_eq_dec sigma)))).\n  destruct (exec_parn_O 2 (step_to_eq_dec (step_to_eq_dec sigma)))).\n  destruct (exec_parn_O 2 (step_to_eq_dec (step_to_eq_dec sigma)))).\n  destruct (exec_parn_O 3 (step_to_eq_dec (step_to_eq_dec sigma))).\n  destruct (exec_parn_O 2 (step_to_eq_dec sigma)).\n  destruct (exec_parn_O 3 (step_to_eq_dec (step_to_eq_dec sigmaQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  induction sigma; auto.\n  rewrite <- app_nil_r.\n  apply step_refl.\n  apply step_refl.\n  apply step_refl.\n  apply step_refl.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros. unfold prog, mains.\n  apply functional_extensionality.\n  intros.\n  destruct st.\n  simpl.\n  apply H.\n  intros.\n  apply H.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H.\n  intros.\n  apply H0.\n  intros.\n  apply H.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H0.Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  rewrite (is_empty_or_nil sigma).\n  apply H.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  set (b:=fun (s: state) (s: state) => if (is_basic_nat s) then s else s).\n  set (b':=fun (s: state) (s: state) => if (is_basic_nat s) then s else s).\n  set (b':=fun (s: state) (s: state) => if (is_basic_nat s) then s else s).\n  assert (b':=fun (s: state) (s': state) => if (is_basic_nat s) then s else s').\n  assert (b':=fun (s: state) (s': state) => if (is_basic_nat s') then s else s').\n  assert (b':=fun (s: state) (s': state) => if (is_basic_nat s) then s else s').\n  apply (well_founded_induction_wf state).\n  apply well_founded_induction_wf.\n  apply well_founded_induction_wf.\n  apply well_founded_induction_wf.\n  apply well_founded_induction_wf.\n  apply well_founded_induction_wf.\n  applyQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  generalize (verify_deterministic (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value)).\n  intros.\n  generalize (verify_deterministic (fun _ => value) (fun _ => value) (fun _ => value)).\n  intros.\n  generalize (verify_deterministic (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value)).\n  intros.\n  generalize (verify_deterministic (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (fun _ => value) (Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros. unfold prog.\n  case (is_empty_or_nil (nil, nil)).\n  intros.\n  rewrite e0.\n  rewrite e2.\n  rewrite e3.\n  reflexivity.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  induction sigma; simpl; intros.\n  auto.\n  destruct (is_basic_nat n (S n)); auto.\n  destruct (is_basic_nat n (S n)); auto.\n  destruct (is_basic_nat n (S n)); auto.\n  destruct (is_basic_nat n (S n)); auto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  apply functional_extensionality.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  apply functional_extensionality; intros.\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_I (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_I (fun t => t)).\n  apply (updaten_I (fun t => t)).\n  apply (updaten_I (fun t => t)).\n  apply (updaten_O (fun t => t)).\n  apply (updaten_I (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply H; simpl; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply program_induction with (p,p); intros; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_induction with p; auto.\n  apply program_inductionQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  apply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  apply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  eapply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  apply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  eapply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  apply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  apply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  apply hoare_weaken_time with (p:=fun st => exists n, st#n = Some n).\n  intros.\n  eapply hoare_weaken_timeQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; red; intros.\n  destruct H as [A B].\n  destruct H as [A B].\n  assert (A: forall (s: A) (x: A), s x = s) by auto.\n  destruct H0.\n  subst s.\n  econstructor; eauto.\n  apply H0 with (x:=x).\n  apply H1.\n  apply H2.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply hoare_weaken_no_O.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply hoare_weaken_pre with (fun n => value n = value n).\n  intros.\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  intros.\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  intros.\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  intros.\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  intros.\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  intros.\n  apply hoare_weaken_pre with (fun n => value n = value n).\n  apply hoare_weaken_pre with (fun n => value n = value nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  assert (forall n, In (n, st) -> exists n, exists n, st n = Some n).\n    intros.\n    destruct (classic (exists n, st n = Some n)).\n    destruct H0 as [n?].\n    exists (n, st).\n    apply H.\n    auto.\n  destruct (H0 n).\n  destruct H0.\n  destruct H1 as [n?].\n  exists (n, st).\n  apply H.\n  auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct (H (rt_refl _ _ _ H)) as [A B C].\n  destruct (H (rt_refl _ _ _ H)) as [A B C].\n  destruct (H (rt_refl _ _ _ H)) as [A B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [A B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [A B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [B C].\n  destruct (H0 (rt_refl _ _ _ H)) as [C [D C]].\n  destruct (H0 (rt_refl _ _ _ H)) as [C [Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p as [p [p' [H1 [H2 [H3 [H4 H5]]]]]].\n  destruct p' as [p' [H4 [H5 [H5 H6]]]].\n  destruct p' as [p'' [H5 [H5 [H6 [H7 [H8 [H9 [H10 [H10 [H10 [H11 [H12 [H13 [H14 [H14 [H14 [H14 [H15 H15]]]]]]]].\n  econstructor; split; eauto.\n  apply H4.\n  eapply H4.\n  eapply H4.\n  eapply H4.\n  eapply H4.\n  eapply H8.\n  eapply H4.\n  eapply H8.\n  eapply H8.\n  eapply H9.\n  eapply H1.\n  eapply H8.\n  eapply H.\n  eapply H8.\n  eapply H.\n  eapply H8.\n  eapply H0.\n  eapply H8.\n  eapply H4.\n  eapply H9.\n  eapply H.\n  eapply H.\n  eapply H8.\n  eapply H0.\n  eapply H4.\n  eapply H.\n  eapply H7.\n  eapply H8.\n  eapplyQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply hoare_seq with (fun s => forall p, s = p -> exists s', step p p s' s' /\\ p = s').\n  intros.\n  apply hoare_if; intro.\n  destruct H0 as [s' [p' [s' [p'' [s' [p'' [H1 [H2 H3 [H4 H5]]]]]]]].\n  econstructor; split; eauto.\n  exists s'; exists p''; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros; split; auto.\n  apply H0 with (x := y); auto.\n  intros; apply H1; auto.\n  intros; apply H1; auto.\n  intros; apply H1; auto.\n  intros; apply H1; auto.\n  intros; apply H2; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof. auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  apply functional_extensionality; intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  eapply H0; eauto.\n  eapply H1; eauto.\n  eapply H1; eauto.\n  eapply H1; eauto.\n  eapply H2; eauto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nunfold program, program, program, program, program, program, program, program, program, program, program, program, program, program,\n  -> program, program, program_eq p post.\nProof.\n  intros. destruct H as [st p]. destruct H as [st' p'].\n  generalize (step_eq p' st' H0); clear H0.\n  intros st st' st'' H0.\n  generalize (step_eq p' st' H0); clear H0.\n  intros st'' st'' H0.\n  generalize (step_eq p' st'' H0); clear H0.\n  intros st'' H0.\n  generalize (step_eq p' st'' H0); clear H0.\n  intros st'' H0.\n  generalize (step_eq p' st'' H0); clear H0.\n  intros st'' H0.\n  generalize (step_eq p' st'' H0); clear H0.\n  intros st'' H0.\n  generalize (step_eq p' st'' H0); clear H0.\n  intros st'' H0.\n  generalize (step_eq p' st'' H0); clear H0.Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros. apply H.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros. apply H. apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  apply program_induction.\n  applyQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct H as [x [y [F [H1 [H2 H3]]]].\n destruct (H0 x); destruct (H1 x).\n destruct (H2 x).\n destruct (H4 x).\n destruct (H5 x).\n destruct (H5 x).\n destruct (H5 x).\n destruct (H6 x).\n destruct (H6 x).\n destruct (H6 x).\n destruct (H6 x).\n destruct (H6 x).\n destruct (H6 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H7 x).\n destruct (H8 x).\n destruct (H8 x).\n destruct (H8 x).\n destruct (H7 x).\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintros.\nrepeat (destruct p as [p' [H1 H2]].\nexists p'; split; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\n",
                "context_tokens": 556,
                "proof_start_offset": 1603,
                "proof_end_offset": 1825,
                "proof": "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros e p1 p2 e' e'' H H0.\n rewrite <- (H _ _ _ H0).\n rewrite <- (H _ _ _ _ H0).\n rewrite <- (H _ _ _ _ H0).\n rewrite <- (H _ _ _ _ _ H0).\n auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\ninduction e; simpl; auto.\ndestruct (H0 e); destruct (H2 e'); simpl; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros.\n  generalize H0.\n  induction H0.\n  intros.\n  destruct H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H5.\n  inversion H6.\n  inversion H5.\n  inversion H6.\n  inversion H6.\n  inversion H7.\n  inversion H5.\n  inversion H5.\n  inversion H6.\n  inversion H6.\n  inversion H6.\n  inversion H6.\n  inversion H6.\n  inversion H6.\n  inversion H6.\n  inversionQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e p1 p2 e' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e'' e''Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e p1 p2 e'.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e') as q.\n  remember (exec e (Iif cond p1 p2) e')Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros.\n  inversion H; subst; auto.\n  apply exec_Iif_false; auto.\n  apply exec_Iif_false; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros.\n  destruct e; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\ninduction e; simpl; auto.\nintros.\ninversion H; subst; auto.\nintros.\ninversion H; subst; auto.\nintros.\ninversion H; subst; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e p1 p2 e' e' e'' H; elim H; elim H; elim H; elim H0; elim H0; elim H0;\n elim H; elim H0; elim H1; elim H1; elim H2;\n elim H2; elim H3; elim H4;\n elim H4; elim H4; elim H4;\n elim H4; elim H4; elim H4;\n elim H5; elim H4;\n elim H4; elim H5;\n elim H4; elim H4;\n elim H5; elim H4;\n elim H5;\n [ intro H5; elim H5; elim H5;\n clear H6 H7; intros H8.\nelim H8; elim H8; elim H8;\n [ intro H5; elim H5; elim H7;\n [ intro H5; elim H7; clear H8; intros H8.\nelim H8; elim H8;\n [ intro H7; elim H8;\n [ intro H8; elim H8; clear H8; intros H8.\nelim H8; elim H8;\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n induction e; simpl; intros; auto.\n destruct H0 as [H1|H1]; destruct H1 as [H2|H2];\n  destruct H2 as [H3|H3];\n  try destruct (E.compare_bool p1 p2); try discriminate.\n  destruct (E.compare_bool p2 p3); try discriminate.\n  destruct (E.compare_bool p2 p3); try discriminate.\n  destruct (E.compare_bool p2 p3); try discriminate.\n  destruct (E.compare_bool p3 p3); try discriminate.\n  destruct (E.compare_bool p2 p3); try discriminate.\n  destruct (E.compare_bool p3 p3); try discriminate.\n  destruct (E.compare_bool p3 p3); try discriminate.\n  destruct (E.compare_bool p3 p3); try discriminate.\n  destruct (E.compare_bool p3 p3); try discriminate.\n  destruct (E.compare_bool p3 p3); try discriminate.\n  destruct (E.compare_bool p3 p4); try discriminate.\n  destruct (E.compare_bool p3 p3); try discriminateQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\n",
                "context_tokens": 646,
                "proof_start_offset": 1829,
                "proof_end_offset": 2053,
                "proof": "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif_true.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif_true.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": " E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nLemma exec_Iif_false:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=false\n      -> (exec e p2 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nDefinition Pred := E.Env -> Prop.\n\nDefinition wlp: ImpProg -> Pred -> Pred\n := fun prog post e => (forall e', (exec e prog e') -> (post e')).\n\nDefinition wp: ImpProg -> Pred -> Pred\n := fun prog post e => exists e', (exec e prog e') /\\ (post e').\n\n\nNotation \"p |= q\" := (forall e, (p e) -> (q e)) (at level 80, no associativity).\nNotation \"p {= post =}\" := (wlp p post) (at level 70).\nNotation \"p [= post =]\" := (wp p post) (at level 70).\n\nEnd HLD.\n\nExport HLD.\n\nModule PHL<: HoareProofSystem := PartialHoareLogic(HLD). \nModule THL<: HoareProofSystem := TotalHoareLogic(HLD). \n\nImport THL.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 2648,
                "proof_end_offset": 2853,
                "proof": "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\nunfold wp, wlp.\nintros prog post e H e' H'.\ndec2 e0 H.\ndec2 H0 H.\nrewrite (exec_deterministic H' H0).\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  generalize (proj1 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2 (projT1 (projT2 (projT2 (projT1 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT1 (projT1 (projT2 (projT2 (projT2 (projT1 (projT1 (projT2 (projT1 (projT2 (projT2 (projT2 (projT1 (projT2 (projT2 (projT2 (projT1 (projT2 (projT2 (projT2 (projT1 (projT2 (projT1 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT1 (projT2 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2 (projT1 (projT2 (projT2 (projT2 (projT2 (projT1 (projT2 (projT1 (projT2 (projT2 (projTQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros. apply functional_extensionality_dep.\n  intros.Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  assert (H: forall (x y:T), (x = y) -> (x = y)).\n  {\n    intros.\n    rewrite <- H.\n    auto.\n  }\n  clear H.\n  apply H.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros. destruct st; simpl.\n  unfold transition.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  destruct (eval_error (temp t)) as [e' [H1 H2]].\n  destruct (eval_error e') as [e'' [H3 H4]].\n  rewrite (proj1 (proj2 (proj2 (proj2 (proj2 H3))) H4).\n  rewrite (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 H3)))) H4).\n  rewrite (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H3)))).\n  rewrite (proj2 (proj2 (proj2 (proj2 (proj2 H3)))).\n  rewrite (proj2 (proj2 (proj2 (proj2 (proj2 H3)))).\n  rewrite (proj2 (proj2 (proj2 (proj2 (proj2 H3)))).\n  rewrite (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H3)))).\n  rewrite (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H3)))).\n  rewrite (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H3))))).\n  rewrite (proj2Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  rewrite <- (is_In_or_or_and_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  destruct (update_Oif_false state state state state) as [st1 st2].\n  apply step_Iif_true.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros. unfold compose.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; introsQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; unfold wlp.\n  rewrite <- (Hss (projT1 (projT2 (projT2 (projT1 (projT2 (projT2 (projT1 (projT2 (projT2 (projT1 (projT1 (projT2 (projT1 (projT2 (projT1 (projT2 (projT1 (projT1 (projT2 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT1 (projT1 (projT2 (projT1 (projT2 (projT1 (projT2 (projT2 (projT1 (projT2 (projT2 (projT2 (projT2 (projT1 (projT2 (projT1 (projT2 (projT2 (projT1 (projT2 (projT2 (projT1 (projT1 (projT1 (projT2 (projT2 (projT2 (projT1 (projT1 (projT1 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2 (projT2 (projT1 (projT1 (projT2 (projT2 (projT1 (projT2 (projT2 (projT1 (projT2 (projT1 (projT2 (projT2 (projT2 (projT2 (projT2))))) (projT1 (projTQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto.\nintros n H; elim H.\nintros m H; elim H.\nintros m H0; elim H.\nintros m H0; elim H0.\nintros m H0; elim H1.\nintros m H0; elim H0.\nintros m H0; elim H1.\nintros m H0; elim H1.\nintros m H1; elim H1.\nintros m H1; elim H1.\nintros m H1; elim H1.\nintros m H2; elim H2.\nintros m H2; elim H2.\nintros m H3; elim H3.\nintros m H4; elim H5.\nintros m H5; elim H5.\nintros m H6; elim H6.\nintros m H6 H7; elim H7.\nintros m H7; elim H8.\nintros m H8; elim H9.\nintros m H9; elim H10.\nintros m H10; elim H10.\nintros m H10; elim H10.\nintros m H10; elim H10.\nintros m H10; elim H10.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (H 0).\nintros.\nelim H.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H3.\nintros.\nelim H4.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\nelim H5.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\nelim H9.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nelim H9.\nintros.\nelim H10.\nintros.\nelim H11.\nintros.\nelim H10.\nintros.\nelim H11.\nintros.\nelim H11.\nintros.\nelim H11.Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction 1; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (even_odd_inv _ H).\nauto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\napply Nil.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (even_odd_plus n 0); intros.\nleft.\napply H.\nauto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (even_odd_odd_odd_odd 0 H).\nelim (even_odd_odd_odd_odd 0 H).\nelim (odd_odd_odd_odd_odd 0 H).\nelim (even_odd_odd_odd_odd 0 H).\nelim (even_odd_odd_odd 0 H).\nelim (even_odd_odd_even 0 H).\nelim (even_odd_odd_odd 0 H).\nelim (even_odd_odd_odd 0 H).\nelim (even_odd_odd_odd 0 H).\nelim (even_odd_odd 0 H).\nelim (even_odd_odd 0 H).\nelim (even_odd_odd 0 H).\nelim (odd_odd_even 0 H).\nelim (even_odd_odd 0 H).\nelim (odd_odd_odd 0 H).\nelim (even_odd_odd 0 H).\nelim (odd_odd_odd 0 H).\nelim (odd_odd_odd 0 H).\nelim (even_odd_odd 0 H).\nelim (even_odd_odd 0 H).\nelim (even_odd_Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros n H; elim H.\nintros n0 H; elim H.\nintros m0 H0; elim H.\nintros m0 H0; elim H0.\nintros m1 H0; elim H0.\nintros m1 H1; elim H1.\nintros m1 H1; elim H1.\nintros m2 H2; elim H2.\nintros m3 H4; elim H4.\nintros m3 H5; elim H5.\nintros m3 H5; elim H6.\nintros m3 H6; elim H6.\nintros m3 H7; elim H8.\nintros m3 H8; elim H8.\nintros m3 H7; elim H8.\nintros m3 H8; elim H8.\nintros m4 H8; elim H8.\nintros m5 H8; elim H8.\nintros m5 H8; elim H8.\nintros m6 H8; elim H9.\nintros m5 H8; elim H8.\nintros m6 H8; elim H8.\nintros mSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nintros.\nelim (plus_n_O 0); auto.\nintros.\nelim (plus_n_O 0); auto.\nintros.\nelim (plus_n_O 0); auto.\nintros.\nelim (plus_n_O 0); auto.\nintros.\nelim (plus_n_O 0); auto.\nintros.\nelim (plus_n_O 0); auto.\nintros.\nelim (plus_n_O 0); auto.\nintros.\nelim (plus_n_O (S (S n0))); auto.\nintros.\nelim (plus_n_O (S (S n0))); auto.\nintros.\nelim (plus_n_O (S (S n0))); auto.\nintros.\nelim (plus_n_O (S (S n0))); auto.\nintros.\nelim (plus_n_O (S n0)); auto.\nintros.\nelim (plus_n_O (S (S n0))); auto.\nintros.\nelim (plus_n_O (S n0))); auto.\nintros.\nelim (plus_n_Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (even_inv n); intros.\nabsurd (S n = S p); auto with arith.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros.\npattern m, n in |- *; apply plus_n_O.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros.\npattern m at 2 in |- *; apply O_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.\napply S_n_S.Save Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros m n; elim n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros.\nelim (mult_n_O m).\nauto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros.\napply (H (S m)); auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nintros n m H H0; elim H0.\nauto with arith.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nintros n m p; elim m; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nintros n m p; elim n.\nsimple induction m; simpl in |- *; auto with arith.\nintros n0 H0; elim H0.\nintros n1 H0; elim H0.\nintros m1 H0; elim H0.\nintros n2 H H0; elim H0.\nintros m1 H0; elim H0.\nintros m2 H1 H2; elim H1.\nintros n3 H3 H4; elim H4.\nintros m1 H4; elim H4.\nintros m3 H5; elim H5.\nintros n3 H6; elim H6.\nintros n3 H6 H7; elim H7.\nintros m3 H7; elim H7.\nintros m3 H7; elim H8.\nintros n4 H8; elim H8.\nintros m3 H9; elim H9.\nintros m4 H9; elim H9.\nintros n5 H9; elim H9.\nintros n5 H9; elim H9.\nintros m1 H9; elim H10.\nintros n5 HSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with bool.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nsimple induction t0; simpl in |- *; auto with arith.\nsimple induction u; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; apply tip.\npattern (size v) at 1 3 in |- *.\npattern (size v) at 3 in |- *.\npattern (size v) at 2 in |- *.\npattern (size v) at 3 in |- *.\npattern (size v) at 2 in |- *.\npattern (size v) at 2 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 2 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 2 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 2 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v) at 1 in |- *.\npattern (size v)Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with bool.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nintros.\napply (le_le_trans (S (size u) (S (size u))); auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\n",
                "context_tokens": 379,
                "proof_start_offset": 1699,
                "proof_end_offset": 1769,
                "proof": "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\nelim (H (B C)).\nauto.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintro.\nelim H.\nintros.\nelim H0.\nintros.\napply H3.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintro.\napply H0.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\nelim (not_or_lt A B C); auto.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\napply H0.\napply H1.\napply H1.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nunfold not in |- *; intros.\napply H1.\napply H0.\napply H1.\napply H2.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nsimple induction 1; intros.\n (* Base case *)\n (* Base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n(* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n (* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* shift case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* base case *)\n(* shift case *)\n(* base case *)\n(* base case *)\n(* shift case *)\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\n\n(*bisness of intuition properties of a non-dependent version of *)\n\nDefinition P (A : Set) := (A -> Prop) -> (P A -> Prop) -> A -> Prop.\n\nDefinition P (A : Set) := (P A -> Prop) -> A -> Prop.\n\nDefinition P (A : Set) := (P A -> Prop) -> (P A -> Prop) -> Prop.\n\n(*bisness of a non-dependent version of a non-dependent version of *)\n\nDefinition P (A : Set) := (P A -> Prop) -> (P A -> Prop) -> Prop.\n\n(*bisness of a non-dependent version of a non-dependent version of a given *)\n\nDefinition P (A : Set) := (P A -> Prop) -> A -> Prop.\n\n(*bisness of a non-dependent version of a non-dependent version of a\n   non-dependent version of a non-dependent version of the\n   same time. *)\n\nDefinition P (A : Set) := (P A -> Prop) -> (P A -> Prop) -> Prop.\n\nDefinition P (A : Set) := (P A -> Prop)Qed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\nelim H.\nintros.\napply H.\napply H.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\napply H.\napply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 1771,
                "proof_end_offset": 1818,
                "proof": "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\nintro.\nelim H.\nintro.\nelim H0.\nintro.\nelim H0.\nintro.\nelim H1.\nintro.\nelim H2.\nintro.\nelim H2.\nintro.\nelim H3.\nintro.\nelim H4.\nintro.\nelim H5.\nintro.\nelim H5.\nintro.\nelim H4.\nintro.\nelim H5.\nintro.\nelim H6.\nintro.\nelim H5.\nintro.\nelim H5.\nintro.\nelim H6.\nintro.\nelim H6.\nintro.\nelim H6.\nintro.\nelim H7.\nintro.\nelim H8.\nintro.\nelim H8.\nintro.\nelim H7.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nintro.\nelim H9.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \n",
                "context_tokens": 448,
                "proof_start_offset": 1867,
                "proof_end_offset": 1948,
                "proof": "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nProof.\nintro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro n.\nunfold not in |- *; intro n.\nunfold not in |- *; intro n.\nunfold not in |- *; intro n.\napply H0.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro n; elim n; auto with arith.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro n; elim n; auto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.\nintro n.\napply n.Qed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\n",
                "context_tokens": 499,
                "proof_start_offset": 2006,
                "proof_end_offset": 2102,
                "proof": "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\nintro.\nelim H0.\nintro.\napply H.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\nintro.\napply H0.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\n",
                "context_tokens": 582,
                "proof_start_offset": 2243,
                "proof_end_offset": 2346,
                "proof": "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\n",
                "context_tokens": 750,
                "proof_start_offset": 3167,
                "proof_end_offset": 3202,
                "proof": "Lemma NoMember : False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma NoMember : False.\nProof.\nsplit.\n- intros (H1,H2).\n  inversion_clear H1.\n  inversion_clear_clear H1.\n  inversion_clear_clear H2.\n  inversion_clear_clear_clear H3.\n  inversion_clear_clear_clear H4.\n  inversion_clear_clear_clear_clear_clear H4.\n  inversion_clear_clear_clear_clear H4.\n  inversion_clear_clear_clear H4.\n  inversion_clear_clear_clear_clear H4.\n  inversion_clear_clear_clear H4.\n  inversion_clear_clear_clear H4.\n  inversion_clear_clear_clear H4.\n  inversion_clear_clear_clear_clear_clear H4.\n  inversion_clear_clear_clear_clear H4.\n  inversion_clear_clear_clear H4.\n  inversion_clear_clear_clear_clear H4.\n  inversion_clear_clear_clear H4.\n  inversion_clear_clear_clear_clear H4.\n  inversion_clear_clear H4.\n  inversion_clear_clear_clear_clear H4.\n  inversion_clear_clear H4.\n Qed.",
                    "Lemma NoMember : False.\napply (Build_nat (fun x => x)).\nQed.",
                    "Lemma NoMember : False.\nProof.\nunfold not in |- *; intro; apply H.\nQed.",
                    "Lemma NoMember : False.\nreflexivity.\nQed.",
                    "Lemma NoMember : False.\nassumption.\nQed.",
                    "Lemma NoMember : False.\nintro.\napply H0.\nQed.",
                    "Lemma NoMember : False.\nProof.\nsplit.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\n+ apply H.\nQed.",
                    "Lemma NoMember : False.\napply not_refl.\nQed.",
                    "Lemma NoMember : False.\napply (Build_A (fun x => ~ P x)).\nQed.",
                    "Lemma NoMember : False.\nintro.\napply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3215,
                "proof_end_offset": 3288,
                "proof": "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros x y H.\nelim H.\nintros y Hy.\nelim H; intros.\nelim H0; intro.\nelim H1; intro.\nelim H2; intro.\nelim H3; intro.\napply H4; assumption.\napply H4; assumption.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros x y H.\napply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintro.\napply P.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintro.\nassert (H := H x y H0).\napply H0.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\n  intro.\n  apply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros x y Hxy.\nassert (Hx : x = y).\n subst; rewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- HQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros x y.\napply (H _ _ _).\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nexact P.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintro.\nintro.\napply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3290,
                "proof_end_offset": 3326,
                "proof": "Theorem tauto1 : A -> A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto1 : A -> A.\nProof.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\napply (Build_A (fun _ : A => forall y : nat, P y) (fun _ : A => forall y : nat, P y) (fun _ : A => forall y : nat, P y) (fun _ : A => forall y : nat, P y) (fun _ : A => forall y : nat, P y) (fun _ : A => forall y : nat, P y).\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\nintro.\napply H.\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\nintro x; tauto.\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\nintros x H; split; intros.\ncase (H x); auto.\ncase (H x); auto.\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\n  intros.\n  apply (H (A:=A)).\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\nexact A.\nQed.",
                    "Theorem tauto1 : A -> A.\nProof.\nintros x y H.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ulus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 3328,
                "proof_end_offset": 3393,
                "proof": "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\nintros.\napply H.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\nProof.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\nProof.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "bolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3395,
                "proof_end_offset": 3462,
                "proof": "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\nProof.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3464,
                "proof_end_offset": 3527,
                "proof": "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 3529,
                "proof_end_offset": 3565,
                "proof": "Theorem a4 : ~ A -> ~ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\n",
                "context_tokens": 745,
                "proof_start_offset": 3567,
                "proof_end_offset": 3607,
                "proof": "Theorem e2 : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "amathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3609,
                "proof_end_offset": 3657,
                "proof": "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 3659,
                "proof_end_offset": 3767,
                "proof": "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3769,
                "proof_end_offset": 3823,
                "proof": "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ".\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3825,
                "proof_end_offset": 3883,
                "proof": "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3885,
                "proof_end_offset": 3937,
                "proof": "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "s red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\nTheorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4257,
                "proof_end_offset": 4323,
                "proof": "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "s of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\n",
                "context_tokens": 377,
                "proof_start_offset": 2468,
                "proof_end_offset": 2722,
                "proof": "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.",
                "end_command": "Save Ackermann.",
                "generated_proofs": [
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\napply\n (fun p : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forall q : nat, q = q -> q = q)\n    (fun n : nat => forallSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\nintros n m; elim n.\napply sym_not_eq; auto.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\nsimple induction n.\nauto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction 1.\nauto with arith.\nauto with arith.\nauto with arith.\nauto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros.\napply (f_equal S (S n)).\nauto.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p; elim n; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m; elim m; elim m.\nintros n0 H; elim H; auto with arith.\nintros m0 H; elim H; auto with arith.\nintros m0 H; elim H; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m; elim n; simpl in |- *; auto.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction 1; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\n  simple induction n.\n  simpl in |- *.\n  apply le_n_O.\n  simpl in |- *.\n  apply lt_O_n.\n  simpl in |- *.\n  apply lt_O_n.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_S.\n  simpl in |- *.\n  apply le_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_S.\n  simpl in |- *.\n  apply le_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_n_S.\n  simpl in |- *.\n  apply le_n_S.\n  simplSave Ackermann."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": " not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\n",
                "context_tokens": 519,
                "proof_start_offset": 3199,
                "proof_end_offset": 3373,
                "proof": "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.",
                "end_command": "Save ack_Ack.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p; elim p; auto.\nintros n m p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros n' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros m' p; elim p; auto.\nintros mSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p; elim p; elim p; elim m; simpl; auto.\nintros m' H'; elim H'; intros.\nelim (H' n0); intros.\nexists x; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintros.\n(* S n *)\nsimple induction m.\n(* S n *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\nintros.\nelim (H0 n).\nintro m; elim H1; intros.\nelim (H1 n).\nintro m; elim (H2 n).\nintro m; elim H2; intros.\nelim (H1 n).\nintro m; elim H2; intros.\nelim (H2 n).\nintro m; elim H3; intros.\nelim (H3 m).\nintro m; elim H3; intros.\nelim (H3 m).\nintro m; elim H4; intros.\nelim (H5 m).\nintro m; elim H5; intros.\nelim (H5 m).\nintro m; elim H5; intros.\nelim (H5 m).\nintro m; elim H5; intros.\nelim (H5 m).\nintro m; elim H5; intros.\nelim (H5 m).\nintro m; elim H5; intros.\nelim (H5 m).\nintro m; elim H5; intros.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p; elim p; elim p; auto with arith.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H.\napply H.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eqSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H'; elim H'.\n(* 0 *)\nintros n m H'; elim H'.\n(* 0 *)\nintros n m H' H'0 H'1 H'2 H'3 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'3 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'3 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'3 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'3 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'3 H'4.\n(* n *)\nintros n m H' H'1 H'2 H'3 H'4.\n(* n *)\nintros n m HSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case p.\nintro m; case pSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H0; elim H0; intros.\nexists (S m); auto.\nintros m' H'; elim H''.\nintros m' H'0 H'1 H'2 H'3 H'4.\nelim H'2; intros.\nexists (S m'); auto.\nintros m' H'3; elim H'3; intros.\nexists (S m'); auto.\nintros m' H'3; elim H'3; intros.\nexists (S m'); auto.\nintros m' H'3; elim H'3; intros.\nexists (S m'); auto.\nintros m' H'4; elim H'4; intros.\nexists (S m'); auto.\nintros m' H'5; elim H'5; intros.\nexists (S m'); auto.\nintros m' H'5; elim H'5; intros.\nexists (S m'); auto.\nintros m' H'5; elim H'5; intros.\nexists (S m'); auto.\nintros m' H'5; elim H'5; intros.\nexists (S m'); auto.\nintros m'Save ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintros m p; elim p; intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H0 p); intros.\nelim (H1 p); intros.\nelim (H2 p); intros.\nelim (H1 p); intros.\nelim (H2 p); intros.\nelim (H3 p); intros.\nelim (H3 p); intros.\nelim (H1 p); intros.\nelim (H3 p); intros.\nelim (H3 p); intros.\nelim (H3 p); intros.\nelim (H4 p); intros.\nelim (H5 p); intros.\nelim (H5 p); intros.\nelim (H5 p); intros.\nelim (H5 p); intros.\nelim (H5 p); intros.\nelim (H6 p); intros.\nelim (H5 p); intros.\nelim (H6 p); intros.\nelim (H6 p); intros.\nelim (H6 p); intros.\nelim (H6 p); intros.\nelim (H7 p); intros.\nelim (H7 p); intros.Save ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H0; generalize (le_O_Sn n m p H0); clear p H0.\nunfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *;\n unfold F in |- *; unfold F in |- *; unfold F in |- *;\n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *;\n unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F inSave ack_Ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "               *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\nGoal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.\n\n",
                "context_tokens": 554,
                "proof_start_offset": 3375,
                "proof_end_offset": 3606,
                "proof": "Goal forall n m : nat, Ack n m (ack n m).\nProof.\nsimple induction n.\nsimpl in |- *; auto.\nintros n' H; simple induction m.\nsimpl in |- *; auto.\nintros m' H'; apply AckSS with (ack (S n') m'); auto.\napply (H (ack (S n') m')).\nSave Ack_ack.",
                "end_command": "Save Ack_ack.",
                "generated_proofs": [
                    "Goal forall n m : nat, Ack n m (ack n m).\nintros n m; elim n; elim m; elim n; simpl in |- *; auto.\nintros n1 m1 n2; elim m1; simpl in |- *; auto.\nintros n2 m2; elim m2; simpl in |- *; auto.\nintros n3 m1 n2; elim m1; simpl in |- *; auto.\nintros n3 m2 n3; elim m1; simpl in |- *; auto.\nintros n4 m2 n4; elim m1; simpl in |- *; auto.\nintros n5 m2 n5; elim m2; simpl in |- *; auto.\nintros n6 n6; elim m1; simpl in |- *; auto.\nintros n6 n7; elim m1; simpl in |- *; auto.\nintros n7 n8; elim m1; simpl in |- *; auto.\nintros n7 n8; elim m1; simpl in |- *; auto.\nintros n5 n6; elim m1; simpl in |- *; auto.\nintros n7; elim m1; simpl in |- *; auto.\nintros n7 n8; elim m1; simpl in |- *; auto.\nintros n8; elim mSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq a1 AO Eq a1 AO Eq a1 AO Eq a1 AO Eq a1 AO.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 n2 m2 n3 m3 n4 Eq a1 AO Eq a1 AO Eq a1 AO Eq a1 AO.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 n2 m4 Eq a1 AO Eq a1 AO Eq a1 AO Eq a1 AO Eq a1 AO.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 n2 m4 m5 a1 AO Eq a1 AO Eq a1 AO Eq a1 AO Eq a1 AO.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 n2 m4 m5 a1 AO Eq a1 AO Eq a1 AO Eq a1 AO.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 n2 m5Save Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 n2 H' H'0; elim H'; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n m1 p1 q1 ASn Eq P; elim Eq; trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nintros n m; elim n; elim m; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; auto.\nintros n1 m1 n2 Eqmy; elim Eq; trivial.\nintros n1 m2 n3 Heqmy; elim Eq; trivial.\nintros n1 m1 n3 Heqmy; elim Eq; trivial.\nintros n2 m1 n4 Heqmy; elim Eq; trivial.\nintros n3 Heqmy; elim Eq; trivial.\nintros n1 n3 Heqmy; elim Eq; trivial.\nintros n3 Heqmy; elim Eq; trivial.\nintros n1 n4 Heqmy; elim Eq; trivial.\nintros n4 Heqmy; elim Eq; trivial.\nintros n5 Heqmy; elim Eq; trivial.\nintros n5 Heqmy; elim Eq; trivial.\nintros n5 Heqmy; elim Eq; trivial.\nintros n5 Heqmy; elim Eq; trivial.\nintros n5 Heqmy; elim Heqmy; trivial.\nintros n5 Heqmy; elim Eq; trivial.\nintros n6 Heqmy; elim Eq; trivial.\nintros n6 Heqmy; elim Eq; trivial.\nintros n6 Heqmy; elim Eq; trivial.\nintros n6 Heqmy; elimSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1; elim (H1 n1); trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 Ale2.\napply (Build_finiteT (lt_n_O n1 m1)); auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 n2 p2 q1 ASn Eq another f n1 An1 ASn Eq another f n2. \napply Le.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nintros n m; elim n; elim n; simpl in |- *; auto.\nintros n1 m1 p1 ASn Eq An; elim Eq; elim Eq; trivial.\nSave Ack_ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\n",
                "context_tokens": 307,
                "proof_start_offset": 1329,
                "proof_end_offset": 1418,
                "proof": "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nautorewrite with base0 using try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply refl_equal.\napply sym_equal.\napply sym_eq.\napply sym_eq.\napply sym_Qed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply sym_not_eq.\nauto with base0.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply sym_eq.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nunfold AM, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Inc, Fifth Floor, Boston, MA);\n intros.\nelim H0.\nelim H1; elim H2; intros H3 H4; elim H4; intros H5 H6; elim H6; clear H6; intros H7 H8; elim H8; clear H8; \n intros H8 H9; elim H9; clear H10; intros H10 H11; elim H10; \n clear H10; intros H11 H12; elim H10; clear H10; introsQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.\nunfold Refl.Qed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply sym_eq.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply refl_equal.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nunfold Suat, nat_rect; simpl; auto with base.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\napply sym_eq.\napply refl_equal.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nrewrite <- (inj_eq (S n) (S n)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\n",
                "context_tokens": 462,
                "proof_start_offset": 1725,
                "proof_end_offset": 1826,
                "proof": "Lemma Resg0 : g 1 110 = 100.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  auto with arith.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\nLemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1828,
                "proof_end_offset": 1927,
                "proof": "Lemma Resg1 : g 1 95 = 91.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "ense, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\n",
                "context_tokens": 352,
                "proof_start_offset": 2584,
                "proof_end_offset": 2664,
                "proof": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nsimple induction x.\nauto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nsimple induction X.\nauto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n  intros; generalize (foo_eq1 x); generalize (foo_eq2 x y); case (foo_eq2 x y); intro H1.\n  auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros; apply X.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nunfold si, X in |- *; auto with bool.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n  intros.\n  elim X.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n  intros.\n  injection H.\n  auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nunfold tp, O in |- *; auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction 1; auto with bool.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nunfold lift, X in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "                                                *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 373,
                "proof_start_offset": 2666,
                "proof_end_offset": 2747,
                "proof": "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\nauto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "eceived a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\n",
                "context_tokens": 475,
                "proof_start_offset": 3105,
                "proof_end_offset": 3181,
                "proof": "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n trivial.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "rogram; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 3183,
                "proof_end_offset": 3264,
                "proof": "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\n",
                "context_tokens": 501,
                "proof_start_offset": 3267,
                "proof_end_offset": 3361,
                "proof": "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "n                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4026,
                "proof_end_offset": 4088,
                "proof": "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof. auto. Qed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "        *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4090,
                "proof_end_offset": 4181,
                "proof": "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n intros.\n destruct n.\n simpl.\n rewrite H.\n simpl.\n rewrite <- H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n simpl.\n rewrite H.\n trivial.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 4183,
                "proof_end_offset": 4343,
                "proof": "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n destruct n.\n simpl in |- *.\n intros.\n inversion H.\n inversion H.\n inversion H0.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n apply sorted_eq2.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n simpl.\n destruct (lt_eq_dec n m).\n left.\n auto.\n right.\n elim (lt_eq_eq_dec n m).\n left.\n elim (lt_eq_eq_eq_dec n m).\n left.\n elim (lt_eq_eq_eq_dec n m).\n right.\n elim (lt_eq_eq_eq_dec n m).\n left.\n elim (lt_eq_eq_eq_dec n m).\n right.\n elim (lt_eq_eq_eq_dec n m).\n right.\n elim (lt_eq_eq_eq_dec n m).\n right.\n elim (lt_eq_eq_eq_dec n m).\n right.\n elim (lt_eq_eq_eq_dec n m).\n left.\n elim (lt_eq_eq_eq_eq_dec n m).\n right.\n elim (lt_eq_eq_eq_eq_dec n m).\n right.\n elim (lt_eq_eq_eq_eq_dec n m).\n right.\n elim (ltQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros; elim n; simpl; auto.\n intros; elim m; simpl; auto.\n intros; elim m; simpl; auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n induction n.\n simpl.\n intuition.\n intros m IH.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\n intros.\n simpl.\n case (IH (S m) x).\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros; generalize (sorted_eq2 n m); case (sorted_eq2 n m); auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n destruct (le_lt_eq_dec n m).\n subst.\n rewrite <- (IH _ x).\n rewrite <- (IH _ x).\n rewrite <- (IH _ x).\n rewrite <- (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ x).\n rewrite (IH _ xQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n destruct x.\n simpl.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n destruct (le_gt_dec n m).\n right.\n left.\n right.\n right.\n left.\n apply (H (S m)).\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n unfold sorted in |- *.\n simpl in |- *.\n intros.\n elim (lt_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4504,
                "proof_end_offset": 4577,
                "proof": "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n intros; unfold nfin in |- *; auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n intros.\n induction n.\n simpl.\n rewrite <- nat_rect.\n rewrite (IH _ _ H).\n simpl.\n rewrite (IH _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ H).\n simpl.\n rewrite (IH _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.\n rewrite (IH _ _ _ H).\n simpl.Qed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 4579,
                "proof_end_offset": 4724,
                "proof": "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n apply nocc_eq2.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n apply nocc_eq2.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n unfold nfin in |- *.\n reflexivity.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n unfold nocc in |- *.\n reflexivity.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n unfold nocc.\n induction n.\n simpl.\n rewrite H.\n reflexivity.\n intros.\n simpl.\n rewrite H.\n reflexivity.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n induction n.\n simpl.\n rewrite IHn.\n rewrite IHn.\n rewrite (IHn m).\n rewrite (nocc_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n m).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2 n).\n rewrite (nim_eq2Qed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n induction n.\n simpl; auto.\n simpl; auto.\n intros x y IH.\n simpl; auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n unfold nocc in |- *.\n apply nocc_eq1.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n unfold nocc in |- *.\n unfold nocc in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member in |- *.\n unfold n member inQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n destruct x.\n simpl.\n rewrite plus_n_Sm.\n apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\n",
                "context_tokens": 746,
                "proof_start_offset": 4780,
                "proof_end_offset": 4846,
                "proof": "Theorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\napply (eq_true_elim (O_nat 0)).\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nunfold not in |- *; intros; discriminate.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\n",
                "context_tokens": 698,
                "proof_start_offset": 4879,
                "proof_end_offset": 5155,
                "proof": "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\nintros.\nrewrite si_eq1.\napply H.\ntrivial.\nintros.\nrewrite si_eq2.\napply H0.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\napply H.\napply H0.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nauto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\n(* -ooire *)\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H0.\napply H0.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\n(* = Sur *)\napply H.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b Hb Hb Hb Hb Hc.\nelim Hb; clear Hb; intros x y Hb Hc.\nelim Hb; clear Hb; intros y Hy.\nelim Hb; clear Hb; intros y Hy.\nelim Hb; clear Hb; intros y Hy.\nelim Hb; clear Hb; intros y Hy.\nelim Hb; clear Hb; intros y Hy.\nelim Hb; clear Hb; intros y Hy.\nelim Hy; clear Hb; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy; intros y Hy.\nelim Hy; clear Hy;Qed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b Hb Hc.\nassert (a : P (y = false :>bool) -> P y).\napply Hb.\napply H0.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros; discriminate.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\napply H.\napply H0.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b Hb Hc.\nassert (P (x = true :>bool) (b = true :>bool) (c = true :>bool).\napply H.\napply H0.\napply H1.\napply H2.\napply H1.\napply H2.\napply H1.\napply H1.\napply H1.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\nrewrite H0.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\n",
                "context_tokens": 728,
                "proof_start_offset": 5197,
                "proof_end_offset": 5481,
                "proof": "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\nintros.\napply False_ind.\napply diff_true_false.\nassumption.\nsimple induction m.\nintro.\ntrivial.\nintros.\nrewrite inf_egal_eq3.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n intros.\n case_eq (inf_prop n m).\n intro H.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite H.\n reflexivity.\n intros.\n rewrite H0.\n reflexivity.\n intros.\n apply nocc_eq1.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n discriminate.\n intros.\n discriminate.\n intros.\n discriminate.\n intros.\n discriminate.\n intros.\n discriminate.\n intros.\n discriminate.\n intros.\n discriminate.\n intros.\n discriminate.\n intros.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintro.\nsimple induction m.\n simpl in |- *.\n intro.\n discriminate.\n simpl in |- *.\n intro.\n discriminate.\n simpl in |- *.\n intro.\n discriminate.\n simpl in |- *.\n intro.\n discriminate.\n simpl in |- *.\n intro.\n discriminate.\n simpl in |- *.\n intro.\n discriminate.\n simpl in |- *.\n intro.\n discriminate.\n simpl in |- *.\n intro.\n discriminate.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n intros.\n unfold inf_egal.\n case m.\n intro.\n apply (lt_irrefl m).\n apply (lt_irrefl m).\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintros.\nsimpl in H.\ninduction m.\nsimpl in |- *.\ntrivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintros n m.\napply n.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.\n rewrite n.\n simpl in |- *.\n intros.Qed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintros n m H.\nelim H; trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n apply H.\n trivial.\n intros.\n rewrite m.\n apply H.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ") (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 5518,
                "proof_end_offset": 5731,
                "proof": "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\nintro.\nunfold sorted in |- *.\ntrivial.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n simple induction n.\n intro.\n apply False_ind.\n apply (H 0).\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H1.\n intros.\n apply H0.\n intros.\n apply H0.\n intros.\n apply H1.\n intros.\n apply H0.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H0.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H0.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\n apply H1.\n intros.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply H.\n apply H.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\nintro.\n apply (H 0).\n simpl in |- *.\nintro.\nelim H.\n intro.\n apply (H x0).\n apply le_S_n.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply (H 0).\n trivial.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n simple induction n.\n intros.\n apply False_ind.\n apply (lt_irrefl (S n)).\n intros.\n apply le_trans with (S (n + S n)).\n apply le_S_n.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n apply H.\n intros.\n simpl in |- *.\n apply H.\n intros.\n simpl in |- *.\n apply H.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply H.\n trivial.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\nintro.\n apply n.\n simpl in |- *.\nintro.\n discriminate.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n apply le_trans with (S (S (S (S n))).\n apply le_n_S.\n apply le_S_n.\n apply H.\n apply le_S_n.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n simple induction n.\n intros.\n apply False_ind.\n apply (H x).\n intros.\n apply H0.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \n",
                "context_tokens": 719,
                "proof_start_offset": 5734,
                "proof_end_offset": 5910,
                "proof": "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply (H (S m)).\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intro.\n unfold sorted in |- *. trivial.\n intro.\n rewrite minus_n_O.\n apply H.\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intro.\n rewrite <- (IHn (n:=n))).\n rewrite (S_S (n:=n)).\n rewrite (S_S (n:=n)).\n rewrite (S_S (n:=n)).\n rewrite (S_S (n:=n)).\n rewrite (S_S (n:=n)).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (S (n:=n))).\n rewrite (S_S (n:=n)).\n rewrite (S_n (n:=n)).\n rewrite (S_n (S (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=n))).\n rewrite (S_n (S (n:=Qed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply H.\n simpl in |- *.\ntauto.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply (H x).\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n apply False_ind.\n apply H.\n apply n.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intro.\n apply False_ind.\n apply (H 0).\n intro.\n apply (H (S (S (S m))).\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intro.\n apply False_ind.\n apply (H n).\n intro.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simpl in |- *.\n intros.\n apply n.\n simplQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intro.\n unfold sorted in |- *. trivial.\n intro.\n rewrite (Hrec nat (S (S m) x)).\n apply H.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n apply (H m).\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 6171,
                "proof_end_offset": 6267,
                "proof": "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\ninduction n.\nreflexivity.\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n reflexivity.\n simpl in |- *.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n simple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintro.\n rewrite hd_eq1.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n simple induction n.\n simple induction n.\n simpl in |- *.\n intros.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n simple induction n.\n simpl in |- *.\n trivial.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n trivial.\nintro.\nsimpl in |- *.\napply le_S_n.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plus_n_O.\nsimpl in |- *.\nrewrite plusQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintro.\n rewrite (Hrec (pred n)).\n rewrite (Hrec (pred n)).\n rewrite (Hrec (pred n)).\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite <- (plus_n_O n).\n rewrite <- (plus_n_O n).\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *.\n reflexivity.\nintros.\nrewrite (IHn).\ntrivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 6269,
                "proof_end_offset": 6448,
                "proof": "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n simple induction n.\n intros.\n rewrite <- plus_n_O.\n rewrite <- plus_n_O.\n rewrite <- plus_n_O.\n rewrite <- plus_n_O.\n rewrite <- plus_n_O.\n rewrite <- plus_n_O.\n rewrite <- plus_n_O.\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n simple induction n.\n intro.\n reflexivity.\n intros.\n rewrite plus_comm.\n simpl.\n rewrite minus_plus_plus.\n rewrite plus_comm.\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n functional induction n.\n intro.\n rewrite (IHnat n).\n reflexivity.\n simpl in |- *.\n rewrite (IHnat (S (S (S n))) (S (S (S (S n))) (S (S (S (S (S n))) (S (S (S (S n)))) (S (S (S (S (S (S (S n)))) (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n rewrite (IHnat).\n reflexivity.\n intros.\n simpl in |- *.\n rewrite (IHnat).\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n unfold hd in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 3 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 3 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 3 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 3 in |- *.\n unfold hd at 2 in |- *.\n unfold hd at 2 in |- *.\n unfold hd atQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2 n m).\n rewrite <- (nth_eq2Qed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n unfold app in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite (Hrec (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S(S(S(S (S (S (S(S (SQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n reflexivity.\n intro.\n simpl in |- *.\n reflexivity.\n intro.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n simple induction n.\n intros.\n apply False_ind.\n apply Cons_eq2.\n apply Cons_eq2.\n apply Cons_eq2.\n apply H0.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 6573,
                "proof_end_offset": 6640,
                "proof": "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6642,
                "proof_end_offset": 6758,
                "proof": "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n induction n.\n simpl in |- *.\n intros.\n apply IH.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intros.\n unfold lx_ins in |- *.\n unfold lx_ins in |- *.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfold lx_rec in H.\n unfoldQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n unfold lx_By in |- *.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n simple induction n.\n simple induction n.\n simple induction n.\n simpl in |- *.  intros.\n apply IHm.\n simpl in |- *.\n intros.\n simpl in |- *.\n intros.\n simpl in H.\n simpl in H.\n elim H.\n intros.\n simpl in |- *.\n apply IHm.\n simpl in |- *.\n intros.\n simpl in |- *.\n intros.\n simpl in H.\n elim H.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in |- *.\n elim H.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in |- *.\n elim H0.\n intros.\n simpl in H.\n elim H0.\n intros.\n simpl in H0.\n elim H0.\n intros.\n simpl in |- *.\n elim H0.\n intros.Qed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\ninduction n.\nsimpl in |- *.\n trivial.\nintros.\nsimpl in |- *.\nrewrite hd_eq2.\napply H.\napply H.\napply H.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intros.\n apply lx_rec_eq1.\n apply lx_rec_eq1.\n apply lx_rec_eq2.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n simple induction n.\n simpl in |- *.\n trivial.\n intro.\n rewrite hd_eq2.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intros.\n unfold lx_rec in |- *.\n elim n.\n intro.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\n",
                "context_tokens": 711,
                "proof_start_offset": 6851,
                "proof_end_offset": 7541,
                "proof": "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\nintros.\nrewrite ins_eq1.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\nintro.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\nrewrite sorted_eq3.\nsplit.\napply H2.\napply (sorted_cdr m).\nassumption.\nintro.\nrewrite sorted_eq3.\nsplit.\napply (sorted_inf m x0 l).\nassumption.\napply H.\nassumption.\napply (sorted_cdr m).\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros x n.\n case x.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n intros.\n apply H0.\n simpl in |- *.\n introsQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intro.\n unfold sorted in |- *.\nintro.\n apply H.\n trivial.\n intro.\n elim H0.\n intro.\n elim (H x).\n intro.\n apply H0.\n trivial.\n intro.\n apply H.\n trivial.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H0.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H0.\n simpl in |- *.\n intros.\n inversion H0.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H0.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |-Qed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n intro.\n inversion H0.\nintros.\ninversion H1.\nintros.\ninversion H1.\nintros.\ninversion H2.\nintros.\ninversion H3.\nintros.\ninversion H3.\nintros.\ninversion H3.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.\nintros.\ninversion H4.Qed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\n tauto.\n simpl in |- *.\n tauto.\n simpl in |- *.\n tauto.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n apply le_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_S_n.\n simpl in |- *.\n intros.\n apply le_Qed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros.\napply sorted_rec.\nintros.\napply sorted_rec.\nintros.\napply sorted_inf.\nintros.\napply sorted_rec.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\napply H.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\napply H.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\nintros.\napply sorted_inf.\napply H.\napply sorted_inf.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintro.\n intro.\n apply H.\n assumption.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros.\ninduction m.\n simpl in |- *.\nauto.\n simpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n intros.\n unfold not in |- *.\n intros.\n unfold not in |- *.\n intros.\n apply (H x).\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 7543,
                "proof_end_offset": 7836,
                "proof": "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply si_intro.\nintros.\nrewrite sorted_eq3.\nsplit.\nassumption.\nassumption.\nintro.\napply sorted_ins_Cons.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite insert_eq1.\n rewrite (insert_eq2 x).\n apply IH.\napply insert_eq2. assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nunfold insert in |- *.\nintros n.\ninduction n.\n simpl in |- *.\nintros.\napply insert_eq1 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insert_eq2 with (x := x).\napply insertQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\ninduction n.\n simpl in |- *. intros.\n apply (sorted_drop_one n (Cons nat n x)).\nintro.\nrewrite (sorted_drop_zero n (Cons nat n x)).\nsplit.\n   apply (sorted_drop_one n (Cons nat n x)).\n apply (sorted_drop_one n (Cons nat n x)).\napply (sorted_drop_one n (Cons nat n x)).\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nintro.\nunfold sorted in |- *.\nintro.\napply (sorted_ins_eq1 n x).\nintro.\napply (sorted_ins_eq1 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq1 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\napply (sorted_ins_eq2 n x).\nintro.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nintros.\napply sorted_ins_ind.\napply (sorted_inf _ _ _ _ _ _ H).\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n simple induction n.\n intro.\n rewrite (Hrec _ _ _ H).\n intro.\n rewrite (Hrec _ _ _ H).\n intro.\n rewrite (Hrec _ _ _ H0).\n intro.\n rewrite (Hrec _ _ _ H0).\n intro.\n rewrite (Hrec _ _ _ H0).\n intro.\n rewrite (Hrec _ _ _ H0).\n intro.\n rewrite (Hrec _ _ _ H0).\n intro.\n rewrite (Hrec _ _ _ H1).\n intro.\n rewrite (Hrec _ _ _ H1).\n intro.\n rewrite (Hrec _ _ _ H0).\n intro.\n rewrite (Hrec _ _ H1).\n intro.\n rewrite (Hrec _ _ H1).\n intro.\n rewrite (Hrec _ _ H1).\n rewrite (Hrec _ _ H1).\n intro.\n rewrite (Hrec _ _ _ H1).\n intro.\n rewrite (Hrec _ _ _ H1).\n intro.\n rewrite (Hrec _ _ H1).\n intro.\n rewrite (Hrec _ _ H1).\n intro.\n rewrite (Hrec _ _ H1).\n intro.\n rewrite (Hrec _ _ _ H1).Qed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\nintro.\n intro.\n apply (sorted_leaf _ _ _ _ _ _ _ _ _ _ H0).\nintro.\n rewrite (sorted_eq2 n x).\nrewrite (sorted_eq2 n x).\nrewrite (sorted_eq2 n x).\nrewrite (sorted_eq2 n x).\nrewrite (sorted_eq2 n x).\nrewrite (sorted_eq2 n x).\napply H.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *.\nintro.\n apply (sorted_ins_eq2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n intro.\n rewrite (insert_eq2 n x).\n intro.\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewrite (insert_eq2 n x).\n rewriteQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n intro.\n rewrite (sorted_eq2 n).\n split.\n   apply sorted_inf.\n   assumption.\n intros.\n rewrite (sorted_eq2 n).\n split.\n   apply (sorted_inf m x).\n   assumption.\n   apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7983,
                "proof_end_offset": 8871,
                "proof": "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\nintro.\nrewrite nocc_eq2.\napply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite (nocc_eq2 n m x).\napply si_intro.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n intros.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.\nrewrite hd_eq2.Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction x.\n trivial.\nintros.\napply (nfin_Cons_Cons nat p n).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tail_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tl_Cons nat p).\napply (tlQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n trivial.\nintros.\nrewrite (nInd_Cons_Cons n m x).\nrewrite (nInd_Cons_Cons n m x).\nrewrite (nInd_Cons_Cons _ m x).\napply (nInd_Cons_Cons m x).\nassumption.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n intro.\nrewrite <- H.\nrewrite (nfin_monotonic_aux_aux n m p).\nrewrite (nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewrite (S_nfin_monotonic_aux n m p).\nrewriteQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl.\nintro.\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewrite (nil_ind nat).\nrewriteQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n intro.\n rewrite (nInd_conv_aux_conv_aux_conv_aux_conv_aux_conv_aux_conv_aux_aux.\napply n.\nintro.\napply (nInd_conv_aux_conv_aux_conv_aux_conv_aux_conv_aux_conv_aux_conv_aux_conv_aux_aux_conv_aux_aux_conv_aux_aux_conv_aux_aux.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n intro.\nrewrite insert_eq2.\nrewrite insert_cons.\nrewrite insert_cons.\nrewrite insert_cons.\napply (nfin_monotonic x).\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n intro.\n rewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assoc.\nrewrite hd_assocQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n trivial.\n intros.\n rewrite (nocc_Cons _ _ _ _ _ _ H0).\nrewrite (nocc_Cons _ _ _ _ _ _ H0).\ntrivial.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl.\n rewrite <- (nfin_monotonic n p).\n rewrite <- (nfin_monotonic n p).\n rewrite <- (nfin_monotonic p p).\n rewrite <- (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\n rewrite (nfin_monotonic p p).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 8873,
                "proof_end_offset": 9171,
                "proof": "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\nassumption.\nintro.\nrewrite H0.\nsimpl in |- *.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_ind.\n intro.\n rewrite (nocc_eq2 n p (Cons nat m y)).\n apply nocc_ind.\n intro.\n rewrite nocc_eq2.\n rewrite H0.\n apply nocc_ind.\n intro.\n rewrite (nocc_eq2 n p (Cons nat m y)).\n apply (nocc_ind (fun p : nat => p = S (S (nocc n (Cons nat m y))))\n  (n (fun p : nat => p = S (natch n (Cons nat m y)))\n  (n (fun p : nat => p = S (n <=? m))))\n  (n (fun p : nat => p = S (n :: m)))\n  (n (fun p : nat => p = S (n :: m))))\n  (n (fun p : nat => p = S (n :: m)))\n  (n (fun p : nat => p = S (n :: m))))\n  (n (fun p : nat => p = S (n :: m)))\n  (n (fun p :Qed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_ind. assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_ind.\n intro.\n rewrite nocc_eq2.\n apply nocc_ind.\n intro.\n rewrite nocc_eq2.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n apply H.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply nocc_ind.\napply (nInd_intro (list nat) (fun x : list nat => n = S (S (nInd_ind _ x))).\n  intro.\n  rewrite nInd_eq2.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  reflexivity.\n  intro.\n  rewrite (nInd_eq2 n m x).\n  rewrite H.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply nocc_ind.\ntrivial.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n simple induction n.\n simpl in |- *. intros.\n rewrite (nInd_eq2 n m y).\n rewrite H.\n reflexivity.\n intro.\n rewrite nInd_eq2.\n rewrite H.\n reflexivity.\n intro.\n rewrite H.\n reflexivity.\n intro.\n rewrite H.\n reflexivity.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m y)).\n apply nocc_ind.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_Cons. assumption. assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_Cons_Cons. assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_ind.\n rewrite H.\n apply nocc_ind.\n intros.\n rewrite (nocc_eq2 n m y).\n apply H.\n apply (n fin_inj).\n intro.\n rewrite (nocc_eq2 n m y).\n apply nocc_ind.\n intro.\n rewrite (ninterp_eq2 n m y).\n apply nocc_ind.\n rewrite H.\n apply (nfin_inj).\n intro.\n rewrite (ninterp_eq2 n m y).\n apply nocc_ind.\n rewrite H.\n apply H.\n apply (nfin_inj).\n intro.\n rewrite H.\n apply nocc_ind.\n rewrite H.\n apply nocc_ind.\n rewrite H.\n apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 9173,
                "proof_end_offset": 9520,
                "proof": "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\ntrivial.\nintro.\nrewrite nocc_Cons_Cons.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\n intros.\n unfold nocc in |- *.\n apply nocc_ind.\n intro.\n rewrite nocc_eq2.\n apply (foo_refl_equal nat (S m)).\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply (nocc_ind_Cons nat (fun x : nat => x = n) (fun x : nat => x = n) (fun x : nat => x = m)).\nintro.\nrewrite nInd_eq2.\nrewrite H.\nrewrite H0.\napply (nInd_intro (fun x : nat => x = n) (fun x : nat => x = m) (fun x : nat => x = m)).\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_Cons.\n intro.\nrewrite H0.\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n simpl in |- *.\ntauto.\n simpl in |- *.\nintros.\napply nocc_Cons_Cons. assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nInd_ind.\n intro.\nrewrite nInd_eq2.\nrewrite H.\nsimpl in |- *.\nassumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nmake in |- *.\napply nInd_ind.\nintro.\nrewrite H0.\nsimpl in |- *.\napply H0.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_Cons_Cons. assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\n intros.\n unfold nocc in |- *.\n apply nInd_ind.\n intro.\n rewrite nInd_eq2.\n apply (nInd_ind (fun p : nat => p = S (nocc n (Cons nat m x)))).\n intro.\n rewrite nInd_eq2.\n apply (nInd_ind (fun p : nat => p = S (nocc n (Cons nat m x)))).\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nInd_intro.\nintro.\nrewrite (ninterp_eq2 m n).\napply (nim_intro n).\nintro.\nrewrite (ninterp_eq2 m n).\napply (nim_intro n).\nintro.\nrewrite (nim_intro n).\napply (nim_intro n).\nintro.\nrewrite (nim_intro n).\napply (nim_intro n).\nintro.\nrewrite (nim_intro n).\napply (nim_intro n).\nintro.\nrewrite (nim_intro n).\napply (nim_intro n).\nintro.\nrewrite (nim_intro n).\napply (nim_intro n).\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\n intros.\n unfold nocc in |- *.\n apply nocc_ind.\n intro.\n rewrite (ninterp_eq2 n m x).\n apply nocc_ind.\n intro.\n rewrite (ninterp_eq2 n m y).\n apply nInd_ind.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 9522,
                "proof_end_offset": 9729,
                "proof": "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite tri_ins_eq2.\nrewrite nocc_ins.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintro.\nrewrite (nocc_eq2 n p (Cons nat p n)).\napply (IHn (index p n)).\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\nrewrite (nocc_eq2 n p).\napply (tail_irrefl (n:=n)).\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\napply (nocc_ind (list nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> n :>nat) (fun t : list nat => n <> nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n simple induction x.\n trivial.\n intros.\n rewrite nocc_eq2.\n apply (ys0 (S n)).\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n simple induction x.\n trivial.\n intros.\n rewrite (nocc_eq2 n p (Cons nat p (Cons nat p (Cons nat p x))).\n trivial.\n intro.\n rewrite nocc_eq2.\n rewrite (nocc_eq2 n p (Cons nat p (Cons nat p (Cons nat p x))).\n trivial.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\napply nocc_Cons.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply nocc_Cons.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\nrewrite (nocc_eq2 n p (Cons nat n (Cons nat n (Cons nat n p x))).\napply nocc_Cons.\napply (IHn nat (fun t : list nat => n Is n t = n :: n)).\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\nrewrite (nocc_eq2 n p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p)))) (Cons nat p))))\n    (fun t : list nat => ninterp n t = n free n t) (fun t : list nat => ninterp n t = ninterp n t)).\nProof.\nintros.\nrewrite (nInd_eq2 n p (Cons nat p (Cons nat p (Cons nat p (Cons nat p (Cons nat p)))) (Cons nat p))).\napply nInd_eq2.\napply H.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\nrewrite insert_eq2.\napply (foo_trans (list nat)\n     (fun t : list nat => nocc n t = n member n t)).\napply nInd_ind.\nintro.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply nInd_ind.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 10123,
                "proof_end_offset": 10190,
                "proof": "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bub concat_aux.\napply bubym.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bub Rev.\napply bubpairs_aux.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bubym in |- *.\nrewrite <- (plus_n_O n).\napply plus_n_Sm.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bubregs.\napply bub Injective_eq1.\napply bub Injective_eq1.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bubcomplement in |- *.\napply bubEmbed_eq1.\napply bub rtimes_eq1.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bubded.\napply bubcmpu_eq1.\napply bublxor_eq2.\napply bublxor_eq1.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bubym in |- *.\napply bubfl.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bub alt in |- *.\napply bub Injective_eq1.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\n trivial.\nintros.\nrewrite <- (refl_equal (length (x :: nil)) (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil)).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (x :: nil))).\nrewrite <- (refl_equal (length (xQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bubpairs.\napply bubTrace.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 10192,
                "proof_end_offset": 10301,
                "proof": "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  induction n.\n  simpl.\n  rewrite IH.\n  simpl.\n  rewrite IH.\n  simpl.\n  rewrite IH.\n  reflexivity.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  trivial.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  intros.\n  apply bubym.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n intros.\n unfold bub maxRat_aux.\n rewrite <- (bubym_eq1 n).\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite mult_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite plus_comm.\n simpl in |- *.\n rewrite <- plus_comm.\n simpl in |- *.\n rewrite mult_comm.\n simpl in |- *.\n rewrite mult_comm.\n simpl in |- *.\n rewrite (mult_comm b2).\n simpl in |- *.\n rewrite mult_comm.\n simpl in |- *.\n rewrite (mult_comm b2).\n simpl in |- *.\n rewrite (mult_comm b2).\n simpl in |- *.\n rewrite (mult_comm b2).\n simpl in |- *.\n rewrite (mult_comm b2).\n simpl in |-Qed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  intros.\n  simpl in |- *.\n  reflexivity.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  intros.\n  unfold bub bx_aux.\n  apply bub Injective_eq1.\n  apply bubym_eq2.\n  apply bubym_eq2.\n  apply bubym_eq2.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat). \nProof.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ".\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\n",
                "context_tokens": 682,
                "proof_start_offset": 10302,
                "proof_end_offset": 10522,
                "proof": "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  unfold bubised in |- *.\n  elim (le_or_lt n m).\n  auto.\n  intro.\n  rewrite (nerr ld nat).\n  apply IH.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  simpl in |- *.\n  unfold bubpairs in |- *.\n  rewrite <- plus_n_O.\n  simpl in |- *.\n  rewrite H.\n  rewrite plus_n_O.\n  simpl in |- *.\n  rewrite <- plus_n_O.\n  simpl in |- *.\n  rewrite <- plus_n_O.\n  reflexivity.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nintros.\nunfold bubGuts in |- *.\napply bubapt_eq1.\napply bubym_eq3.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nintros.\nunfold bub familiarity in |- *.\napply buburd_ind.\napply H.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite (IHnat m).\n simpl in |- *.\n rewrite (plus_comm (S (S (S m))).\n apply plus_le_compat.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nsimple induction n.\n trivial.\n intros.\n rewrite hd_eq2.\n simpl.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\n rewrite hd_eq1.\n rewrite hd_eq2.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  unfold bub getMax in |- *.\n  rewrite (Hrec nat (Cons nat (Cons nat n m (Cons nat m x))) (Cons nat m (bub)))...\n  trivial.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  simple induction n.\n  trivial.\n  intros.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nsimple induction n.\n simpl in |- *.\n intros.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl in |- *.\n rewrite (H 0).\n simpl inQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  induction n.\n  trivial.\n  simpl.\n  rewrite IH.\n  simpl.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 11196,
                "proof_end_offset": 11281,
                "proof": "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  rewrite fifth_length.\n  rewrite plus_n_Sm.\n  apply plus_n_O.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  induction 1; simpl.\n  auto.\n  rewrite IHm.\n  simpl.\n  rewrite IHm.\n  rewrite IHm.\n  rewrite IHm.\n  rewrite IHm.\n  rewrite IHm.\n  simpl.\n  rewrite IHm.\n  rewrite IHm.\n  auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  induction x; destruct x; simpl; trivial.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  unfold fusion.\n  rewrite (fusion_eq1).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewrite (fission_eq2).\n  rewriteQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  induction e.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  induction f ; simpl.\n  auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  induction 1; auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n induction 1; simpl; auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\ninduction f;[ | x : list nat] using f [@ | x : list nat] using f [@ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat] using f [ | y : list nat]Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 11283,
                "proof_end_offset": 11406,
                "proof": "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros.\n destruct n.\n simpl.\n rewrite H.\n reflexivity.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros.\n rewrite <- fNth_eq2.\n rewrite <- fission.\n rewrite <- fission.\n rewrite <- fission.\n rewrite <- fission.\n rewrite <- fission.\n rewrite <- fission.\n rewrite <- fission.\n reflexivity.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros.\n unfold fvstore.\n rewrite <- fummies_eq2.\n rewrite <- f feq_eq2.\n rewrite <- fusion_eq1.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq1.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq1.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewriteQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros.\n simpl.\n rewrite <- plus_n_O.\n simpl.\n rewrite plus_n_O.\n simpl.\n rewrite <- plus_n_O.\n simpl.\n reflexivity.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros.\n rewrite <- fusion_eq2.\n rewrite <- fusion_eq2.\n rewrite <- fusion_eq2.\n rewrite <- f feq_eq2.\n rewrite <- fusion_eq2.\n rewrite <- f feq_eq2.\n rewrite <- ftyz_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f fifo_eq2.\n rewrite <- fusion_eq2.\n rewrite <- f feq_eq2.\n rewrite <- fission_eq2.\n rewrite <- fusion_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eq2.\n rewrite <- f feq_eqQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n  intros.\n  induction n.\n  simpl.\n  rewrite plus_n_O.\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros n.\n induction ns.\n simpl.\n rewrite IHs.\n reflexivity.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n  intros.\n  unfold fusion.\n  destruct n.\n  reflexivity.\n  reflexivity.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\nLemma fusion_eq2 :\n forall (n : nat) (ns : list nat),\n fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 11408,
                "proof_end_offset": 11665,
                "proof": "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n  intros.\n  induction ns.\n  simpl.\n  rewrite IH.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros n.\n functional induction n.\n simpl in |- *.\n rewrite f {_}.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fifth_l in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fuction_r in |- *.\n unfold fusion_r in |- *.\n unfold fifth_l in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\n unfold fuction_r in |- *.\n unfold fusion_r in |- *.\n unfold fifth_r in |- *.\n unfold fusion_r in |- *.\n unfold fusion_r in |- *.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros.\n rewrite fusion_eq3.\n rewrite <- farb.\n rewrite <- ffirstn.\n rewrite <- ffirstn.\n rewrite <- ffirstn.\n rewrite <- fproduct.\n rewrite <- ffirstn.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- ffirstn.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewrite <- fproduct.\n rewriteQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n induction n; simpl; intros.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eq3 n0 n0); simpl; auto.\n destruct (fusion_eqQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros.\n destruct (figeonhole_eq_2 n n0) as [H|H].\n apply H.\n apply H.\n apply H.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n  intros.\n  rewrite fMapFold_eq3.\n  rewrite fMapFold_eq3.\n  rewrite <- fusion_eq3.\n  rewrite <- fTlOK_eq3.\n  rewrite <- fNth_eq3.\n  rewrite <- fNth_eq3.\n  rewrite <- fission_eq3.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.\n  rewrite <- fission_eq4.Qed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros.\n destruct (le_lt_dec n (f tfn (Cons nat n) (Cons nat m ms) (Cons nat m ms))).\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_n_Sm.\n rewrite plus_comm.\n rewrite plus_n_Sm.\n rewrite plus_comm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_n_Sm.\n rewrite plus_comm.\n rewrite plusQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros.\n induction m.\n simpl.\n rewrite (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (fusion_eq3 n0 (f)))...\n intros.\n rewrite <- fusion_eq3.\n rewrite <- fusion_eq3.\n rewrite <- fusion_eq3.\n rewrite <- fNth_eq3.\n rewrite <- fission_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fission_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewrite <- fproduct_eq3.\n rewriteQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros.\n rewrite fTlOK.\n rewrite fequals_eq3.\n rewrite fequals_eq3.\n rewrite fequals_eq3.\n rewrite fequals_eq3.\n rewrite fequals_eq3.\n rewrite fequals_eq3.\n rewrite fequals_eq4.\n rewrite fequals_eq3.\n rewrite fequals_eq4.\n rewrite fequals_eq3.\n rewrite fequals_eq3.\n rewrite fequals_eq3.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq5.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_eq4.\n rewrite fequals_Qed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros n m.\n induction m; simpl; auto.\n intros n0 H.\n destruct (fapt_sort n0 (fusion n0 (fusion n0 (Cons nat n0 l2)))) as [H|H].\n rewrite <- H.\n rewrite <- H.\n rewrite <- H.\n rewrite <- H.\n rewrite <- H.\n rewrite H.\n rewrite H.\n rewrite <- H.\n rewrite <- H.\n rewrite H.\n rewrite <- H.\n rewrite H.\n rewrite <- H.\n rewrite H.\n rewrite H.\n rewrite H.\n reflexivity.\nQed."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 753,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\nunfold b.\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Predicate (fun x y => y)).\napply (Build_Save solution'_b.",
                    "Goal solvable b.\napply b.\napply H.\nSave solution'_b.",
                    "Goal solvable b.\nunfold b.\napply b.\nSave solution'_b.",
                    "Goal solvable b.\nintro.\napply H.\nSave solution'_b.",
                    "Goal solvable b.\nunfold b, b in |- *.\nintros.\napply H.\nSave solution'_b.",
                    "Goal solvable b.\nFail apply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napply (Build_Setoid (C:=C)).\napplySave solution'_b.",
                    "Goal solvable b.\nunfold b, b, b.\nintro.\nsubst.\nsplit.\napply H.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.Save solution'_b.",
                    "Goal solvable b.\ndestruct b.\napply H.\nSave solution'_b.",
                    "Goal solvable b.\nunfold b, b.\nunfold b, b in |- *; intros H.\napply H.\nSave solution'_b.",
                    "Goal solvable b.\nunfold b in |- *.\nsplit.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\n- exact I.\nSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 748,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nintros.\nunfold micerve in |- *.\nunfold micOREan_1 in |- *.\nunfold micGutsan_2 in |- *.\nunfold micOREan_1 in |- *.\nunfold micGutsInfix_1 in |- *.\nunfold micGutsInfix_2 in |- *.\n\n(* Moveing the same time we have a single name. *)\n\n(* Moveing the two cases are not needed in the same state *)\n\n(* Moveing the same state is a small-sideer, which is actually a small-sideer. *)\n\n(* Moveing the same state is a small-sideer. *)\n\nGoal Moveing F (Moveing F).\nintros.\napply Mak.\nchange (Moveing F (Masting F (Masting F (Moveing F (Moveing F (Moveing F (Moveing F (Moveing F (Moveing F (Merting F (Moveing F (Moveing F (Moveing F (Moveing F (Moveing F (Moveing F (Moveing F (Moveing F (Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGutsan_2 in |- *.\nsplit.\nunfold micGutsInfix_3 in |- *.\nsplit.\nunfold micGutsTactic_4 in |- *.\nsplit.\nunfold micGutsInfix_4 in |- *.\nsplit.\nunfold micGutsInfix_4 in |- *.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.Save microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\nunfold micOREan_2.\nintros mic members mic.\napply (Build_Map (B micorphism an_2) (B mic csemT an_4) (B micorphism an_4) (B micorphism an_4) (B micorphism an_4) (B micctor an_4) (B micbitsToBytes an_4) (B micContext) (B micctor an_5) (B micorphism an_4) (B micctor an_4) *)\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGutsan_2, micGutsan_3, mic NGan_3, micEalignofan_3, micmkPoolan_3.\nintros.\n\n(* This is actually harder to unfold *)\nFail apply consistent with (micGutsSet_1).\nunfold micGutsan_1, micGutsan_3 in |- *.\napply transpose.\napply consistent with (micPermutedSet_2).\nassumption.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nintros.\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_neg O).\napply(is_power_neg O).\napply(is_power_pos O).\napply(is_power_neg O).\napply (is_power_neg O).\napply(is_power_pos O).\napply(is_power_pos O).\napply(is_power_neg O).\napply(is_power_neg O).\napply(is_power_neg O).\napply(Save microban_1_solution.",
                    "Goal solvable microban_1.\napply(Build_Prop_stable_1 _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_2 _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_3 _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _ _ _).\napply(Build_Prop_stable_4 _ _ _ _ _ _ _ _ _ _ _ _ _).\napply(BuildSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold microtran_1 in |- *.\napply ~micssue.\nunfold micPtrally_1 in |- *.\nunfold micPtrally_1 in |- *.\nunfold mic Doneally_2 in |- *.\nunfold mic********_1 in |- *.\nunfold micCoarsely_2 in |- *.\nunfold micwayly_1 in |- *.\nunfold mic deadvars_1 in |- *.\nunfold mic Bid in |- *.\nunfold mic ipattern:(b) ipattern:(c) ipattern:(d) ipattern:(d) ipattern:(d) ipattern:(H0) ipattern:(H1) ipattern:(H2) ipattern:(H3)\n ipattern:(H4) ipattern:(H5) ipattern:(H5) ipattern:(H6) ipattern:(H7)\n ipattern:(H7) ipattern:(H7) ipattern:(H8) ipattern:(H9) ipattern:(H8) ipattern:(H9)\n ipattern:(H9) ipattern:(H9) ipattern:(H9) ipattern:(H9) ipattern:(H9) ipattern:(H9)\n ipattern:(H9) ipattern:(H9) ipattern:(H9) ipattern:(H9) ipattern:(Save microban_1_solution.",
                    "Goal solvable microban_1.\napply consistent_side_1.\napply all_equiv_1.\napply all_equiv_2.\napply all_equiv_1.\napply all_equiv_3.\napply all_equiv_1.\napply all_equiv_2.\napply all_equiv_3.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.\napply all_equiv_4.Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micShiftcalan_2.\nunfold micGutsInfix_1.\nunfold micTIiso oc_1 in |- *.\nunfold micGutsInfix_1.\nunfold micGutsInfix_2.\nunfold micefinan_2 in |- *.\nunfold micOREan_1 in |- *.\nunfold micGutsInfix_1.\nunfold micGutsInfix_2.\nunfold micCOPYINGInfix_3.\nunfold micCOPYINGat_1.\nunfold micGutsInfix_2.\nunfold micTIiso oc_2 in |- *.\nunfold micGutsInfix_1.\nunfold micGutsInfix_3.\nunfold micObjat_2 in |- *.\nunfold micObjat_2 in |- *.\nunfold micGutsInfix_3.\nunfold micxmat_1 in |- *.\nunfold mic gbat_1 in |- *.\nunfold micGutsInfix_3.\nunfold mic >>\"\n\n(* The following lemma is used in the same proof of the proof of the proof of the proof of the proof of the proof in the proof of the proof in the proof. *)\n\n(** * The proof ofSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGutsan_2 in |- *.\nsplit.\napply full_uniqueness with O E E' O.\napply all_trivial.\nassumption.\nassumption.\nassumption.\nassumption.\nSave microban_1_solution."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\n",
                "context_tokens": 356,
                "proof_start_offset": 1314,
                "proof_end_offset": 1504,
                "proof": "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs.\nsimpl.\napply head_insertion.\nsimpl.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nsimple induction xs.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nsimple induction xs; simpl in |- *; intros.\napply in_or_app; trivial.\napply in_or_app; trivial.\napply in_or_app; trivial.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nsimple induction xs; intros.\nauto with datatypes.\nintros.\napply H.\nauto with datatypes.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs; simpl; auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs; simpl in |- *; intros; trivial.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nunfold'))) in |- *.\nintro.\napply (H _ H).\napply (H _ H).\napply (H _ H).\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros A x xs.\ninduction xs.\nsimpl.\nauto.\nsimpl.\nauto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nunfold insertion in |- *.\nintros x xs.\napply (tail_insertion_drop x xs); assumption.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nunfold insertion in |- *.\nintro.\napply (tail_insertion A x l l' (cons x nil) (head x)).\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros.\napply (app_ass A x xs (cons x nil)).\napply (app_ass A x xs (cons x nil)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\n",
                "context_tokens": 435,
                "proof_start_offset": 1551,
                "proof_end_offset": 1679,
                "proof": "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\nintros.\ninduction H;simpl;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  simple induction l.\n  simpl.\n  apply IHl.\n  intros.\n  apply (app_removelast_tl_preserves_in _ _ _ _ H).\n  apply H0.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\ninduction l.\nsimpl.\napply app_ass.\napply (app_ass A x l l' l' l' l' l' H).\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  apply (app_or_or_or_or _ _ _ _ H).\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\ninduction l.\nsimpl.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.\napply app_ass.Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  simple induction l.\n  simpl.\n  apply head_'))).\n  simpl.\n  apply tail_')).\n  simpl.\n  apply head_unfolding.\n  intros.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  induction l.\n  simpl.\n  apply app_ass.\n  simpl.\n  apply app_ass.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\ninduction l.\n simpl.\napply app_cons.\nauto.\napply app_cons.\napply app_cons.\nauto.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  intros.\n  apply (app_head_unfolding _ _ _ _ _ _ _ _ _ _ _ l').\n  apply (app_head_unfolding _ _ _ _ _ _ _ _ _ l').\n  apply (app_head_unfolding _ _ _ _ _ _ _ _ _ _ _ _ _ l').\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  intros.\n  apply (insert_occ_tail_occ_tail_occ_tail_occ_tail_occ_tail_occ_head_in_in_insert_in.\n  apply IHl.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\n  apply app_ass.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  apply app_nil_end.\n  simpl.\n  apply app_nil_end.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\n",
                "context_tokens": 500,
                "proof_start_offset": 1735,
                "proof_end_offset": 1960,
                "proof": "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;simpl;try tauto.\ncase H0;try tauto.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l.\n  simpl.\n  apply head_??.\n  apply (head_')))).\n  apply (tail_Upd1 _ _ _ _ _ H0).\n  apply (head_prem2 _ _ _ _ _ _ _ H0).\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H.\n  simpl.\n  apply tl_pop.\n  apply (tl_pop (A:=A) (l0:=x) (l0:=x) (l1:=x) (l1:=x) (l2:=x) (l1:=x) (l2:=x) (l1:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (l2:=x) (Qed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l.\n  simpl in H.\n  apply IHl.\n  simpl in H.\n  apply H.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl;tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl;tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  apply H.\n  apply (H (head_'')); auto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H.\n  simpl.\n  apply head_contin.\n  apply IHl.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l.\n  simpl.\n  apply tail_ November;auto.\n  simpl.\n  applyhead_insertion.\n  auto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l.\n  simpl.\n  apply IHl.\n  simpl; apply IHl.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l.\n  simpl in *.\n  apply (app_removelast_?]]]]]; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\n",
                "context_tokens": 603,
                "proof_start_offset": 2029,
                "proof_end_offset": 2310,
                "proof": "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\ninduction l;simpl;try tauto;intros.\ncase H;intro.\nrewrite H0;exists l;apply head_insertion.\nelim (IHl H0);intro l';intro.\nexists (a::l');apply tail_insertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  case (in_equivlistA_right A x l l'); intros.\n  apply in_app_or_app_or in H0; auto.\n  apply in_split_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_app_or_app_or in H0; auto.\n  apply in_Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l.\n  simpl.\n  apply in_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  apply in_app_or_app.\n  apply in_app_or_app.\n  eapply in_or_app_or_app.\n  apply in_or_app_or_app.\n  apply in_app_or_app.\n  eapply in_app_or_app.\n  eapply in_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  eapply in_or_app_or_app.\n  eapplyQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case (in_app_or _ _ _ H H); auto.\n  inversion H0;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  case (in_??.\n  left;auto.\n  right;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  exists (nil (nil (nil (nil (cons x nil))).\n  exists (nil (nil (cons x nil))).\n  apply in_or_app; auto.\n  apply in_or_app; auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  exists (nil (x::l)).\n  split.\n  simpl.\n  apply (in_insert_everywhere x l l' H).\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l.\n  simpl.\n  apply in_or_app.\n  inversion H.\n  left;apply in_or_app.\n  eapply in_or_app.\n  apply in_or_app.\n  eapply in_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  apply in_or_app.\n  eapply in_app.\n  eapply in_or_app.\n  apply in_or_app.\n  eapply in_or_app.\n  apply in_or_app.\n  eapply in_app.\n  apply in_or_app.\n  eapply in_app.\n  eapply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  eapply in_app.\n  apply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_app.\n  eapply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l;simpl;tauto.\n  case H0;try tauto.\n  case H0;try tauto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros; exists (nil (A:=A)).\n  exists (nil (A:=A)).\n  exists (nil (A:=A)).\n  exists (nil (A:=A)).\n  exists (nil (A:=A)).\n  exists (nil (A:=A)).\n  exists (nil (A:=A)).\n  exists (nil (A:=A)).\n  split.\n  apply app_ass.\n  apply app_ass.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;intros.\n  exists (nil A).\n  apply app_ass.\n  simpl.\n  apply IHl.\n  simpl.\n  apply app_ass.\n  simpl.\n  apply app_ass.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "riais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\n",
                "context_tokens": 694,
                "proof_start_offset": 2378,
                "proof_end_offset": 2605,
                "proof": "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\nProof.\nintros.\ninduction H;simpl in H0.\ncase H0;intro H1;try (symmetry in H1);tauto.\ncase H0;simpl;intro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case (in_indexes_inv _ _ _ H0);intro.\n  destruct (in_indexes_inv _ _ _ H1).\n  elim (IHl H1);intro.\n  exists (a::l');apply in_map_iff;trivial.\n  rewrite H1; apply in_map_iff;trivial.\n  apply in_map_iff;trivial.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  case (in_dests A x l');intro.\n  left;auto.\n  right;auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros; inversion_clear H.\n  case H;intros.\n  rewrite in_map_iff in H1.\n  assert (in_list l).\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_app_or in H1.\n  destruct H1.\n  apply in_or_appQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros; apply in_]]]]]]].\n  elim (in_app_or _ _ _ H); intro.\n  rewrite H0;exists l0;apply in_app_or; auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros; elim (in_zip_inv _ _ _ H); intro.\n  exists l; applyhead_ November;trivial.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  case H0;intro.\n  rewrite H1; exists l0; apply head_Tri;trivial.\n  elim (IHl H0);intro.\n  rewrite H2; exists l; apply head_Multi;trivial.\n  apply in_or_app; auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  inversion_clear H;inversion_clear H;inversion_clear H; inversion_clear H; inversion_clear H; inversion_clear H.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction l;simpl;try tauto;intros.\n  case H;intros.\n  apply in_or_app; assumption.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros; apply in_xelements;apply in_]]]]]]].\n  destruct (in_insert x l l);elim (in_insert x l');intro; simpl; auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case H0;try tauto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2890,
                "proof_end_offset": 3177,
                "proof": "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\ninduction 1;intros.\ninversion H;trivial.\ninversion H0.\napply cons_is_set.\napply IHinsertion;trivial.\nintro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l.\n  simpl;tauto.\n  intros.\n  case H0;intros.\n  constructor.\n  simpl.\n  apply IHl.\n  apply (IHl x).\n  apply (IHl x).\n  apply (IHl x).\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l.\n  simpl.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  applyQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l.\n  simpl.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app_or_or_or_or_or_or_or_or_or_or.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros.\n  case H;simpl in H0;apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_appQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l.\n  simpl.\n  apply (in_app_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or.\n  left;tauto.\n  right;tauto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l;simpl;try tauto;intros.\n  case H0;try tauto;intros.\n  case H0;try tauto;intros.\n  apply in_or_app;auto.\n  apply in_or_app;auto.\n  apply in_or_app;auto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l.\n  simpl.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l.\n  simpl.\n  apply l'.\n  intros.\n  case (in_set A (x::l)); intro.\n  apply H0.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l.\n  simpl;tauto.\n  case H0;intros.\n  case H1;intros.\n  case H1;intros.\n  case H2;intros.\n  apply in_or_app; assumption.\n  apply in_or_app; assumption.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l.\n  simpl; tauto.\n  simpl; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\n",
                "context_tokens": 713,
                "proof_start_offset": 3243,
                "proof_end_offset": 3575,
                "proof": "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;rewrite <- H3 in H0;inversion H0.\nsimpl in H7;trivial.\nintro.\ncase H10;intro.\napply H9;rewrite H11;eapply insertion_in;apply H5.\nelim (IHl l'0 x H5 H8 H11).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  apply not_and_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_or_orQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction 1;intros.\n  inversion H;trivial.\n  case H0;intro.\n  case H1;intros.\n  case H2;intro.\n  apply in_or_app_or_or_or_or_or_or_or_or.\n  apply in_or_app_or_or_or_or.\n  apply in_or_app_or_or.\n  apply in_or_app_or.\n  apply in_or_app_or_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_app_or.\n  apply in_or_app_or_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_or.\n  apply in_or_app_orQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction l.\n  simpl.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.Qed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l.\n  simpl.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n  apply not_In_cons.\n Qed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\ninduction 1;intros.\nconstructor;auto.\nconstructor;auto.\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napply (H4 x).\napplyQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  apply (IHl H1).\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H2.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_app_or in H1.\n  apply in_or_appQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;intros.\n  simpl.\n  case H0;intros; assumption.\n  apply IHl'.\n  apply H0;apply (IHl' H1).\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l.\n  simpl;apply is_set_'....\n  constructor;intros.\n  inversion H;trivial.\n  constructor;intros.\n  inversion H;trivial.\n  constructor;intros.\n  inversion H;trivial.\n  constructor;intros.\n  apply (IHl H0 H1).\n  constructor;intros.\n  inversion H0;trivial.\n  constructor;intros.\n  apply (IHl H0 H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n  constructor;intros.\n  apply (IHl H1).\n Qed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  unfold is_set;simpl;try tauto;intros.\n  case H0;intros.\n  apply In_not_set;trivial.\n  apply (IHl H0);apply (IHl H0);apply (IHl H0).\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros; eapply is_set_ WITHOUTin.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\nLemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;rewrite <- H3 in H0;inversion H0.\n  simpl in H7;trivial.\n  intro.\n  case H10;intro.\n  apply H9;rewrite H11;eapply insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\n",
                "context_tokens": 697,
                "proof_start_offset": 4672,
                "proof_end_offset": 5534,
                "proof": "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros;simpl in H.\ndestruct l'.\napply nil_is_permutation.\nelim (H a);intros.\nelim H3;simpl;tauto.\ninversion H0.\nsymmetry in H2;rewrite H2 in H;elim (H a);intros.\nrewrite H2 in H6;rewrite H2.\nassert (In x l');auto.\nelim (in_insertion A x l' H8).\nintro l'';intro.\napply cons_is_permutation with l'';trivial.\napply IHl;trivial.\nsplit;intro.\nelim (H x0);intros.\nelim (in_insertion_inv A x0 x l'' l');auto.\nintro;rewrite H13 in H10;rewrite H2 in H5;tauto.\nelim (H x0);intros.\ncase H12;try tauto.\napply (insertion_inclusion A x l'' l');trivial.\nintro;rewrite <- H13 in H10.\nelim (is_set_insertion_in A l'' l' x);trivial.\neapply is_set_insertion;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros.\ninversion H.\nelim (in_insert_in _ _ _ _ _ H).\napply H0;trivial.\napply (in_insert_in _ _ _ _ _ H0).\napply H0;trivial.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l; simpl;auto.\ndestruct l'; simpl;auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l.\nconstructor.\nconstructor.\nconstructor;intro.\neapply IHl.\neapply IHl.\neapply IHl.\napply (H1 H0).\napply (H1 H2).\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros.\ninversion H;trivial.\nsimpl in H.\ninversion H.\ninversion H.\ninversion H.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction l.\n  simpl;intros.\n  inversion H;trivial.\n  inversion H.\n  constructor.\n  constructor.\n  apply (IHl l'0).\n  apply (IHl l'0).\n  apply (IHl l'0).\n  apply (IHl l'0).\n  apply (IHl l'0).\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros.\n  induction l.\n  inversion H;trivial.\n  intro.\n  case (in_variety_in _ _ _ _ _ H7 H7).\n  intro.\n  case (in_variety_in _ _ _ _ _ _ H8 H8 H8).\n  intro.\n  case (in_variety_in _ _ _ _ _ H8 H8).\n  intro.\n  case (in_variety_in _ _ _ _ _ _ H8 H8).\n  intro.\n  case (in_variety_in _ _ _ _ _ H8 H8).\n  intro.\n  case (in_variety_in _ _ _ _ H8 H9).\n  intro.\n  case (in_variety_in _ _ _ _ H8 H9).\n  intro.\n  case (in_variety_in _ _ _ H8 H9).\n  intro.\n  case (in_variety_in _ _ _ _ H9 H9).\n  intro.\n  case (in_variety_in _ _ _ _ H9).\n  intro.\n  case (in_variety_in _ _ _ _ H9).\n  intro.\n  case (in_variety_in _ _ _ _ HQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction l;intros.\n  simpl in H.\n  case H.\n  simpl.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_appQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction l.\n  simpl.\n  intros.\n  apply In_not_eq.\n  apply H.\n  apply In_not_eq.\n  apply H.\n  apply in_or_app_or_or_eq.\n  apply in_or_app_or_eq.\n  apply in_app_or_or_eq.\n  apply in_app_or_or_eq.\n  apply in_app_or_eq.\n  apply in_app_or_or_eq.\n  apply in_app_or_or_eq.\n  apply in_or_app_or_eq.\n  apply in_app_or_or_eq.\n  apply in_or_app_or_or_eq.\n  apply in_app_or_or_eq.\n  apply in_or_app_or_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_or_eq.\n  apply in_or_app_or_eq.\n  apply in_app_or_or_eq.\n  apply in_app_or_or_eq.\n  apply in_or_app_orQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros.\n  inversion H.\n  apply H.\n  inversion_clear H.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\n  constructor; trivial.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros.\n  induction l.\n  simpl; tauto.\n  apply IHl.\n  simpl; tauto.\n  intros.\n  apply (IHl' l0).\n  apply H1.\n  apply in_or_app.\n  eapply in_or_app.\n  eapply in_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_app.\n  eapply in_or_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\n",
                "context_tokens": 732,
                "proof_start_offset": 5571,
                "proof_end_offset": 5760,
                "proof": "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\ninduction l.\napply nil_is_permutation.\neapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intro; apply (is_empty_is_empty_spec A l l); auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\ninduction l; intros;simpl in H.\napply in_or_app_or_or_or_or_or_or_or_or_or_or_or_and_or_or_or_or_or_or_and;\nrepeat (apply in_or_app_or_or_or_or_or_or_or);\nrepeat (apply in_or_app_or_or_or_or_or_or_or);\nrepeat (apply in_or_app_or_or_or_or_or_or);\nrepeat (apply in_or_app_or_or_or_or_or_or);\nrepeat (apply in_or_app_or_or_or_or_or_or);\nrepeat (apply in_or_app_or_or_or_or_or;);\nrepeat (apply in_or_app_or_or_or_or_or);\nrepeat (apply in_or_app_or_or_or_or);\nrepeat (apply in_or_app_or_or_or_or);\nrepeat (apply in_Qed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros.\n  case (in_insert_in A l); intro.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\n  apply in_insert_in; auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros.\n  case l.\n  intro.\n  case (in_]]]]]].\n  intro.\n  inversion H0.\n  apply (in_insert_is_set).\n  apply (in_insert_is_set).\n  apply (in_insert_not_set).\n  apply (in_insert_not_set).\n  apply H0.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_Qed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros;apply is_permutation_refl.\n  auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  induction l.\n  simpl.\n  tauto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros.\n  case (in_insert_or_eq A l); trivial.\n  apply in_cons_or_eq; trivial.\n  apply in_or_eq; trivial.\n  apply in_or_eq; trivial.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intro; red; intro.\n  contradiction (H l').\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\ninduction l;intros;simpl in H.\ndestruct l.\napply nil_is_permutation;auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intro; induction l.\n  apply nil_is_permutation.\n  apply (IHl (l0:=l) (l0:=l) (l0:=l) (l1:=l) (l2:=l) (l2:=l) (l1:=l) (l2:=l) (l2:=l) (l3:=l4) (l1:=l2) (l3:=l1) (l2:=l2) (l3:=l2) (l4:=l2) (l3:=l4) (l2:=l2) (l3:=l4) (l4:=l4) (l4:=l2) (l4:=l4) (l5:=l2) (l4:=l2) (l4:=l2) (l4:=l2) (l4:=l4) (l4:=l2) (l4:=l2) (l4:=l2) (l5:=l2) (l4:=l4) (l4:=l2) (l1:=l2) (l4:=l2) (l2:=l2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\n",
                "context_tokens": 716,
                "proof_start_offset": 5839,
                "proof_end_offset": 6163,
                "proof": "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\nProof.\ninduction 1.\napply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\napply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  apply (IHl l).\n  apply (IHl l).\n  apply (IHl l).\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\nProof.\ninduction l;simpl;intros;auto.\ndestruct l'.\napply nil_is_empty.\napply nil_is_empty.\napply (IHl l');trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l.\n  simpl; tauto.\n  simpl; tauto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l;simpl in |- *; auto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l.\n  intros.\n  simpl.\n  rewrite app_nil_r.\n  apply app_nil_end.\n  rewrite app_nil_r.\n  apply app_nil_end.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l.\n  intros;simpl in H.\n  destruct l'.\n  apply nil_is_empty.\n  apply (IHl l).\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  simpl.\n  intros.\n  case (in_ Sup_inv _ _ _ _ _ _ H H0).\n  elim (in_contin_inv _ _ _ _ _ _ H0).\n  intros.\n  apply (in_insert_inv _ _ _ _ _ _ H0).\n  apply H1.\n  apply (in_insert_inv _ _ _ _ _ _ H0).\n  apply H0.\n  apply (in_insert_inv _ _ _ _ _ _ H0).\n  apply H0.\n  apply (in_insert_inv _ _ _ _ _ _ H0).\n  apply H0.\n  apply (in_insert_inv _ _ _ _ _ _ H0).\n  apply H0.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l.\n  simpl;tauto.\n  simpl.\n  intros.\n  case (in_insert_inv _ _ _ _ _ H).\n  apply IHl;trivial.\n  apply (IHl l);trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l;intros;simpl in H;tauto.\ndestruct l'.\n  apply (IHl A x l');trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  Proof.\n    simple induction l.\n    simpl;intros.\n    apply (in_preserves_empty A (x::l)).\n    apply in_or_app.\n    rewrite in_app.\n    rewrite in_app.\n    rewrite in_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_app.\n    apply in_or_app.\n    apply in_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply inQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ".\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\n",
                "context_tokens": 682,
                "proof_start_offset": 6350,
                "proof_end_offset": 6985,
                "proof": "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\nProof.\ninduction 1;intros.\ninversion H.\nexists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\nexists l';split;[trivial | apply head_insertion].\ninversion H0.\nexists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\nelim (IHinsertion l'0 y0 H5);intro l3;intro.\nelim H6;intros.\nexists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  apply (IHl0 l1).\n  apply (IHl2 l2).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0;intros;exists l1;exists l2;split;trivial.\n  apply IHl;trivial.\n  apply IHl1;trivial.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H.\n    apply (IHl1 l2);trivial.\n  destruct l0.\n  apply (IHl1 l2);trivial.\n  apply (IHl2 l2);trivial.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H.\n  apply (IHl l2).\n  destruct l3.\n  apply (IHl1 l2).\n  apply (IHl1 l2).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1.\n  apply (IHl0 l1).\n  apply (IHl1 l2).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1.\n  apply IHl1.\n  apply (IHl2).\n  apply (IHl1).\n  apply (IHl1).\n  apply (IHl2).\n  apply (IHl3).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H;inversion H.\n  destruct l2.\n  apply (IHl1 l2);trivial.\n  elim (IHl2 l2);trivial.\n  intro; rewrite H2 in H; inversion H.\n  apply IHl1;trivial.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  apply (IHl0 l2).\n  destruct (IHl1 l2).\n  destruct (IHl2 l3).\n  apply (IHl1 l3).\n  apply (IHl2 l3).\n  apply (IHl1 l3).\n  apply (IHl1 l2).\n  apply (IHl1 l3).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l;intros;simpl in H.\n  destruct l1.\n  apply in_map_iff in H.\n  destruct H.\n  destruct H.\n  destruct (in_insert_in A x l0 l1).\n  subst.\n  exists (x::l1).\n  apply in_map_iff.\n  destruct H.\n  destruct H.\n  apply in_map_iff in H.\n  destruct H.\n  subst.\n  exists x.\n  apply in_map_iff.\n  destruct H.\n  exists x.\n  apply in_map_iff.\n  destruct H.\n  subst.\n  exists x.\n  apply in_map_iff.\n  destruct H.\n  subst.\n  exists x.\n  apply in_map_iff.\n  destruct H.\n  subst.\n  exists x0.\n  apply in_map_iff.\n  destruct H.\n  subst.\n  exists x.\n  apply in_map_iff.\n  destruct H.\n  exists x0.\n  apply in_map_iff.\n  destruct H.\n  subst.\n  exists x0.\n  apply in_map_iff.\n  destruct H.\n  subst.\n  exists x.\n  apply in_map_iff.\n  destruct HQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0;intros;simpl in H.\n  destruct l0.\n  apply (IHl1 l2);trivial.\n  destruct l0.\n  apply (IHl1 l2);trivial.\n  destruct l0.\n  apply (IHl2 l3);trivial.\n  exists l3;trivial.\n  apply (IHl1 l3);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\n",
                "context_tokens": 690,
                "proof_start_offset": 7110,
                "proof_end_offset": 7644,
                "proof": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\nProof.\ninduction 1;intros.\ninversion H;inversion H0;apply is_permutation_refl.\ninversion H1.\napply cons_is_permutation with l'';trivial.\napply cons_is_permutation with l';trivial.\nelim (insertion_trans A l' l'' x H0 l3 x0 H2).\nintro l4;intro.\nelim H8;intros.\napply cons_is_permutation with l4;trivial.\neapply IHis_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  apply (in_insert_preserves_zero A l0 l1);apply in_map_iff; auto.\n  apply IHl0;trivial.\n  apply (in_insert_preserves_zero A l0 l1);apply in_map_iff; auto.\n  apply IHl1;trivial.\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  intros.\n  inversion H.\n  inversion H.\n  subst.\n  inversion H0.\n  exists (y::l1);split;[apply (IHl1 l1) | apply (IHl2 l3) ].\n  apply (IHl1 l3).\n  apply (IHl2 l3).\n  apply (IHl1 l3).\n  apply (IHl2 l3).\n  apply (IHl1 l3).\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l0;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H.\n Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l.\ninduction l0;intros.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0].\ninversion_clear H0.\ndestruct l0 as [ | x l0Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  apply (H x0).\n  apply (H x0).\n  apply (H x0).\n  apply (H x0).\n  apply (H x0).\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  apply (app_sym A).\n  apply (app_sym A).\n  apply (app_sym A).\n  apply (app_assoc A).\n  apply (app_comm A).\n  apply (app_assoc A).\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H.\n  apply (IHl0 l0).\n  apply (IHl2 l0).\n  apply (IHl1 l2).\n  apply (IHl1 l2).\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  apply (IHl1 l2);trivial.\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction 1;intros.\ninversion H0.\nexists x0.\nsplit;[apply H0 | apply H1].\napply IHl0.\nassumption.\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  intros; destruct l0; destruct l1;inversion 1.\n  apply (IHl1 (y::l1));split;[apply is_permutation_refl | apply is_permutation_refl].\n  apply (IHl2 (y::l2));split;[apply is_permutation_refl | apply is_permutation_refl].\n  apply (IHl3 (y::l2));split;[apply is_permutation_refl | apply is_permutation_trans].\n  apply (IHl3 (y::l2));split;[apply is_permutation_trans with l2;trivial | apply is_permutation_trans].\n  apply (IHl3 (y::l2));split;[apply is_permutation_trans with l2;trivial|apply is_permutation_trans].\n  apply (IHl3 (y::l2));split;[apply is_permutation_trans with l2;trivial|apply is_permutation_trans].\n  apply (IHl3 (y::l2));split;[apply is_permutation_trans with l3;trivial|apply is_permutation_sym].\n  apply (IHl3 (y::l1));split;[apply is_permutation_trans with l3;trivial|apply is_permutation_sym].\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\n",
                "context_tokens": 722,
                "proof_start_offset": 7681,
                "proof_end_offset": 7890,
                "proof": "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\ninduction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction l;intros.\ninversion H;inversion H0.\napply (IHl l0 l1); trivial.\ninversion H0.\napply (IHl l0 l2); trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l.\n  apply nil_is_permutation.\n  apply nil_is_permutation.\n  apply not_permutation_refl.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_permutation_sym.\n  apply not_Qed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction l.\n  apply is_true_sym.\n  apply is_true_sym.\n  apply is_true_sym.\n  apply is_true_sym.\n  apply is_true_sym.\n  apply is_true_trans with l';trivial.\n  apply is_true_sym.\n  apply is_true_sym.\n  apply is_true_trans with l';trivial.\n  apply is_true_sym.\n  apply is_true_sym.\n  apply is_true_trans with l';trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l.\n  apply cons_is_permutation.\n  apply IHl.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  unfold is_permutation;intros;inversion H;inversion H;apply is_true_sym.\n  apply is_true_sym;apply is_true_sym.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l.\n  left.\n  inversion_clear H.\n  apply in_or_true.\n  inversion_clear H.\n  apply in_or_true.\n  apply in_or_false.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_true.\n  apply in_or_false.\n  apply in_or_true.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_true.\n  apply in_or_false.\n  apply in_or_false.\n  apply in_or_true.\n  apply in_orQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction l.\n  apply nil_is_permutation.\n  apply l0.\n  apply l1.\n  apply (is_empty_is_empty A l0).\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_empty_refl.\n  apply IHl.\n  eapply is_empty_trans;eauto.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nunfold is_permutation.\ninduction l;intros.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_trans.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_trans.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_or_sym.\napply in_Qed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\n  induction l.\n  apply nil_is_permutation.\n  apply nil_is_permutation.\n  apply (IHl l l' l').\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 7892,
                "proof_end_offset": 8346,
                "proof": "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\nProof.\ninduction l;simpl;intros.\ninversion H;simpl;tauto.\ninversion H;simpl.\nsplit;intro.\ncase H5;intro.\neapply insertion_in;rewrite H6 in H4;apply H4.\nelim (IHl l'0 H2 x);intros.\neapply insertion_inclusion;eauto.\ncase (in_insertion_inv A x a l'0 l' H4 H5);intro.\nrewrite H6;tauto.\nelim (IHl l'0 H2 x);intros.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H.\n  apply in_or_app;apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply inQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H;clear H.\n  apply H;apply in_or_app;assumption.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  intros;apply In_sym;apply H.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_sym.\n  apply NoDup_Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n    apply (In_not_in A l l');apply is_permutation_trans with l';apply is_permutation_trans with l';apply is_permutation_sym.\n    apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_in_sym.\n  apply not_inQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  Proof.\n    induction l.\n    simpl.\n    intros.\n    apply (in_app_or _ _ _ _ _ _ H H0).\n  Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H.\n  inversion H;clear H.\n  apply perm_trans with l0;auto.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  intros;apply (in_app_or A l l' l');apply is_permutation_trans with (l' := l');[apply is_permutation_sym|apply l'_..];\ninduction 1;[apply False_ind|apply in_app_or in_app_or;trivial].\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  intros; apply (In_inv _ _ _ H);apply In_inv;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H;apply H; apply H; apply H;apply H;apply H; apply H;apply H;apply H;apply H;apply H; apply H; apply H;apply H; apply H;apply H;apply H; apply H; apply H;apply H;apply H;apply H; apply H;apply H;apply H;apply H; apply H; apply H; apply H; apply H; apply H; apply H;apply H;apply H; apply H;apply H; apply H;apply H; apply H;apply H; apply H; apply H;apply H; apply H;apply H;apply H;applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 8348,
                "proof_end_offset": 8572,
                "proof": "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\nProof.\nintros.\neapply permutation_insertion;eauto.\napply is_permutation_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\n  inversion H;simpl;tauto.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor. constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor. constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructor.\n  constructorQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\ninversion H;clear H; inversion H0;apply is_permutation_trans with l'; trivial.\ninversion H0;apply is_permutation_trans with x; trivial.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\ninversion H;simpl;tauto.\ninversion H0;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H.\n  left;auto.\n  right;auto.\n  left;auto.\n  right;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\n  inversion H;simpl;tauto.\n  left;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  left;auto.\n  right;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  Qed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H; subst; inversion H0;apply is_true_sym.\n  inversion H0;clear H0; subst.\n  constructor;auto.\n  apply IHl;apply H;apply H1.\n  apply H;apply In_insert; auto.\n  apply H;apply In_insert; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 8574,
                "proof_end_offset": 8857,
                "proof": "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\nProof.\nintros.\napply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (length_BDDreplacel_aux (fun a:list A => forall (y:list A)(length y)), length y = length (P a y)).\n  intros.\n  apply (length_BDDreplacel_aux (fun a:list A => forall (y:list A)(length y), length y = length (P a y))).\n  intros.\n  apply (length_listRepeat_aux (fun a:list A => forall (y:list A)(length y)), length y = length (P a y)).\n  intros.\n  apply H.\n  apply length_NegSpaceClause_aux.\n  intros.\n  apply H.\n  apply length_mkArg_eq_impl_eq; auto.\n  apply H;apply H;apply H; apply H; apply H; apply H;apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H;Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;inversion H0.\n  apply (IHl (length_subsequence A) (x::x0::x0));try assumption.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H.\n  apply (H (length x)).\n  apply (H (length x)).\n  apply (H (length x)).\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;simpl.\n  inversion H;clear H.\n  apply (H a).\n  apply (H a).\n  apply H0;assumption.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply NoDup_Permutation.\n  apply elements_lelistA.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros; eapply H.\n  apply (H a).\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  induction l.\n  simpl.\n  rewrite app_nil_end.\n  apply (IHl (list_contents_tail _ _ _ _ _)).\n  apply IHl.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;simpl;tauto.\n  case (in_insertion_aux H).\n  intros.\n  case (in_Exclusive_aux H).\n  intros.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros;inversion H.\n  left;apply (IHl l'); auto.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros; eapply list_preserves_In; eauto.\n  apply (in_insert_preserves_In H).\n  apply (in_insert_preserves_In H).\n  apply (in_insert_preserves_In H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 8859,
                "proof_end_offset": 9031,
                "proof": "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\nProof.\ninduction 1;simpl;trivial.\nrewrite IHinsertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list_induction l l')); unfold Sort;auto.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply H.\n  apply (length_separate_inv A l x).\n  apply H.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H;simpl.\n  apply IHl;apply IHl';apply H.\n  apply (IHl' l');apply H.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl;tauto.\n  inversion H;simpl;auto.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l');intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l');intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l');intros.\n  apply (well_founded_ind (list_induction l l'));intros.\n  apply (well_founded_ind (list_induction l l'));Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l.\n    simpl;intros.\n    inversion H.\n    apply length_runs.\n    apply IHl.\n    apply IHl.\n  apply IHl.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list_induction l l' H) H).\n  apply (well_founded_ind (list_induction l l' H) H0).\n  apply (well_founded_ind (list_induction l l' H0) H1).\n  apply (well_founded_ind (list_induction l l' H0) H1).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (well_founded_ind (list_induction l l' H0) H2).\n  apply (wellQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H;clear H; subst.\n  apply IHl.\n  apply IHl.\n  apply H.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list_induction l l' H0 H1 H2)).\n  apply (well_founded_ind (list_induction l l' H1 H2)).\n  intros.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list_induction l l'0 l0) (list_induction l l0));intros.\n  apply (well_founded_ind (list_induction l'0 l0) (list_induction l0 l0));intros.\n  apply (well_founded_ind (list_induction l l0) (list_induction l0 l1));intros.\n  apply (well_founded_ind (list_induction l l0) (list_induction l0 l1));intros.\n  apply (well_founded_ind (list_induction l l0) (list_induction l0 l1));intros.\n  apply (well_founded_ind (list_induction l0 l0) (list_induction l0 l1));intros.\n  apply (well_founded_ind (list_induction l0 l0) (list_induction l0 l1));intros.\n  apply (well_founded_ind (list_induction l0 l1) (list_induction l0 l1));intros.\n  apply (well_founded_ind (list_induction l0 l1) (list_induction l0 l1));intros.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 9033,
                "proof_end_offset": 9234,
                "proof": "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\nProof.\ninduction 1;simpl;trivial.\ngeneralize (insertion_length A l' l'' x H0);intro;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (list_induction l l' l' H)).\n  apply H.\n  apply app_length.\n  apply H.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;intros.\n  apply cons_is_permutation.\n  apply H.\n  apply (H a).\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (list_induction l l' l' H H0 H1).\n  apply IHl.\n  apply H.\n  apply app_ass.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l;simpl;trivial.\n  rewrite IH']].\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_length.\n  rewrite app_Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l;simpl;trivial.\n  rewrite IH GNUA.\n  rewrite IH GNUA.\n  apply IHl.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (list_induction_list A l l' l' H H0 H1).\n  intro l'.\n  case (in_insert_list A l l' H0 H1).\n  intros.\n  inversion H; subst.\n  apply (IHl _ H1).\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insert_list.\n  apply in_insertQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_induction (list_of_list_ind (list_induction (list_induction (Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l;simpl;trivial.\n  rewrite IH']].\n  rewrite IH'.\n  rewrite IH'.\n  rewrite app_length.\n  apply IH'.\n  auto.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l;simpl;trivial.\n  rewrite IH']].\n  simpl.\n  intros.\n  case (in_app_or _ _ _ _ H); intro.\n  rewrite H0;rewrite <- H1;rewrite H0;rewrite H1.\n  rewrite app_length;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l;simpl;trivial.\n  rewrite IHperpendicular;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\nLemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  generalize (insertion_length A l' l'' x H0);intro;congruence.\nQed.\n\n",
                "context_tokens": 705,
                "proof_start_offset": 9236,
                "proof_end_offset": 10306,
                "proof": "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\nProof.\ninduction l;intros;inversion H.\ninversion H0.\napply is_permutation_refl.\nrewrite <- H4;destruct l.\ninversion H8.\ngeneralize (head_insertion A a0 l);intro.\nassert (In x (a0::l)).\neapply insertion_in;apply H8.\ncase (in_insertion_inv A x a0 l (a0::l) H10 H11);intro.\nrewrite H12;rewrite <- H12 in H10;rewrite <- H12 in H8;rewrite <- H12 in IHl.\nassert (is_permutation A l l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nelim (in_insertion A x l H12);intro l2;intro.\ngeneralize (tail_insertion A x a0 l2 l H13);intro.\nassert (is_permutation A (a0::l2) l1).\neapply IHl;eauto.\napply is_permutation_sym;auto.\neapply cons_is_permutation;eauto.\nrewrite H1 in H3.\ninversion H0.\nrewrite <- H9;apply insertion_is_permutation;trivial.\nassert (is_permutation A l0 l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list A) (fun l':list A => length l = length l')%nat).\n  apply (well_founded_ind (list A) (fun l':list A => length l = length l')%nat).\n  apply (well_founded_ind (list A) (fun l0:list A => length l = length l')%nat).\n  apply (well_founded_ind (list A) (fun l0:list A => length l = length l')%nat).\n  apply (well_founded_ind (list A) (fun l0:list A => length l0 = length l')%nat).\n  apply (well_founded_ind (list A) (fun l0:list A => length l = length l')%nat).\n  apply (well_founded_ind (list A) (fun l0:list A => length l0 = length l')%nat).\n  apply (well_founded_ind (list A) (fun l0:list A => length l0 = length l')%nat).\n  apply (well_founded_ind (list A) (fun l0:list A => length l0 = length l)%natQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros;apply (well_founded_ind (list A) (fun l':list A => length l' = l') (A:=A) (l:=A) (l:=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=A) (l':=AQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list_induction l l') (list_induction l l');simpl;intros.\n  apply H.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list_induction l l'));apply (well_founded_ind (list_induction l l');trivial.\n  generalize (IHl' x H0);intro;congruence.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (list_preserves_distinct A x a l l' H0 H1).\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros;apply (well_founded_ind (list_induction l l') (list_induction l l') (list_induction l l');intros.\n    apply (in_app_or _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\n  intro l'.\n  elim (IHl l' H1);intros.\n  left;auto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list_induction l l' l'' x H0).\n  apply (well_founded_induction l l'' x H0).\n  intros.\n  apply (well_founded_induction l l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction l'' x).\n  apply (well_founded_induction lQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list A) (fun l0:list A => length l0=l0) (length l0));intro;congruence.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list A) (fun l':list A => length l = length l'));trivial.\n  generalize (Sort_length A l' l' x H0);intro;congruence.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list_induction l l l' x);intros.\n  apply (well_founded_ind (list_induction l l' x);intros.\n  apply (well_founded_ind (list_induction l l' x);intros.\n  apply (well_founded_ind (list_induction l l' x);intros.\n  apply (well_founded_ind (list_induction l l' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_founded_ind (list_induction l l'' x);intros.\n  apply (well_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "1 l2.\n  generalize l1;clear l1.\n  induction l2;intros.\n  inversion H.\n  inversion H.\n  subst a.\n  subst x0.\n  subst l.\n  subst l2.\n  inversion H0.\n  subst x0.\n  subst l.\n  subst l''.\n  exists l'.\n  tauto.\n  subst x0.\n  subst l'.\n  subst a.\n  subst l1.\n  inversion H0.\n  subst x0.\n  subst l''.\n  subst l0.\n  elim (IHl2 l x H4 l' H3).\n  intro l3;intros.\n  elim H1;clear H1;intros.\n  elim (insertion_trans A l3 l' x H2 l4 y H6).\n  intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 12697,
                "proof_end_offset": 12967,
                "proof": "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\nProof.\nintros.\napply is_permutation_reverse_impl_is_permutation.\nrewrite rev_involutive.\nrewrite rev_involutive.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  inversion H.\n  destruct H.\n  apply (in_empty_not_nil A l l' H0).\n  assumption.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutationQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutationQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutationQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutationQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  induction l.\n  intros.\n  inversion H.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply inQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutationQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\nProof.\ninduction l.\n  intros.\n  inversion H.\n  apply in_or_app_or_or_app_or_app_or_app_or_not_nil.\n  apply H0.\n  apply in_or_app_or_app_or_or_app_or_app_or_not_nil.\n  apply in_or_app_or_app_or_app_or_not_nil.\n  apply in_or_app_or_app_or_app_or_app_or_not_nil.\n  apply in_or_app_or_app_or_app_not_nil.\n  apply in_or_app_or_app_or_app_or_app_not_nil.\n  apply in_or_app_or_app_or_app_or_not_nil.\n  apply in_or_app_or_app_or_app_or_not_nil.\n  apply in_or_app_or_app_or_app_or_not_nil.\n  apply in_or_app_or_app_or_app_or_app_not_nilQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutationQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\nProof.\n  intros.\n  apply is_permutation_trans with (l0:=l) (l1:=l') (l1:=l').\n  apply is_permutation_trans with (l0:=l) (l1:=l') (l2:=l2).\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutation_sym.\n  apply is_permutationQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 13186,
                "proof_end_offset": 13460,
                "proof": "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\nProof.\ninduction 1.\nsimpl.\nintros.\napply head_insertion.\nintros.\nsimpl.\napply tail_insertion.\napply IHinsertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (app_comm (app xs xss) (app xs yss)).\n  apply (app_comm (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs) (x::xs)).\n  apply (app_assoc (x::xs)).\n  apply (app_assoc (x::xs)).\n  apply (app_assoc (x::xs)).\n  apply (app_assoc (x::xs)).\n  apply (appQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (in_app_or_or_or_sym x (app yss) (app xss) (app yss)).\n  apply (in_app_or_sym x (app xss) (app yss)).\n  apply (in_app_or_sym x (app xss) (app yss)).\n  apply (in_app_or_sym x (app xss)).\n  apply (in_app_or_sym x (app yss)).\n  apply (in_app_or_sym x (app xss)).\n  apply (in_app_or_sym x (app yss)).\n  apply (in_app_or_sym x (app xss)).\n  apply (in_app_or_sym x (app xss)).\n  apply (in_app_or_sym x (app yss)).\n  apply (in_app_or_sym x (app yss)).\n  apply (in_app_or_sym x (app yss)).\n  apply (in_app_or_sym x (app yss)).\n  apply (in_app_sym x (app yss)).\n  apply (in_app_Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (app_ass H).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply (list_append_trans _ _ x' yss).\n  apply (list_append_trans _ _ x' yss).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.\n  apply (list_append_trans _ _ (x::xs) (app yss)).\n  intros.Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (list_append x (app yss) (app yss) (app xss) (app yss)).\n  intros.\n  apply (list_append x (app yss) (app yss) (app xss) (app yss)).\n  intros.\n  apply (list_append_right x (app yss) (app xss) (app yss)).\n  intros.\n  apply (list_append_right x (app yss) (app yss) (app xss)).\n  intros.\n  apply (list_append_right x (app yss) (app yss) (app yss)).\n  intros.\n  apply (list_append_right x (app yss) (app yss)).\n  intros.\n  apply (list_append_right x (app yss) (app yss) (app xss)).\n  intros.\n  apply (list_append_right x (app yss) (app yss) (app yss)).\n  intros.\n  apply (list_append_right x (app yss) (app yss) (app xss)).\n  intros.\n  apply (list_append_right xQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply permutation_app.\n  apply H.\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (in_app_or_one _ xss).\n  apply (in_app_or_one _ xss).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (app_ass A xss yss).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction x; intros; simpl; trivial.\n  apply app_ass.\n  apply app_ass.\n  apply H.\n  apply app_ass.\n  apply app_ass.\n  apply H0.\n  apply app_ass.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\n",
                "context_tokens": 672,
                "proof_start_offset": 13801,
                "proof_end_offset": 14387,
                "proof": "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\nProof.\ninduction 1;intros.\nexists (cons x0 xs).\nsimpl.\nsplit.\nsubst x;subst l;auto.\napply head_insertion.\ndestruct xs.\ndiscriminate H1.\nsimpl in H1.\ninjection H1;clear H1;intros.\nelim (IHinsertion _ _ _ H0 _ H1).\nintro xss;intros.\nelim H3;clear H3;intros.\nexists (cons a xss).\nsimpl.\nsplit.\nsubst y;subst l';auto.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs.\n  simpl.\n  intros.\n  apply H0.\n  intros.\n  apply H.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros; simpl.\n  - inversion H.\n    subst.\n    simpl.\n    exists (f x).\n    split.\n    + simpl.\n      apply (IHl (list_contents_r x0)).\n      apply (IHl (list_contents_r y0)).\n    + simpl.\n      exists (f x).\n      split.\n      apply (IHl (list_contents_r y0)).\n    + simpl.\n      exists (f x0).\n      split.\n      apply (IHl (list_contents_r y0)).\n    + simpl.\n      exists (f x0).\n      split.\n      apply (IHl (list_contents_r x0)).\n    + simpl.\n      exists (f x0).\n      split.\n      apply (IHl (list_contents_r y0)).\n      apply (list_contents_r x0).\n    + simpl.\n      exists (f x0).\n      split.\n      apply (IHl (list_contents_r x0)).\n      apply (list_contents_r x0).\n    + simpl.\n      exists (f x0).\n      split.\n      apply (IHl (list_contents_r x0)).\n    + simpl.\n      exists (f x0).\n      split.\n     Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros.\n  simpl.\n  inversion H.\n  subst.\n  simpl.\n  inversion H.\n  subst.\n  inversion H.\n  subst.\n  simpl.\n  apply IHys.\n  apply H1.\n  apply (H0 xss).\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction y; intros.\n  simpl.\n  destruct (IHys y H).\n  apply (H0 (x:=x)); auto.\n  intros.\n  apply (H0 (x:=x)); auto.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros; simpl in *.\n  contradiction.\n  simpl.\n  eapply map_app.\n  apply H.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs.\n  simpl.\n  intros.\n  apply H.\n  intros.\n  apply H0.\n  intros.\n  simpl.\n  apply (H1 x0 H0).\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros.\n  simpl.\n  auto.\n  simpl.\n  intros.\n  apply (list_map_filter_permutation_sym (map f H) (map f H)).\n  intros.\n  apply (list_map_filter_permutation_trans (map f H) (map f H)).\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros; simpl.\n  intros.\n  inversion H.\n  inversion H.\n  subst.\n  destruct H0.\n  subst.\n  auto.\n  apply (IHl (y:=y)).\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs.\n    simpl.\n    intros.\n    inversion H.\n    subst.\n    inversion H.\n    subst.\n    apply IHl.\n    intros.\n    inversion H.\n  Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs.\n  simpl.\n  intros.\n  inversion H.\n  inversion H0.\n  subst.\n  induction H0.\n  simpl.\n  apply H2.\n  destruct (IHl y (cons x0 xs)).\n  simpl.\n  apply H3.\n  apply H1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\nLemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\n",
                "context_tokens": 677,
                "proof_start_offset": 14389,
                "proof_end_offset": 15125,
                "proof": "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\nProof.\ninduction 1.\nintros.\ndestruct xs1;try (discriminate H).\nexists (nil (A:=A)).\nsplit.\napply nil_is_permutation.\nreflexivity.\nintros.\ndestruct xs1;try (discriminate H1).\nsimpl in H1.\ninjection H1;clear H1;intros.\nsubst x.\nelim (IHis_permutation _ _ _ H1).\nintro xs2.\nintros.\nelim H2;clear H2;intros.\nsubst l'.\nelim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\nintros.\nelim H3;clear H3;intros.\nexists x.\nsplit;auto.\neapply cons_is_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  simpl.\n  apply IHp.\n  simpl.\n  apply IHp.\n  intro.\n  apply IHp.\n  apply (IHl1 (y:=x)).\n  simpl.\n  apply IHp.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1;intros.\n  simpl.\n  apply (in_map_iff _ _ _ _ H1).\n  apply (in_map_iff _ _ _ _ H0).\n  apply (in_map_iff _ _ _ _ H0).\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  apply IHl1.\n  simpl.\n  apply IHl2.\n  intros.\n  apply (In_map _ _ _ H).\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply inQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  simpl.\n  auto.\n  simpl.\n  apply (IHl1 _ _ H1).\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  apply (IHl1 H0).\n  apply IHl2.\n  apply IHl1.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  simpl.\n  case_eq (A:=A) (IHl1 xs2).\n  intro xss1.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss2.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss2.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss1.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss2.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss2.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss1.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss2.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss2.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss2.\n  case_eq (A:=A) (IHl2 xs2).\n  intro xss1.\n  case_eq (A:=A) (IHl2 xs2).Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  split; intros.\n  apply in_map_iff in H.\n  inversion_clear H.\n  destruct xs1.\n  discriminate H.\n  inversion_clear H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear H.\n  inversion_clear H.\n  simpl in H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear H.\n  simpl in H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear H.\n  simpl in H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear H.\n  simpl in H.\n  destruct xs2.\n  discriminate H.\n  inversion_clear HQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros; simpl.\n  discriminate.\n  simpl.\n  eapply map_is_permutation_trans.\n  apply (in_map (fun x:A => map f (fst x) (snd x)) xs1) ys2).\n  apply H.\n  intros.\n  apply H.\n  simpl.\n  eapply map_is_permutation_trans.\n  apply (in_map (fun x:A => map f (snd x)) xs1) ys2).\n  apply H0.\n  intros.\n  apply H.\n  simpl.\n  eapply map_preserves_permutation.\n  apply map_ext.\n  apply (in_map (fun x:A => map f (snd x)) xs1) ys2).\n  apply H.\n  intros.\n  apply H.\n  simpl.\n  eapply map_preserves_permutation_trans.\n  apply map_ext.\n  apply (in_map (fun x:A => map f (snd x)) xs1) ys2).\n  apply H.\n  intros.\n  apply H.\n  simpl.\n  eapply map_preserves_permutation_trans.\n  apply map_ext.\n  apply (in_map (fun x:A => map f (snd x))Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  simpl.\n  case (IHl1 _ _ _ H1); intros.\n  subst.\n  simpl.\n  case (IHl2 _ _ _ H2); intros.\n  apply (H0 xss); auto.\n  apply (H1 xss); auto.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  subst y.\n  apply (H ass).\n  simpl.\n  apply app_ass.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ")(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 15959,
                "proof_end_offset": 16380,
                "proof": "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\nProof.\ninduction 1.\nexists (nil (A:=A)).\nexists l.\nsplit;try reflexivity.\nelim IHinsertion.\nintro l1.\nintro.\nelim H0.\nintro l2;intros.\nelim H1;clear H1;intros.\nexists (cons y l1).\nexists l2.\nsubst l;subst l'.\nsplit;try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\ninduction 1.\n  exists l0.\n  simpl.\n  split.\n  eapply IHl.\n  eapply IHl.\n  eapply H.\n  eapply IHl.\n  eapply H.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1;intros.\n  exists nil.\n  simpl.\n  split.\n  apply nil_is_permutation.\n  apply IHl.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\ninduction 1.\nintros.\ndestruct l' as [l1 l2].\nexists l1.\nsplit.\napply (IHl1 l2 l2).\napply IHl1.\napply IHl2.\napply (IHl1 l2 l2).\napply (IHl2 l2).\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation_set.\n  apply IHl.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists nil.\n  simpl.\n  split.\n  apply nil_is_permutation_set.\n  apply IHl'.\n  apply IHl'.\n  intros.\n  apply (In_app_or_eq _ _ _ H1).\n  apply H3.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1;intros.\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation_set.\n  apply H0.\n  apply in_or_app.\n  eapply IHl0.\n  apply in_or_app.\n  eapply IHl0.\n  apply in_or_app.\n  eapply IHl0.\n  apply in_or_app.\n  eapply IHl0.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl0.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl0.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  apply in_or_app.\n  eapply IHl1.\n  applyQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  apply nil_is_permutation_set.\n  destruct l1.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_split_hyp.\n  apply in_splitQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\ninduction l;intros.\ndestruct l'.\napply in_or_app.\ninversion H0.\nsubst.\napply in_or_app.\ninversion H1.\nsubst.\napply in_or_app.\ninversion H2.\nsubst.\napply in_or_app.\ninversion H2.\nsubst.\napply in_or_app.\ninversion H2.\nsubst.\napply in_or_app.\ninversion H2.\nexists x.\nsplit;auto.\napply in_or_app.\ninversion H2.\nsubst.\napply in_or_app.\ninversion H2.\nexists x.\nsplit;auto.\napply in_or_app.\ninversion H2.\nsubst.\napply in_or_app.\ninversion H2.\nexists x.\nsplit;auto.\napply in_or_app.\ninversion H2.\nexists x.\nsplit;auto.\napply in_or_app.\ninversion H2.\nsubst.\napply in_or_app.\ninversion H2.\nexists x.\nsplit;auto.\napply in_or_app.Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\nProof.\n  induction 1.\n  exists nil.\n  split.\n  subst x.\n  auto.\n  apply IHl.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  intros.\n  exists (nil (A:=A)).\n  split.\n  eapply IHl.\n  apply (app_ass l).\n  apply (app_ass l).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\nLemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists (nil (A:=A)).\n  exists l.\n  split;try reflexivity.\n  elim IHinsertion.\n  intro l1.\n  intro.\n  elim H0.\n  intro l2;intros.\n  elim H1;clear H1;intros.\n  exists (cons y l1).\n  exists l2.\n  subst l;subst l'.\n  split;try reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 16382,
                "proof_end_offset": 16713,
                "proof": "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\nProof.\ninduction 1.\napply perm_nil.\nelim (insertion_append_decompose _ _ _ _ H0).\nintro l1;intros.\nelim H1.\nintro l2;intros.\nelim H2;clear H2;intros.\nsubst l';subst l''.\napply Permutation_cons_app.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply IHl.\n  intros.\n  apply (In_cons _ _ H).\n  apply in_app_or in H.\n  destruct H.\n  subst l0.\n  eapply permutation_is_permutation.\n  apply IHl.\n  eapply Permutation_sym.\n  apply in_app_or in H.\n  destruct H.\n  subst l0.\n  eapply Permutation_sym.\n  apply in_app_or in H.\n  destruct H.\n  subst l1.\n  apply in_app_or in H.\n  destruct H.\n  subst l2.\n  apply in_or_app_or in H.\n  destruct H.\n  subst l2.\n  apply in_or_app_or in H.\n  destruct H.\n  subst l2.\n  apply in_or_app_or in H.\n  destruct H.\n  subst l1.\n  apply in_or_app_or in H.\n  destruct H.\n  subst l2.\n  apply in_or_app_or in H.\n  destruct H.\n  subst l2.\n  apply in_or_app_or in H.\n  destruct H.\n  subst l2.\n  apply in_or_app_orQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  intros.\n  apply permutation_impl_Permutation.\n  apply H.\n  apply H.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\ninduction l.\nexact (app_or_assoc A).\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  unfold permutation.\n  intros.\n  apply permutation_sym.\n  apply Permutation_impl_Permutation.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists nil.\n  split.\n  apply (IHl l' l' l' l' H).\n  apply (IHl l' l' l' H).\n  intros.\n  apply (IHl l' l' l' H).\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  Proof.\n    intros.\n    apply perm_sym.\n    apply permutation_app.\n    apply permutation_app.\n    apply permutation_sym.\n    apply permutation_sym.\n    apply permutation_sym.\n    apply permutation_sym.\n    apply permutation_sym.\n    apply perm_comm.\n    apply perm_skip.\n    apply perm_swap.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply nil_is_permutation.\n  apply IHl.\n  apply IHl.\n  apply IHl.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\ninduction 1.\n  intros.\n  apply in_cons.\n  apply in_cons.\n  apply in_cons.\n  apply in_cons.\n  apply in_cons.\n  apply in_cons.\n  apply in_app.\n  apply in_cons.\n  apply in_or_app.\n  apply in_cons.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply inQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\nProof.\n  induction l.\n  simpl.\n  apply IHl.\n  simpl.\n  apply IHl.\n  intros.\n  apply IHl.\n  intros.\n  apply (H0 l0).\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\ninduction 1.\n  auto.\n  intros.\n  exists (nil (A:=A)).\n  split; try reflexivity.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nelim (le_gt_dec n m).\n intro.\n right.\n assumption.\n intro.\n right.\n assumption.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nintros.\napply mult_lemma1; auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  simple induction m.\n  simpl in |- *.  intros.  elim (le_lt_eq_dec n m).\n  left.  elim (le_lt_eq_dec n m).\n  left.  reflexivity.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.  apply le_n_S.\n  assumption.  intro.  rewrite H.Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nsimple induction n.\n simple induction m.\n simpl in |- *.\n intros.\n apply plus_n_O.\n simpl in |- *.\n intros.\n apply plus_n_O.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_O.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_O.\n simpl in |- *.\n intros.\n apply plus_n_Sm.\n simpl in |- *.\n intros.\n apply plus_n_O.\n simpl inQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_eq (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nelim (le_or_lt (S n) (S m)).\nintro.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n simple induction m.\n simpl in |- *.\n reflexivity.\n intros m IH.\n simpl in |- *.\n reflexivity.\n intros m IH.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  intros n m.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _ H).\n  intros m IH.\n  elim (le_Sn_O _ _Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nintros m m H.\nrewrite H.\nsimpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nunfold mult_by_distr_l.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nelim (le_gt_dec n m).\n intro.\n right.\nassumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  induction m;simpl;auto with arith.\n  elim H;trivial.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  intros.\n  simpl in H.\n  right.\n  apply (mult_lemma1 (m * S m) m (S m)).\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction m.\n  tauto.\n  simpl in |- *.\n  rewrite H.\n  simpl in |- *.\n  intros.\n  elim H.\n  apply plus_le_compat_l.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction m.\n  tauto.\n  simpl in H.\n  apply le_n_S.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  elim (plus_lemma3 n m H).\n  left.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  elim H.\n  simpl in |- *; intros.\n  elim H.\n  intros.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in |- *.\n  intros.\n  elim H0; intro.\n  rewrite <- H.\n  rewrite H.\n  rewrite H0.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  elim (plus_lemma3 n m).\n  intros.\n  rewrite mult_comm.\n  rewrite (plus_comm n m).\n  rewrite (plus_comm n m).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).\n  rewrite (plus_comm m n).Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in |- *.\n  elim H.\n  left.\n  apply mult_lemma3.\n  intros.\n  apply H0.\n  left.\n  apply mult_lemma3.\n  right.\n  apply mult_lemma3.\n  right.\n  apply mult_lemma3.\n  left.\n  apply mult_lemma3.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\n",
                "context_tokens": 502,
                "proof_start_offset": 1721,
                "proof_end_offset": 2052,
                "proof": "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\nProof.\nintros n m.\ncase n.\nleft;trivial.\nintros.\nright.\ndestruct m.\nrewrite mult_comm in H.\ndiscriminate.\ndestruct m;trivial.\nassert ((S n0)<(S n0)*(S (S m))).\napply mult_lemma3;intros;auto with arith.\nrewrite <- H in H0.\nelim (lt_irrefl (S n0) H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  induction m.\n  left.\n  destruct m.\n  left.\n  destruct m.\n  right.\n  destruct m.\n  left.\n  destruct m.\n  left.\n  right.\n  destruct m.\n  left.\n  destruct m.\n  left.\n  destruct m.\n  left.\n  destruct m.\n  left.\n  destruct m.\n  right.\n  left.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  right.\n  destruct m.\n  left.\n  destruct m.\n  right.\n  destruct m.\n  left.\n  destruct m.\n  right.\n  destruct m.\n  left.\n  destruct m.\n  left.\n  destruct m.\n  right.\n  destruct m.\n  left.\n  destruct m.\n  right.\n  destructQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  inversion H.\n  rewrite mult_comm in H.\n  inversion H.\n  tauto.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  destruct n.\n  left.\n  left.\n  simpl.\n  assert (m = m).\n  omega.\n  subst m.\n  left.\n  simpl.\n  reflexivity.\n  inversion H.\n  right.\n  trivial.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  assert (m < n);try omega.\n  inversion H;try omega.\n  left.\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  elim (mult_lemma1 n m).\n  tauto.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\nintros.\nrewrite mult_comm.\ninduction m.\nsimpl.\nauto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  split;intro.\n  inversion H.\n  simpl.\n  case (O m).\n  simpl.\n  case (O m).\n  simpl.\n  case (O m).\n  intros.\n  left.\n  split.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  induction n.\n  simpl in H.\n  tauto.\n  simpl in H.\n  left.\n  apply mult_lemma3.\n  tauto.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  tauto.\n  simpl in H.\n  right.\n  assert (m > 0).\n  omega.\n  generalize (plus_lemma1 m n); tauto.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  elim (plus_lemma3 n m H4).\n  tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\n",
                "context_tokens": 628,
                "proof_start_offset": 2054,
                "proof_end_offset": 2503,
                "proof": "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\nProof.\ninduction n;simpl;intros;try discriminate.\ninduction m.\nrewrite mult_comm in H.\nsimpl in H;discriminate.\nassert ((S n)<=((S n)*(S m))).\napply mult_lemma1;discriminate.\nassert (((S n)*(S m))=((S m)+n*(S m))).\nreflexivity.\nrewrite H1 in H0.\nrewrite H in H0.\nassert ((S n)=1).\nomega.\nsplit;trivial.\ninversion H2.\nrewrite H4 in H.\nsimpl in H.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  induction n.\n  reflexivity.\n  simpl.\n  rewrite mult_comm.\n  induction m.\n  reflexivity.\n  simpl.\n  rewrite mult_comm.\n  case n.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  induction n.\n  reflexivity.\n  simpl in H.\n  elim (le_S_n _ H).\n  left;trivial.\n  right.\n  left;trivial.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros n m.\n  case n.\n  left;trivial.\n  right.\n  destruct m;trivial.\n  right.\n  left;trivial.\n  right.\n  destruct m;trivial.\n  right.\n  destruct m;trivial.\n  right.\n  destruct m;trivial.\n  left;trivial.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  induction n.\n  left;trivial.\n  intros.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  destruct (plus_lemma1 n0 m).\n  rewrite H in H.\n  discriminate.\n  left.\n  rewrite H in H.\n  discriminate.\n  left.\n  rewrite H in H.\n  discriminate.\n  right.\n  rewrite H in H.\n  discriminate.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  case m.\n  left;trivial.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminate.\n  intros.\n  case m.\n  rewrite mult_comm in H.\n  discriminateQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  case m.\n  left;trivial.\n  intro.\n  rewrite mult_comm in H.\n  rewrite mult_assoc in H.\n  discriminate.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  elim (lt_irrefl n).\n  left;trivial.\n  intro H.\n  inversion H.\n  intros.\n  inversion H.\n  apply H0.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros n m.\n  case n.\n  left;trivial.\n  right.\n  intros.\n  rewrite mult_comm in H.\n  inversion H.\n  left.\n  inversion H.\n  right.\n  inversion H0.\n  right.\n  inversion H0.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H0.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  left.\n  inversion H1.\n  left.\n  inversion H1.\n  right.\n  inversion H1.\n  left.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  left.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n  right.\n  inversion H1.\n Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros n m.\n  case n.\n  left;trivial.\n  right;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2505,
                "proof_end_offset": 2662,
                "proof": "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\ninduction y;intros;rewrite plus_comm;simpl.\nauto with arith.\nrewrite plus_comm.\napply IHy.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  destruct x.\n  omega.\n  rewrite plus_comm in H.\n  inversion H.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\nunfold mult_plus in |- *.\nintros.\nrewrite plus_comm in H.\ninduction m.\nsimpl in |- *.\nassert ((S m + S (S m))).\napply mult_lemma1;trivial.\nrewrite <- H1.\nsimpl in |- *.\napply mult_assoc;apply mult_assoc;apply mult_assoc.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nintro.\nrewrite mult_comm in H.\nelim mult_assoc_lemma1.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nintros.\nrewrite mult_comm.\ninduction y.\nsimpl.\nassert (m = S (S m)).\napply mult_lemma1;auto with arith.\nrewrite plus_comm.\ninduction m.\nsimpl.\nassert ((S m)+(S m) = S m + S (S m))).\napply plus_assoc;apply plus_assoc.\nsimpl in |- *.\napply plus_minus_lemma1;auto with arith.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n  intros.\n  rewrite plus_comm.\n  induction y.\n  simpl.\n  assert (m = S (S (S (S m))).\n  apply plus_le_compat_l.\n  simpl;auto.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  destruct (plus_assoc x y) as [H|H].\n  apply plus_minus_lemma1;trivial.\n  assumption.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nintros.\nomega.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n destruct x; simpl; try discriminate.\n simpl in H.\n destruct y.\n rewrite plus_comm in H.\n discriminate.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nintros.\nomega.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nintros.\n  destruct y.\n  rewrite mult_comm in H.\n  case (le_gt_dec x y).\n  right;trivial.\n  destruct (plus_assoc x (S y) H0).\n  rewrite mult_assoc in H0.\n  discriminate.\n  apply mult_lemma1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2664,
                "proof_end_offset": 2918,
                "proof": "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\nintros.\ninduction a.\nsimpl.\ntrivial.\nreplace (S a*n) with (n+a*n);try (auto with arith).\nrewrite plus_comm.\nrewrite plus_minus_lemma1.\nsimpl.\nrewrite <- minus_n_O;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros.\n  induction a.\n  simpl.\n  reflexivity.\n  simpl.\n  assert (a+0 = a + 1).\n  omega.\n  simpl in H.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros a n.\ninduction n.\nsimpl;auto with arith.\nsimpl;auto with arith.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros.\nrewrite plus_comm.\ninduction a.\nsimpl.\nrewrite mult_comm.\nsimpl.\napply plus_minus_lemma1.\nsimpl.\napply mult_minus_lemma2.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros.\ninduction n.\nreflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros a n.\ninduction n.\nreflexivity.\nrewrite mult_comm.\nsimpl.\nrewrite plus_comm.\napply plus_assoc.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros.\ninduction a;simpl;intros;trivial.\ndestruct a.\nrewrite mult_comm.\nrewrite plus_comm.\napply plus_minus_lemma1.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\n  intros.\n  case a.\n  rewrite mult_comm.\n  induction a; simpl;auto with arith.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros.\ninduction n.\nsimpl; auto with arith.\nsimpl; auto with arith.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\n  intros.\n  induction n.\n  reflexivity.\n  simpl in H.\n  rewrite plus_comm in H.\n  inversion H.\n  simpl in H.\n  assert (x=0).\n  omega.\n  rewrite <- H in H0.\n  discriminate.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros a n.\n  induction n;simpl;intros; try discriminate.\n  rewrite plus_comm in H.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 2920,
                "proof_end_offset": 3619,
                "proof": "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\nProof.\ninduction a.\nintros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\nintros b n H.\nrewrite mult_comm;simpl;rewrite mult_comm;intro.\nassert (n*a = n*b-n).\napply plus_minus;auto.\nassert (a*n=(b-1)*n).\nrewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\nassert (a=(b-1)).\napply (IHa (b-1) n);trivial.\nrewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\ndestruct b;simpl in H3.\nrewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\nrewrite <- minus_n_O in H3;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  replace (S a) with (S a+a*n); try (auto with arith).\n  rewrite plus_comm.\n  simpl.\n  rewrite mult_plus_distr_r.\n  simpl.\n  rewrite <- mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm a).\n  simpl.\n  rewrite mult_plus_distr_r.\n  simpl.\n  rewrite mult_plus_distr_r.\n  simpl.\n  rewrite <- (mult_comm a).\n  rewrite (mult_comm a).\n  simpl.\n  rewrite <- (mult_assoc a).\n  simpl.\n  rewrite mult_plus_distr_r.\n  simpl.\n  rewrite <- (mult_assoc a).\n  rewrite (mult_comm a).\n  simpl.\n  rewrite <- (mult_assoc a).\n  rewrite (mult_comm a).\n  simpl.\n  rewrite mult_plus_distr_r.\n  simpl.\n  rewrite <- (mult_comm a).\n  rewrite (mult_comm (S n)).\n  simpl.\n  rewrite mult_plus_distr_r.\n  simpl.\n  rewrite (mult_comm (S n)).\n  simpl.Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  rewrite (plus_comm a).\n  simpl.\n  rewrite plus_comm.\n  apply plus_minus_lemma1.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  replace (S a*n) with (S (a-n)).\n  rewrite plus_comm.\n  simpl.\n  rewrite plus_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n*a+n) by omega.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite <- (plus_comm a).\n  rewrite plus_assoc.\n  simpl.\n  rewrite plus_comm.\n  rewrite <- plus_assoc.\n  rewrite <- mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite <- (plus_comm b).\n  rewrite (mult_comm b).\n  rewrite mult_assoc.\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a;simpl;intros;try discriminate.\n  simpl.\n  case (le_lt_eq_dec n m).\n  rewrite <- (plus_assoc a).\n  rewrite <- (plus_assoc a).\n  apply mult_assoc.\n  apply IHn.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  replace (a*n) with (S (a-1)) by (auto with arith).\n  rewrite plus_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  replace (S a * n + S n) with (S (a-1)); try omega.\n  apply mult_assoc.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a;simpl;intros;trivial.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_nat_dec a 0).\n  subst.\n  destruct (eq_Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a;simpl;trivial.\n  simpl.\n  rewrite plus_comm.\n  simpl.\n  rewrite plus_comm.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  destruct t.\n  simpl.\n  trivial.\n  simpl.\n  apply mult_lemma1.\n  simpl.\n  auto with arith.\n  simpl.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction t.\n  simpl.\n  trivial.\n  simpl.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  simpl;rewrite mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;simpl;intros;rewrite mult_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHx.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm n (a+1)).\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+1)).\n  rewrite (mult_comm (a+Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros;apply mult_lemma2;auto.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction t.\n  simpl.\n  trivial.\n  simpl.\n  rewrite plus_comm.\n  apply IHn.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;simpl;intros;rewrite plus_comm;simpl;trivial.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite <- mult_assoc.\n  rewrite <- plus_minus_assoc.\n  rewrite <- (mult_comm n (n*y)).\n  apply plus_minus.\n  trivial.\n  rewrite <- plus_assoc.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (plus_comm n (n*y)).\n  apply plus_minus.\n  trivial.\n  rewrite <- (mult_comm (n*y)).\n  apply plus_minus.\n  trivial.\n  rewrite <- (mult_comm (n*y)).\n  apply mult_assoc.\n  trivial.\n  rewrite <- (mult_comm (n*y)).\n  apply mult_assoc.\n  rewrite mult_comm.\n  rewrite <- (mult_comm n (n*y)).\n  apply mult_assoc.\n  trivial.\n  rewrite <- (mult_comm (n*y)).\n  apply mult_assoc.\n  trivial.\n  rewrite <- (mult_comm (n*y)).\n  apply mult_assoc.\n  rewrite (mult_comm (n*yQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite plus_comm;rewrite plus_comm;simpl;rewrite multQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction t.\nsimpl.\nintros.\nauto with arith.\nsimpl.\nintros.\nauto with arith.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction t.\nsimpl;trivial.\nsimpl;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  apply mult_assoc.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\ninduction a.\nsimpl.\ntrivial.\nintros.\nrewrite <- mult_n_O in H.\nsimpl in H.\napply le_n_S;auto.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a; simpl;auto.\n  intros.\n  inversion H.\n  simpl.\n  rewrite plus_comm.\n  apply plus_le_compat_r.\n  apply le_trans with (S a).\n  apply le_plus_r.\n  apply le_plus_r.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  rewrite <- plus_n_O;trivial.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\ninduction a.\nsimpl.\nauto.\nsimpl.\nauto.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  unfold S.\n  apply le_n.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a;simpl;trivial.\n  rewrite plus_comm;simpl.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite <- plus_comm.\n  rewrite plus_comm.\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite <- plus_assoc.\n  rewrite plus_comm.\n  rewrite <- plus_assoc.\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (mult_comm (a+b)).\n  rewrite (multQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\nomega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  auto with arith.\n  simpl.\n  auto with arith.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  case (le_gt_dec (S a) (S b)).\n  trivial.\n  simpl.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite <- plus_assoc.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite <- mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite <- plus_assoc.\n  rewrite plus_comm.\n  rewrite <- mult_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite (mult_comm a b); trivial.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite (mult_comm (b-1)).\n  rewrite (mult_comm (b-1)).\n  rewrite <- (mult_comm (b-1)).\n  rewrite (mult_comm (b-1)).\n  rewrite (mult_comm (b-1)).\n  rewrite (mult_comm (b-1)).\n  rewrite (mult_comm (b-1)).\n  rewrite (mult_comm (b-1)).\n  rewrite (mult_comm (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  induction m;intros;rewrite plus_comm;simpl;trivial.\n  intros;rewrite plus_comm;simpl;trivial.\n  intros;rewrite plus_comm;simpl;trivial.\n  intros;rewrite plus_comm;simpl;trivial.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  induction m.\n  simpl;trivial.\n  rewrite plus_comm.\n  apply plus_minus_lemma1.\n  simpl;trivial.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma2 x y l);rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;auto with arith.\n  change (x+(y-z)) with (x*(z+y)).\n  rewrite <- (mult_plus_distr_r (x-y) (z-x)).\n  rewrite mult_plus_distr_r;rewrite mult_comm;simpl;auto with arith.\n  replace (x+(y-z)) with (x*(z+y)).\n  rewrite (mult_comm x (y-z)).\n  rewrite mult_plus_distr_r;rewrite mult_comm;simpl;auto with arith.\n  replace (x+(y-z)) with (x*(z+y)).\n  rewrite mult_plus_distr_r;rewrite mult_comm;simpl;auto with arith.\n  apply plus_reg_l with (y+z);ring.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (plus_comm x z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_eq_dec x y);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;auto with arith.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (plus_comm x z);rewrite (plus_comm y z);rewrite plus_minus;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 x z l);rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;auto with arith.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite (plus_comm z y);rewrite (plus_comm z y);auto with arith.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;auto with arith.\n  rewrite H;rewrite <- plus_minus_distr_r;auto with arith.\n  rewrite H;rewrite <- plus_minus_distr_r;auto with arith.\n  rewrite <- minus_n_O in H;auto with arith.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);auto with arith.\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;\n    rewrite <- plus_assoc;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;\n    rewrite <- plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;\n    rewrite <- plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;\n    rewrite <- plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;\n    rewrite plus_comm;rewrite plus_comm;rewrite plus_comm; rewrite plus_comm;\n    rewrite <- plus_Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);auto with arith.\n  replace (x+(y-z)) with (x+(y-z)+0);try (auto with arith).\n  replace (x+(y-z)) with (x+(y-z)+0);try (auto with arith).\n  replace (x+(y-z)) with (y-z);try (auto with arith).\n  replace (x+(y-z)) with (y-z);try (auto with arith).\n  replace (x+(y-z)) with (y-z);try (auto with arith).\n  replace (y+(y-z)) with (y-z);try (auto with arith).\n  replace (y+(y-z)) with (y-z);try (auto with arith).\n  replace (y+(y-z)) with (y-z);try (auto with arith).\n  replace (y+(z-z)) with (y-z);try (auto withQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;auto with arith.\n  replace (x*y) with (y+(x+y)).\n  rewrite mult_plus_distr_l;rewrite mult_comm;simpl;auto with arith.\n  apply mult_plus_distr_r;auto with arith.\n  apply mult_plus_distr_r;auto with arith.\n  apply mult_plus_distr_r;auto with arith.\n  apply mult_plus_distr_r;auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ";rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma2 x z l);rewrite (minus_lemma2 y z l);rewrite plus_comm;simpl;auto.\n  apply plus_minus_lemma1;auto.\n  apply minus_minus_lemma2;auto.\n  apply minus_minus_lemma1;auto.\n  apply minus_minus_lemma2;auto.\n  apply minus_minus_lemma1;auto.\n  apply minus_minus_lemma1;auto.\n  apply plus_minus_lemma2;auto.\n  apply plus_minus_lemma1;auto.\n  apply minus_minus_lemma2;auto.\n  apply minus_minus_lemma1;auto.\n  apply plus_minus_lemma2;auto.\n  apply minus_minus_lemma1;auto.\n  apply minus_minus_lemma1;auto.\n  apply minus_minus_lemma2;auto.\n  apply minus_minus_lemma2;auto.\n  apply minus_minus_lemma1;auto.\n  apply minus_minus_lemma2;auto.\n  apply plus_minus_lemma1;auto.\n  apply plus_minus_lemma1;auto.\n Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma1 y z l);rewrite mult_comm;simpl;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  replace (y+z+1+1) with (z+(y-z)+1).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);auto with arith.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma1 x z l);rewrite mult_comm;simpl;rewrite minus_diag;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply plus_le_compat_r;auto with arith.\n  apply plus_le_compat_r;auto with arith.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);auto.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y z);rewrite plus_minus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma1 y z l);rewrite plus_comm;simpl;rewrite minus_minus;trivial.\n  rewrite mult_comm;rewrite plus_minus;rewrite plus_comm;rewrite mult_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (plus_minus_lemma1 x y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma2 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1 y z l);rewrite (minus_lemma1Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma1 x z l);rewrite (minus_lemma2 y z);rewrite mult_comm;simpl;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;auto.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus x y);try (auto with arith).\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma2 y z l);rewrite plus_comm;simpl;rewrite minus_minus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);simpl.\n  replace (x+y+(y-z)) with (x+x+(z-y)).\n  replace (x+y+(z-x)) with (x+y+(z-y)).\n  rewrite mult_plus_distr_r;rewrite mult_plus_distr_r;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite plus_plus;rewrite minus_plus;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);rewrite mult_plus_distr_r;rewrite plus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  replace (y-z) with ((z+y)+z)+z).\n  rewrite plus_minus_lemma2.\n  simpl.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm x y);trivial.\n  rewrite (mult_comm y).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (S x)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (S yQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma2 x z l);rewrite plus_minus;trivial.\n  rewrite plus_comm;rewrite mult_plus_distr_l;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\n",
                "context_tokens": 375,
                "proof_start_offset": 1374,
                "proof_end_offset": 1542,
                "proof": "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nunfold is_gcd.\nintros.\nelim H;elim H0;intros.\napply divides_antisym;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b c d'; rewrite <- (gcd_sym d').\nrewrite <- (gcd_sym d').\nrewrite <- (gcd_sym d').\nrewrite <- (gcd_sym d').\nrewrite <- (gcd_sym d').\nrewrite (gcd_sym d').\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcd_sym (d * d')).\nrewrite (gcdQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b; case (gcd_antisym d a b); intros.\nrewrite (gcd_sym d' a).\nrewrite (gcd_sym d' b).\nrewrite <- (gcd_sym d' a).\nrewrite <- (gcd_sym d' b).\nrewrite <- (gcd_sym d' a).\nrewrite <- (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewrite <- (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewrite (gcd_sym d' b).\nrewriteQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\nred in |- *; red in |- *; intro.\ninversion H0.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b d d' H.\napply gcd_unique.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\napply gcd_unique; auto with *.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintro d; elim d; simpl; auto.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n  unfold gcd, is_gcd; intros d d'; apply gcd_sym.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b; generalize (gcd_sym d' b); cleargcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_trans d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_trans d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcd.\ngeneralize (gcd_sym d' b); clear gcd_sym.\nunfold gcdQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nunfold gcd.\nintros d d' a b d d'.\nrewrite <- (mult_comm d' b).\napply gcd_unique.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d'; unfold gcd in |- *; simpl in |- *.\nrewrite gcd_sym; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\n",
                "context_tokens": 457,
                "proof_start_offset": 1571,
                "proof_end_offset": 1763,
                "proof": "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros.\nelim H;intros.\nsplit.\nred;red in H0;tauto.\nintros.\napply H1.\nred;red in H2;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nunfold is_gcd.\n  intros.\n  elim (H0 d).\n  intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim (H0 d').\n  intros.\n  apply H2.\n  apply mod_sym.\n  assumption.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros d a b.\ncase (gcd_sym d a b); auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\n  unfold gcd.\n  intros.\n  elim H; elim H0; intros.\n  elim H0; intros.\n  apply (gcd_sym (d' * a) (d' * a) (d * b)).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  applyQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nunfold gcd.\nintros.\napply gcd_trans with (b:=d); auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nunfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_sym; assumption.\n  apply gcd_sym; assumption.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H11; intros.\n  elim H11; intros.\n  elim H11; intros.\n  elim H12; intros.\n  elim H13; intros.\n  elim H13; intros.\n  elim H14; intros.\n  elim H14; intros.\n  elim H14; intros.\n  elim H14; intros.\n  elim H14; intros.\n  elim H14; intros.\n  elim H14; intros.\n  elim H15; intros.\n  elim H14Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H0; intros.\n  apply (gcd_sym d' a b).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold gcd.\nintros.\nelim H; auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nunfold is_gcd.\n  intros.\n  elim H; intros.\n  assumption.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\n",
                "context_tokens": 545,
                "proof_start_offset": 1783,
                "proof_end_offset": 1947,
                "proof": "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\nunfold is_gcd.\nintro.\nsplit.\nred;split;[apply zero_max_div | apply divides_refl].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply (gcd_sym a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a (gcd a))))) a)))).\n  unfold gcd.\n  introsQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd in |- *.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elimQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\nunfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  apply (H (S (S p)).\n  apply (H0 (S p)).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcdQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim (prime_intro _ _ H0).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  applyQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  intro.\n  elim H; intros.\n  apply H0.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  applyQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\nintro.\nelim H; intros.\nelim (gcd_sym (S a) (S a)).\n intros.\nelim (gcd_sym (S a) (S a)).\n intros.\nelim (gcd_sym (S a) (S a)).\n intros.\nelim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_sym (S a) (S a)).\n intros.\n elim (gcd_symQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  red; intros.\n  elim (gcd_sym a (eq_refl a)).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; simpl in H0; tauto.\n  elim H; intros.\n  elim H; intros.\n  apply H0.\n  red; simpl in H0; tauto.\nQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim (gcd_sym1 H2).\n  elim (gcd_sym2 H3).\n  intros.\n  elim (gcd_sym2 H1).\n  intros.\n  elim (gcd_sym2 H3).\n  intros.\n  elim H3; intros.\n  apply H4.\n  elim (gcd_sym2 H3).\n  intros.\n  elim (gcd_sym2 H3).\n  intros.\n  elim H3; intros.\n  apply H4.\n  elim H5; intros.\n  apply H5.\n  elim H6; intros.\n  apply H7.\n  elim H7; intros.\n  elim H7; intros.\n  apply H7.\n  elim H7; intros.\n  elim H8; intros.\n  apply H8.\n  elim H8; intros.\n  apply H9.\n  elim H8; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  apply H8.\n  elim H8; intros.\n  apply H8.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elimQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\n  simple induction 1; simpl; auto with arith.\n  intros.\n  elim (gcd_sym (a-a)).\n  intros.\n  case (gcd_sym (a-b) (m-a)).\n  intros.\n  case (gcd_sym (a-a) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).\n  intros.\n  case (gcd_sym (a+b) (m-a)).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\n",
                "context_tokens": 615,
                "proof_start_offset": 1967,
                "proof_end_offset": 2130,
                "proof": "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\nunfold is_gcd.\nintros.\nsplit.\nred;split;[apply divides_refl | apply one_min_div].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim (prime_abs_1 a); intros.\n  elim H; intros.\n  elim (prime_abs_2 a); intros.\n  elim (prime_abs_2 a); intros.\n  elim (prime_abs_2 a); intros.\n  elim (prime_abs_2 a); intros.\n  elim (prime_abs_3 b); intros.\n  elim H0; intros.\n  elim (prime_abs_3 b); intros.\n  elim (prime_abs_2 b); intros.\n  elim H0; intros.\n  elim (prime_abs_2 a); intros.\n  elim (prime_abs_3 b); intros.\n  elim H3; intros.\n  elim (prime_abs_4 b); intros.\n  elim H5; intros.\n  elim H6; intros.\n  apply H6; rewrite H6; rewrite H6; rewrite H7; reflexivity.\n  apply (prime_abs_3 b); auto.\n  apply (prime_abs_4 b); auto.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply gcd_0_r.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\n intros.\n induction a.\n simpl; auto with arith.\n simpl; auto with arith.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H11; intros.\n  elim H11; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim H13; intros.\n  elim H13; intros.\n  elim H14; intros.\n  elim H15; intros.\n  elim H16; intros.\n  elim H16; intros.\n  elim H16; intros.\n  elim H17; intros.\n  elim H17; intros.\n  elim H17; intros.\n  elim H18; intros.\n  elim H18; intros.\n  elim HQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\n  intro.\n  elim H; intros.\n  elim H; intros.\n  elim (H1 (S x)).\n  assumption.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\n  intro.\n  elim H; intros.\n  elim H; intros.\n  elim H; intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elimQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply prime_antisym;auto.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_symQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\n  simple induction 1.\n  simpl; auto with arith.\n  intros.\n  apply gcd_sym; auto with arith.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\n  simple induction 1; intros.\n  apply gcd_sym.\n  unfold is_gcd in H0.\n  elim H0; intros.\n  apply gcd_sym.\n  apply H0.\n  apply gcd_refl.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\n",
                "context_tokens": 697,
                "proof_start_offset": 2174,
                "proof_end_offset": 2759,
                "proof": "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\nintros.\nunfold is_gcd.\nsplit;intro.\nelim H0;intros.\nsplit.\nred in H1;red.\nelim H1;intros.\nsplit;try tauto.\napply divides_minus;trivial.\nunfold is_cd;intros.\napply H2;red;elim H3;intros.\nsplit;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nelim H0;unfold is_cd;intros.\nsplit.\nsplit;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nintros.\nelim H3;intros;apply H2.\nsplit;try (apply divides_minus);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  elim (gcd_total d a b); intro.\n  elim (gcd_total d a b); intro.\n  elim (gcd_total d a b); intro.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply prime_trans with (d*a); [| apply prime_div | apply prime_div ]; auto.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcdQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  elim H; intros.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  elim (gcd_antisym d a b); auto.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\nintros.\nassert (H := gcd_unique d a b H).\ndestruct (gcd_sym (gcd_sym (gcd_sym (gcd a b) (gcd a b)))).\ndestruct (gcd_sym (gcd_sym (gcd a b) (gcd b a))).\ndestruct (gcd_sym (gcd_sym (gcd a b) (gcd b a))).\ndestruct (gcd_sym (gcd_sym (gcd a b) (gcd a b))).\ndestruct (gcd_sym (gcd_sym (gcd a b) (gcd_sym (gcd a b))).\ndestruct (gcd_sym (gcd a b) (gcd_sym (gcd a b))).\ndestruct (gcd_sym (gcd a b) (gcd_sym (gcd a b))).\ndestruct (gcd_sym (gcd a b) (gcd_sym (gcd a b))).\ndestruct (gcd_sym (gcd a b) (gcd_sym (gcd a b))).\ndestruct (gcd_sym (gcd a b) (gcd_sym (gcd a b))).\ndestruct (gcd_sym (gcd a b) (gcd_sym (gcd a b))).\ndestruct (gcd_sym (gcd aQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H11; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim H10; intros.\n  elim HQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n intros.\n apply gcd_trans with (m:=m); trivial.\n apply gcd_sym.\n apply gcd_trans with (m:=m); trivial.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n intros.\n apply gcd_unique.\n apply gcd_unique.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_opp_l.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n intros.\n apply gcd_unique.\n apply gcd_sym.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\n",
                "context_tokens": 739,
                "proof_start_offset": 2781,
                "proof_end_offset": 2923,
                "proof": "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nunfold is_gcd.\nintros.\nunfold is_cd.\nsplit;try tauto.\nsplit;apply divides_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nunfold is_gcd.\n  intros.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H2;intros.\n  split;try tauto.\n  apply H; trivial.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split;red in H0;tauto.\n  apply H1; auto.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  split; try assumption.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim H12; intros.\n Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nunfold is_gcd.\n  intros.\n  elim H; intros.\n  elim (Even_witness a H1); intros.\n  elim H0; intros.\n  elim (Even_witness a H1); intros.\n  elim H3; intros.\n  apply H3.\n  elim H3; intros.\n  elim (Even_witness a H2); intros.\n  elim H3; intros.\n  elim H4; intros.\n  apply H4.\n  split; try (apply H5; assumption).\n  elim H3; intros.\n  apply H4.\n  elim H3; intros.\n  elim H4; intros.\n  apply H4.\n  elim H4; intros.\n  elim H5; intros.\n  apply H5.\n  split; try (apply H5; assumption).\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split;try tauto.\n  split;try tauto.\n  apply gcd_refl.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply gcd_refl.\n  apply gcd_refl.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim H0; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  split; try tauto.\n  rewrite <- H3; apply gcd_refl.\n  unfold is_gcd.\n  split.\n  assumption.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  split; try tauto.\n  rewrite <- H3; apply gcd_refl.\n  unfold is_gcd.\n  split.\n  assumption.\n  elim H0; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H10; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elimQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nunfold is_gcd.\nintros.\nelim H;intros.\nelim H0;intros.\nelim H1; intros.\nelim H2;intros.\nelim H3; intros.\nelim H4;intros.\nelim H5;intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd in |- *; intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  split.\n  red in |- *; split; trivial.\n  split; trivial.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H4; intros.\n  elim H5; intros.\n  split.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  split.\n  assumption.\n  split.\n  assumption.\n  split; trivial.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 2965,
                "proof_end_offset": 3080,
                "proof": "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red; split; tauto.\n  apply gcd_refl.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H1.\n  assumption.\n  apply H3.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; split.\n  apply gcd_refl.\n  apply gcd_sym; trivial.\n  apply gcd_sym; trivial.\n  apply gcd_sym; trivial.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red; split; tauto.\n  apply gcd_refl.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  case (gcd_sym d a); intros.\n  elim H1; intros.\n  split; try tauto.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  intros.\n  unfold is_gcd.\n  split.\n  red; split;[apply gcd_refl|apply gcd_refl].\n  unfold is_gcd.\n  intros.\n  apply gcd_refl.\n  unfold is_gcd.\n  intros.\n  apply gcd_refl.\n  unfold is_gcd.\n  intros.\n  apply gcd_refl.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H; intros.\n  split; trivial.\n  intros.\n  apply H; auto.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply gcd_refl.\n  apply gcd_sym; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\n",
                "context_tokens": 731,
                "proof_start_offset": 3102,
                "proof_end_offset": 3217,
                "proof": "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;simpl; tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;simpl;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;intros;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  apply gcd_sym.\n  apply gcd_trans with (a*a); trivial.\n  apply gcd_div_r; trivial.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;intros;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd in |- *; unfold is_gcd in |- *; intros;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd in |- *; unfold is_gcd in |- *; intros.\n  elim H; intros.\n  split; trivial.\n  apply gcd_div_l.\n  apply gcd_div_r.\n  apply gcd_div_r.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd; unfold is_gcd;intros;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    intros.\n  elim H0; intros.\n  elim H1; intros.\n  split; [ elim H1 | elim H2].\n  apply gcd_sym; trivial.\n  apply gcd_div_l; trivial.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd; unfold is_gcd; unfold is_gcd;\n intros.\n  apply gcd_antisym;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3393,
                "proof_end_offset": 3478,
                "proof": "Lemma Rwf : well_founded R.\nProof.\nunfold R.\napply (well_founded_ltof (nat*nat) f).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Rwf : well_founded R.\nProof.\nunfold R; intros.\ninduction H.\n compute in H;tauto.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold R, R_dist; intros;apply (well_founded_induction R).\n  unfold is_gcd;intros.\n  apply (well_founded_induction R).\n  unfold R_dist;intros.\n  apply (well_founded_induction R).\n  unfold is_gcd;intros.\n  apply (well_founded_induction R).\n  unfold is_gcd;intros.\n  apply (well_founded_induction R).\n  unfold is_gcd;intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold is_gcd; intros.\n  apply (well_founded_induction R).\n  unfold isQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded;unfold well_founded; unfold well_founded; unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded; unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded;\n    unfold well_founded; unfold well_founded;\n    unfold well_founded;\n    unfold well_founded;\n    unfold well_founded;\n    unfold well_founded;\n    unfold well_founded;\n    unfold well_founded;\n    unfold well_founded;\n    unfold well_founded;\n    unfoldQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded;tauto.\nQed.",
                    "Lemma Rwf : well_founded R.\n  intros.\n  apply (Build_well_founded_induction (R:=R)).\n  apply (Build_well_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  apply (Build_founded_induction (R:=R)).\n  applyQed.",
                    "Lemma Rwf : well_founded R.\nProof.\n unfold is_gcd;intros.\napply (Build_induction (fst (f x)).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x)).\napply (Build_induction (snd (f x))).\napply (Build_induction (fst (f x))).\napply (Build_induction (snd (f x)).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_induction (fst (f x)).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x)).\napply (Build_induction (snd (f x))).\napply (Build_induction (snd (f x))).\napply (Build_Qed.",
                    "Lemma Rwf : well_founded R.\n  unfold is_gcd;intros;tauto.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded;intros.\n  split;[apply infinite_O|apply infinite_O ]; trivial.\nQed.",
                    "Lemma Rwf : well_founded R.\nProof.\n  unfold is_gcd;simpl; tauto.\nQed.",
                    "Lemma Rwf : well_founded R.\napply (Build_Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred; intros.\napply (Build_Setoid (R:=R)).\nred;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ".\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\n",
                "context_tokens": 724,
                "proof_start_offset": 3573,
                "proof_end_offset": 4309,
                "proof": "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nexists (snd x);apply gcd_zero.\nelim (H (S n,snd x-S n)).\nsimpl;intro d;intro.\nexists d.\nelim (gcd_minus d (S n) (snd x));try (auto with arith).\nsimpl.\nomega.\nrewrite e;exists (snd x);apply gcd_refl.\ndestruct (snd x).\nexists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n)).\nsimpl;intro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_minus d (S n) (fst x));try (auto with arith).\nsimpl.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros x.\n  assert (nz_nat x >= 0).\n  apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f).\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros x.\n  case (f x);intros.\n  apply gcd_sym.\n  apply gcd_trans with (x*nat); trivial.\n  apply gcd_trans with (y*nat); trivial.\n  apply gcd_sym; trivial.\n  apply gcd_sym; trivial.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  unfold is_gcd.\n  case_eq (f x); intros.\n  elim H0; intros.\n  split.\n  apply (f_equal (fun x:nat => (x*nat*nat*nat) ^ (x*nat) ^ (x*nat)) (d*x)).\n  apply (f_equal (fun x:nat => (x*nat) ^ (x*nat) ^ (x*nat)) (d*x)).\n  apply (f_equal (fun x:nat => (x*nat*nat) ^ (x*nat))).\n  apply (f_equal (fun x:nat => (x*nat*nat) ^ (x*nat))).\n  apply (f_equal (fun x:nat => (x*nat*nat) ^ (x*nat)) (d*x)).\n  apply (f_equal (fun x:nat => (x*nat) ^ (x*nat) ^ (x*nat))).\n  apply (f_equal (fun x:nat => (x*nat) ^ (x*nat))).\n  apply (f_equal (fun x:nat => (x*nat) ^ (x*nat)Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  destruct x.\n  left; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n  assumption.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  exists (S(nat*nat*nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (S(nat)).\n  unfold pred.\n  exists (S(nat*nat)).\n  unfold pred.\n  exists (SQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros x.\n  unfold gcd.\n  case (f x);intros.\n  elim H; intros.\n  split.\n  red; split;[apply (H1 x).\n  split; [apply (H2 x).\n  rewrite <- (abs_div x b (b*b)) at 2.\n  apply gcd_mult_l.\n  apply gcd_mult_r.\n  apply gcd_mult_r.\n  apply gcd_mult_l.\n  apply gcd_mult_r.\n  apply gcd_mult_r.\n  apply gcd_mult_l.\n  apply gcd_mult_r.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  destruct (H (f x)).\n  exists x.\n  split; trivial.\n  destruct H as (y,H0).\n  exists (y*nat).\n  split; trivial.\n  destruct (H0 (f y)).\n  exists y; trivial.\n  exists (y*nat).\n  split; trivial.\n  destruct (H0 (f y)).\n  exists (y*nat).\n  split; trivial.\n  destruct H0 as (y,H0).\n  exists (y*nat).\n  split; trivial.\n  destruct H0 as (y,H0).\n  exists (y*nat).\n  split; trivial.\n  destruct (H0 (f y)).\n  exists y; trivial.\n  destruct H0 as (y,H0).\n  exists (y*nat).\n  split; trivial.\n  destruct H0 as (y,H0).\n  exists (y*nat).\n  split; trivial.\n  destruct H0 as (y,H0).\n  exists (y*nat).\n  split; trivial.\n  destruct H0 as (y,H0).\n  exists (y*nat).\n  split; trivial.\n  destruct H0 as (y,H0).\n  existsQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  destruct (f x) as (g,(g,(g,(Hg,(Hg,(Hg,(Hg,(Hg,(Hg,(Hg,(Hg,(Hg,(Hg,(Hg,(Hg,Hg))))).\n  left; left; left.\n  apply gcd_eq_compat; apply gcd_sym; trivial.\n  right.\n  apply gcd_div_r; trivial.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd; unfold is_gcd;unfold is_gcd;unfold is_gcd;intros;tauto.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  assert (H0 : (x<0)%positive) by (apply gcd_0; auto).\n  assert (H1 : (x<0)%positive) by (apply gcd_0; auto).\n  assert (H2 : (x<0)%positive) by (apply gcd_0; auto).\n  destruct (gcd_exists_prod d (fst x)).\n  destruct H2 as (H3,H4).\n  exists x.\n  unfold f.\n  apply H3.\n  assumption.\n  assumption.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4346,
                "proof_end_offset": 4496,
                "proof": "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod (a,b)).\nsimpl;intro d;intro;exists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  unfold gcd; intros.\n  case (lt_eq_dec (fst a) (fst b)); intro.\n  exists (S x).\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_comm.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_div_l.\n  apply gcd_sym.\n  apply gcd_div_r.\n  apply gcd_div_r.\n  apply gcd_div_r.\n  apply gcd_div_r.\n  apply gcd_div_r.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd; intros.\n  case (lt_eq_lt_dec (fst a) (fst b)); intro.\n  left;apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  right; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  right; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  right; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  right; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  right; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  right; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  right; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b; exists (gcd a b).\n  apply gcd_div_r.\n  intros.\n  case (lt_eq_dec (fst a) (fst a)); intro.\n  rewrite <- (gcd_0_l a b).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_l b (S n)).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_r b (S n)).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_l b (S n)).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_r b (S n)).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_l b (S n)).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_l b (S n)).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_r b (S n)).\n  apply gcd_div_r.\n  intros.\n  rewrite <- (gcd_0_l b (S n)).\n Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  induction a.\n  exists 1.\n  apply gcd_refl.\n  rewrite gcd_div_l.\n  rewrite <- gcd_div_r.\n  generalize (gcd_div_r a b).\n  destruct (gcd_div_r a b).\n  exists b; trivial.\n  rewrite <- gcd_div_r.\n  generalize (gcd_div_r b d).\n  destruct (gcd_div_r b d).\n  exists d; trivial.\n  rewrite <- gcd_div_r.\n  generalize (gcd_div_r b d).\n  destruct (gcd_div_r b d).\n  exists d; trivial.\n  rewrite gcd_div_r.\n  generalize (gcd_div_r b d).\n  destruct (gcd_div_r b d).\n  exists d; trivial.\n  rewrite gcd_div_r.\n  generalize (gcd_div_r b d).\n  destruct (gcd_div_r b d).\n  exists d; trivial.\n  rewrite <- gcd_div_r.\n  generalize (gcd_div_r b d).\n  destruct (gcd_div_r b d).\n  exists d; trivial.\n  rewrite gcd_div_r.Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  unfold gcd.\n  case (lt_eq_dec (snd a) (snd b)); intro.\n  destruct (H0 (S n)).\n  exists b; auto.\n  rewrite <- H0; apply gcd_div_l.\n  omega.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  case (le_gt_dec (fst a) (fst b)); intro.\n  exists (S m).\n  apply gcd_div_r.\n  trivial.\n  exists (S m).\n  apply gcd_div_r.\n  trivial.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  destruct (le_gt_dec (fst a) (fst a)); [left|right].\n  apply gcd_div_l.\n  intros.\n  assert (a<b) by (apply gcd_0_nonneg; auto).\n  exists (S a); auto.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  elim (gcd_div_r a b d); intros.\n  exists (a/b).\n  apply gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_l.\n  rewrite <- gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_l.\n  rewrite gcd_div_l.\n  rewrite gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_div_r.\n  rewrite gcd_divQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  destruct (gcd_exists_prod a b).\n  exists (S n).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_div_l.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (lt_eq_lt_dec (S a) (S b)).\n  intro.\n  apply gcd_div_l.\n  rewrite (gcd_comm a b).\n  destruct (gcd_comm b (S a)); auto.\n  apply gcd_div_l.\n  intro d.\n  destruct (gcd_comm d (S b)); auto.\n  apply gcd_div_l.\n  apply gcd_div_r.\n  apply gcd_div_r.\n  apply gcd_div_l.\n  apply gcd_div_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4634,
                "proof_end_offset": 4785,
                "proof": "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\nintros.\nunfold gcd.\ngeneralize (gcd_exists a b).\nintro;elim s;intro d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros a b; split.\n  apply gcd_sym; exact (gcd_sym a b).\n  apply gcd_sym; exact (gcd_sym a b).\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  destruct (gcd_exists_prod a b).\n  simpl.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd; intros.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros a b.\n  elim (gcd_exists_prod a b); intros.\n  elim (gcd_exists_prod b d); intros.\n  exists (gcd a d).\n  split; auto.\n  apply gcd_refl.\n  apply gcd_sym; auto.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_exists_prod (a,b) (gcd a b)); intro d; exists d.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  assert (a = gcd a b).\n  apply gcd_sym.\n  rewrite gcd_sym.\n  apply gcd_sym.\n  destruct (gcd_exists_prod a b d).\n  subst.\n  exists (gcd a b); trivial.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd; intros.\n  case (gcd_exists_prod a b); intro.\n  destruct (gcd_exists_prod b d) as [d|d].\n  rewrite gcd_mul_comm.\n  rewrite gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_refl.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans.\n  apply gcd_sym.\n  apply gcd_trans.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans.\n  apply gcd_sym.\n  apply gcd_sym.\n  applyQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  case (gcd_exists_prod (a,b)) (gcd_exists a b).\n  simpl; intros.\n  case (gcd_exists_prod (a,b)).\n  simpl; intro d;intro; exists d; trivial.\n  case (gcd_exists_prod (a,b)).\n  simpl; intro d; intro d.\n  exists d; trivial.\n  rewrite <- gcd_eq_alt.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_refl.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcdQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd; intros.\n  case (gcd_exists_prod (a,b) (gcd a b)); intros.\n  apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; trivial.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  destruct (gcd_exists_prod a b) as [d|d].\n  left; trivial.\n  right; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 4948,
                "proof_end_offset": 5077,
                "proof": "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  elim (gcd_exists_prod a b); auto.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (rel_prime_trans a b H).\n  generalize (rel_prime_sym b H).\n  case (rel_prime_trans b a b); auto.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (rel_prime_sym a b);intro.\n  case (rel_prime_sym b a); intros.\n  generalize (rel_prime_trans b a);intro.\n  case (gcd_def_2 b a); intros.\n  rewrite <- H2; auto with arith.\n  apply div_rel_prime_sym; auto with arith.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  unfold rel_prime.\n  case (rel_prime_sym a b); intro.\n  rewrite H; auto.\n  intro d; rewrite H0; auto.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_prime_sym (gcd a b)).\n  generalize (rel_primeQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  case (rel_prime_sym a b); trivial.\n  elim (gcd_exists_prod b a b); trivial.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  destruct (rel_prime_sym a b) as [H|H].\n  apply H.\n  destruct (rel_prime_sym a b) as [H|H].\n  apply H.\n  destruct (rel_prime_sym a b) as [H'|H'].\n  apply H'.\n  destruct (rel_prime_sym a b) as [H'|H'].\n  apply H.\n  destruct (rel_prime_sym a b) as [H'|H'].\n  apply H'.\n  destruct (rel_prime_sym a b) as [H'|H'].\n  apply H'.\n  destruct (rel_prime_trans a b) as [H'|H'].\n  apply H'.\n  destruct (rel_prime_trans a b) as [H'|H'].\n  apply H'.\n  destruct (rel_prime_trans a b) as [H'|H'].\n  apply H.\n  destruct (rel_prime_trans a b) as [H'|H'].\n  apply H'.\n  destruct (rel_prime_trans a b) as [H'|H'].\n  apply H'.\n  destruct (rel_prime_trans a b) as [H'|H'].\n  apply H'.\n Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  case (rel_prime_sym a b);intros.\n  apply (rel_prime_sym a b).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_prime_trans b (gcd a b)).\n  apply (rel_Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros a b; apply rel_prime_sym.\n  exact (rel_prime_trans _ _ (rel_prime_trans _ _ (rel_prime_trans _ _ (rel_prime_trans _ _ b))).\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime; intros.\n  elim (gcd_exists_prod (a,b) (a,b)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\n",
                "context_tokens": 738,
                "proof_start_offset": 5126,
                "proof_end_offset": 5240,
                "proof": "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;apply gcd_one.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; apply gcd_sym;trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime; intros;omega.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros a b; apply rel_prime_sym;trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros.\n  case (rel_prime_1 a); intro.\n  trivial.\n  apply H1.\n  trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros; apply (rel_prime_intro a);trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime; intros; omega.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; omega.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; elim (gcd_exists_prod a 1).\n  apply (fun p => (fun p => (p * (p * p))%type)).\n  unfold rel_prime.\n  intros; elim (gcd_exists_prod a 1).\n  intros; exists (p * (p * (p * p)))%type; auto.\n  intros; elim H.\n  exists (p * (p * (p * p)))%type; auto.\n  intros; exists (p * (p * (p * p))%type; auto.\n  intros; elim H0.\n  exists (p * (p * (p * p)))%type; auto.\n  intros; elim H0.\n  intros; exists (p * (p * (p * p)))%type; auto.\n  intros; elim H0.\n  intros; exists (p * (p * (p * p))%type; auto.\n  intros; elim H.\n  exists (p * (p * (p * p))); auto.\n  intros; elim H0.\n  exists (p * (p * (p * p)))%type; auto.\n  intros; elim H0.\n  intros; elim H0.\n  existsQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros.\n  case (eq_lt_dec (gcd a b) 1); intro.\n  generalize (gcd_exists_prod a a0 b).\n  generalize (gcd_exists_prod a a0 b).\n  case (gcd_sym a a0); intro.\n  exists (gcd a b); trivial.\n  generalize (gcd_sym b a0 b).\n  case (gcd_sym a a0); intro.\n  exists (gcd a b); trivial.\n  generalize (gcd_sym (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0) (gcd_eq (gcd a b0)Qed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; elim (gcd_exists_prod a 1); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\n",
                "context_tokens": 696,
                "proof_start_offset": 5309,
                "proof_end_offset": 6031,
                "proof": "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (quo_is_quo a d (gcd_div_l d a b H));intro.\ngeneralize (quo_is_quo b d (gcd_div_r d a b H));intro.\nunfold is_gcd;split;unfold is_cd.\nsplit;apply one_min_div.\nintros.\nelim H3;intros.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H6 in H1.\nrewrite H7 in H2.\nassert (divides d (d*d')).\nred in H;elim H;intros.\napply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\nelim H8;intros.\nexists x.\napply mult_lemma6 with d;trivial.\nrewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  assert (H0:(0<a) by (apply gcd_sym; apply gcd_sym).\n  assert (H1:(0<a) by (apply gcd_sym; apply gcd_sym; apply gcd_sym).\n  destruct (gcd_exists_prod d a b).\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n\tdestruct (gcd_exists_prod d a b).\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n\tdestruct (gcd_exists_prod d a b).\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n\tdestruct (gcd_exists_prod d a b).\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n\tdestruct (gcd_exists_prod d a b).\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n\tdestruct (gcd_exists_prod d a b).\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; elim (gcd_exists_prod (c,d) (d, d)).\n  unfold rel_prime; intros; split; trivial.\n  intros (H1, H2); unfold rel_prime in H1.\n  apply gcd_sym; trivial.\n  intros (H3, H4); unfold rel_prime in H3.\n  apply gcd_sym; trivial.\n  intros (H4, H5); unfold rel_prime in H4.\n  apply gcd_sym; trivial.\n  intros (H4, H5); unfold rel_prime in H4.\n  apply gcd_sym; trivial.\n  intros (H5, H5); unfold rel_prime in H4.\n  apply gcd_sym; trivial.\n  intros (H5, H5); unfold rel_prime in H5.\n  apply gcd_sym; trivial.\n  intros (H6, H6); unfold rel_prime in H5.\n  apply gcd_sym; trivial.\n  intros (H6, H6); unfold rel_prime in H6.\n  apply gcd_sym; trivial.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  apply gcd_sym; apply gcd_sym;trivial.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  unfold rel_prime in H.\n  apply gcd_sym;trivial.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  generalize (gcd_exists d a H); clear H.\n  induction d; simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_def d a); auto.\n  simpl; intros.\n  case (gcd_Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  apply gcd_intro; apply gcd_intro; apply gcd_sym; trivial.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime; intros.\n  case (gcd_exists_prod (a,b) (gcd a b)).\n  simpl; intro d; intro.\n  case (gcd_exists_prod (a,b) (gcd a b)).\n  simpl; intro d; intro.\n  case (gcd_div_r d (gcd a b)).\n  simpl; intro d.\n  case (gcd_div_r d (gcd a b)).\n  simpl; intro d.\n  case (gcd_div_r d (gcd a b)).\n  simpl; intro d; intro.\n  case (gcd_div_r d (gcd a b)).\n  simpl; intro d.\n  case (gcd_div_r d (gcd a d)).\n  simpl; intro d; intro.\n  case (gcd_div_r d (gcd a b)).\n  simpl; intro d.\n  case (gcd_div_r d (gcd a d)).\n  simpl; intro d.\n  case (gcd_div_r d (gcd a b)).\n  simpl; intro d.\n  case (gcd_div_r d (gcd a b)).\n  simpl; intro d.\n  case (gcd_div_r d (gcd bQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  unfold rel_prime.\n  intros.\n  case (gcd_exists (a, b)); intro d; case (gcd_exists_prod (a, b)); intro d.\n  case (gcd_exists (a, b)); intro d; case (gcd_exists_prod (a, b)); intro d.\n  rewrite <- H; rewrite H; auto.\n  rewrite <- H; auto.\n  rewrite <- H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 6065,
                "proof_end_offset": 6268,
                "proof": "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nunfold is_gcd.\nintros.\nelim H0;intros.\nintro.\nelim H1;intros.\nelim H5;intros.\nrewrite H3 in H6;simpl in H6;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros.\ngeneralize (gcd_exists p q H0 H1 H2); intro.\nelim H1; intro.\nelim H2; intro.\nelim H4;intro.\napply H5; rewrite H5;auto.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros d p q.\ngeneralize (gcd_exists p q).\ninduction p as [|p|p].\nintros.\nsimpl in |- *; auto with arith.\nintros p q.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros q'.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros.\nintros q.\nsimpl in |- *.\nintros q'.\nsimpl in |- *.\nintros.\nintros q'.\nsimpl in |- *.\nintros.\nintros.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros q'.\nsimpl in |- *.\nintros.\nintros q.\nsimpl in |- *.\nintros.\nintros.\nsimpl in |- *.\nintros q.\nsimpl in |- *.\nintros q'.\nsimpl in |- *.\nintros q'.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nintros q.\nsimpl inQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold gcd in |- *; intros.\n  elim (gcd_is_gcd d p (gcd_div_r d p q H0)).\n  intros.\n  elim H; intros.\n  elim H8; intro.\n  rewrite H7 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewriteQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros.\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (p*q).\n  apply gcd_intro with (pQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros.\nrewrite <- gcd_factor_l.\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_comm q).\nrewrite <- (gcd_commQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros.\nunfold gcd.\ngeneralize (gcd_exists p q H);intro.\nelim (gcd_exists_pos p q H).\nrewrite mult_comm;rewrite H1;auto.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_l.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_r.\n  rewrite <- gcd_div_Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros; unfold gcd.\n  generalize (gcd_exists d p (gcd (p,q) (p,q)).\n  generalize (gcd_exists d p (gcd (p,q) (p,q)).\n  intros.\n  destruct (gcd_exists_gcd d p q) as [H1 H2].\n  exists x.\n  apply gcd_sym;apply gcd_sym; apply gcd_refl.\n  intros.\n  elim H2; intro.\n  rewrite H7 in H1.\n  rewrite H7 in H2.\n  assert (exists d, gcd d (p,q) (p,q) (p0,q).\n  apply gcd_unique with d; trivial.\n  rewrite <- H1; trivial.\n  rewrite <- H3; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n  apply gcd_sym; apply gcd_sym; apply gcd_sym;\n  apply gcd_symQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros.\ndestruct (gcd_exists_prod d p).\nexists p.\nexists q.\nunfold gcd.\nrewrite <- (gcd_sym q p).\nrewrite <- (gcd_intro q p).\nrewrite <- (gcd_intro q p).\nrewrite <- (gcd_intro q p).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_intro q q).\nrewrite <- (gcd_introQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros.\n  apply gcd_is_gcd.\n  intros.\n  apply gcd_intro;apply gcd_intro;apply gcd_intro;apply gcd_intro;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\n",
                "context_tokens": 700,
                "proof_start_offset": 6472,
                "proof_end_offset": 6772,
                "proof": "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros.\nelim (gcd_minus ((u+v)*x-v*y) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\ninduction x.\nintro.\ndestruct u.\nrewrite H0.\nrewrite <- H1.\nrewrite <- (mult_1_r x), (mult_comm y), (mult_1_r y), (mult_comm y).\nrewrite <- (mult_assoc z), (mult_1_r y), (mult_comm (z-x)).\nrewrite <- (mult_comm (z*x)).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc z).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc z).\nrewrite <- (mult_comm (z*x)).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc z).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc z).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc z).\nrewrite <- (mult_assoc (z*x)).\nrewrite <- (mult_assoc (zQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros x y u v.\n  case u; intros.\n  elim H0; intro.\n  elim H1; intros.\n  elim H2; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  intro.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  elim H3; intro.\n  elim H4; intro.\n  rewrite H5 in H6; simpl in H6; auto.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in H6; auto.\n  elim H3; intro.\n  rewrite H4 in H6; simpl in HQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros x y u v; unfold is_gcd; split; intros.\n  case (u*x); intros.\n  exists (u*x).\n  apply mod_lemma1; auto.\n  rewrite <- H1; rewrite H2; ring.\n  intros.\n  apply H1; rewrite H3; rewrite H4; ring.\n  intros.\n  apply H3; rewrite H4; rewrite H5; ring.\n  intros.\n  apply H3; rewrite H4; rewrite H5; ring.\n  intros.\n  apply H4; rewrite H4; rewrite H5; ring.\n  intros.\n  apply H4; rewrite H5; rewrite H5; ring.\n  intros.\n  apply H4; rewrite H5; rewrite H6; ring.\n  intros.\n  apply H4; rewrite H5; rewrite H6; ring.\n  intros.\n  apply H5; rewrite H6; rewrite H6; ring.\n  intros.\n  apply H3; rewrite H4; rewrite H6; ring.\n  intros.\n  apply H4; rewrite H5; rewrite H6; ring.\n  intros.\n  apply H4; rewrite H4; rewrite H6; ring.\n  introsQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\ninduction x; simpl; intros.\nrewrite H0 in H.\nrewrite H1 in H.\nrewrite H1 in H.\nrewrite H in H.\nrewrite H in H.\ndestruct (u*x-v)(y-v)(y-v)(y-v)(y-v=(y-v) H0).\ndestruct (u*x-v)(y-v)(y-v)(y-v) H0).\ndestruct (u*x-v)(y-v)(y-v) H0).\ndestruct (v*x-v)(y-v) H0).\ndestruct (v*x-v)(y-v) H0).\ndestruct (v*x-v)(y-v) H0).\ndestruct (v*x-v) H0).\ndestruct (v*x-v)(y-v) H0).\ndestruct (v*x-v) H0).\ndestruct (v*x) as [H|H].\ndestruct (v*x) as [H|H].\nexists x; auto.\ndestruct (v*x) as [H|H].\ndestruct (Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\ninduction x; simpl; auto.\nintros; exists (u*x*x); auto.\nintros; exists (u*x); auto.\nintros; exists (u*x); auto.\nintros; exists (u*x); auto.\nintros; exists (u*x); auto.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\ninduction x;simpl;intros.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [p q| ]; simpl;auto.\ndestruct (u*x)%Z as [pQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nunfold is_gcd, div in |- *.\nintros.\nelim H; intros.\nelim H2; intros.\nelim H3; intro.\nrewrite H4 in H1; simpl in H1;auto.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros.\n  unfold is_gcd in H.\n  generalize (gcd_is_gcd u x y H).\n  intro.\n  generalize (gcd_is_gcd u y x H).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_is_gcd u y x H0).\n  intro.\n  generalize (gcd_isQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\ninduction x; destruct y; simpl; trivial.\nintros.\nrewrite H3 in H0; simpl in H0;auto.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros.\n  apply gcd_sym;apply gcd_sym;apply gcd_sym;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n",
                "context_tokens": 700,
                "proof_start_offset": 6774,
                "proof_end_offset": 7070,
                "proof": "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\nProof.\nintros.\nelim (gcd_minus (v*y-(u+v)*x) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u*x-v*y-v*y) x) y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- H2;auto with arith.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v*y-x)*v) x y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- H3;auto with arith.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v*y-v*y) x) y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- H1;auto with arith.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v*y-v)*(y-v+v+v*y) x y H); intros.\n  rewrite H2.\n  rewrite plus_comm;rewrite <- (mult_comm u (v*y-v*y*y+v*y+v*y+v*y*y+v*y)).\n  rewrite (mult_comm u (v*y-v*y+v*y+v*y+v*y+v*y*y+v*y)).\n  rewrite (mult_comm u (v*y-v*y+v*y+v*y+v*y+v*y+v*y+v*y+v*y)).\n  rewrite (mult_comm u (v*y-v*y+v*y+v*y+v*y+v*y*z*y+v*y+v*y+v*y+v*y)).\n  rewrite (mult_comm u (v*y-v*y+v*y+v*y+v*y+v*y*y+v*y+v*yQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (u*x-v) (u*y-v) y y H); intros.\n  apply H2.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; auto with arith.\n  apply mult_le_compat_r; auto with arith.\n  rewrite <- (mult_comm (u*y-v)).\n  rewrite (mult_comm (u*y-v)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (u*y)).\n  rewrite (mult_comm (Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u*x-v*(y-u*y)+v*y) x y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- H4;auto with arith.\n  rewrite mult_plus_distr_r;rewrite <- H4;auto with arith.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u*x-v)-v*y) x y H); intros.\n  apply H2.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite plus_minus_lemma1;try (auto with arith).\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;ring.\n  apply (H1 y u v w y H H1 H2).\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v*y-v)+v*y) x y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- H3;auto with arith.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u*x-v)*(y-x)) x y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assoc; rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assoc;rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assoc;rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assoc;rewrite <- (mult_comm u (v*y)).\n  rewrite (mult_comm u (v*y)).\n  rewrite (mult_comm u (v*y)).\n  rewrite mult_assoc;rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assoc; rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assoc; rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assoc; rewrite <- (mult_comm u (v*y)).\n  rewrite (mult_comm u (v*y)).\n  rewrite mult_assoc; rewrite <- (mult_comm u (v*y)).\n  rewrite mult_assocQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*(y-x)+v*y) x y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- (mult_comm x).\n  rewrite mult_comm;rewrite <- (mult_comm y).\n  rewrite mult_comm;rewrite <- (mult_comm x).\n  rewrite mult_comm;rewrite <- (mult_comm y).\n  rewrite mult_assoc;rewrite <- (mult_comm x).\n  rewrite mult_comm;rewrite <- (mult_comm x).\n  rewrite mult_assoc;rewrite <- (mult_comm y).\n  rewrite mult_comm; rewrite <- (mult_comm y).\n  rewrite mult_assoc;rewrite <- (mult_comm (a*x)).\n  rewrite mult_assoc;rewrite (mult_comm (a*x)).\n  rewrite (mult_comm (a*x)).\n  rewrite mult_assoc;rewrite <- (mult_comm (a*x)).\n  rewrite (mult_comm (a*x)).\n  rewrite mult_assoc; rewrite mult_comm; rewrite <- (mult_comm (a*x)).\n  rewrite mult_comm; rewrite <- (mult_commQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\n",
                "context_tokens": 677,
                "proof_start_offset": 7098,
                "proof_end_offset": 8538,
                "proof": "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nright;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\nelim (H (S n,snd x-S n));try (intro;simpl).\nelim a;intro y;intro.\nleft;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nright;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nrewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\ndestruct (snd x).\nleft;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n));try (intro;simpl).\nelim a;intro y;intro.\nright;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nleft;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  apply H.\n  apply H;auto.\n  apply not_le_antisym;auto.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (H 0); intros.\n  elim H1; intros.\n  apply H1; assumption.\n  rewrite H2.\n  rewrite mult_plus_distr_r; rewrite plus_comm; rewrite mult_comm; rewrite mult_comm;\n    rewrite <- mult_plus_distr_r; rewrite <- mult_assoc;\n      rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n        rewrite <- mult_plus_distr_r; rewrite <- mult_assoc;\n          rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n          rewrite <- mult_assoc;\n          rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n          rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n          rewrite <- mult_assoc; rewrite <- mult_assoc;\n          rewrite <- mult_assoc; rewrite <- mult_assoc;\n          rewrite <- mult_assoc; rewrite <- mult_assoc;\n          rewrite mult_comm; rewrite <- mult_assoc;\n            rewrite <- mult_assoc; rewrite <- mult_comm;\n            rewrite <- mult_assoc; rewrite <- mult_comm;\n            rewrite <- mult_assoc;Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (H _ H1); intros.\n  elim H1; intros.\n  rewrite H3 in H1; simpl in H1; auto.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (H (u*y)); intros.\n  apply H1; trivial.\n  rewrite mult_comm; rewrite H1; rewrite mult_comm.\n  rewrite mult_plus_distr_r;rewrite <- mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite plus_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (H1 y x H2); intros.\n  elim H3; intros.\n  rewrite H3 in H3; rewrite H3 in H3; auto.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (H (fst y)); intros.\n  apply H3;auto with arith.\n  apply H1.\n  rewrite mult_comm; rewrite <- minus_minus_lemma1;try (auto with arith).\n  apply H1;auto with arith.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (H (fst y) (fst y)); intros.\n  elim H1; intros.\n  rewrite H3 in H1.\n  rewrite H4 in H1.\n  rewrite H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H3 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (H 1 (fst y)); intros.\n  apply H3.\n  rewrite H3.\n  rewrite mult_plus_distr_r; rewrite <- mult_plus_distr_r;auto with arith.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (prod_minus_l x y (fst y));intros.\n  apply H1; assumption.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n    rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n      rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n        rewrite mult_comm; rewrite (mult_comm (a*x)) at 1;\n          rewrite mult_comm; rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n            rewrite (mult_comm (a*x)) at 1;\n              rewrite (mult_comm (a*x)) at 1;\n              rewrite (Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros x.\n  elim (H (fst (fst y))).\n  intros.\n  elim H; intros.\n  apply (H2 (fst y)).\n  rewrite mult_plus_distr_r; rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n    rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_assoc;\n      rewrite mult_assoc; rewrite mult_assoc; rewrite mult_comm; rewrite mult_comm;\n      rewrite mult_comm; rewrite mult_comm; rewrite <- mult_assoc;\n        rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n        rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n          rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n          rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n          rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n          rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;\n          rewrite <- mult_comm; rewrite <- mult_comm;\n            rewrite mult_comm; rewrite (mult_comm (n * (n * n * n * n * n * (n * n *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\nLemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\n",
                "context_tokens": 690,
                "proof_start_offset": 8563,
                "proof_end_offset": 8967,
                "proof": "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros.\nelim (bezout_exists_prod (a,b));intro.\nelim a0;destruct x;simpl;intros.\nleft;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\nelim b0;destruct x;simpl;intros.\nright;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  case (le_lt_dec a b); intro.\n  left; exists (1+a).\n  apply H; assumption.\n  left; exists ((snd a)*(1+a)).\n  simpl; apply H; assumption.\n  right; exists ((fst a)*(1+a))).\n  simpl; apply H; assumption.\n  right; exists (1+a).\n  simpl;apply H; assumption.\n  right; exists ((snd a)*(1+a))).\n  simpl; apply H; assumption.\n  right; exists ((fst a)*(1+a)).\n  simpl; apply H; assumption.\n  right; exists ((snd a)*(1+a))).\n  simpl; apply H; assumption.\n  right; exists ((snd a)*(1+a)).\n  simpl; apply H; assumption.\n  right; exists ((fst a)*(1+a)).\n  simpl; apply H; assumption.\n  left; exists ((snd a)*(1+a)).\n  simpl; apply H; assumption.\n  right; exists ((snd a)*(1+a)).\n  simpl; apply H; assumption.\n  right; exists ((fst a)*(1+a)).\n  simpl; apply H; assumption.\n  right;Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  case (lt_eq_lt_dec (fst a) (snd a)).\n  left;exists ((snd a)*(fst a)*(fst a))).\n  simpl; apply is_gcd_eq.\n  apply is_gcd_eq; auto with arith.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro; auto with arith.\n  apply is_gcd_intro.\n  apply is_gcd_intro; auto with arith.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_introQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  case (le_lt_eq_dec a b); intros.\n  left; exists ((fst a+u*v)); simpl; ring.\n  apply (lt_S_n _ _ (le_lt_trans _ _ _ (le_S_n _ _ (lt_S_n _ _ H))).\n  apply le_trans with (m*v+1).\n  apply le_S_n; apply le_n_S.\n  apply le_n_S.\n  apply le_trans with (m*v).\n  apply le_trans with (m*v).\n  apply le_n_S.\n  apply le_n_S.\n  apply le_trans with (m*v).\n  apply le_S_n; trivial.\n  apply le_trans with (m*v).\n  apply le_n_S.\n  apply le_trans with (m*v).\n  apply le_n_S.\n  apply le_n_S.\n  apply le_trans with (m*v).\n  apply le_S_n.\n  apply le_trans with (m*v).\n  apply le_n_S.\n Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  elim (le_lt_dec a b); intros.\n  elim H; intro.\n  apply H0.\n  rewrite H2.\n  apply (H (S n), (S n).\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- (mult_comm (a+n)).\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plus_r.\n  apply le_plusQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  case (le_gt_dec a b); intro.\n  rewrite (H a b a0 b a0 b a0 b a0 b0 b0 b0 a1 a1 a2 b2 b3 b4 b5 b6 b7 b8 b8 b9 b10 b10 b11 b11 b12 b13 b13 b14 b15 b15 b5 b15 b5 b5 b6 b6 b7 b8 b9 b10 b13 b15 b15 b15 b5 b5 b6 b7 b8 b9 b15 b15 b15 b15 b5 b5 b6 b7 b8 b8 b9 b15 b15 b15 b5 b6 b7 b7 b8 b9 b15 b15 b4 b4 b5 b6 b6 b7 b8 b9 b15 b15 b4 b5 b6 b6 b8 b9 b15 b4 b5 b6 b7 b7 b8 b9 b4 b4 b4 b6 b8 b8 b5 b8 b9 b10 b11 b1 b2 b3 b4 b4 b5 b6 b7 b8 bQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros.\n  exists (a-b).\n  replace (a-b) with (a-b).\n  replace (a-b) with (a-b).\n  apply gcd_div2; auto.\n  unfold a;auto.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros.\n  destruct (lt_gt_dec a b).\n  left.\n  destruct b.\n  left.\n  destruct b.\n  left.\n  destruct b.\n  left.\n  destruct b.\n  right.\n  destruct b.\n  left.\n  destruct b.\n  right.\n  destruct b.\n  left.\n  destruct b0.\n  left.\n  destruct b0.\n  left.\n  destruct b.\n  left.\n  destruct b0.\n  right.\n  destruct b0.\n  right.\n  destruct b0.\n  right.\n  destruct b0.\n  left.\n  destruct b0.\n  right.\n  destruct b0.\n  right.\n  destruct b0.\n  right.\n  destruct b0.\n  left.\n  destruct b0.\n  left.\n  destruct b0.\n  right.\n  destruct b0.\n  left.\n  destruct b0.\n  right.\n  destruct b0.\n  left.\n  destruct b0.\n  left.\n  destruct b0.\n  right.\n  destruct b0.\n  left.\n  destruct b0.\n  right.\n  destruct b0.\n  right.\n  destruct b0.\n  left.\n  destruct b0.\n  left.\n  destruct b0Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintro a.\ninduction a.\nsimpl.\ndestruct b.\ndestruct b.\ndestruct b.\ndestruct b.\ndestruct (H (S n) a).\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  case (lt_eq_lt_dec a b); intros.\n  destruct (le_lt_eq_dec a b).\n  left;apply (H (S n)).\n  apply (H (S n)).\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (gcd_div2 a b); intros.\n  elim (gcd_div2 a b); intros.\n  apply (gcd_div2 b a b); auto.\n  elim b; intro.\n  right; exists ((fst x)*(fst x*(0,(0,(0,(0,(0,(1,(1,(2,(3,(4,(5,(6,6)))))))); auto.\n  apply (H1 (S n, snd x)); auto.\n  apply (H2 (S n, snd x)); auto.\n  apply (H1 (S n, snd x)); auto.\n  apply (H2 (S n, fst x)); auto.\n  apply (H1 (S n, snd x)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\n",
                "context_tokens": 708,
                "proof_start_offset": 9005,
                "proof_end_offset": 9380,
                "proof": "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\nelim (bezout_exists a b);intro.\nelim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\nelim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (gcd_exists_aux1 d a b);intro.\n  case (gcd_exists_aux2 d a b);intro.\n  right;exists 1;auto.\n  right;exists (S n);auto.\n  right;exists n;exists n0;auto.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (Zis_gcd_exists_strong a b (S b));intro.\n  exists (S b);simpl;rewrite <- (mult_comm a);trivial.\n  left;exists (S b);simpl;rewrite <- (mult_comm b);trivial.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\ncase (is_gcd d a b); intro.\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (b*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (b*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).\nexists (a*u).Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\ndestruct d; simpl; intros; auto.\ndestruct (H0 a).\ndestruct (H1 a).\ndestruct (H2 a).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).\nexists (S b).Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\ndestruct (H (a*v)).\nexists (a*v).\ndestruct (H (a*v)).\nexists (a*v).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\nexists (a*v).\ndestruct (H (a*v)).\nexists (a*v).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (a*v)).\ndestruct (H (aQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (is_gcd_exists u); intro.\n  left;exists n;exists 1;auto.\n  right;exists n;exists 1;auto.\n  left;exists n;exists 1;auto.\n  right;exists n;exists 1;auto.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nintros.\ninduction d.\nexists 0; exists 1; exists 1; rewrite mult_comm; rewrite <- (mult_comm a);trivial.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (Zle_lt_eq_dec a b); intro.\n  left;exists (a*u);simpl;rewrite (mult_comm b);trivial.\n  left;exists n;exists (a*u);simpl;rewrite (mult_comm a);trivial.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  destruct d as [u u].\n  exists u.\n  intros.\n  elim (Zis_gcd_for_gcd_nat (a,b) (a,b));intro.\n  exists (S u).\n  intros.\n  elim H; intros.\n  apply H2.\n  apply H1.\n  apply H2.\n  assumption.\n  rewrite H1; ring.\n  intros.\n  apply H2.\n  apply H1.\n  assumption.\n  apply H2.\n  assumption.\n  assumption.\n  assumption.\n  apply H1.\n  assumption.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintro a.\ninduction a as [|a|a].\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexists (a-b).\nexistsQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\n",
                "context_tokens": 704,
                "proof_start_offset": 9434,
                "proof_end_offset": 10062,
                "proof": "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nunfold rel_prime.\nsplit;intro.\napply bezout;trivial.\nelim H;intro u;intro H0.\nelim H0;intro v;intro.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H2;intros.\nelim H3;intro q;intro.\nelim H4;intro q';intro.\nrewrite H5 in H1;rewrite H6 in H1.\ncase H1;intro.\nexists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nexists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (MV_exists_rel a b);intro.\n  elim a0; intro.\n  left; exists (S n); rewrite (plus_comm a);trivial.\n  left; exists (S n);rewrite (plus_comm a);trivial.\n  right; exists (S n);rewrite (plus_comm b);trivial.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (Zis_gcd_for_prime a b); intro.\n  elim a0; intro u; elim u; intro; elim v;intro; exists v; right; auto.\n  elim a0; intro v; elim a1; intro v; exists v; right; auto.\n  elim a0; intro v; elim a1; intro v; elim a2; intro v; exists v; right; auto.\n  elim a0; intro v; elim a2; intro v; exists v; right; auto.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (rel_prime_bezout a b);intro.\n  elim a0; intro.\n  right; exists 1; rewrite <- (mult_comm a).\n  apply (rel_prime_bezout a b); trivial.\n  right; exists (1, b); rewrite (mult_comm b).\n  apply (rel_prime_bezout a b); trivial.\n  elim b0; intro.\n  left; exists (1, b); rewrite <- (mult_comm b).\n  apply (rel_prime_bezout a b); trivial.\n  apply (rel_prime_bezout b (a*v) a b); trivial.\n  elim b0; intro.\n  left; exists (1, b); rewrite <- (mult_comm b).\n  apply (rel_prime_bezout a b); trivial.\n  left; exists (1, b); rewrite <- (mult_comm b).\n  apply (rel_prime_bezout a b); trivial.\n  left; exists (1, b); rewrite <- (mult_comm b).\n  apply (rel_prime_bezout a b); trivial.\n  right; exists (1, b); rewrite <- (mult_comm b).\n  apply (rel_prime_Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros a b; elim (Zis_gcd_bezout a b);intro.\n  exists (S a).\n  split;intro.\n  elim (Zis_gcd_bezout a b); intro.\n  elim H; clear H; intro H0.\n  elim H0; clear H0; intro H1.\n  right; exists (S b).\n  split;intro.\n  elim (H (S b)).\n  right; exists (S b).\n  split;intro.\n  elim H1; intro.\n  right; exists (S b).\n  split;intro.\n  elim H1; intro.\n  elim H2; intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intro.\n  elim H6; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H7; intro.\n  elim H8; intro.\n  elim H8; intro.\n  elim H8; intro.\n  elim H8; intro.\n  elim H8; intro.\n  elim H8Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (Zis_gcd_prime a b); intro.\n  elim H; intro.\n  exists (S b); exists (S b); split.\n  left; exists (S b); split.\n  left; exists (S b); split.\n  left; exists (S b); split.\n  left; exists (S b); split.\n  right; exists (S b); split.\n  left; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  left; exists (S b); split.\n  right; exists (S b); split.\n  left; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  right; exists (S b); split.\n  left; exists (S b); split.\n  right; exists (S b); split.\n Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (Zis_gcd_exists_prime a b);intro.\n  elim a0; intro v; exists v;auto.\n  elim a1; intro v; exists v;auto.\n  elim a1; intro v; exists v;auto.\n  elim (Zis_gcd_exists_prime a b); intro.\n  elim b0; intro v; exists (1/1); auto.\n  elim a2; intro v; exists (1/1).\n  elim (Zis_gcd_exists_prime a b); intro.\n  elim a0; intro v; exists (1/1); auto.\n  elim a0; intro v; exists (1/1).\n  elim (Zis_gcd_exists_prime a b); intro.\n  elim a0; intro v; exists (1/1).\n  elim ( Zis_gcd_exists_prime a b); intro.\n  elim a0; intro v; exists (1/2).\n  elim ( Zis_gcd_exists_prime a b); intro.\n  elim a0; intro.\n  rewrite <- H2; rewrite (mult_comm a); rewrite (mult_comm b); auto.\n  apply gcd_intro with (Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (Zis_gcd_prime a b); intro.\n  elim a0; intro a1; case a1; intro a2; case a2; intro a3; case a4; intro a4; case a5;\n   intro a5; case a6; intro a7; case a7; intro a7; case a7;\n   intro a7; case a7; intro a7; case a7; intro; case a7;\n   intro a7; case a7; intro a7; case a7; intro; case a7;\n   intro a7; case a7; intro a7; case a7; intro a7; case a7;\n   intro a7; case a7; intro a7; case a7; intro a7; case a7;\n   intro a7; case a7; intro a7; case a7; intro a7; case a7;\n   intro a7; case a7; intro a7; case a7; intro a7; case a7;\n   intro a7; case a7; intro a7; case a7; intro; case a7;\n   intro a7; case a7;Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (thm_exists a b);intro.\n  elim H; clear H; intros u [v [H1 H2]].\n  exists v; exists v; exists v; exists v; split; auto.\n  rewrite H1; rewrite H2; rewrite H3; rewrite H4; auto.\n  rewrite H4; rewrite H4; rewrite H4; auto.\n  rewrite H4; rewrite H4; rewrite H4; auto.\n  rewrite H4; rewrite H4; auto.\n  rewrite H4; rewrite H4; auto.\n  rewrite H4; rewrite H4; auto.\n  rewrite H4; rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\n  rewrite H4; auto.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros a b; elim (Zis_gcd_exists a b);intro.\n  exists (1*u-a*v).\n  rewrite (Zmult_comm a b); trivial.\n  rewrite (Zmult_comm b a); trivial.\n  rewrite (Zmult_comm a b); trivial.\n  rewrite (Zmult_comm a b); trivial.\n  rewrite (Zmult_comm b a); trivial.\n  rewrite (Zmult_comm b a); trivial.\n  rewrite (Zmult_comm a b); trivial.\n  rewrite (Zmult_comm b a); trivial.\n  rewrite (Zmult_comm a b); trivial.\n  rewrite (Zmult_comm a b); trivial.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros a b; generalize (rel_prime_bezout a b); intro.\n  case a;intro.\n  exists (S a);split.\n  apply div_pos;auto.\n  exists (S b);split.\n  apply div_pos;auto.\n  apply div_pos;auto.\n  exists (S b);split.\n  apply div_pos;auto.\n  exists (S b);split.\n  apply div_pos;auto.\n  exists (S b);split.\n  apply div_pos;auto.\n  exists (S b);split.\n  apply div_pos;auto.\n  exists (S b);split.\n  apply div_pos;auto.\n  exists (S b);split.\n  apply div_pos;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 10097,
                "proof_end_offset": 10866,
                "proof": "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nunfold is_gcd;unfold is_cd.\nintros.\nelim H;intros.\nelim H0;intros.\nsplit.\nelim H2;intro q;intro.\nelim H3;intro q';intro.\nrewrite H4;rewrite mult_assoc.\nrewrite H5;rewrite mult_assoc.\nsplit;[exists q;trivial | exists q';trivial].\nintros.\nelim H4;intros.\nelim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\nintro u;intro.\nelim H7;intro v;intro.\nelim H5;intro q;intro.\nelim H6;intro q';intro.\ncase H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\ndestruct (gcd_mult d a b); trivial.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\nunfold rel_prime.\ncase (Zis_gcd_exists_dec (n*d) (n*d) (n*d)) with (n*d*d); trivial.\nelim n; intros.\nunfold rel_prime.\nreplace (n*d) with (n*d*d).\nrewrite mul_comm.\nrewrite mul_comm.\nrewrite <- (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (mult_comm (n*d)).\nrewrite (multQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\nelim (  \n   (Odd_exists_ex (S n) (S n)) (S (S n)) (S (S n)) (S (S n)) (S (S n))); trivial.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\nelim (Zis_reg_is_gcd d a b).\nintros n H.\nelim H; intros.\nexists n; rewrite mul_comm; rewrite <- H; ring.\nintros n H.\nelim H; intros.\nelim H0; intros.\nrewrite H5 in H; rewrite H in H; rewrite H; ring.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\napply gcd_mult.\nrewrite <- (mult_comm (n*a*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (mult_comm (n*d)).\nrewrite <- (multQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\ninduction n.\nunfold is_gcd;simpl.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nrewrite <- (mult_comm (n*d)) at 1.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\nassert (H : forall n, n = (n*d) * (d*d*d) < (d*d*d)).\n  intros.\n  omega.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\nelim (gcd_mult (d a b) (d * a) (d * a) (d * a) (d * a) (d * b)).\nintros.\nrewrite <- H0; apply gcd_mult_l.\nrewrite <- H0; apply gcd_mult_l.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\ndestruct (gcd_mult d a b);trivial.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nintros.\ndestruct (rel_prime_dec (d - a) (d - a) (d - b)) as [H|H].\n  elim H; intro.\n  elim H0; intro.\n  right; exists n; rewrite mult_comm; rewrite (mult_comm a);trivial.\n  rewrite <- H; rewrite <- H; rewrite mult_assoc; rewrite mult_comm; rewrite (mult_comm a);trivial.\n  rewrite H; rewrite mult_comm; rewrite (mult_comm a); rewrite (mult_comm a);trivial.\n  rewrite <- H; rewrite <- H; rewrite mult_assoc; rewrite <- H; rewrite (mult_comm a);trivial.\n  apply le_trans with (n*d*d).\n  rewrite mult_comm; rewrite (mult_comm a); rewrite (mult_comm a);trivial.\n  rewrite <- H; rewrite mult_comm; rewrite (mult_comm b);trivial.\n  apply le_trans with (n*d*d).\n  rewrite mult_comm; rewrite (mult_comm a);rewrite (mult_comm a);trivial.\n  rewrite <- H; rewrite mult_comm; rewrite <- H; rewrite <- H; ring.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "formulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 10903,
                "proof_end_offset": 11396,
                "proof": "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nintros.\nelim (bezout 1 a d H);intro u;intro.\nelim H1;intro v;intro.\nelim H0;intro q;intro.\ncase H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros d a b; elim (div_rel_prime d a b); intros; elim H; clear H; intros;\n elim H0; intros.\n  elim H3; intro.\n  rewrite H4; rewrite mult_comm; rewrite mult_comm; rewrite <- H3; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite mult_comm; rewrite <- H3; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite mult_comm; rewrite <- H3; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite mult_comm; rewrite <- H3; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite mult_comm; rewrite <- H4; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite <- H4; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite <- H4; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite mult_comm; rewrite <- H4; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite <- H4; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite <- H4; reflexivity.\n  rewrite H4; rewrite mult_comm; rewrite <-Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nintros.\napply inv_prime_mult;trivial.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold is_gcd;unfold is_gcd; unfold is_gcd;unfold is_gcd;unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nintros.\nunfold rel_prime.\nrepeat split;intro.\nrewrite <- H0.\nrewrite mult_assoc.\nrewrite <- H0.\nrewrite mult_comm.\nrewrite <- H1.\nrewrite mult_assoc.\nrewrite <- H0.\nrewrite mult_comm.\nrewrite <- H0.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite <- H1.\nrewrite mult_assoc.\nrewrite <- H1.\nrewrite mult_assoc.\nrewrite <- H1.\nrewrite mult_comm.\nrewrite <- H1.\nrewrite mult_assoc.\nrewrite <- H1.\nrewrite mult_assoc.\nrewrite <- H1.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite H1.\nrewrite <- H1.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite H0.\nrewrite mult_comm.\nrewrite <- H1.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite H1.\nrewrite mult_comm.\nrewrite H1.\nrewrite mult_comm.\nrewrite <- H1.\nrewrite mult_comm.\nrewrite H1.\nrewrite mult_comm.Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n   Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nintros.\ngeneralize (rel_prime_div d a b d H).\nunfold rel_prime;unfold is_gcd;simpl.\nintros.\nelim H; intros.\nelim H0;intros.\nrewrite H4; rewrite H5; rewrite <- H5; assumption.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  exists (q*u-q).\n  rewrite (mult_comm (a*b)) in H; rewrite mult_minus_lemma1; rewrite <- H; assumption.\n  intros.\n  elim H2; intros.\n  elim H3; intro.\n  elim H4; intro.\n  rewrite H4; rewrite <- H4; rewrite <- H5; assumption.\n  intros.\n  elim H3; intros.\n  elim H4; intro.\n  rewrite H4; rewrite <- H4; rewrite <- H5; assumption.\n  intros.\n  elim H4; intro.\n  rewrite H4; rewrite <- H4; rewrite <- H4; assumption.\n  intros.\n  elim H4; intro.\n  rewrite H4; rewrite <- H4; rewrite <- H5; assumption.\n  intros.\n  elim H4; intro.\n  rewrite H4; rewrite <- H4; rewrite <- H5; assumption.\n  intros.\n  elim H4; intro.\n  rewrite H4; rewrite <- H4; rewrite <- H4; rewrite <- H4; assumption.\n  intros.\n  elim H4; intro.\n  rewrite H4;Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  intros.\n  unfold rel_prime.\n  case (rel_prime a d); intro.\n  elim H0;intros.\n  elim H0;intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  apply (le_lt_trans _ _ _ (le_lt_trans _ _ _ (le_lt_trans _ _ _ (le_S_n _ _ H))).\n  apply H1; assumption.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold is_gcd; unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n   unfold is_gcd; unfold is_gcd;\n   unfold is_gcd; unfold is_gcd;\n   unfold is_gcd; unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;\n   unfold is_gcd;Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros.\nelim (IHp d a b); intros.\nelim (Hrec d a); intros.\nelim H0;intros.\nelim (Hrec d a); intros.\nelim (Hrec d a); intros.\nelim (Hrec d a); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0); intros.\nelim (Hrec d a0);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\nTheorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro u;intro.\n  elim H1;intro v;intro.\n  elim H0;intro q;intro.\n  case H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 11456,
                "proof_end_offset": 13305,
                "proof": "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nintros.\ngeneralize (quo_rem_euclide a b H);intro.\nred;split;intro.\nrewrite H0 in H1.\nelim H1;intros.\nunfold is_gcd;unfold is_cd.\nelim H2;intros.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nreplace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\nassert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\nrewrite <- H6;rewrite minus_plus;trivial.\nrewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\nexists (q-q'*(quotient_euclide a b H));trivial.\nrewrite <- H7;trivial.\nintros.\nelim H6;intros.\napply H3.\nunfold is_cd;split;try tauto.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nrewrite H10.\nreplace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H9;trivial.\nunfold is_gcd;unfold is_cd.\nunfold is_gcd in H1;unfold is_cd in H1.\nelim H1;intros.\nelim H2;intros.\nrewrite H0.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H7.\nreplace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H6;trivial.\nintros.\napply H3.\nsplit;try tauto.\nelim H6;intros.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nassert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\nrewrite minus_plus;trivial.\nrewrite H9 in H11.\nexists (q-q'*(quotient_euclide a b H)).\nrewrite mult_minus_lemma2;rewrite mult_assoc.\nrewrite <- H10;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (Zis_gcd_gcd_2 d a b H); intro v;intro.\n  elim H; intro.\n  case H2; intro.\n  apply (gcd_bezout (a*b) (b*d) (d*d) a (d*d)).\n  rewrite H; rewrite H0; rewrite (mult_comm a b); rewrite (mult_comm b d).\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\n  apply div_div; auto with arith.\nQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd in |- *.\n  intros.\n  elim (bezout 1 a b H);intro u;intro.\n  elim H1;intro u; intro.\n  elim H2;intro v;intro.\n  elim H4; intro v; intro.\n  case H4; intro.\n  case H5; intro.\n  apply (H5 v).\n  rewrite H6; rewrite (mult_comm a b); rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm b a);\n   rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm b a);\n   rewrite (mult_comm a b); rewrite (mult_comm a b); rewrite (mult_comm b a);\n   rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b a);\n   rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b a);\n   rewrite (mult_comm b a); rewrite (mult_comm a b); rewrite (mult_comm b a);\n   rewrite (mult_comm a b); rewrite (mult_comm b a); rewriteQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (Zis_gcd_dec d a b H); intro a.\n  elim H; intro a.\n  elim H; intro b.\n  elim H1; intro b.\n  case H1; intro b.\n  case H2; intro b.\n  case H3; intro b.\n  case H4; intro b.\n  case H4; intro b.\n  case H5; intro b.\n  case H4; intro b.\n  case H5; intro b.\n  case H5; intro b.\n  case H5; intro b.\n  case H5; intro b.\n  case H5; intro b.\n  case H5; intro b.\n  case H5; intro b.\n  case H6; intro b.\n  case H6; intro b.\n  case H6; intro b.\n  case H7; intro b.\n  case H7; intro b.\n  case H7; intro b.\n  case H7; intro b.\n  case H7; intro b.\n  case H7; intro b.\n  case H7; intro b.\n  case H7; intro b.\n  case H7; intro b.\n Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (bezout 1 a b H);intro v;intro.\n  elim H0;intro v;intro.\n  elim H1;intro v;intro.\n  elim H2;intro v;intro.\n  elim H3; intro v;intro.\n  elim H4; intro.\n  elim H4; intro.\n  case H4; intro.\n  case H4; intro.\n  case H4; intro.\n  rewrite H4; rewrite plus_comm; rewrite mult_comm; rewrite (mult_comm a b); rewrite (mult_comm b a);\n   rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b a);\n   rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b a);\n   rewrite (mult_comm b a); rewrite (mult_comm a b); rewrite (mult_comm b a);\n   rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b a);\n   rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfoldQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd; unfold is_gcd;unfold is_gcd;simpl;\n  case (gcd_bezout (a*b) (a*b)) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));intro.\n  case (gcd_bezout (a*b) (a*b));introQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n    unfold is_gcd in H; unfold is_gcd in H;\n    unfold is_gcd in H;\n    rewrite (H1 (gcd_sym a b) (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b)))).\n  unfold gcd;unfold is_gcd in H; unfold is_gcd in H;\n    rewrite (H1 (gcd_sym a b) (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b (gcd_sym b)))).\n  unfold gcd; unfold is_gcd in H;unfold is_gcd in H;Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (Zis_gcd_for (gcd a b) (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b (gcd b))))) H))).\n  unfold rel_prime.\n  intros.\n  elim H1; intros.\n  elim H2; intro.\n  elim H4; intro.\n  rewrite H5; rewrite mult_comm; rewrite (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b);\n    rewrite (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b);\n      rewrite (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b);\n        rewrite (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b);\n        rewrite (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b);\n          rewriteQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd; unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n    apply gcd_sym; apply gcd_sym; apply gcd_sym;\n      [ apply gcd_sym | apply gcd_sym | apply gcd_sym];\n      [ apply gcd_sym | apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym];\n      [ apply gcd_sym | apply gcd_sym];\n      [ apply gcd_sym | apply gcd_sym ];\n      [ apply gcd_sym | apply gcd_sym];\n      [ apply gcd_sym| apply gcd_sym];\n      [ apply gcd_sym | apply gcd_sym];\n      [ apply gcd_sym | apply gcd_sym];Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;simpl; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\nLemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  intros.\n  generalize (quo_rem_euclide a b H);intro.\n  red;split;intro.\n  rewrite H0 in H1.\n  elim H1;intros.\n  unfold is_gcd;unfold is_cd.\n  elim H2;intros.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  replace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\n  assert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\n  rewrite <- H6;rewrite minus_plus;trivial.\n  rewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\n  exists (q-q'*(quotient_euclide a b H));trivial.\n  rewrite <- H7;trivial.\n  intros.\n  elim H6;intros.\n  apply H3.\n  unfold is_cd;split;try tauto.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  rewrite H10.\n  replace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 13371,
                "proof_end_offset": 14277,
                "proof": "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof;unfold f;intros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ncase (eq_nat_dec (fst x) 0);intro.\nrewrite e;exists (snd x);apply gcd_zero.\nelim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\nintro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_euclide d (snd x) (fst x) n);auto.\ngeneralize (rem_euclide (snd x) (fst x) n);try omega.\nrewrite e;exists (snd x);apply gcd_refl.\ncase (eq_nat_dec (snd x) 0);intro.\nrewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\nintro d;intro.\nexists d.\nelim (gcd_euclide d (fst x) (snd x) n);auto.\ngeneralize (rem_euclide (fst x) (snd x) n);try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  elim (Pos.le_gt_dec (gcd d x)).\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\n  apply gcd_div_pos; trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros x.\n  case (gcd_exists_prod_bis x (fst x)).\n  intros.\n  exists (S x).\n  rewrite H0.\n  rewrite H0; auto.\n  rewrite H0.\n  rewrite H.\n  replace (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + x)))) + (x + (x + (x + (x + (x + (x + (x + x))))) * x))\n    with (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + x)))) + (x + (x + (x + (x + (x + (x + (x + (x + (x + x)))) + (x + (x + (x + (x + (x + (x + (x + x)))) + (x + (x + (x + (x + (x + (x + (x + (x + (x + x))))) * x)) + (x + (x + (x +Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  case (gcd_exists_prod_bis x (fst x) (snd x)); trivial.\n  intros.\n  unfold is_gcd; simpl.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intro.\n  unfold is_gcd; simpl; trivial.\n  elim H4; intro.\n  elim H5; intros.\n  apply H3; auto with arith.\n  elim H5; intro.\n  elim H5; intros.\n  elim H5; intros.\n  apply H3; auto with arith.\n  elim H5; intro.\n  apply H3; auto with arith.\n  elim H5; intro.\n  apply H3; auto with arith.\n  elim H5; intro.\n  elim H5; intros.\n  elim H5; intros.\n  apply H4; auto with arith.\n  elim H5; intro.\n  apply H3; auto with arith.\n  elim H5; intro.\n  elim H5; intro.\n  elim H5; intros.\n  elim H5; intros.\n  apply H3; auto with arith.\n  elim H5; intro.\n  apply H3; auto with arith.\n  elim HQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  generalize (gcd_exists_prod_bis x (snd x) (snd x)).\n  case (gcd_exists_prod_bis x (snd x) (snd x)).\n  intros.\n  unfold is_gcd; simpl.\n  elim H; intros.\n  apply H2.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros.\ngeneralize (gcd_exists_prod_aux x (fst x) (fst x)).\nintro.\nelim H.\nintros.\ngeneralize (gcd_exists_prod_aux x (fst x) (fst x) H).\nintro.\nelim H1; intros.\nrewrite H1.\nsplit; try tauto.\nelim H1; intro.\nrewrite H2.\nsimpl; auto.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros x.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_bis x).\n  intros.\n  generalize (gcd_exists_prod_Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros x.\ndestruct x as [d [x0 [d [x1 [d [x2 d]]]]].\nexists d.\nrewrite <- (fun d => (fun d => (d + d)%nat)).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d + d)%nat).\nrewrite <- (fun d => (d +Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  destruct x as [ | x ].\n  exists 1; auto.\n  destruct (gcd_exists_prod_bis x (snd x)) as [x [y0 [H1 H2]]].\n  exists (x*(x*y0)); auto.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  case (gcd_exists_prod_bis (gcd_exists_prod_bis (gcd_witness x) x (snd x)) H).\n  intros.\n  elim H0; intros.\n  apply gcd_uniqueness with (p*q)%nat; trivial.\n  rewrite <- H0; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; trivial.\n  rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_comm; rewrite mult_comm; trivial.\n  rewrite <- mult_assoc; rewrite <- mult_assoc; rewrite <- mult_comm; rewrite mult_comm; trivial.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; trivial.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; trivial.\n  rewrite <- mult_assoc; rewrite mult_comm; rewrite plus_comm; trivial.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; trivial.\n  rewrite <- mult_comm; rewrite mult_comm; trivial.\n  rewrite mult_comm; trivial.\n  rewrite <- mult_comm; rewrite mult_comm; trivial.\n  rewrite mult_comm; rewrite mult_commQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros x.\ncase (gcd_exists_prod_bis x 1 (fst x)); trivial.\nintros.\nelim H; clear H; intros.\nexists x; exists 0.\nexists 0; exists 0; exists 0.\nexists (S x0); exists 0; exists 0; exists 0.\nexists 0; exists 0; exists 0.\nexists 0; exists 0; exists 0; exists 0; exists 0; exists 0.\nexists 0; exists 0; exists 0; exists 0; exists 0; exists 0;\n exists 0; exists 0; exists 0; exists 0; exists 0;\n exists 0; exists 0; exists 0; exists 0; exists 0; exists 0;\n (S x0); exists 0; exists 0; exists 0; exists 0;\n (S x0); exists 0; exists 0; exists 0; exists 0; exists 0;\n (S x0); exists 0; exists 0; exists 0; exists 0; exists 0; exists 0;\n (S x0); exists 0; exists 0; exists 0; exists 0; exists 0;\n (S x0); exists 0; exists 0; exists 0; exists 0; existsQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 730,
                "proof_start_offset": 14326,
                "proof_end_offset": 14485,
                "proof": "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\nexists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd.\n  intros a b.\n  case (lt_eq_dec (fst a) 0).\n  apply gcd_intro with (p:=p); trivial.\n  apply gcd_intro with (p:=p); trivial.\n  apply gcd_intro with (p:=p); trivial.\n  apply gcd_intro with (p:=p); trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (lt_eq_lt_dec (fst a) (fst a)); intro.\n  rewrite e;exists (snd a).\n  rewrite (gcd_sym a).\n  rewrite <- (gcd_sym a).\n  apply gcd_sym.\n  assumption.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros a b; case (lt_eq_lt_dec (fst a) (snd a));intro.\n  rewrite <- (gcd_sym a b) in H.\n  apply gcd_sym.\n  destruct (gcd_euclBy a b H) as (x,(H1,H2)); trivial.\n  destruct H1 as (x,(H1,H2)); trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; trivial.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcdQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros a b; case (le_gt_dec (snd a) (snd b));intros.\n  case (le_gt_dec (snd a) (fst b));intros.\n  rewrite H.\n  rewrite H0.\n  split; try tauto.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n  apply gcd_trans with b; auto.\n  apply gcd_trans with b; auto.\n  apply gcd_sym.\n Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b; case (eq_nat_dec (fst a) (snd a)); intros.\n  rewrite H0; rewrite H1; rewrite H2; ring.\n  generalize (gcd_exists_prod_bis a b a H); case (gcd_exists_aux a b a H); simpl.\n  intro d; intro.\n  elim (gcd_eucl_bound a b a H); auto.\n  rewrite H0; rewrite H1; ring.\n  generalize (gcd_exists_gcd_aux a b a H); case (gcd_exists_aux a b a H); simpl.\n  intro d; intro.\n  elim (gcd_eucl_bound a b a H); auto.\n  intro d; intro.\n  elim (gcd_eucl_bound a b a H); auto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  simple induction a.\n  unfold gcd; intros; auto.\n  intro d; case (gcd_exists_aux a b d H);simpl; auto.\n  intro d; case (gcd_exists_aux b d H);simpl; auto.\n  intro d; case (gcd_exists_aux d d H); simpl; auto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (lt_eq_dec (fst a) (fst a));intro.\n  case (gcd_dec (fst a) 0); intros.\n  rewrite e; exists (fst a).\n  rewrite e; exists (fst a).\n  rewrite mult_comm.\n  rewrite <- mult_plus_distr_r.\n  rewrite <- (mult_comm (a+b)).\n  apply mult_reg_l with b; auto.\n  rewrite <- (mult_comm (a+b)).\n  apply mult_reg_l with b; auto.\n  rewrite <- (mult_comm (a+b)).\n  apply mult_reg_l with b; auto.\n  rewrite <- (mult_comm (a+b)).\n  apply mult_reg_l with b; auto.\n  rewrite <- (mult_comm (a+b)).\n  apply mult_reg_l with b; auto.\n  rewrite <- (mult_comm (a+b)).\n  apply mult_reg_l with b; auto.\n  rewrite <- (mult_comm (a+b)).\n  apply mult_reg_l with b; auto.\n  rewrite <- (mult_comm (a+b)).\n Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b; exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (le_gt_dec (fst a) (fst a)); intro.\n  rewrite e;exists (fst a).\n  rewrite <- e;exists (snd a).\n  rewrite <- e;trivial.\n  case (le_gt_dec (fst a) (fst a));intro.\n  rewrite e;trivial.\n  generalize (gcd_gcd_bound a b (fst a) n);try omega.\n  rewrite e;exists (snd a);apply gcd_refl.\n  case (le_gt_dec (fst a) (snd a));intro.\n  rewrite e;trivial.\n  rewrite e;trivial.\n  case (le_gt_dec (snd a) (snd a));intro.\n  rewrite e;trivial.\n  case (le_gt_dec (fst a) (snd a));intro.\n  rewrite e;trivial.\n  rewrite e;trivial.\n  case (le_gt_dec (snd a) (snd a));intro.\n  rewrite e;trivial.\n  case (le_gt_dec (snd a) (snd a));intro.\n  rewrite e;trivial.\n  rewrite e;trivial.\n  case (le_gt_dec (Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b; case (lt_eq_dec a b).\n  intros.\n  elim (rel_ind (nat*nat) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S(S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\n",
                "context_tokens": 729,
                "proof_start_offset": 14549,
                "proof_end_offset": 14831,
                "proof": "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\nintros.\nunfold rel_prime.\ngeneralize (gcd_is_gcd a b);intro.\ncase (eq_nat_dec (gcd a b) 1);intro.\nleft;rewrite e in H;trivial.\nright;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros a b; case (rel_prime_dec a b); intro.\n  apply rel_prime_intro;apply rel_prime_intro;auto.\n  elim (rel_prime_dec a b); intro.\n  rewrite H in H0.\n  elim (rel_prime_intro d a0); intros.\n  apply rel_prime_intro;auto.\n  apply H0; auto.\n  elim (rel_prime_intro d a0); intros.\n  apply rel_prime_intro;auto.\n  elim (rel_prime_intro d a0); intros.\n  apply rel_prime_intro;auto.\n  apply H0; auto.\n  elim (rel_prime_intro d a0); intros.\n  apply rel_prime_intro;auto.\n  elim (rel_prime_intro d a0); intros.\n  apply rel_prime_intro;auto.\n  apply H0; auto.\n  elim (rel_prime_intro d a0); intros.\n  apply rel_prime_intro;auto.\n  apply H0; auto.\n  elim (rel_prime_intro d a0); intros.\n  apply rel_prime_intro;auto.\n  elim (rel_primeQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros a b.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b);intro.\n  case (rel_prime_dec a b); intro.\n  apply gcd_intro; apply gcd_intro; auto.\n  rewrite <- H0; apply gcd_sym; apply gcd_0_l.\n  rewrite <- H0; apply gcd_sym; apply gcd_0_l.\n  rewrite <- H0; apply gcd_sym; apply gcd_sym; apply gcd_0_l.\n  rewrite H0; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_0_l.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_0_l.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_0_l.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_0_l.\n  apply gcd_trans with (gcd a b); auto.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b); intro.\n  apply gcd_intro with b; auto.\n  apply gcd_intro with b; auto.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  case (rel_prime_dec a b);intros.\n  left; assumption.\n  right; assumption.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b); intro d.\n  apply rel_prime_dec; auto.\n  apply rel_prime_intro; auto.\n  intro d; elim (rel_prime_dec a d); intro d.\n  rewrite e; exists (d * d); apply gcd_sym; auto.\n  intro d; elim (gcd_gcd d (d * d)); auto.\n  intro d; elim (gcd_eucl Inv d d); auto.\n  intro d; elim (gcd_eucl Inv d d); auto.\n  intro d; elim (gcd_eucl Inv d d); auto.\n  intro d; elim (gcd_eucl Inv d d); auto.\n  intro d; elim (gcd_eucl Inv d d); auto.\n  intro d; elim (gcd_eucl Inv d d); auto.\n  intro d; elim (gcd_eucl Inv d d); auto.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b); intro d; simpl.\n  case (rel_prime_dec a b); intro.\n  rewrite e; exists (p ^ a); trivial.\n  rewrite <- e; exists (p ^ b); trivial.\n  rewrite <- e; exists (p ^ b); trivial.\n  rewrite <- e; exists (p ^ b); trivial.\n  rewrite <- e; exists (p ^ b); trivial.\n  rewrite <- e; exists (p ^ b); trivial.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros a b; case (rel_prime_dec a b); intro d;simpl.\n  case (rel_prime_dec a b); intro d;simpl.\n  case (rel_prime_dec b d); intro d;simpl.\n  case (rel_prime_dec d d); intro d;simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); intro d; simpl.\n  case (rel_prime_dec d d); introQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b); auto.\n  intros.\n  case (rel_prime_dec a b); auto.\n  intros.\n  elim (rel_prime_dec b a); auto.\n  intros.\n  case (rel_prime_dec a b); auto.\n  intros.\n  case (rel_prime_dec a b); auto.\n  intros.\n  case (rel_prime_dec b a); auto.\n  intros.\n  case (rel_prime_dec b a); auto.\n  intros.\n  case (rel_prime_dec a b); auto.\n  intros.\n  case (rel_prime_dec b a); auto.\n  intros.\n  case (rel_prime_dec a b); auto.\n  intros.\n  case (rel_prime_dec b a); auto.\n  intros.\n  case (rel_prime_dec a b); auto.\n  intros.\n  case (rel_prime_dec b a); auto.\n  intros.\n  case (rel_prime_dec b a); auto.\n  intros.\n  case (rel_prime_dec a b); auto.\n  intros.\n  case (rel_prime_dec a b); auto.Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b); intro d.\n  elim (rel_prime_dec b d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  case (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d.\n  elim (rel_prime_dec d d); intro d'.\n  elim (rel_prime_dec d d); intro d'.\n  elim (rel_prime_dec d d'); intro d'.\n  elim (rel_prime_dec d d'); intro d'.\n  elim (rel_prime_dec d d'); intro d'.\n  elim (rel_prime_dec d d'); intro d'.\n  elim (rel_prime_dec d d'); intro d'.\n Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros a b; case (rel_prime_dec a b);intro d;simpl;intros.\n  case (rel_prime_dec a b);intro d;simpl;intros.\n  apply gcd_sym; auto.\n  case (rel_prime_dec a b);intro d;simpl;intros.\n  apply gcd_sym; auto.\n  apply gcd_uniqueness; auto.\n  case (rel_prime_dec a b);intro d;simpl; intros.\n  apply gcd_sym; auto.\n  apply gcd_uniqueness; auto.\n  apply gcd_uniqueness; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\n",
                "context_tokens": 721,
                "proof_start_offset": 14887,
                "proof_end_offset": 15621,
                "proof": "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\nintros.\nsplit.\nsplit;try (apply one_min_div).\nintros.\nelim H1;intros.\ncase (rel_prime_dec b d');intro.\nassert (divides c d').\napply gauss with b;trivial.\nelim H0;intros.\napply H6;unfold is_cd;tauto.\ngeneralize (gcd_is_gcd b d');intro.\nassert ((gcd b d')<>1).\nintro;apply n.\nunfold rel_prime;rewrite <- H5;trivial.\ngeneralize (gcd_div_l (gcd b d') b d' H4);intro.\ngeneralize (gcd_div_r (gcd b d') b d' H4);intro.\nassert (divides a (gcd b d')).\napply divides_trans with d';[apply H2 | apply H7].\nelim H5.\napply divides_antisym.\napply one_min_div.\nelim H;intros;apply H10;unfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros a b c H; elim H; trivial.\n  left;rewrite H;trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  unfold rel_prime.\n  generalize (rel_prime_mult a b);intro.\n  generalize (gcd_exists_prod_bis (a*c) (b*c)).\n  generalize (rel_prime_mult a b);intro.\n  generalize (rel_prime_mult b c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_prime_mult c c);intro.\n  generalize (rel_primeQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  elim (gcd_exists_prod a b).\n  left;rewrite e in H; auto.\n  right; intro; discriminate.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_mult a b);intro.\n  generalize (rel_prime_mult b c);intro.\n  destruct (gcd_exists_prod_bis (a+c) (b*c));trivial.\n  left;rewrite e in H;omega.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  unfold rel_prime.\n  generalize (gcd_exists_prod_bis (a,b)).\n  case (rel_prime_dec (gcd a b) 1);intro.\n  left;rewrite e in H;discriminate.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_trans (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_trans (gcd a b) 1 a b);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros a b c.\n  apply rel_prime_mult;trivial.\n  right;intro.\n  rewrite (gcd_sym a b) in H.\n  apply gcd_intro;apply n;apply (gcd_intro c);trivial.\n  right;intro;apply n;apply (gcd_intro c);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_mult (a*c) (a*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n  generalize (rel_prime_mult (a*c) (b*c)).\n Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  unfold rel_prime.\n  generalize (gcd_exists_prod_bis (a,c));intro d;simpl;intros.\n  generalize (gcd_exists_prod_bis (a,c));intro d;simpl;intros.\n  generalize (gcd_exists_prod_bis (a,c));intro d;simpl;intros.\n  generalize (gcd_exists_prod_bis (a,c)).\n  generalize (gcd_exists_prod_bis (a,c));intro d;simpl;intros.\n  generalize (gcd_exists_prod_bis (a,c));intro d;simpl;intros.\n  generalize (gcd_exists_prod_bis (a,c));intro d;simpl;intros.\n  generalize (gcd_exists_prod_bis (a,c));intro d;simpl;intros.\n  generalize (gcd_exists_prod_bis (a,c)).\n  generalize (gcd_exists_prod_bis (a,c)).\n  generalize (gcd_exists_prod_bis (a,c)).\n  generalize (gcd_exists_prod_bis (a,c)).\n  generalize (gcd_exists_prod_bis (a,c)).\n  generalize (Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  apply rel_prime_intro.\n  intros.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  rewrite e in H0.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_trans a b);intro.\n  destruct (gcd_exists_prod_bis (a*c) c) as [H|H].\n  left;rewrite H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\n",
                "context_tokens": 718,
                "proof_start_offset": 15677,
                "proof_end_offset": 15983,
                "proof": "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\nintros.\nsplit;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nintros.\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*c)).\ndestruct (gcd_exists_prod_bis (a,b*Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_exists_prod_pre (a,b*c) (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,b*c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)); intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (a,c)).\n  intro d; elim (gcd_exists_prod_bis (Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  apply div_rel_prime; auto.\n  apply div_rel_prime; auto.\n  apply div_rel_prime; auto.\n  apply div_rel_prime; auto.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  apply (rel_prime_mult a b c); auto.\n  apply div_rel_prime; auto.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b*c)) (b*c));intro d';simpl;intros.\n  apply H0; unfold is_gcd; simpl.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_opp; assumption.\n  elim H1; intros.\n  case (gcd_exists_gcd a b); intro.\n  apply gcd_sym.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_opp; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_opp; assumption.\n  elim H1; intros.\n  case (gcd_exists_gcd a b); intro.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_opp; assumption.\n  elim H1; intros.\n  case (gcd_exists_gcd a b); intro.\n  apply gcd_sym; apply gcd_sym; apply gcd_opp; assumption.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_opp; assumption.\n  elim H1; intros.\n Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b*c)) (a*c)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b*c)) (a*c)).\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  apply H3; unfold is_gcd in H3; auto.\n  generalize (gcd_is_gcd b c); intro.\n  elim H3; intros.\n  elim H4; intros.\n  apply H4; unfold is_gcd in H3; auto.\n  generalize (gcd_is_gcd b c); intro.\n  elim H3; intros.\n  rewrite H4 in H3.\n  rewrite <- H3; auto.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; auto.\n  apply gcd_sym; apply gcd_sym; auto.\n  apply gcd_sym; apply gcd_sym; auto.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_exists_prod_bis (a,b)) (a,b*c)).\n  intros.\n  elim H1; intros.\n  apply H.\n  split; try (apply one_min_div).\n  intros.\n  elim H1; intros.\n  case (gcd_exists_prod_bis (a,b) (b*c)).\n  intros.\n  elim H2; intros.\n  apply H3; unfold is_c;tauto.\n  apply (gcd_is_gcd a b); trivial.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_exists_prod_aux a (b*c)) (b*c) H).\n  intros.\n  case (gcd_exists_gcd a b);intro.\n  apply gcd_sym.\n  elim (gcd_exists_prod_aux a (b*c)) (b*c) H).\n  intros.\n  case (gcd_exists_aux a (b*c) H).\n  intros.\n  elim H1; intros.\n  case (gcd_exists_aux b (b*c)) with (a*c) (b*c)); trivial.\n  intros.\n  case (gcd_exists_aux a (b*c) H).\n  intros.\n  elim H2; intros.\n  case (gcd_exists_aux b (b*c) H).\n  intros.\n  elim H3; intros.\n  elim H4; intros.\n  apply H5; unfold is_gcd in H4; tauto.\n  generalize (gcd_div_r (gcd a (b*c)) b c H4 H1);intro.\n  assert (b*c) by (apply gcd_div_r; order).\n  apply gcd_div_r; trivialQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  unfold rel_prime in H.\n  generalize (gcd_is_gcd a b);intro.\n  case (gcd_exists_factor a b);intro.\n  apply gcd_intro; apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  assert (H0:=H1).\n  apply mod_rel_prime.\n  trivial.\n  assert (H2:=H2).\n  apply mod_rel_prime.\n  trivial.\n  assert (H5:=H3).\n  apply div_prime; trivial.\n  apply div_prime; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 16024,
                "proof_end_offset": 16251,
                "proof": "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\ninduction n;simpl;intros.\nunfold rel_prime;apply gcd_sym;apply gcd_one.\ngeneralize (IHn H);intro.\napply rel_prime_mult;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  assert (H1:=H1).\n  destruct (rel_prime_dec d a n) as [H2|H2].\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).\n  apply (rel_prime_mult d a n H2 H1).Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  case (rel_prime_dec d a);intro.\n  right;intro;apply n;apply (gcd_sym n (div d a)).\n  right;intro;apply n;apply (gcd_sym n (div d a)).\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  case (rel_prime_dec d a); intro.\n  generalize (gcd_is_gcd a d);intro.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4; intros.\n  apply H3;unfold is_gcd;tauto.\n  generalize (gcd_is_gcd a d);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcd_div_r (gcd a d) n);intro.\n  generalize (gcdQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  destruct (gcd_exists_factor d a n) as [H|H].\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  generalize (rel_prime_rel (S n) d a); intro.\n  generalize (rel_prime_rel (S n) d a);intro.\n  destruct (rel_prime_dec d a); [|intros].\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  apply H4; split;trivial.\n  generalize (gcd_non_gcd d a d); intro.\n  elim H3; intros.\n  apply H4; split;trivial.\n  generalize (gcd_div_r (gcd a d) (gcd a d));intro.\n  elim H3; intros.\n  apply H4; split;trivial.\n  generalize (gcd_div_r (gcd a d) d a);intro.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  apply H4; split;trivial.\n  generalize (gcd_div_r (gcd a d) d a);intro.\n Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  case (rel_prime_dec d a); intro.\n  exists 1.\n  split.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_introQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split;split;try (apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d a n));simpl;intros.\n  apply (rel_prime_trans (gcd a d) (div d aQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply (rel_prime_mult _ _ _ H).\n  apply (rel_prime_mult _ _ _ H).\n  apply (rel_prime_mult _ _ _ H0).\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  elim (gcd_exists_strong d a n); intro.\n  elim H;intros.\n  apply gcd_intro with (p*n);trivial.\n  rewrite <- H0.\n  apply gcd_intro with (p*n);trivial.\n  apply gcd_intro with (p*n);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\n",
                "context_tokens": 723,
                "proof_start_offset": 16300,
                "proof_end_offset": 16486,
                "proof": "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\ndestruct n;simpl;intros.\ninversion H.\nelim (mult_rel_prime a d (power d n));auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  destruct (gcd_exists_pos d a n) as [H|H].\n  exists (S n).\n  apply gcd_sym;trivial.\n  destruct (gcd_exists_pos d a n) as [H|H].\n  apply gcd_sym;trivial.\n  destruct (gcd_exists_pos d a n) as [H|H].\n  apply gcd_sym;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  case (gcd_exists_prod_aux d a n); trivial.\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec d a n); trivial.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  unfold rel_prime; rewrite H5; rewrite H5; rewrite H6; ring.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; assumption.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  assert (H := gcd_is_gcd a d); destruct (gcd_exists_pos d n H).\n  generalize (gcd_is_gcd a d n H); destruct (gcd_exists_pos d n H).\n  rewrite H;trivial.\n  rewrite H0;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  unfold rel_prime;rewrite gcd_sym; apply gcd_sym;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  assert (n>1) by (apply div_prime_mult;trivial).\n  assert (n>1) by (apply div_prime_mult;trivial).\n  assert (n>2) by (apply div_prime_mult;trivial).\n  destruct (eq_nat_dec (div d a) n) as [H'|H']; trivial.\n  generalize (gcd_factor_r (gcd a d') (gcd a (gcd a (div d a))).\n  destruct (eq_nat_dec (div d a) n) as [H'|H']; trivial.\n  generalize (gcd_factor_r (gcd a d') (gcd a (div d a))).\n  destruct (eq_nat_dec (div d a) n) as [H'|H']; trivial.\n  generalize (gcd_factor_r (gcd a d') (gcd a (div d a))).\n  destruct (eq_nat_dec (div d a) n) as [H'|H']; trivial.\n  generalize (gcd_factor_r (gcd a d') (gcd a (div d a))).\n  destruct (eq_nat_dec (div d a) n) as [H'|HQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_sym;apply gcd_sym;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  case (rel_prime_dec d a);intros.\n  generalize (gcd_is_gcd (gcd d a) (div d a) (div d a n H0 H1).\n  case (rel_prime_dec d a); intros.\n  rewrite H0; rewrite H1; rewrite H2; rewrite H3;trivial.\n  destruct (rel_prime_dec d a0); simpl;\n    [ assumption | rewrite H1; rewrite H2; rewrite H3; ring ].\n  unfold rel_prime; rewrite H1; rewrite H2; ring.\n  unfold rel_prime; rewrite H1; rewrite H2; ring.\n  unfold rel_prime; rewrite H1; ring.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  unfold rel_prime;rewrite gcd_eq_iff;split;intros.\n  generalize (gcd_is_gcd d a); intro.\n  generalize (gcd_is_gcd d a n); intro.\n  generalize (gcd_div_r (gcd a d) a n);intro.\n  destruct H0 as [H1|H1].\n  apply gcd_sym;trivial.\n  apply gcd_sym;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply gcd_intro;trivial.\n  apply gcd_intro;trivial.\n  apply gcd_intro;trivial.\n  apply gcd_intro;trivial.\n  apply gcd_intro;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\nLemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  destruct n;simpl;intros.\n  inversion H.\n  elim (mult_rel_prime a d (power d n));auto.\nQed.\n\n(** if n>0 and m>0 then gcd(a^n,b^m)=1 iff gcd(a,b)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 16545,
                "proof_end_offset": 16906,
                "proof": "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\nsplit;intro.\napply power_rel_prime with m;trivial;apply rel_prime_sym;apply power_rel_prime with n;trivial;apply rel_prime_sym;trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power;apply rel_prime_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  destruct n;simpl;intros.\n  inversion H.\n  apply prime_mult_l.\n  apply divide_refl.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  unfold rel_prime;apply div_rel_prime;trivial.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  destruct n.\n  unfold rel_prime; rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\n  rewrite <- H;trivialQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  destruct (div_exists_dec a m) as (p,H).\n  destruct (div_exists_dec a m) as (p,_).\n  assert (p=0).\n  apply gcd_unique with p;auto.\n  destruct (div_exists_dec a m) as (p',H').\n  apply gcd_unique with p;auto.\n  destruct (gcd_exists_dec a m) as (p',H').\n  apply gcd_unique with p;auto.\n  destruct (gcd_exists_dec a m) as (p',H').\n  apply gcd_unique with p';auto.\n  destruct (gcd_exists_dec a m) as (p',H').\n  apply gcd_unique with p';auto.\n  destruct (gcd_exists_dec a m) as (p',H').\n  apply gcd_unique with p';auto.\n  destruct (gcd_exists_dec a m) as (p',H').\n  apply gcd_unique with p';auto.\n  destruct (gcd_exists_dec a m) as (p',H').\n  destruct (gcd_exists_dec a m) as (p',H').\n  apply gcd_unique with p;Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  destruct n;simpl;intros.\n  unfold rel_prime;rewrite div_rel_prime;trivial.\n  rewrite <- (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewrite (mult_comm (S m)).\n  rewriteQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  elim (div_rel_prime a d (div_rel_prime a b m)).\n  intros.\n  elim (div_rel_prime a d (div_rel_prime a b m)).\n  intros.\n  elim (div_rel_prime a d (div_rel_prime a b m)).\n  intros.\n  elim H1; intros.\n  apply H1.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_rel_prime.\n  apply div_Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply div_rel_prime;trivial.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  elim (mult_rel_prime a d (div a n)); auto.\n  intros.\n  elim H1; intros.\n  elim (mult_rel_prime a d (div a n)); auto.\n  intros.\n  elim H2; intros.\n  rewrite H3; rewrite H4; rewrite H5; rewrite H5; apply gcd_sym; auto.\n  rewrite H3; rewrite H4; rewrite H5; apply gcd_sym; auto.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  destruct n;simpl;intros.\n  inversion H.\n  auto.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply div_rel_prime.\n  intros.\n  elim H; clear H; intros.\n  elim (mult_rel_prime a d (div b a)); auto.\n  elim H1; clear H1; intros.\n  elim (mult_rel_prime a d (div b a)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\n",
                "context_tokens": 275,
                "proof_start_offset": 1044,
                "proof_end_offset": 1166,
                "proof": "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros.\napply le_mult_l.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square.\nunfold square; simpl.\nrewrite Rmult_1_l.\nring.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nintros.\nunfold square.\napply (f_equal (fun p:nat => plus_comm p (S p)) (S p)).\napply le_succ_l.\napply le_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\napply lt_O_n.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square; intros.\ndestruct (le_lt_eq_dec (S a) (S b)) as [H|H].\nrewrite H; reflexivity.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros.\nunfold square.\nrewrite (mult_comm a).\nrewrite H.\nrewrite H.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite (mult_comm (a*b)) at 1.\nrewrite mult_assoc.\nrewrite (mult_comm b).\nrewrite <- (mult_assoc a).\nrewrite (mult_comm (a*b)) at 1.\nrewrite mult_assoc.\nrewrite (mult_comm (a*b)) at 1.\nrewrite (mult_comm (a*b)) at 1.\nrewrite (mult_comm (a*b)) at 1.\nrewrite <- (mult_comm a).\nrewrite (mult_comm (a*b)) at 1.\nrewrite (mult_comm (a*b)) at 1.\nrewrite (mult_comm (a*b)) at 1.\nrewrite <- (mult_assoc a).\nrewrite (mult_comm (a*b)) at 1.\nrewrite (mult_comm a).\nrewrite (mult_comm (a*b)) at 1.\nrewrite (mult_comm (a*b)) at 1.\nrewrite <-Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros.\nunfold square in |- *.\nreplace (x*x) with ((x*y)*x*y+x*y).\nreplace (x*y+x*y+x*y) with ((x*y)+x*y+x*y+x*y).\nring.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros; apply square_mult_lemma.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros.\napply le_plus_r; try assumption.\napply lt_O_n.\napply lt_O_n.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square; intros a b; rewrite (mult_comm a b); rewrite (mult_comm b a);\n rewrite (mult_comm b a); rewrite (mult_comm b a);\n rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b a);\n rewrite (mult_comm (a*b)); rewrite (mult_comm a b); rewrite (mult_comm a b);\n rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm a b);\n rewrite (mult_comm (a*b)); rewrite (mult_comm b a); rewrite (mult_comm b a);\n rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm b a);\n rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm a b);\n rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm b a);\n rewrite (mult_comm (a*b)); rewrite (mult_comm b a); rewrite (mult_comm b a);\n rewrite (mult_commQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square; intros.\nrewrite pow_add_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 1331,
                "proof_end_offset": 1483,
                "proof": "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\ninduction n;simpl;trivial.\nintros;rewrite (IHn x y);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  simple induction n.\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec y x).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (le_gt_dec x y).\n  intros.\n  simpl.\n  case (leQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  simple induction n; simpl; auto with arith.\n  intros; ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  elim (le_lt_eq_dec n x).\n  apply (H (S n)).\n  apply (H (S n)).\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  simple induction n; simpl; auto with arith.\n  intros; ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  intros.\n  induction n.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  simple induction n; simpl; auto with arith.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  simple induction n.\n  intros.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  induction n.\n  simpl.\n  rewrite Rmult_plus_distr_l.\n  rewrite Rmult_1_r.\n  simpl.\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n  induction n; simpl; intros.\n  reflexivity.\n  destruct n; simpl.\n  reflexivity.\n  destruct n; simpl.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1485,
                "proof_end_offset": 1642,
                "proof": "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\nProof.\ninduction n;simpl;intros.\nauto with arith.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  unfold pow.\n  intros.\n  ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m;simpl;trivial.\n  intros;rewrite (IHn x m);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m;simpl;trivial.\n  intros; rewrite <- (mult_comm m x).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros; rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m;simpl;trivial.\n  intros;rewrite (IHn x m);ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\n",
                "context_tokens": 483,
                "proof_start_offset": 1644,
                "proof_end_offset": 1799,
                "proof": "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\nProof.\ninduction n;simpl;intros.\ninversion H.\nexists (power x n);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros;auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  intros.\n  apply power_mult_lemma1.\n  apply power_mult_lemma1.\n  apply power_mult_lemma1.\n  apply pow_mult_lemma1.\n  apply pow_mult_lemma1.\n  apply pow_mult_lemma1.\n  apply pow_mult_lemma1.\n  apply pow_mult_lemma1.\n  apply pow_mult_lemma1.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros; rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  unfold power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power, power.\nProof.\n  intros n x; generalize (pow_integral _ _ _ H); intros.\n  destruct (ln_abs_inv _ _ H) as (n,H1).\n  destruct H1 as (n0,H2).\n  rewrite H2.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\n",
                "context_tokens": 536,
                "proof_start_offset": 1801,
                "proof_end_offset": 2053,
                "proof": "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\nProof.\ninduction n;simpl;intros.\ninduction m;simpl;auto with arith.\nrewrite IHm;ring.\nrewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m;simpl;intros.\n  auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;trivial.\n  intros; rewrite <- (Nat2Z.inj_succ (Pos.of_nat n)).\n  apply IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m;simpl;intros.\n  apply power_mult_lemma1; auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m;simpl;intros.\n  auto with arith.\n  rewrite plus_comm;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  rewrite (IHn m x); ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\n",
                "context_tokens": 619,
                "proof_start_offset": 2055,
                "proof_end_offset": 2202,
                "proof": "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\ninduction n;simpl;intros.\ndiscriminate.\ncase (mult_lemma2 x (power x n) H);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros n x; elim x; simpl;intros.\n  inversion H.\n  exists 0%nat;auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros.\ndestruct (le_lt_eq_dec (S n) (S m)); auto.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros.\napply power_power_zero.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros.\ncase (le_lt_eq_dec n x); intros.\nrewrite (pow_zero x n H0) in H.\napply (pow_zero x n H0);auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros; case n; simpl;intros.\n  inversion H.\n  exists 0;auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros n x H; elim H; intro.\nrewrite H0.\ntrivial.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros.\napply power_zero.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros; simpl in H.\n  apply power_zero.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros; discriminate.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nintros.\nunfold power in H.\nrewrite H.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\n",
                "context_tokens": 692,
                "proof_start_offset": 2237,
                "proof_end_offset": 2543,
                "proof": "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nProof.\ninduction m;simpl;try omega;intros.\ndestruct m;simpl;try omega.\nsimpl in IHm.\nassert (1 < p*(power p m)).\napply IHm;auto with arith.\nrewrite mult_comm.\napply lt_trans with (1*p);try omega.\napply mult_lt_compat_r;try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nProof.\n  intros.\n  case (mult_lemma1 p m); auto with arith.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  intros.\n  case (mult_lemma1 p m); auto with arith.\n  intros; apply (mult_eq_reg_l p m); auto with arith.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  intros.\n  apply plus_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply multQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  intros; apply pow_le; auto with arith.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nProof.\n  induction p;simpl;intros.\n  discriminate.\n  rewrite <- (mult_n_O p m) in H; inversion H.\n  rewrite <- H;ring.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  intros.\n  case (mult_lemma1 p m);intros.\n  apply H.\n  apply plus_le_compat_l.\n  rewrite <- (mult_1_l m) in H.\n  apply mult_le_compat_l.\n  apply le_lt_trans with (m + p).\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply le_trans with (m + p).\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply le_lt_trans with (m + p).\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply le_trans with (m + p).\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply le_trans with (m + p).\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply le_S.\n  apply plus_le_compat_l.\n  apply le_S.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  applyQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  auto with arith.\n  rewrite <- (mult_0_l p (S m));ring.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  intros; omega.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nProof.\n  intros; subst; auto with arith.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nintros.\napply le_trans with (2:=H); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\n",
                "context_tokens": 740,
                "proof_start_offset": 2560,
                "proof_end_offset": 2661,
                "proof": "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\ninduction n;simpl;trivial.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  induction n;simpl;try omega;intros.\n  simpl; ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite power_succ_r.\n  simpl in IHn.\n  case (mult_lemma1 (1 * p) (2 * p)); auto with arith.\n  intros; rewrite H0; ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  induction n;simpl;trivial.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  induction n;simpl;auto with arith.\n  intros; discriminate.\n  intros; discriminate.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\ninduction n;simpl;auto.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  induction n;simpl;auto with arith.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  intros.\n  induction n.\n  simpl;auto with arith.\n  intros;rewrite plus_comm.\n  apply plus_comm.\n  apply plus_comm.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  induction n;simpl;intros.\n  rewrite plus_1_r.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  apply plus_le_compat_l.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  induction n;simpl;auto.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\n  intros.\n  case (mult_zero p);auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": ".  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\nLemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;trivial.\n  rewrite IHn;ring.\nQed.\n\n(** if x>1 and x^m | x^n then m<=n *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2701,
                "proof_end_offset": 3361,
                "proof": "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\nintros.\ncase (le_lt_dec m n);trivial.\nintro.\ngeneralize (le_plus_minus n m);intro.\nrewrite H1 in H0;try omega.\nelim H0;intro q;rewrite power_plus_lemma1;intro.\nassert (1=(power x (m-n))*q).\napply mult_lemma6 with (power x n).\nintro;generalize (power_zero n x H3);omega.\nrewrite mult_assoc;rewrite <- H2;ring.\nsymmetry in H3;elim (mult_lemma5 (power x (m-n)) q H3);intros.\ncase (eq_nat_dec (m-n) 0);intro;try omega.\nassert (x=1);try omega.\napply divides_antisym;[apply one_min_div | rewrite <- H4;apply power_divides_lemma1;omega].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction m;simpl;intros.\n  rewrite power_mult_lemma1;rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  inversion H.\n  apply IHn.\n  apply plus_lt_compat_r.\n  apply le_trans with (2*p);try omega.\n  apply plus_le_compat_l.\n  apply IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite power_mul_1;simpl; auto.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  destruct m;simpl;try omega.\n  rewrite IHn;ring.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply plus_le_compat_r;try omega.\n  rewrite plus_comm.\n  apply plus_le_compat_r;try omega.\n  apply IHn.\n  apply plus_le_compat_r;try omega.\n  apply IHn.\n  apply plus_le_compat_l;try omega.\n  apply IHn.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;try omega;intros.\n  destruct m;simpl;try omega;omega.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\n  induction n;simpl;intros.\n  apply power_mult_lemma1.\n  rewrite pow_comm.\n  rewrite <- plus_assoc.\n  rewrite pow_add_distr_r.\n  rewrite pow_add_distr_r.\n  rewrite (mult_comm x), plus_comm.\n  rewrite pow_add_distr_r.\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm x).\n  rewrite (mult_comm x), (mult_comm xQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  destruct m;simpl;try omega;\n  rewrite mult_comm;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\ninduction n;simpl;intros;try omega;case (mult_lemma2 x m);auto.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;trivial.\n  intros; simpl in H; discriminate.\n  intros;simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros;simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl in H; discriminate.\n  intros; simpl inQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  case (mult_lemma1 x (S m));auto.\n  rewrite IHn;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n unfold modulo in |- *.\n unfold modulo in |- *.\n rewrite S_eq_O.\n rewrite (fun p : nat => plus_comm (S p) (S p)).\n rewrite <- plus_assoc.\n rewrite S_eq_plus.\n rewrite S_eq_plus.\n rewrite S_eq_plus.\n rewrite S_eq_plus.\n rewrite S_eq_plus.\n rewrite (fun p : nat => plus_comm (S p) (S p)).\n rewrite <- plus_assoc.\n rewrite (plus_comm (S p)).\n rewrite S_eq_plus.\n rewrite S_eq_plus.\n rewrite S_eq_plus.\n rewrite S_eq_plus.\n rewrite (fun p : nat => plus_comm (S p) (S p)).\n rewrite (plus_comm (S p)).\n rewrite <- mult_assoc.\n rewrite <- (mult_assoc (S p)).\n rewrite <- (mult_assoc (S p)).\n rewrite (mult_assoc (S p)).\n rewrite <- (mult_assoc (S p)).\n rewrite <- mult_assoc.\n rewrite <- (mult_assoc (S pQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n discriminate.\n simpl in |- *.\n intros.\n discriminate.\n simpl in |- *.\n intros.\n discriminate.\n simpl in |- *.\n intros.\n discriminate.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n.\n  intros.\n  case (le_or_lt 0 n).\n  intros.\n  unfold modulo in |- *.\n  simpl in |- *.\n  elim (le_or_lt 0 n).\n  intros.\n  apply H.\n  intros.\n  apply H.\n  simpl in |- *.\n  unfold modulo in |- *.\n  simpl in |- *.\n  elim (le_or_lt 0 n).\n  intros.\n  elim H1.\n  intros.\n  apply H0.\n  simpl in |- *.\n  unfold modulo in |- *.\n  simpl in |- *.\n  elim (le_or_lt 0 n).\n  intros.\n  elim H1.\n  intros.\n  apply H1.\n  simpl in |- *.\n  unfold modulo in |- *.\n  simpl in |- *.\n  elim (le_or_lt 0 n).\n  intros.\n  elim H1.\n  intros.\n  apply H1.\n  simpl in |- *.\n  unfold modulo in |- *.\n  simpl in |- *.\n  elim (le_or_lt 0 n).\n  intros.\n  elim H1.\n  intros.\n  apply H2.\n  simpl in |- *.\n  unfold modulo in |- *.\n  simpl in |- *.\n  elim (le_or_Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro n; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n.\n  simple induction n.\n  simpl in |- *.\n  intros.  elim H0.  intros.  simpl in |- *.  intros.  elim H0.  intros.  elim H1.\n  intros.  simpl in |- *.  intros.  elim H1.  intros.  elim H2.\n  intros.  elim H3.  intros.  simpl in |- *.  intros.  elim H3.\n  intros.  split.  apply H1.  assumption.  assumption.  assumption.  assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro n; elim n; simpl in |- *.\n intros.\n elim H; simpl in |- *.\n intros.\n exists (S p).\n apply le_n_O.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros; elim (le_or_lt n 0); auto.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n.\n  simpl in |- *.  intros.  elim H.  intros.  elim H.  intros.  apply H.\n  intros.  elim H1.  intros.  elim H2.  intros.  apply H2.\n  intros.  elim H3.  intros.  apply H5.  assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro n; case n; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intro.\n  exists (S n).\n  reflexivity.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim (le_n_O _ H).\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intro.\n  red.\n  intro.\n  absurd (0 < n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intro.\n  red in |- *.\n  intros.\n  elim (le_O_n _ H).\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (le_or_lt 0 n).\n  intro.\n  apply le_n_S.\n  apply le_n_n.\n  apply le_O_n.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nred in |- *.\n intros.\nelim (le_O_le_or_eq (S n) (S n)).\n intro.\n absurd (exists q:nat, q = q * q).\n trivial.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intro.\n  unfold modulo in |- *.\n  exists n.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intro.\n  elim (le_or_lt 0 1).\n  intros.\n  elim H0.\n  intros.\n  elim H0.\n  intros.\n  elim H1.\n  intros.\n  assumption.\n  intros.\n  assumption.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intro.\n  red.\n  intros.\n  apply H.\n  apply one_min_div.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  red.\n  intros.\n  elim (H (S (S n))).\n  intros.\n  apply H0.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intro.\n  elim (H (a + 1)).\n  simpl in |- *.\n  right.\n  left.\n  reflexivity.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intro.\n  apply H.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  red.\n  intro.\n  apply (H (a*q)).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  red; intros.\n  apply H.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n intros.\n apply (H (pred_diag_min a a)).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  apply opp_refl.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n red.\n intros.\n apply (is_neg_div a a).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  red.\n  exists O.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intro.\n  unfold modulo in H.\n  apply le_n_S.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  unfold modulo in H.\n  elim (le_or_lt 0 a H).\n  intros.\n  assumption.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  red.\n  intros.\n  apply (H0 (a + b)).\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  unfold Divides, modulo.\n  intros.\n  exists (b * c).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  elim (le_gt_dec (Zabs_nat a) (Zabs_nat b)).\n  left.\n  assumption.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  unfold Reflexive, modulo.\n  intros.\n  case (Z_le_gt_dec n 0); intro.\n  left.\n  assumption.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply div_trans with (a:=b).\n  apply div_trans with (a:=c).\n  apply div_sym.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  red.\n  intros.\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _ _ (Zabs_eq b c)).\n  apply (le_trans _Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  elim (H (b*c) (c*c) (c*c) (c*c) (c*c)).\n  intros.\n  elim H0.\n  intros.\n  elim H1.\n  intros.\n  apply H0.\n  assumption.\n  assumption.\n  intros.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; rewrite H0 in H1.\n  rewrite (H q) in H1.\n  rewrite H1 in H1.\n  rewrite H2.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; elim H0; intro.\n  elim H; intro.\n  rewrite H0 in H1.\n  apply (H0 (b * q)).\n  rewrite H1; auto with arith.\n  rewrite H1; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; elim H0; intro q'; elim H1; intros.\n  rewrite H2 in H1.\n  rewrite <- H1.\n  apply (H3 (p * q)).\n  rewrite H1.\n  apply (H3 (p * q)).\n  rewrite H2.\n  rewrite H3.\n  apply (H3 (p * q)).\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; rewrite (H0 q); rewrite (H1 q); rewrite (H2 q); auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  elim (H0 q); intro.\n  rewrite H1 in H.\n  rewrite H2 in H.\n  simpl in H.\n  rewrite H.\n  rewrite H.\n  apply prime_trans with b; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H1.\n  elim H1; intro.\n  apply H1.\n  rewrite H2.\n  elim H1; intro.\n  rewrite H3 in H1.\n  elim H1; intro.\n  rewrite H4 in H1.\n  apply H4.\n  rewrite H2.\n  elim H1; intro.\n  rewrite H4 in H1.\n  rewrite H1 in H1.\n  elim H1; intro.\n  rewrite H4 in H1.\n  apply H1.\n  rewrite H2.\n  elim H1; intro.\n  rewrite H4 in H1.\n  rewrite H1.\n  rewrite H4.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  unfold Divides in |- *.\n  intros.\n  elim (H0 a).\n  intro.\n  elim H; intro.\n  elim (H1 q).\n  intro.\n  elim H1; intros.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  apply H1.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim (H (b*q)); intro.\n  elim H; intro q'.\n  elim H; intro q'.\n  rewrite H2 in H1.\n  rewrite (H0 q' * q').\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  elim (H0 p).\n  elim H0; intro.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  elim (H1 q).\n  intro.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  elim (H1 q).\n  intro.\n  rewrite H2 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  elim (H1 q).\n  intro.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1.\n  rewrite H1.\n  auto with arith.\n  intro.\n  rewrite H1 in H1.\n  rewrite H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  rewrite H0 in H.\n  elim (H0 p); intro.\n  rewrite H1 in H.\n  elim (H0 p); intro.\n  rewrite H1 in H.\n  apply H0.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2349,
                "proof_end_offset": 2501,
                "proof": "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\nintros.\nred.\nintro.\napply H.\napply divides_antisym;trivial.\napply one_min_div.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro.\n  rewrite H2 in H.\n  elim (mult_lemma5 (a*q) (a*q) (a*q)).\n  rewrite H2.\n  auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nunfold modulo.\nintros.\nelim H; intro.\nelim H0; intro.\nrewrite H4 in H1; clear H4.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1; clear H1.\nelim H1; intro.\nrewrite H4 in H1;Qed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q;intro.\n  apply mult_lemma4; auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H3 in H; rewrite H; rewrite H0; auto.\n  rewrite H3; auto.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q;intro.\n  elim H0; intro.\n  rewrite H2 in H1.\n  cut ((a-1) = 0).\n  intro.\n  rewrite H1 in H1; rewrite H1; rewrite H2;trivial.\n  elim (mult_lemma5 q' H1); intros.\n  rewrite H5 in H1; rewrite H1; rewrite H2;trivial.\n  elim (mult_lemma5 q' H1); intros.\n  rewrite H5 in H1; rewrite H1; rewrite H2; rewrite H2; ring.\n  elim (mult_lemma5 q' H1); intros.\n  rewrite H5 in H1; rewrite H1; rewrite H2; ring.\n  elim (mult_lemma5 q' H1); intros.\n  rewrite H5 in H1; rewrite H1; rewrite H2; ring.\n  elim (mult_lemma5 q' H1); intros.\n  rewrite H5 in H1; rewrite H1; rewrite H2; ring.\n  elim (mult_lemma5 q' H1); intros.\n  rewrite H6 in H1; rewrite H1; rewrite H2; ring.\n  elimQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nintros.\nelim H; intro.\nelim H0; intro.\nelim H0; intro.\nrewrite H4 in H1.\nelim (mult_lemma5 q' H1).\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros a.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H1.\n  exists 1.\n  rewrite H2.\n  apply mult_lemma_1.\n  rewrite <- H0.\n  rewrite H1.\n  reflexivity.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro.\n  elim H0;intro.\n  rewrite H2 in H1.\n  cut (a=1).\n  intro.\n  apply (pos_div_1 a a).\n  rewrite <- H3.\n  rewrite <- H4.\n  replace (a*(0/a)) with (a*(1/a)).\n  rewrite H4.\n  auto with arith.\n  rewrite H2.\n  rewrite H1; auto with arith.\n  rewrite H2; auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nintros.\nelim H; intro.\nrewrite H2 in H; simpl in H; auto.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  unfold modulo.\n  intros.\n  elim H; intro q;intro.\n  elim H0; intro.\n  elim H1; intro.\n  rewrite H2 in H0.\n  rewrite H2 in H0.\n  rewrite H0 in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm a a) in H0.\n  rewrite (plus_comm (a + q)) in H0.\n  rewrite (plus_comm (a + q)) in H0.\n  rewrite (plus_comm (a + q)) in H0.\n  rewrite (plus_comm (a + q)) in H0.\n  rewrite (plus_comm (a + q)) in H0.\n  rewrite (plus_comm a a) inQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "s *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2544,
                "proof_end_offset": 2770,
                "proof": "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nexists (q+q').\nrewrite H1;rewrite H2.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H1.\n  rewrite (mult_comm (a*q)).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite <- (mult_comm (a*q)).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm (a*q)).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm (a*q)).\n  rewrite (mult_comm (a*q)).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm (a*q)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (a*q)).\n  rewrite (mult_comm (a*q)).\n  rewrite (mult_comm (a*q)).\n  rewrite (mult_comm (a*q)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (a*q)).\n  rewrite (mult_comm (a*q)).\n  rewrite mult_assoc.\n  rewrite (Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  elim H0; intro.\n  rewrite H2 in H2.\n  apply H0.\n  apply div_left.\n  apply div_left.\n  apply div_sym; trivial.\n  apply div_sym; trivial.\n  apply div_sym; trivial.\n  apply div_sym; trivial.\n  apply div_sym; trivial.\n  apply div_sym; trivial.\n  apply div_sym; trivial.\n  apply div_sym; trivial.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\n  unfold modulo.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H; rewrite H; auto with arith.\n  elim (mult_lemma5 d a b); intro.\n  rewrite H2 in H; rewrite H; auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro.\n  rewrite H2 in H; rewrite (plus_comm a b) in H; assumption.\n  apply plus_le_compat_l.\n  rewrite <- (plus_comm a b) in H; assumption.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold Divides in |- *.\n  intros.\n  elim H; intro q; elim H0; intro.\n  rewrite H2 in H0.\n  rewrite H1.\n  rewrite H0.\n  auto with arith.\n  rewrite H2.\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  elim H1; intro.\n  rewrite H2 in H; rewrite H4 in H.\n  elim (mult_lemma5 q' H4).\n  rewrite <- H4.\n  rewrite H5; auto.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H1.\n  rewrite H2 in H1.\n  rewrite H0.\n  elim (mult_lemma5 d a b d d H1).\n  elim (mult_lemma5 d b a d d H1).\n  elim (mult_lemma5 d b a d d H1).\n  elim (mult_lemma5 d b a d H1).\n  elim (mult_lemma5 d b a b d H1).\n  elim (mult_lemma5 d b a b d H1).\n  elim (mult_lemma5 d b a b d H1).\n  elim (mult_lemma5 d b a b d H1).\n  elim (mult_lemma5 d b a b d H1).\n  elim (mult_lemma5 d b a b d H1).\n  elim (mult_lemma5 d b a b d H1).\n  elim (mult_lemma5 d b a b c d H1).\n  elim (mult_lemma5 d b a b c d H1).\n  elim (mult_lemma5 d b a b c d H1).\n  elim (multQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1.\n  auto.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold Divides in |- *.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H.\n  elim (mult_lemma5 d a b); auto.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold Divides in |- *.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H1; simpl in |- *; apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_plus.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\n  apply div_div.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\n",
                "context_tokens": 732,
                "proof_start_offset": 2801,
                "proof_end_offset": 2971,
                "proof": "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nexists (b * q).\nrewrite H0.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro q;intro.\n  elim H0; intro.\n  rewrite H2 in H; auto.\n  rewrite H1; auto.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1 in H; simpl in H; rewrite plus_comm in H; assumption.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2; ring.\n  apply H.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  apply H.\n  elim H; intro.\n  apply H.\n  elim H; intro.\n  elim H; intro.\n  apply H0.\n  apply H.\n  elim H; intro.\n  apply H.\n  apply H.\n  elim H; intro.\n  apply H0.\n  apply H.\n  elim H; intro.\n  apply H.\n  apply H0.\n  elim H; intro.\n  apply H.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  apply H.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply H.\n  apply H.\n  elim H0; intro.\n  apply H0.\n  elim H; intro.\n  apply H0.\n  elim H; intro.\n  apply HQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  rewrite H2 in H.\n  rewrite H2 in H.\n  auto.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro q; intro.\n  elim H0; intro.\n  elim H0; intro.\n  rewrite H2 in H1; rewrite <- H0; simpl in H1; rewrite H2; ring.\n  rewrite H1; ring.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2.\n  ring.\n  red.\n  intro.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides, mult in |- *.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H0.\n  elim (mult_lemma5 d a b).\n  rewrite H0; rewrite H1; rewrite H2; auto.\n  rewrite H0; rewrite H1; rewrite H2; auto.\n  rewrite H0; rewrite H1; rewrite H2; rewrite H2; auto.\n  rewrite H0; rewrite H1; rewrite H2; rewrite H4; auto.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H0; simpl in H0; rewrite H0; auto.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  rewrite H2 in H0.\n  elim (mult_lemma5 d a b).\n  rewrite H2; rewrite H2; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3014,
                "proof_end_offset": 3325,
                "proof": "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H1;rewrite H2.\nexists (q'-q).\nrewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1.\n  rewrite H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2.\n  rewrite H1; auto with arith.\n  rewrite H2; auto with arith.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides in |- *.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1; ring.\n  red; intro.\n  elim (mult_lemma5 d a b).\n  elim H0; intros.\n  rewrite H1; rewrite H2; ring.\n  apply H0.\n  rewrite H1; rewrite H2; ring.\n  apply H.\n  rewrite H1; rewrite H2; ring.\n  apply H0.\n  rewrite H1; ring.\n  apply H0.\n  rewrite H1; rewrite H2; ring.\n  apply H0.\n  rewrite H1; ring.\n  apply H0.\n  rewrite H1; ring.\n  apply H1.\n  rewrite H1; ring.\n  apply H0.\n  rewrite H1; ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides in |- *.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H0.\n  rewrite <- H0 in H1.\n  rewrite <- H0 in H1.\n  rewrite <- H0 in H1.\n  rewrite <- H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides.\n  intros.\n  elim H; intro q; intro.\n  rewrite H2 in H0.\n  rewrite H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  rewrite H0.\n  case (mult_lemma5 d a a); auto.\n  apply le_trans with (b * d * d * a).\n  rewrite (mult_comm b).\n  rewrite H0; auto with arith.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2 in H0.\n  rewrite <- H2.\n  rewrite H1; auto with arith.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2.\n  case (b * (d - a)); auto with arith.\n  rewrite H1; auto with arith.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold modulo.\n  intros.\n  elim H; intro.\n  rewrite H0.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold Divides.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1; rewrite H2; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\n",
                "context_tokens": 730,
                "proof_start_offset": 3412,
                "proof_end_offset": 4144,
                "proof": "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\nProof.\nintros.\napply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\nintro.\ncase n;intros.\nexists 0;auto with arith.\nelim (H0 ((S n0)-b)).\nintro q;intro.\nexists (S q).\nreplace (S n0) with (b+(S n0-b)).\nrewrite p;rewrite plus_comm;auto with arith.\nsymmetry.\napply le_plus_minus.\nelim H1;intros.\nrewrite H2.\nreplace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\napply mult_le_compat_r.\ndestruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\nsimpl;auto with arith.\ndestruct b.\nelim H1;simpl;intros;discriminate.\nomega.\napply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q; intro.\n  rewrite H1; rewrite H2.\n  ring.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros a b.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1; rewrite <- H2.\n  rewrite <- H3; rewrite H4; auto.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q; elim H0; intro.\n  exists (q*q).\n  rewrite H0.\n  rewrite H1; rewrite (mult_comm q (q*q)); rewrite <- H0; auto with arith.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros a b.\n  elim H; intro q; intro.\n  elim H0; intro.\n  elim H0; intro.\n  apply H1.\n  rewrite H2; rewrite H4; auto.\n  rewrite H4; auto.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros a b; elim H; intro.\n  elim H0; intro.\n  exists (b * q).\n  rewrite H0; ring.\n  exists (b * q).\n  rewrite H0; ring.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros a b.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1.\n  rewrite H2.\n  case (b*q);intro.\n  rewrite <- (mult_comm a); rewrite (mult_comm b); rewrite (mult_comm a); ring.\n  rewrite <- (mult_comm a); rewrite (mult_comm b); rewrite (mult_comm b); ring.\n  rewrite <- (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b); ring.\n  rewrite <- (mult_comm b); rewrite (mult_comm b); rewrite (mult_comm b); ring.\n  rewrite <- (mult_comm b); rewrite (mult_comm a); rewrite (mult_comm b); ring.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q; elim H0; intro.\n  apply (H0 (a*q)); auto with arith.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\nProof.\nintros a b.\ninduction a; simpl; auto with arith.\ndestruct (mult_integral _ _ _ H) as (q & r & H).\nrewrite (mult_comm q r); rewrite (mult_comm q r); rewrite H;\n ring.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1 in H1.\n  rewrite <- H2 in H0; simpl in H0; rewrite H0; rewrite H1; ring.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H2.\n  rewrite <- H3.\n  rewrite <- H1.\n  rewrite H3.\n  rewrite H3.\n  rewrite H4.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": ".\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\n",
                "context_tokens": 727,
                "proof_start_offset": 4328,
                "proof_end_offset": 4482,
                "proof": "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\nintros.\nunfold quo.\ngeneralize (quo_dec a b H);intro;elim s;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  case (le_or_lt (quotient a (quotient b H))) with (r * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (c * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b))))))));\n    auto with arith.\n  apply le_trans with (r * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (a * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (b * (bQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nunfold dvd; intros.\nelim H; intros.\nelim H0; intro.\nrewrite H2.\nrewrite H1.\nring.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  unfold modulo.\n  intros.\n  elim (H (b - a) H0); intros.\n  exists (q+q).\n  rewrite H; auto with arith.\n  simpl.\n  rewrite <- H; auto with arith.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  unfold is_factor, is_factor, is_factor, is_factor, is_factor in |- *; simpl in |- *; intros.\n  elim (H (quotient_sym a b H)); intros.\n  elim H0; intro.\n  rewrite H1; rewrite H2.\n  apply mod_refl.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nunfold modulo.\nintros.\nelim H; intros.\nelim H0; intros.\nexists (q+q).\nrewrite H1.\nrewrite (mult_comm a b); auto with arith.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  apply (le_trans _ (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_right (alpha_of_left (alpha_irr_left (alpha_of_left (alpha_irr_left (mu_refl _))))))).\n  apply (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_left (alpha_refl _))))).\n  apply (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_left (alpha_of_right (alpha_of_left (alpha_refl _))))).\n  apply (alpha_of_left (alpha_of_left (alpha_of_right (alpha_of_right (alpha_of_left (alpha_irr_right (alpha_of_right (alpha_irr_right (psi_of_left (alpha_irr_right (psi_irr_left (psi_irr_right)))).\n  apply (alpha_of_leftQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  elim H; intros.\n  exists 0; auto with arith.\n  elim H; intros.\n  apply H1; auto with arith.\n  rewrite H0; rewrite H2; rewrite H1; auto with arith.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  unfold has_a; intros.\n  elim H; intros.\n  exists (p*q).\n  rewrite H0.\n  ring.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  unfold half.\n  intros.\n  elim H; intros.\n  exists (b * q).\n  rewrite H.\n  ring.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nintros.\napply (le_trans _ (Mod a b H)).\napply (H (fun x:nat => (p - a)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\nLemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  unfold quo.\n  generalize (quo_dec a b H);intro;elim s;trivial.\nQed.\n\n(** if b | a then (n*a/b) = n*(a/b) *) \n",
                "context_tokens": 706,
                "proof_start_offset": 4524,
                "proof_end_offset": 5018,
                "proof": "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\nintros.\ngeneralize (quo_is_quo (a*n) b (divides_mult b a n H));intro.\ngeneralize (quo_is_quo a b H);intro.\nreplace (a*n = b * quo (a * n) b (divides_mult b a n H)) with (b*(quo a b H)*n = b * quo (a * n) b (divides_mult b a n H)) in H1.\nsymmetry;rewrite mult_comm.\napply mult_lemma6 with b;trivial.\nrewrite mult_assoc;trivial.\nrewrite <- H2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  generalize (factor_factor_prod a b H); intro; elim H.\n  intro q; intro.\n  apply (H1 (S n) (S (S n0))); auto with arith.\n  intro n; rewrite H0; rewrite H1; simpl; auto with arith.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  generalize (le_le_trans _ (le_refl n)).\n  apply le_trans with (m := (n*a/b) (modulus_mult b a n H)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <- (mult_assoc n a (le_refl n)).\n  rewrite <-Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold nc in |- *.\n  elim H; intro q; elim H0; intros.\n  rewrite H0.\n  apply (H1 (pos (pos (pos (abs (pos (abs (abs (abs (abs (abs (abs (abs (abs b)))).\n  intro p; rewrite (abs_eq b p); rewrite (abs_eq b p); rewrite (abs_eq b p);\n    rewrite (abs_eq b p); rewrite (abs_eq b p); rewrite (abs_eq b p);\n      rewrite (abs_eq b p); rewrite (abs_eq b p); rewrite (abs_eq b p);\n        rewrite (abs_eq b p); rewrite (abs_eq b p); rewrite (abs_eq b p);\n        rewrite (abs_eq b p); rewrite (abs_eq b p); rewrite (abs_eq b p);\n          rewrite (abs_eq b p); rewrite (abs_eq b p); rewrite (abs_eq b p);\n            rewrite (abs_eq b p); rewrite (abs_eq b p); rewrite (abs_eq b p);\n            rewrite (abs_eq b p); rewrite (abs_eq b p); rewriteQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros a b H.\n  pattern a at 1 3; rewrite <- (factor_intro (H a) (H a) (H a) (H a) (H b H0)).\n  pattern a at 2; rewrite <- (factor_intro (H a) (H a) (H a) (H a) (H b H0)).\n  apply le_n_S; assumption.\n  rewrite H; apply le_n_S; assumption.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (H (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) H)).\n  apply (H (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) H)).\n  apply (H (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) H)).\n  apply (H (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) H)).\n  apply (H (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) H)).\n  apply (H (n*a) (n*a) (n*a) (n*a) (n*a) (n*a) (n*aQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold half.\n  generalize (factor_dec a b H); intro.\n  elim H0; intro.\n  rewrite H1.\n  rewrite (factor_factor_factor_r a b (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) (S n0) H0 H1).\n  apply H; auto with arith.\n  apply H; auto with arith.\n  apply H; auto with arith.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  generalize (factor_factor_l (a*n) (a*n));intro; elim H; intro.\n  rewrite H0; rewrite <- H1; rewrite H1; rewrite H2; auto with arith.\n  rewrite H1; rewrite H2; auto with arith.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (le_trans _ (quotient_factor_prod a b (quotient_factor_prod a b H))).\n  apply (le_trans _ (quotient_factor_prod a b H)).\n  apply (le_trans _ (quotient_factor_prod a b H)).\n  apply (le_trans _ (quotient_factor_prod a b H)).\n  apply (le_trans _ (quotient_factor_prod a b H)).\n  apply (le_trans _ (quotient_factor_prod a b H)).\n  apply (le_trans _ (quotient_factor_prod a b H)).\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold abs.\n  generalize (factor_intro a b H); intro.\n  case n;intros.\n  exists (S n).\n  apply (H0 (S n)).\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfoldquo.\n  generalize (factor_bound_eq a b H); intro; elim (H0 (H0 (H0 (H0 (H1 (H2 (H2 (H3 (H4 (H3 (H4 (H4 (H5 (H6 H7)))));\n    intro; auto.\n  apply (H1 (H2 (H3 (H4 (H4 (H5 (H7 H)))); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\n",
                "context_tokens": 314,
                "proof_start_offset": 1197,
                "proof_end_offset": 1343,
                "proof": "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime.\nintro.\nelim H;intros.\ncase (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nintro.\nunfold is_prime, is_prime, is_prime, is_prime.\nintro.\napply (H (S p)); auto with arith.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n intros d.\n apply (not_O_neq_le_incl d).\n apply is_prime_intro.\n intros.\n unfold is_prime in H.\n tauto.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime, is_prime, is_prime, is_prime.\nintros d.\nunfold is_prime, is_prime in |- *; simpl in |- *.\nintros.\napply (H d).\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime; simpl; auto with *.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime, is_prime, is_prime; simpl.\nintros.\nelim H; intros p H1.\nelim H1; intros p H2; elim H3; intros p H4; elim H5; intros p H5;\n elim H6; intros p H6; elim H7; intros p7 H8;\n elim H7; intros p8 H9; elim H9; intros p9 H10; \n elim H9; intros p10 H10; elim H10; intros p11 H11;\n elim H10; intros p11 H12; elim H12; intros p13 H14;\n elim H13; intros p14 H15; elim H15; intros p6 H6; \n elim H6; intros p7 H8; elim H8; intros H8 H9;\n elim H9; intros H9 H10; elim H10; intros p11 H12;\n elim H10; intros p12 H13; elim H13; intros p13 H15; \n elim H14; intros p14 H15; elim H15; intros p16 H17; \n elim H16; intros p15 HQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime, is_prime, is_prime; simpl; intros.\napply is_prime_intro; trivial.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime in |- *; intros d; apply (is_prime_intro d).\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime in |- *.\nintros.\nelim (p H).\nintros.\nelim H0.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H3.\nintros.\nelim H3.\nintros.\nelim H4.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\nelim H7.\nintros.\napply H8.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\napply H10.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime, is_prime; simpl; intros.\napply (is_prime_eq_divisors (fun d : nat => d=1 /\\ d=1)).\napply is_prime_intro.\napply (is_prime_intro d).\napply (is_prime_intro d).\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nintro.\napply (not_neg_sym (fun d : nat => d=0)).\napply (not_neg_sym (fun d : nat => d=0)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\n",
                "context_tokens": 376,
                "proof_start_offset": 1372,
                "proof_end_offset": 1780,
                "proof": "Lemma is_prime_2 : (is_prime 2).\nProof.\nunfold is_prime.\nsplit.\nintro;discriminate.\nintros.\nelim H;destruct x;rewrite mult_comm.\nintro;discriminate.\nsimpl.\ncase d.\nsimpl.\nrewrite mult_comm;simpl;intro;discriminate.\nintros.\ninversion H0.\nsymmetry in H2.\ncase (plus_is_one n (x*(S n)) H2);intro.\nelim a;intros.\nleft;rewrite H1;trivial.\nelim a;intros.\nright;rewrite H1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime.\nintro.\nelim H; intros.\napply (is_prime_intro (S p)).\napply (is_prime_intro (S p)).\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime in |- *; intros.\ncase (is_prime_2_prime 2).\nintro.\nabsurd (0 < p).\nred in |- *; intros.\napply is_prime_2.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_4.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\napply is_prime_3.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime in |- *; intros.\nelim H; intros.\ncase (H1 2); intros.\nabsurd (exists p : nat, p = S (p * p))%Z; auto.\nelim H; intros.\nelim H; intros.\ngeneralize (H1 p H1); clear H1 H2.\ncase (H1 2); intros.\ngeneralize (H1 p H2); clear H1 H2.\ncase (H1 2); intros.\nabsurd (exists p : nat, S p = S (p * S p))%Z; auto.\nelim H1; intros.\nabsurd (S p = S (p * S p))%Z; auto.\nelim H1; intros.\nabsurd (S p = S (p * S p))%Z; auto.\nelim H1; intros.\nabsurd (S p = S p); auto.\nelim H1; intros.\nabsurd (S p = S (p * S p))%Z; auto.\nelim H2; intros.\nabsurd (S p = S (p * S p))%Z; auto.\nelim H1; intros.\nabsurd (S p = S pQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime in |- *.\nunfold is_prime in |- *.\nintros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime in |- *; unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\n unfold is_prime in |- *;\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime.\nunfold is_prime.\nintro.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H7; intros.\nelim H9; intros.\nelim H8; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H11; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime.\nintro.\napply (is_prime_intro (fun d : nat => d <> 0 /\\ d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (fun d : nat => d <> 0)).\napply (is_prime_intro (Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_prime.\nunfold is_Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\nProof.\nunfold is_prime; intros.\ncase (not_neg_or_eq _ _ H); intros.\nabsurd (p=0).\ndiscriminate.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nunfold is_prime.\nintro.\ncase (is_prime_2 p); intros.\nabsurd (0 < p)%Z; auto with zarith.\nelim H0; intros.\napply (H1 (S p)); auto with zarith.\nintros.\nred in |- *; intro.\nabsurd (S p < S q)%Z; auto with zarith.\napply (H2 (S p)); auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\n",
                "context_tokens": 535,
                "proof_start_offset": 1852,
                "proof_end_offset": 2186,
                "proof": "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nunfold is_prime.\nunfold rel_prime.\nintros.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H;intros.\nelim H1;intros.\ncase (H3 d' H4);intro.\nrewrite H6;apply divides_refl.\nrewrite H6 in H5;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nintros p a.\ncase (prime_non_prime_2 p); intros.\ncase (gcd_non_prime_2 p (Zabs_nat p));intros.\napply (H1 (S p)); trivial.\napply (H2 (S p)); trivial.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nunfold is_prime in |- *; intros.\nelim H; intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H0 p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nelim (H p); intros.\nleft; rewrite H1; rewrite H2; auto.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros; case (is_prime_2 p); case (is_prime_2 p); auto.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nintros.\napply not_prime_one; apply is_prime_2; apply is_prime_4;\n apply is_prime_2; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply is_prime_4; apply is_prime_4;\n apply isQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nintros; elim H; intros.\ncase (H1 2); try (apply False_ind; assumption).\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nunfold is_prime.\nintros.\nelim H; intros.\ncase (H1 2); intros.\nleft; assumption.\nright; apply prime_div; assumption.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nunfold is_prime.\nintros; elim H; intros.\ncase (H1 2); intros.\ncase (H2 2); intros.\ncase (H2 2); intros.\ncase (H3 2); intros.\ncase (H3 2); intros.\ncase (H4 2); intros.\ncase (H4 2); intros.\ncase (H5 2); intros.\ncase (H5 2); intros.\ncase (H5 2); intros.\ncase (H6 2); intros.\ncase (H7 2); intros.\ncase (H8 2); intros.\ncase (H8 2); intros.\ncase (H7 2); intros.\ncase (H7 2); intros.\ncase (H8 3); intros.\ncase (H8 2); intros.\ncase (H9 3); intros.\ncase (H10 2); intros.\ncase (H8 3); intros.\ncase (H10 3); intros.\ncase (H9 4); intros.\ncase (H9 4); intros.\ncase (H8 4); intros.\ncase (H9 5); intros.\ncase (H9Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nintros p a.\ngeneralize (lt_O_nat_1 p); unfold rel_prime.\ngeneralize (lt_O_nat_2 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_1 p); unfold rel_prime.\ngeneralize (lt_O_nat_2 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3 p); unfold rel_prime.\ngeneralize (lt_O_nat_3Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nintros.\napply is_prime_2.\napply is_prime_2.\napply is_prime_2.\napply is_prime_3.\napply is_prime_3.\napply is_prime_4.\napply is_prime_2.\napply is_prime_4.\napply is_prime_3.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\napply is_prime_4.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nunfold is_prime.\nintros.\nelim H; intros.\nelim H0; intros.\nelim (H0 2); intros.\nelim (H0 2); intros.\nelim H1; intros.\nelim (H2 2); intros.\nelim H2; intros.\nelim (H3 2); intros.\nelim (H4 2); intros.\nelim (H5 2); intros.\nelim (H5 2); intros.\nelim (H5 2); intros.\nelim (H6 2); intros.\nelim (H6 2); intros.\nelim (H7 2); intros.\nelim (H7 2); intros.\nelim (H7 2); intros.\nelim (H7 2); intros.\nelim (H8 2); intros.\nelim (H7 2); intros.\nelim (H7 2); intros.\nelim (H8 2); intros.\nelim (H7 2); intros.\nelim (H8 2); intros.\nelim (H7 2); intros.\nelim (H7 2); intros.\nelim (H7 2); intros.\nelim (H7 2); intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\n",
                "context_tokens": 691,
                "proof_start_offset": 2286,
                "proof_end_offset": 2466,
                "proof": "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nunfold is_prime.\nintros.\nelim H;intros.\napply H2.\nelim H0;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  unfold gcd.\n  case (gcd_dec d p); intro.\n  elim H1; intros.\n  case (gcd_sym d p H2); intro.\n  elim H2; intros.\n  rewrite <- H5; rewrite H6; apply gcd_sym; assumption.\n  elim H4; intros.\n  rewrite <- H5; rewrite H5; rewrite H6; apply gcd_sym; assumption.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nintros.\nunfold gcd.\ncase (gcd_eq_dec d p).\nintros.\nrewrite (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym p).\nrewrite <- (gcd_sym pQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  elim H; intros.\n  rewrite <- (gcd_sym (p*p)); rewrite <- (gcd_sym (p*p)); rewrite (gcd_sym (p*p));\n  rewrite <- (gcd_sym (p*p)); rewrite (gcd_sym (p*p)); rewrite (gcd_sym (p*p));\n  rewrite <- (gcd_sym (p*p)); rewrite (gcd_sym (p*p)); rewrite (gcd_sym (p*p));\n  rewrite <- (gcd_sym (p*p)); rewrite (gcd_sym (p*p)); rewrite (gcd_sym (p*p));\n  rewrite <- (gcd_sym (p*p)); rewrite (gcd_sym (p*p)); rewrite (gcd_sym (p*p));\n  rewrite (gcd_sym (p*p)); rewrite <- (gcd_sym (p*p)); rewrite (gcd_sym (p*p));\n  rewrite <- (gcd_sym (p*p)); rewrite (gcd_sym (p*p)); rewrite (gcd_sym (p*p));\n  rewrite (gcd_sym (p*p)); rewrite (gcd_sym (p*Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H0; intros.\n  case (H3 d').\n  simpl; rewrite mult_comm.\n  rewrite mult_comm.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nunfold is_prime.\n  intros.\n  elim H; intros.\n  rewrite <- (mult_comm (p * a)).\n  rewrite <- (mult_assoc (p * a)).\n  rewrite (mult_comm (p * a)).\n  rewrite <- (mult_assoc (p * a)).\n  rewrite <- (mult_assoc (p * a)).\n  rewrite (mult_comm (p * a)).\n  rewrite (mult_comm (p * a)).\n  rewrite (mult_assoc (p * a)).\n  rewrite <- (mult_assoc (p * a)).\n  rewrite <- (mult_assoc (p * a)).\n  rewrite (mult_comm (p * a)).\n  rewrite (mult_assoc (p * a)).\n  rewrite (mult_assoc (p * a)).\n  rewrite (mult_assoc (p * a)).\n  rewrite (mult_comm (p * a)).\n  rewrite (mult_assoc (p * a)).\n  rewrite (mult_comm (p * a)).\n  rewrite (mult_assoc (p * a)).\n  rewrite <- (mult_assoc (p * a)).\n  rewrite (mult_comm (p * a)).\n  rewrite (mult_assoc (p * a)).\n  rewrite (Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nintros d p a.\ninduction p; simpl; intros.\napply gcd_sym; apply gcd_sym; assumption.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nunfold is_prime in |- *; intros.\nelim H; intros.\nunfold is_prime in |- *.\nrewrite (mult_comm (p*a)); rewrite H1; rewrite H1; ring.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nintros.\ninduction p.\nintros.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold is_prime in H.\ninversion H.\nunfold isQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nunfold is_prime.\n  intros.\n  case (gcd_prime_bezout p a (p*a)) with (p*a).\n  rewrite <- (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_sym p a); rewrite (gcd_sym p a);\n  rewrite (gcd_sym p a); rewrite (gcd_symQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime; intros.\n  elim H; intros.\n  case (H1 2); try (apply abs_sym; apply H0).\n  case (H2 2); try (apply abs_sym; apply H1).\n  case (H3 (S p)); try (apply abs_sym; apply H0).\n  apply prime_trans with (S p); trivial.\n  apply prime_trans with (S p); trivial.\n  apply prime_trans with (S p); trivial.\n  apply prime_sym; apply prime_sym; apply H0.\n  apply prime_trans with (S p); trivial.\n  apply prime_trans with (S p); trivial.\n  apply prime_trans with (S p); trivial.\n  apply prime_trans with (S p); trivial.\n  apply prime_trans with (S p); trivial.\n  apply prime_sym; apply prime_sym; apply H1.\n  apply prime_trans with (S p); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "NU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2516,
                "proof_end_offset": 2785,
                "proof": "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (gcd_is_gcd a p);intros.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\nelim H1;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H2; intros.\n  apply H3.\n  elim H4; trivial.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H1.\n  apply prime_sym; trivial.\n  apply prime_sym; trivial.\n  apply prime_sym; trivial.\n  apply prime_sym; trivial.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H3.\n  elim H1; intros.\n  case (H3 d' H4); intros.\n  apply H4.\n  apply H5.\n  apply H1.\n  elim H1; intros.\n  elim H4; intro.\n  apply H5.\n  apply H6.\n  apply H2.\n  apply H1.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  case (H1 (p * p));intro.\n  apply H3; trivial.\n  apply H4; trivial.\n  apply H5; trivial.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H1; trivial.\n  apply H2; trivial.\n  apply H3; trivial.\n  apply H3; trivial.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  case (H0 (p - a)).\n  apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym.\n  apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym;\n    apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym;\n    apply prime_sym; apply prime_sym; apply prime_sym; apply prime_sym;\n    apply prime_sym; apply prime_sym; apply primeQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  case (H1 1).\n  apply H1.\n  apply H3.\n  apply H4.\n  apply H1.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim (H1 p).\n  intros.\n  elim H2; intros.\n  case (H3 p); trivial.\n  intros.\n  apply H3.\n  apply H4.\n  apply H1.\n  apply H2.\n  apply H4.\n  apply H1.\n  apply H4.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H4.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H4.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  applyQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply (H2 a (p*p)); trivial.\n  apply prime_div; assumption.\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H1.\n  elim H1; intros.\n  case (H2 p); trivial.\n  apply H2.\n  elim H1; intros.\n  case (H3 p); trivial.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H1.\n  apply H4.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\n",
                "context_tokens": 720,
                "proof_start_offset": 2840,
                "proof_end_offset": 3139,
                "proof": "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a p);intro.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\nright;apply gauss with a;trivial.\nred in H1;elim H1;intros.\nred in H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H2.\n  elim H3;intros.\n  apply H3.\n  apply H4.\n  apply H.\n  apply H.\n  assumption.\nQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H3; intros.\n  case (gcd_rel_prime p p a); trivial.\n  intros.\n  elim H3; intros.\n  rewrite H4; apply prime_mul; trivial.\n  intros.\n  elim H3; intros.\n  elim H4; intros.\n  apply (prime_mul p p a); trivial.\n  apply H4.\n  rewrite H5; apply prime_mul; trivial.\n  intros.\n  elim H3; intros.\n  elim H3; intros.\n  apply (prime_mul p p a); trivial.\n  rewrite H5; apply prime_mul; trivial.\n  rewrite H6; apply prime_mul; trivial.\n  rewrite H6; apply prime_mul; trivial.\n  rewrite H6; apply prime_mul; trivial.\n  rewrite H6; apply prime_mul; trivial.\n  rewrite H6; apply prime_mul; trivial.\nQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H3.\n  elim H1;intros.\n  case (gcd_exists (a*b)).\n  intro.\n  elim H1; intros.\n  rewrite H3; rewrite H4; rewrite H5; rewrite H6; rewrite H6;\n    rewrite H6; rewrite H7; rewrite H7; rewrite H7; rewrite H7; reflexivity.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  apply prime_div.\n  applyQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  case (H3 d H4); intro.\n  rewrite H4; rewrite H5; rewrite H5; assumption.\n  assumption.\nQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H3.\n  apply H4.\n  apply prime_sym.\n  apply H3.\n  apply (H3 p).\n  apply prime_sym.\n  apply H3.\n  apply (H3 p).\n  apply prime_sym.\n  apply H1.\n  apply H3.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H3.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H2.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H2.\n  apply prime_sym.\n  apply H3.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H2.\n  apply prime_sym.\n  apply H4.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H1.\n  apply prime_sym.\n  apply H1.\n  apply primeQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  case (gcd_is_gcd a p); intros.\n  elim H1; intros.\n  elim H3;trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim H3; intros.\n  elim H4; trivial.\n  intros.\n  case (gcd_is_gcd a p); intros.\n  elim H4; trivial.\n  intro.\n  elim H5; trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim H5; trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim H6; trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim H6; trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim H7; trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim H7; trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim H7; trivial.\n  intro.\n  case (gcd_is_gcd a p); intros.\n  elim HQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime; intros.\n  elim H; intros.\n  apply H2.\n  elim H1;intros.\n  case (gcd_mult_l p p a H1);intro.\n  elim H3; intro.\n  case (gcd_mult_r p p a H1);intro.\n  rewrite H4; apply H4.\n  apply H2.\n  elim H3; trivial.\n  rewrite H4; apply H4.\n  rewrite H4; apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H5.\n  apply H4.\n  apply H5.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H5.\n  apply H4.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H5.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H1.\n  apply H4.\n  applyQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H3; intros.\n  case (H3 p); intro.\n  rewrite H4; rewrite H5; apply prime_sym; assumption.\n  apply prime_trans with (p * (p * a) * (p * a)).\n  rewrite H5; rewrite H6; apply prime_sym; assumption.\n  rewrite H6; apply prime_sym; assumption.\n  rewrite H6; apply prime_sym; assumption.\nQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H4;trivial.\n  elim H5; trivial.\n  intros.\n  apply H5.\n  elim H5; trivial.\n  intros.\n  apply H5.\n  elim H5; trivial.\nQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H4; intros.\n  case (H3 d' H4); intro.\n  case (H4 d' H4); intro.\n  case (H5 d' H4); intro.\n  rewrite H5; apply H5; apply H5; apply H5; apply H6.\n  apply (H4 _ H5 H7).\n  apply (H4 _ H7).\n  rewrite H6; apply H5; apply H6.\n  apply (H4 _ H6).\n  rewrite H5; apply H5; apply H6.\n  apply (H4 _ H7).\n  rewrite H5; apply H5; apply H6.\n  apply (H4 _ H7).\n  rewrite H5; apply H6.\n  apply (H7 _ H7).\n  apply (H4 _ H7).\n  rewrite H5; apply H5; apply H6.\n  apply (H7 _ H7).\n  rewrite H5; apply H5; apply H6.\n  apply (H4 _ H7).\n  rewrite H5; apply H6.\n  apply (H7Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\n",
                "context_tokens": 729,
                "proof_start_offset": 3196,
                "proof_end_offset": 3355,
                "proof": "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\nunfold square.\nintros;case (prime_mult p a a H H0);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H3; intro.\n  apply H3.\n  apply H0; trivial.\n  apply H1; trivial.\n  elim H1; intros.\n  elim H3; intros.\n  elim H4; intro.\n  apply H4.\n  apply H1; trivial.\n  elim H1; intros.\n  elim H4; intro.\n  apply H4; trivial.\n  apply H5; trivial.\n  elim H1; intros.\n  elim H4; intro.\n  apply H4; trivial.\n  apply H1; trivial.\n  apply H1; trivial.\n  apply H1; trivial.\n  apply H1; trivial.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime in |- *; intros.\n  elim H; intros.\n  elim H3; trivial.\n  elim H1; intros.\n  elim H3; trivial.\n  elim H3; trivial.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H3; intros.\n  apply H1; assumption.\n  apply prime_prime_lt_compat; assumption.\n  apply prime_prime_lt_compat; assumption.\n  apply prime_prime_lt_compat; assumption.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime in |- *.\n  intros.\n  elim H; intros.\n  elim H3; intros.\n  elim H4; trivial.\n  apply (H0 (a*b)); trivial.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H1;intros.\n  elim H3; intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H4; intros.\n  apply H4.\n  elim H5; intros.\n  apply H4.\n  elim H4; intros.\n  apply H5.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  apply H4.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elimQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  elim H; intro.\n  rewrite (gcd_sym a p); trivial.\n  elim H; intros.\n  elim H3;trivial.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply H1.\n  elim H1;intros.\n  rewrite H2; rewrite H1; apply prime_le; trivial.\n  apply prime_le; trivial.\n  apply prime_le; trivial.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim (prime_or_lt p a).\n  left; exact (pos_pos a (pos_pos a)).\n  right; exact (pos_pos a (pos_pos b (pos_pos a))).\n  apply prime_prime_pos.\n  assumption.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  case (gcd_is_prime p p a H0); intro; rewrite H3 in H0; try tauto.\n  elim H0; intros.\n  elim H2; trivial.\n  elim H3; trivial.\n  apply H4; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3388,
                "proof_end_offset": 3666,
                "proof": "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\ninduction n;simpl;intros.\nelim H;intros.\nelim H1;apply divides_antisym;trivial;apply one_min_div.\ncase (prime_mult p x (power x n) H H0);trivial.\nintro;apply IHn;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime in |- *; unfold is_prime in |- *.\n  intros; elim H; intros.\n  apply H2.\n  elim H3; intros.\n  apply H4.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold prime.\n  intros.\n  apply H.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_rel_prime.\n  apply prime_relQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold lt, pred, pred.\n  intros.\n  apply (is_prime_rel (S n)).\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros; case (prime_rel_prime p x);trivial.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold prime.\n  intros.\n  apply H.\n  apply (fun p n m:nat => (p * n)%nat).\n  intros.\n  elim H; trivial.\n  intros.\n  elim H3; trivial.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H; trivial.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime in |- *; intros.\n  elim (H0 p); trivial.\n  intros; absurd (x <= n); trivial.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros.\n  elim H; intro.\n  apply H.\n  apply (H1 0%nat).\n  assumption.\n  apply (H2 0%nat).\n  assumption.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime in |- *; unfold prime in |- *; simpl in |- *.\n  intros.\n  elim H; intros.\n  apply H2.\n  assumption.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros; elim H; intros.\n  elim H0; trivial.\n  intros; rewrite H1; apply prime_le_weak; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 3668,
                "proof_end_offset": 4798,
                "proof": "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\ninduction q;simpl;intros.\napply one_min_div.\nrewrite power_plus_lemma1 in H0.\nassert (divides x (power p q)).\napply IHq;trivial.\nelim H0;intros;exists ((power p n)*x0).\nrewrite H2;ring.\nelim H2;intros.\nrewrite H3 in H0.\nrewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\nelim H0;intros.\nassert ((power p (q*n))<>0).\nintro.\ngeneralize (power_zero (q*n) p H5).\nintro.\napply not_prime_zero.\nrewrite H6 in H;trivial.\nrewrite <- mult_assoc in H4.\ngeneralize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\nintro.\nassert (exists n':nat,n=(S n')).\ninversion H1;[exists 0 | exists m];trivial.\nelim H7;intro n';intro.\nrewrite H8 in H6;simpl in H6.\nassert (divides x0 p).\ncase (prime_mult p x0 (power x0 n'));trivial.\nrewrite H6.\nexists ((power p n')*x1);ring.\nintro.\napply prime_power with n';trivial.\nelim H9;intros.\nrewrite H10 in H3.\nrewrite H3.\nexists x2;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred.\nProof.\n  intros.\n  rewrite (fun p n => exists (p n), exists (p n), exists (p n), exists (p n), p).\n  intros.\n  rewrite H1; auto.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime.\n  intros; case (prime_mult p x (power x n) H H0);trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  elim H;intros.\n  elim H1; intros.\n  elim H2;trivial.\n  red in H3;tauto.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold not; intros.\n  elim H;intros.\n  elim H0; intros.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime.\n  intros;case (prime_mult p x n);trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime, pred; intros.\n  apply H.\n  elim H;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H2;trivial.\n  apply IHn;trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime; destruct p; simpl;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3; intros.\n  elim H4;intros.\n  elim H4; intros.\n  elim H4; intros.\n  apply H5.\n  apply H5.\n  apply H1.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  apply H5.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply HQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime.\n  intros;case (prime_mult p x (S n) H H0);trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1;intros.\n  elim H1; intros.\n  elim H2; trivial.\n  red in H2; elim H2; intros.\n  elim H3; trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  apply prime_le_compat;apply prime_le_compat;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\n",
                "context_tokens": 719,
                "proof_start_offset": 4831,
                "proof_end_offset": 5126,
                "proof": "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\nintros;intro.\nelim H;intro p;intro.\nelim H1;intros.\nelim H3;intros.\nunfold is_prime in H0.\nelim H0;intros.\nunfold is_prime in H4.\nelim H4;intros.\ncase (H7 p H5);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a a H.\n  case (prime_prime_mult a p); trivial.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H11; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim H13; intros.\n  elim H14; intros.\n  elim H13; intros.\n  elim H14; intros.\n  elim H14; intros.\n  elim H14; intros.Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a H.\n  elim H.\n  apply prime_mult_l with a; auto with arith.\n  apply prime_mult_l with a; auto with arith.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a p a H0; case (prime_mult_one a p); trivial.\n  intros p H1.\n  exists (S p).\n  rewrite H0; ring.\n  rewrite <- H1; ring.\n  rewrite <- H1; ring.\n  rewrite <- H1; ring.\n  rewrite <- H1; ring.\n  apply le_trans with (S p).\n  rewrite H1; ring.\n  rewrite <- H1; ring.\n  apply le_trans with (S p).\n  rewrite H1; ring.\n  rewrite <- H1; ring.\n  apply le_trans with (S p).\n  rewrite H1; ring.\n  rewrite <- H1; ring.\n  apply le_trans with (S p).\n  rewrite H1; ring.\n  rewrite <- H1; ring.\n  apply le_trans with (S p).\n  rewrite H1; ring.\n  rewrite <- H1; ring.\n  apply le_trans with (S p).\n  rewrite H1; ring.\n  apply le_trans with (S p).\n  rewrite H1; ring.\n  rewrite <- H1; ring.\n  apply le_trans with (S p).\n  rewrite H1;Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros.\n  apply (H0 (a*p) H0 (a*p));trivial.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros a H; apply (prime_mult_reg_l a p); trivial.\n  apply (H (S p) (S p) (S p) (S p) (S p) (S p) (S p)).\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a.\n  case (prime_mult_prime p a H); trivial.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  elim H.\n  intros.\n  elim H0.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3.\n  intros.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H.\n  apply H2.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a H H0.\n  case (prime_mult_prime a a H0); trivial.\n  apply (prime_mult_intro a (S n')).\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  case (prime_prime_div p a H0); intro.\n  elim H1; intro.\n  elim H2; intro.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  apply (prime_mult_sym (a * p) (p * p)); trivial.\n  apply prime_mult_sym.\n  apply prime_mult_sym.\n  apply prime_mult_sym.\n  apply (pos_mult_sym (a * p) (p * p)); trivial.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros.\n  generalize (pred_prime_prime a).\n  case (prime_mult a p); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\n",
                "context_tokens": 713,
                "proof_start_offset": 5187,
                "proof_end_offset": 5475,
                "proof": "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\nProof.\nintros.\nsplit;try tauto.\nintro d';intro.\nassert (is_gcd d' d' p).\nunfold is_gcd;unfold is_cd.\nsplit;[split;[apply divides_refl | tauto] | tauto].\neapply H0;apply H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;unfold gcd.\n  rewrite <- (gcd_sym (p:=p)).\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  elim H; intro p.\n  elim H1; intros.\n  unfold is_prime in H0.\n  elim H; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  unfold is_prime in H4.\n  elim H4; intros.\n  unfold is_prime in H4.\n  elim H4; intros.\n  apply H4; assumption.\n  unfold is_prime in H4.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  case H6; intros.\n  apply H8; assumption.\n  unfold is_prime in H4.\n  elim H7; intros.\n  elim H8; intros.\n  case H7; intros.\n  elim H9; intros.\n  unfold is_prime in H4.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  apply H9; assumption.\n  unfold is_prime in H4.\n  elim H8; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  applyQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;case (prime_prime p); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  case (gcd_prime p a); trivial.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  rewrite H4.\n  exists x1; split; trivial.\n  rewrite H4.\n  rewrite H4.\n  rewrite H4.\n  rewrite H4.\n  rewrite H4.\n  rewrite H4.\n  reflexivity.\n  rewrite H4.Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  elim H; intros.\n  apply gcd_intro with (1:=p).\n  apply gcd_intro with (1:=p).\n  apply gcd_intro with (1:=p).\n  apply gcd_intro with (1:=p).\n  apply gcd_intro with (1:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (1:=p).\n  apply gcd_intro with (1:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_intro with (2:=p).\n  apply gcd_introQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;intro.\n  case (prime_mult p a a); trivial.\nQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;case (prime_prime (S p) (S p));intros.\n  rewrite H;apply gcd_prime.\n  rewrite div_mod; auto.\nQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;unfold gcd in H.\n  elim H; intro p.\n  elim H0; intros.\n  apply prime_mult_l; auto.\n  elim H1; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H1; intros.\n  apply H1; auto.\n  apply H1; auto.\n  case (H7 p H5); auto.\nQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; case (prime_prime p); intros.\n  elim H0; intros.\n  elim H1; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H1; intros.\n  rewrite H4 in H1.\n  elim (H1 (S p)); trivial.\nQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;intro.\n  elim H0;intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  apply H5; apply H5; apply H5; apply H5; apply H5; apply H5; apply H5;apply H5; apply H6;\n    apply H6; apply H6; apply H6; apply H7; apply H7; apply H7;\n    apply H7; apply H7; apply H8; apply H8; apply H9; apply H9; apply H8;\n    apply H8; apply H8; apply H8; apply H9; apply H8; apply H9;\n    apply H8; apply H8; apply H9; apply H9; apply H8; apply H8; apply H9;\n    apply H8; apply H8; apply H9; apply H9; apply H9; apply H9;\n    apply H8; apply H8; apply H9; apply H9; apply H9; apply H10; apply H10;\n    apply H8; apply H9; apply H8; apply H10; apply H9; apply H8Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;subst.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\n  apply gcd_prime.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 5536,
                "proof_end_offset": 5890,
                "proof": "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\nsplit;intros.\nelim H;intros.\nsplit;try tauto.\nintros.\ncase (eq_nat_dec d 1);intro;try tauto.\ncase (eq_nat_dec d p);intro;try tauto.\nelim (H1 d n n0 H2).\nelim H;intros.\nsplit;try tauto.\nintros;intro.\nelim (H1 a H4);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_intro.\n  destruct (H p).\n  left;apply prime_intro;auto.\n  right;apply prime_intro;auto.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros p H.\n  case (prime_exists (p - p));intro.\n  assert (H0:=H1 p H1 H).\n  rewrite H2;ring.\n  rewrite <- (mult_comm (p * p) (p * p)).\n  rewrite (mult_comm (p * p)).\n  rewrite <- H2;ring.\n  rewrite <- (mult_comm (p * p)).\n  rewrite <- H2; ring.\n  apply le_mult_l.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_minus.\n  apply le_Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_intro;assumption.\n  apply prime_intro;assumption.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_div.\n  intros;apply prime_div.\n  intros;apply prime_div.\n  intros;apply prime_div.\n  intros;apply prime_div.\n  intros;apply prime_div.\n  intros;apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.\n  intros; apply prime_div.Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (H:=H0 p).\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_pos.\n  apply gcd_prime.\n  apply gcd_pos.\n  apply gcd_prime.\n  apply gcd_pos.\n  apply gcd_prime.\n  apply gcd_pos.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_prime.\n  apply gcd_Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;unfold is_gcd;unfold is_prime in H.\n  elim H; intros.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  apply (H5 p).\n  apply (H5 p).\n  apply (H6 p).\n  apply (H6 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  apply (H7 p).\n  applyQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_pos_pos;auto.\n  apply prime_pos_pos;auto.\n  apply prime_neg;auto.\n  apply prime_neg_pos;auto.\n  apply prime_neg_neg;auto.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;rewrite <- H;rewrite <- H0; apply le_refl.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_intro.\n  apply prime_intro.\n  apply H0;apply (pos_div_pos p); assumption.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_intro;intros.\n  elim H;intro p.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H1;intros.\n  elim H2; intros.\n  elim H4; intros.\n  unfold is_prime in H4.\n  elim H4; intros.\n  elim H5; intros.\n  unfold is_prime in H5.\n  elim H5; intros.\n  apply H6; auto.\n  unfold is_prime in H5.\n  elim H5; intros.\n  elim H5; intros.\n  unfold is_prime in H5.\n  elim H5; intros.\n  apply H6; auto.\n  unfold is_prime in H5.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  apply H6; auto.\n  apply H6; auto.\n  elim H6; intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\n",
                "context_tokens": 734,
                "proof_start_offset": 5951,
                "proof_end_offset": 6368,
                "proof": "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\nintro.\ncase (divides_nat n);intro.\nelim s;intros.\nright;intro.\nunfold is_prime in H.\nelim H;intros.\nelim (H1 x);try tauto.\ncase (eq_nat_dec n 1);intro.\nright;unfold is_prime;tauto.\nleft;unfold is_prime.\nsplit;trivial.\nintros.\ncase (eq_nat_dec d 1);try tauto.\ncase (eq_nat_dec d n);try tauto;intros.\nelim (n0 d n3 n2 H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros; case (prime_dec n p);intro.\n  generalize (pos_pos (Pos.max n p) (Pos.max n p) H).\n  destruct (Pos.max_case (Pos.max n p) (Pos.max n p) H0); intro.\n  generalize (pos_pos (Pos.max n p) (Pos.max n p) H).\n  destruct (Pos.max_case (Pos.max n p) (Pos.max n p) H0); intro.\n  generalize (pos_pos (Pos.max n p) (Pos.max n p) H).\n  destruct (Pos.max_case (Pos.max n p) (Pos.max n p) H0); intro.\n  generalize (pos_pos (Pos.max n p) (Pos.max n p) H0); intro.\n  assert (H4:=pos_pos (Pos.max n p) (Pos.max n p) H4).\n  destruct (Pos.max_case (Pos.max n p) (Pos.max n p) H4); intro.\n  generalize (pos_pos (Pos.max n p) (Pos.max nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros n.\n  elim (lt_or_lt n m); auto.\n  intros.\n  elim H; intro.\n  apply (H1 (S n)).\n  apply (H0 (S n)).\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros; case (eq_nat_dec n 1); intro.\n  left.\n  apply (H1 p H1).\n  apply (H2 p).\n  apply (H1 p H1).\n  apply (H1 p).\n  apply (H2 p).\n  apply (H1 p).\n  apply (H2 p).\n  apply (H2 p).\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  simple induction n.\n  intro.\n  elim H; intro.\n  elim H; intro.\n  apply (H1 (S n)).\n  intro.\n  case (eq_nat_dec n d); intro;try tauto.\n  elim (H1 d n0 H2).\n  intro.\n  apply (H1 (S n)).\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros;case (le_or_lt n 0); intro.\n  elim (le_or_lt n 0).\n  assumption.\n  intro d;intro.\n  case (le_or_lt n 0).\n  intro; left.\n  elim (le_or_lt n 0).\n  intro; left.\n  apply H1; assumption.\n  intro; right.\n  apply H1; assumption.\n  intro; right.\n  apply H1; assumption.\n  intro; right.\n  apply H2; assumption.\n  intro; right.\n  apply H1; assumption.\n  intro; left.\n  apply H1; assumption.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim (H (S n)).\n  apply (H (S (S n))).\n  apply (H (S (S (S n))).\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros n; case (prime_dec n 1); intro.\n  apply (H0 n).\n  elim (H n).\n  elim (H (S n)).\n  elim (H (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (S n = S (S n)).\n  intro; absurd (Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  intros; apply (is_prime_intro n).\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H;intros.\n  apply H; tauto.\n  tauto.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros n H.\n  elim H; intros.\n  apply (H (S n) (S n) (S n0) (S n0) (S n0) (S n0) H H0).\n  simpl;auto.\n  intros.\n  elim (H (S n0)).\n  simpl;auto.\n  intros.\n  elim (H (S n0)).\n  simpl;auto.\n  intros.\n  elim (H (S n0)).\n  simpl;auto.\n  intros.\n  elim (H0 (S n)).\n  simpl;auto.\n  intros.\n  elim (H1 (S n0)).\n  simpl;auto.\n  intros.\n  elim H1;auto.\n  intros.\n  elim (H1 (S n0)).\n  simpl;auto.\n  intros.\n  elim (H1 (S n0)).\n  simpl;auto.\n  intros.\n  elim (H1 (S n0)).\n  simpl;auto.\n  intros.\n  elim (H1 (S n0)).\n  simpl;auto.\n  intros.\n  elim (H1 (S n0)).\n  simpl;auto.\n  intros.\n  elim H1;auto.\n  intros.\n  elim (H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ".\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\n",
                "context_tokens": 711,
                "proof_start_offset": 6458,
                "proof_end_offset": 7237,
                "proof": "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\nintro.\napply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\ncase (eq_nat_dec n0 1);try tauto;intro.\ncase (eq_nat_dec n0 0);intro.\nleft;exists 2.\nsplit;[apply is_prime_2 | rewrite e;apply zero_max_div].\ncase (divides_nat n0);intro.\nelim s;intro d;intro.\nelim p;intros.\nelim H2;intros.\nassert (d<n0).\ngeneralize (divides_le n0 d n2 H4);omega.\ncase (prime_dec d);intro.\nleft;exists d;tauto.\nelim (H d H5 n3);try tauto.\nintro.\nelim a;intro q;intro.\nleft;exists q.\nsplit;try tauto.\napply divides_trans with d;try tauto.\nelim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros n.\n  case (not_prime_least n); intro.\n  case (eq_nat_dec n 1); intro.\n  left;apply H.\n  elim H1;intros.\n  unfold is_prime in H.\n  elim H; intros.\n  apply H1.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H1; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  unfold is_prime in H2.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  apply H5.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim (H7 p0 H8); auto.\n  apply H5.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H8; intros.\n  apply H8.\n  unfold is_prime in H0.\n  elim H8; intros.\n  elimQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  case (not_prime_or_prime p n); intro.\n  assert (n0 = 1).\n  apply not_prime_intro; auto.\n  destruct (eq_nat_dec d n0); auto.\n  subst.\n  destruct (eq_nat_dec d n0); auto.\n  subst.\n  right; unfold is_prime;tauto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  case (classic (exists n : nat, n=0 /\\ (exists n : nat, n=0 /\\ n=1 /\\ n=1)).\n  left;split;auto.\n  right;split;auto.\n  intros.\n  case (classic (exists n : nat, n=0 /\\ (exists n : nat, n=0 /\\ n=1 /\\ n=1))).\n  left;split;auto.\n  right;split;auto.\n  intros.\n  case (classic (exists n : nat, n=0 /\\ (exists n : nat, n=0 /\\ n=1 /\\ n=1))).\n  right;split;auto.\n  left;split;auto.\n  left;split;auto.\n  intros.\n  case (classic (exists n : nat, n=0 /\\ (exists n : nat, n=0 /\\ n=1 /\\ n=1)); auto.\n  right;split;auto.\n  intros.\n  case (classic (exists n : nat, n=0 /\\ n=1 /\\ n=1)).\n  left;split;auto.\n  right;split;auto.\n  intros.\n  case (classic (exists n : nat, n=0 /\\ (existsQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros; elim H; auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply (H1 y); auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply (H2 y); auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply H3; auto.\n  apply H1; auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply (H2 y); auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply H3; auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply H4; auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply (H2 y); auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply (H1 y); auto.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  apply (H2 y); auto.\n  apply H3Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  assert (H := IHn n).\n  elim H; clear H; intro p.\n  elim H1; intros.\n  unfold is_prime in H.\n  elim H; clear H; intro p.\n  elim H1; intros.\n  elim (H1 x p).\n  apply H4; auto.\n  apply H1; auto.\n  apply H1; auto.\n  apply H4; auto.\n  apply H4; auto.\n  apply H5; auto.\n  apply H5; auto.\n  apply H5; auto.\n  apply H6; auto.\n  apply H6; auto.\n  apply H7; auto.\n  apply H5; auto.\n  apply H6; auto.\n  apply H5; auto.\n  apply H6; auto.\n  apply H6; auto.\n  apply H5; auto.\n  apply H6; auto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  elim H; intro p; intros.\n  case (eq_nat_dec p 0); intro.\n  apply H1; assumption.\n  intro H2.\n  case (eq_nat_dec p n); intro.\n  apply H2; assumption.\n  intro H3.\n  apply False_ind; apply H3; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  elim H4; intros.\n  case (eq_nat_dec p n); intro.\n  apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4; assumption.\n  intro H4.\n  apply False_ind; apply H4Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros n.\n  case (classic (exists n, n = 1 /\\ n=1 /\\ n=1)).\n  exists n; split.\n  intros.\n  elim H; intros.\n  case (eq_nat_dec n 1); intro.\n  case (eq_nat_dec n 1); intro.\n  left;auto.\n  right;intro.\n  case (eq_nat_dec n 1); intro.\n  left;auto.\n  right;intro.\n  case (eq_nat_dec n 1); intro.\n  right;intro.\n  case (eq_nat_dec n 1); intro.\n  left;auto.\n  right;intro.\n  case (eq_nat_dec n 1);intro.\n  right;intro.\n  case (eq_nat_dec n 1);intro.\n  right;intro.\n  case (eq_nat_dec n 1); intro.\n  right;intro.\n  case (eq_nat_dec n 1); intro.\n  left;auto.\n  right;intro.\n  case (eq_nat_dec n 1);intro.\n  left;auto.\n  right;intro.\n  case (eq_nat_dec n 1);intro.\n  right;introQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  unfold is_prime in H.\n  elim (H 0).\n  left; assumption.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  assumption.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  assumption.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  assumption.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  assumption.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  assumption.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  assumption.\n  right; intro.\n  case (eq_nat_dec n 1); intro.\n  assumption.\n  right; intro.\n  elim (n0 d n1 n2 H4).\n  elim H4; intros.\n  elim H5; intros.\n  unfold is_prime in H4.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  unfold is_prime in H5.\n  elimQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  case (classic (exists n : nat, is_prime n /\\ (n=1))).\n  intro.\n  case H1;intros.\n  exists x.\n  split;auto.\n  intro.\n  apply H2.\n  unfold is_prime in H1.\n  elim (H1 x); auto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  case (classic (exists n : nat, n=0 /\\ p=0 /\\ n=1)).\n  left; assumption.\n  intros.\n  case (classic (exists n : nat, n=1 /\\ n=1)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, n=1 /\\ n=1)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, n=1 /\\ n=1)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, n=1 /\\ n=2)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, n=1 /\\ n=2)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, n=1 /\\ n=2 /\\ n=1)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, n=1 /\\ n=1)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, n=2 /\\ n=1)).\n  right; assumption.\n  intros.\n  case (classic (exists n : nat, nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\nLemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intro.\n  apply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\n  case (eq_nat_dec n0 1);try tauto;intro.\n  case (eq_nat_dec n0 0);intro.\n  left;exists 2.\n  split;[apply is_prime_2 | rewrite e;apply zero_max_div].\n  case (divides_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\n",
                "context_tokens": 710,
                "proof_start_offset": 7333,
                "proof_end_offset": 8614,
                "proof": "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\nintros n p H.\napply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\ncase (divides_dec n0 p);intro.\ngeneralize (quo_is_quo n0 p d);intro.\nelim (H0 (quo n0 p d)).\nintro m;intros.\nexists (m+1).\nelim p0;intros.\nelim H3;intros.\nrewrite H5 in H2;rewrite mult_assoc in H2.\nrewrite plus_comm.\nsplit;simpl.\nexists x;trivial.\nrewrite plus_comm;simpl.\nrewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\nelim H6;intros.\nrewrite H2 in H7.\nassert (p<>0).\nintro.\nrewrite H8 in H.\napply not_prime_zero;trivial.\nassert ((power p m)*x=(power p m)*p*x0).\napply mult_lemma6 with p;trivial.\nrewrite mult_assoc;rewrite H7;ring.\nrewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\napply H4.\nrewrite plus_comm;simpl.\nexists x0;trivial.\nrewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\nintro.\napply H1;rewrite H2;rewrite H3;trivial.\nelim H.\nintros.\ndestruct p;omega.\nintro;apply H1.\nrewrite H2;rewrite H3;ring.\nexists 0;simpl.\nsplit.\napply one_min_div.\nrewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (eq_nat_dec p n); intro.\n  elim H; intros.\n  elim (H1 p); trivial.\n  right; intro.\n  elim (H1 p); trivial.\n  right; intro.\n  elim H2; intros.\n  elim (H2 p); trivial.\n  elim (H1 p); trivial.\n  right; intro.\n  elim (H1 p); trivial.\n  elim H2; trivial.\n  elim (H1 p); trivial.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (eq_nat_dec n0 (nat_of_P p)).\n  left;apply is_prime_intro.\n  right;intro.\n  unfold is_prime in H0.\n  elim H0; intros.\n  case (eq_nat_dec n0 0); intro.\n  rewrite H3 in H0; discriminate.\n  apply H0.\n  intro.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H0.\n  applyQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  destruct (classic (exists p : nat, m=p /\\ (p=0 /\\ (p=0 /\\ p=0)))).\n  destruct (exists_nat p).\n  right.\n  split;intros.\n  apply (lt_wf_ind (fun n:nat => (is_prime n)->(S n))); auto.\n  right.\n  destruct (H1 (p=1 /\\ p=1 /\\ (p=0 /\\ (p=0 /\\ p=1))).\n  right.\n  destruct (exists_nat p).\n  left.\n  destruct (H2 p); auto.\n  right.\n  destruct (H1 (p=1 /\\ p=1 /\\ p=1)).\n  left.\n  destruct (H2 (p=1 /\\ p=1 /\\ p=1)).\n  left.\n  destruct (H3 p); auto.\n  right.\n  destruct (H2 p); auto.\n  right.\n  destruct (H1 (p=1 /\\ p=1 /\\ p=1)).\n  right.\n  destruct (H2 p); auto.\n  right.\n  destruct (H4 p); auto.\n  left.\n  destruct (H1 (p=1 /\\ p=0 /\\ p=Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nintros.\nassert (H1 := H1 (S n)).\nassert (H2 := H2 (S n)).\nassert (H3 := H3 (S n)).\nassert (H4 := H4 (S n)).\nassert (H4 := H4 (S n)).\nassert (H5 := H4 (S n)).\nassert (H5 := H5 (S n)).\napply H5.\nassert (H6 := H5 (S n)).\nassert (H7 := H5 (S n)).\napply H5.\nassert (H7 := H5 (S n)).\napply H5.\napply H6.\nassumption.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nintros.\ngeneralize (le_refl n).\ninduction (le_refl n).\nleft;intros.\nelim H;intros.\nrewrite <- (S_n_O p).\nrewrite H; rewrite H0.\nrewrite <- (S_n_O p).\nrewrite <- (S_n_O p).\nrewrite H; auto.\nrewrite <- (S_n_O p).\nrewrite H; auto.\nrewrite <- (S_n_O p).\nrewrite H; auto.\nrewrite <- (S_n_O p).\nrewrite <- (S_n_O p).\nrewrite <- (S_n_O p).\nrewrite <- (S_n_O p).\nrewrite <- (S_n_O p).\nrewrite <- (S_n_O p).\nrewrite H; auto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  destruct (eq_nat_dec n 0).\n  right;intros.\n  elim H;intros.\n  elim (H1 x).\n  left;exists 1.\n  split;auto.\n  elim H2;auto.\n  elim H2;auto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intro.\n  elim (classic (exists n : nat, m = n /\\ n=0)).\n  intro.\n  elim H; intros.\n  case (eq_nat_dec n0 n).\n  left;exists n0.\n  split; auto.\n  case (eq_nat_dec n0 n); intro.\n  elim H2; intros.\n  elim H3; intros.\n  right; intro.\n  unfold is_prime in H0.\n  elim H3; intros.\n  elim H4; intros.\n  elim (H1 x0); intros.\n  apply (H2 x0); assumption.\n  unfold is_prime in H1.\n  elim H3; intros.\n  elim (H3 x1); intros.\n  elim H4; intros.\n  apply (H4 x1); assumption.\n  unfold is_prime in H1.\n  elim H1; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim (H1 x1); intros.\n  apply (H4 x1); assumption.\n  unfold is_prime in H0.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  elim (H1 x);auto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (eq_nat_dec p n); intro.\n  left;apply is_prime_intro; auto.\n  right;intro.\n  apply (H1 p).\n  left;apply is_prime_intro; auto.\n  right;intro.\n  apply (H1 p).\n  right;intro.\n  elim (H1 p); auto.\n  left; left; auto.\n  right; intro.\n  apply (H2 p).\n  right; intro.\n  apply (H2 p).\n  left; right; intro.\n  apply (H2 p).\n  right; intro.\n  apply (H2 p).\n  left; left; auto.\n  right; intro.\n  apply (H2 p).\n  right; intro.\n  apply (H2 p).\n  left; left; auto.\n  right; intro.\n  apply (H2 p).\n  left; right; intro.\n  apply (H2 p).\n  left; auto.\n  right; intro.\n  apply (H2 p).\n  right; intro.\n  apply (H2 p).\n  left; left; auto.\n  right; intro.\n  apply (H2 p).\n  left; right; intro.\n  applyQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\nintros.\nassert (n<>0).\n  generalize (nat_div_mod_eq _ _ _ H).\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\nLemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros n p H.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\n  case (divides_dec n0 p);intro.\n  generalize (quo_is_quo n0 p d);intro.\n  elim (H0 (quo n0 p d)).\n  intro m;intros.\n  exists (m+1).\n  elim p0;intros.\n  elim H3;intros.\n  rewrite H5 in H2;rewrite mult_assoc in H2.\n  rewrite plus_comm.\n  split;simpl.\n  exists x;trivial.\n  rewrite plus_comm;simpl.\n  rewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\n  elim H6;intros.\n  rewrite H2 in H7.\n  assert (p<>0).\n  intro.\n  rewrite H8 in H.\n  apply not_prime_zero;trivial.\n  assert ((power p m)*x=(power p m)*p*x0).\n  apply mult_lemma6 with p;trivial.\n  rewrite mult_assoc;rewrite H7;ring.\n  rewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\n  apply H4.\n  rewrite plus_comm;simpl.\n  exists x0;trivial.\n  rewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\n  intro.\n  apply H1;rewrite H2;rewrite H3;trivial.\n  elim H.\n  intros.\n  destruct p;omega.\n  intro;apply H1.\n  rewrite H2;rewrite H3;ring.\n  exists 0;simpl.\n  split.\n  apply one_min_div.\n  rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.\n\n(** if n>1 then there is a prime number p and two integers m and q with m>0 and q<n such that n=p^m*q and gcd(p,q)=1 *)\n",
                "context_tokens": 686,
                "proof_start_offset": 8736,
                "proof_end_offset": 10293,
                "proof": "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\nintros.\ncase (prime_dec n);intro.\nexists n;exists 1;exists 1;simpl.\nsplit;try tauto.\nsplit;try omega.\nsplit;try ring.\nsplit;try omega.\napply gcd_sym;apply gcd_one.\nelim (not_prime_impl_prime_divides n n0);intro;try tauto.\nelim a;intro p;intro.\nelim p0;intros.\nelim (nat_factor n p H1).\nintro m;intro.\nelim p1;intros.\nexists p;exists m;exists (quo n (power p m) H3).\nsplit;trivial.\nsplit.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nsplit.\napply (quo_is_quo n (power p m) H3).\ngeneralize (gcd_is_gcd p (quo n (power p m) H3));intro.\nassert ((gcd p (quo n (power p m) H3))=1).\ncase (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\napply gcd_sym;trivial.\nintro.\nrewrite H6 in H5;elim H5;intros.\nelim H7;intros.\nelim H4;rewrite plus_comm;simpl.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nelim H10;intros.\nrewrite H12 in H11.\nexists x;rewrite H11;ring.\nrewrite H6 in H5;trivial.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nsplit;trivial.\nrewrite H7;rewrite mult_comm;apply mult_lemma3.\nintro.\napply H;rewrite H7.\nrewrite H8;ring.\nred;apply power_lt.\ndestruct p.\nelim (not_prime_zero H1).\ndestruct p;try omega.\nelim H1;tauto.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  simple induction n.\n  intro m; intros.\n  elim (lt_wf_ind m n).\n  left; exists 0.\n  split; trivial.\n  elim (lt_wf_ind m n).\n  left; exists 0.\n  split; trivial.\n  elim (lt_wf_ind m n).\n  right; exists 0.\n  split; trivial.\n  elim H0; intros.\n  rewrite H1 in H1; rewrite (mult_comm m n) in H1.\n  apply H1.\n  assumption.\n  rewrite <- H1; assumption.\n  apply le_S_n.\n  right; exists 0.\n  split; trivial.\n  elim H0; intros.\n  rewrite H1 in H1; rewrite (mult_comm m n) in H1.\n  apply H1.\n  assumption.\n  rewrite <- H1; assumption.\n  apply le_S_n.\n  right; exists 0.\n  split; trivial.\n  elim H0; intros.\n  rewrite H1 in H1; rewrite (mult_comm m n) in H1.\n  apply H1.\n  assumption.\n  rewrite <- H1; assumption.\n  apply le_S_n.\n Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n p.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:nat | n<>0}) (fun n:nat => n <> 0 -> {m:natQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (n=0)/\\(n=0)/\\(m>0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)->(n=1)/\\(n=0)/\\(n=0)->(n=0))).\n  intros n p H.\n  case (eq_nat n0 p).\n  left; exists p; auto.\n  right; exists p; auto.\n  right; exists p; auto.\n  right; exists p; auto.\n  right; exists p; auto.\n  right; exists p; auto.\n  right; exists p; auto.\n  right; exists p; auto.\n  right; exists p; auto.\nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nintros n p H.\napply (lt_wf_ind (fun n:nat => n <> 0 -> {q:nat & {q:nat | (m<0)/(n>0)))}) with (q:=p).\nintros n p H.\napply (lt_wf_ind (fun n:nat => n <> 0 -> {q:nat | (m<0)=(n<0))))%nat).\nintros n p H.\napply (lt_wf_ind (fun n:nat => n <> 0 -> {q:nat | (n<>0)->(n<0)))%nat).\nintros n H.\napply (lt_wf_ind (fun n:nat => n <> 0 -> {q:nat | (n<>0)))%nat).\nintros n0 H1.\napply (lt_wf_ind (fun n:nat => n <> 0 -> {q:nat | (n<>0)))%nat).\nintros n0 H2.\napply (lt_wf_ind (fun n:nat => n <> 0 -> {q:nat | (n=0)->(n<0)))%nat).\nintros n0 H3.\napply (lt_wfQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_ind (fun n:nat => n <> 0 -> {n=0}) (fun n:nat => n <> 0 -> {n=1}) (fun n:nat => n <> 0 -> {n=1}) (fun n:nat => n <> 0) (fun n:nat => n <> 0 -> {n=0}) (fun n:nat => n <> 0 -> {n=0}+{n<>0}) (fun n:nat => n <> 0 -> {n=0}) (fun n:nat => n <> 0 -> {n=1}) (fun n:nat => n <> 0 -> {n=1}) (fun n:nat => n <> 0 -> {n=0}+{n<>0}) (fun n:nat => n <> 0 -> {n=1}) (fun n:nat => n <> 0 -> {n=0}+{n<>0}) (fun n:nat => n <> 0 -> {n=0}+{n<>0}) (fun n:nat => n <> 0 -> {n=1}+{n=0}) (fun n:nat => n <> 0 -> {n=0Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\nintros n p H.\nassert (H1: forall n, n<>0 -> {n=1}+{n<>1}.\nintros n p H1.\napply (lt_wf_rec n (fun n:nat => n <> 0 -> {n=1}).\nintros n p H2.\ncase (le_lt_eq_dec p p); intros.\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (SQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=0)/\\(m>0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(m=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(m=0)/\\(n=0)/\\(n=0*(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0=(m=0)/\\(n=0)/\\(n=0)/\\(n=0)/\\(n=0=(n=0)*(m=0)/\\(n=0)/\\(n=0)=(n=0))/\\(n=0)/\\(n=0)/\\(n=0)=(n=0/\\n=0)/\\(n=0)/\\(n=0)=0).\n  intros.\n  case (le_or_lt n (fun n:nat => n <> 0 -> {n=0}+{n}) ; introsQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p.\n  case (eq_nat_dec n p); intro.\n  rewrite (H _ H1) in H.\n  generalize (H1 (refl_equal n)).\n  rewrite H1 in H.\n  generalize (H1 (refl_equal n)).\n  destruct (eq_nat_dec n p); intro.\n  subst.\n  elim H1; intro.\n  elim H2; intro.\n  rewrite H3 in H1; rewrite (H2 n) in H1.\n  apply H1; auto.\n  apply H2; auto.\n  apply H1; auto.\n  elim H1; intro.\n  rewrite H3 in H1; rewrite (H2 n) in H1.\n  apply H1; auto.\n  elim H1; intro.\n  rewrite H3 in H1; rewrite (H2 n) in H1.\n  apply H1; auto.\n  rewrite plus_comm; simpl; rewrite plus_comm; simpl; auto.\nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m:nat | (Z.succ n m) /\\ m <> 0}).\n  intros n p H0.\n  elim H0; intro.\n  elim H2; intros.\n  apply (H1 n p).\n  left; assumption.\n  right; apply H1.\n  right; assumption.\n  left; apply H1.\n  right; apply H1.\n  right; assumption.\n  right; assumption.\n  right; apply H1.\n  right; assumption.\n  right; assumption.\n  left; apply H1.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  left; apply H1.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  left; apply H1.\n  right; assumption.\n  left; assumption.\n  right; assumption.\n  right; assumption.\nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\ninduction n.\nexact (fun n:nat => {m:nat | (n >= 0)%N}).\nexact (fun n:nat => {m:nat | (n >= 0)%N}) (fun n:nat => n <> 0}).\nexact (fun n:nat => {m:nat | (n >= 0)%N}) (fun n:nat => n <> 0)).\nexact (fun n:nat => {m:nat | (n >= 0)%N}) (fun n:nat => n <> 0)).\nexact (fun n:nat => {m:nat | (n >= 0)%N}) (fun n:nat => n <> 0)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " omega.\n  apply gcd_sym;apply gcd_one.\n  elim (not_prime_impl_prime_divides n n0);intro;try tauto.\n  elim a;intro p;intro.\n  elim p0;intros.\n  elim (nat_factor n p H1).\n  intro m;intro.\n  elim p1;intros.\n  exists p;exists m;exists (quo n (power p m) H3).\n  split;trivial.\n  split.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  split.\n  apply (quo_is_quo n (power p m) H3).\n  generalize (gcd_is_gcd p (quo n (power p m) H3));intro.\n  assert ((gcd p (quo n (power p m) H3))=1).\n  case (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\n  apply gcd_sym;trivial.\n  intro.\n  rewrite H6 in H5;elim H5;intros.\n  elim H7;intros.\n  elim H4;rewrite plus_comm;simpl.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  elim H10;intros.\n  rewrite H12 in H11.\n  exists x;rewrite H11;ring.\n  rewrite H6 in H5;trivial.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  split;trivial.\n  rewrite H7;rewrite mult_comm;apply mult_lemma3.\n  intro.\n  apply H;rewrite H7.\n  rewrite H8;ring.\n  red;apply power_lt.\n  destruct p.\n  elim (not_prime_zero H1).\n  destruct p;try omega.\n  elim H1;tauto.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  trivial.\nQed.\n\n(** this compute p1^n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\n",
                "context_tokens": 720,
                "proof_start_offset": 10997,
                "proof_end_offset": 12081,
                "proof": "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintro.\ncase (eq_nat_dec n 0);intro.\nright;trivial.\ncase (eq_nat_dec n 1).\nintro;left;exists (nil (A:=nat*nat)).\nsplit;[apply nil_is_wf | simpl;trivial].\ngeneralize n0.\napply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\nelim (nat_factor_prime n1 H0 H1).\nintro p;intro.\nelim p0;intro m;intro.\nelim p1;intro q;intro.\nelim p2;intros.\nelim H3;intros.\nelim H5;intros.\nelim H7;intros.\ncase (eq_nat_dec q 1);intro.\nleft;exists (cons (p,m) nil);simpl;rewrite e in H6.\nsplit;trivial.\napply cons_is_wf;auto;try (apply nil_is_wf).\nunfold rel_prime;simpl;rewrite e in H8;trivial.\nassert (q<>0).\nintro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\nelim (H q H9 H10 n2).\nintro.\nelim a;intro l;intro.\nelim p3;intros.\nleft;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\napply cons_is_wf;auto.\nrewrite <- H12;unfold rel_prime;trivial.\nintro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\n  intros; apply One_is_wf; trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninduction l.\nsimpl.\ninductionQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction l.\ntrivial.\nsimpl.\ndestruct (hd_is_wf l).\ntrivial.\ndestruct (hd_is_wf (fun n => is_wf (S n) (S (S (S (S (S n))))) as [H1 H2].\nrewrite H1 in H2.\nrewrite H2 in H2.\nrewrite <- H2 in H2.\nsimpl.\nassert (H3 : (S n - S (S (S (S (S (S (S n))))) = S (S (S (S (S (S (S n))))) + S (S (S (S (S n)))) + S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) + S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction l; simpl; intros; auto.\ndestruct (Nat.eq_dec (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S(S(S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction l;intros.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napply is_wf_induction.\nsimpl.\napplyQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\nreflexivity.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\ninduction l.\ntauto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n.\nsimpl; trivial.\nsimpl; rewrite <- IHn.\nsimpl; rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHn.\nsimpl;rewrite <- IHnQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n; simpl; intros.\ndestruct l; [left|right]; trivial.\ndestruct l; [left|right]; trivial.\ndestruct l; [right|right]; trivial.\ndestruct l; [right|right]; trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction l; simpl; intros; auto.\ndestruct l; simpl; trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n  simple induction l.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n  simpl; intros.\n  apply list_le; auto.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 12199,
                "proof_end_offset": 12539,
                "proof": "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\ninduction l;simpl;try tauto.\nintro.\ncase H;intro.\ndestruct a.\nrewrite <- H0;simpl.\nexists (refactor l);trivial.\ndestruct a.\nelim (IHl H0);intros.\nrewrite H1.\nexists ((power n n0)*x0);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intro.\n  case (eq_nat_dec x 0);intro.\n  left;trivial.\n  left;trivial.\n  right;trivial.\n  left;trivial.\n  left;trivial.\n  right;trivial.\n  right;trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\ninduction l;simpl;intros.\napply incl_sym.\napply incl_sym.\napply incl_trans with (existT (fun n:nat => n<>0 -> n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:nat => n=0) (fun m:Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\ninduction l;simpl;trivial.\nrewrite <- (app_comm (fun p n:nat => n<>0 -> n<>0 -> exists l, snd (snd p) = (snd p) /\\ (p=0)).\ninduction l;simpl;trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\ninduction l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;simpl.\ndestruct l;Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nintro.\ncase (eq_nat_dec x 0);intro.\nright;trivial.\ndestruct (eq_nat_dec x 0);intro.\nright;trivial.\nright.\ndestruct (eq_nat_dec x 0);intro.\nright;trivial.\nright.\ndestruct (eq_nat_dec x 0);intro.\nright;trivial.\ndestruct (eq_nat_dec x 0);intro.\nright;trivial.\nright;trivial.\nright.\ndestruct (eq_nat_dec x 0);intro.\nright;trivial.\nright;trivial.\nright.\ndestruct (eq_nat_dec x 0);intro.\nright;trivial.\nright;trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\ninduction l;simpl;intros.\nsimpl;auto.\nsimpl;auto.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros.\n  induction l;simpl;apply length_nil.\n  apply (lt_wf_ind n (fun n:nat => n<>0 -> n <> 0 -> {l:list (nat*nat)) | l = 0 -> False).\n  intro;case (eq_nat_dec x 0);intro.\n  left;trivial.\n  left;trivial.\n  right;trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_is_wf.\nintros.\ninduction l.\nsimpl.\napply app_nil_Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nintros.\napply factor_perms;simpl;trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nintro x;case (eq_nat_dec x 0);intro.\nleft;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\n",
                "context_tokens": 704,
                "proof_start_offset": 12623,
                "proof_end_offset": 13304,
                "proof": "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\ninduction l;simpl;intros.\nassert (p=1).\napply divides_antisym;trivial.\napply one_min_div.\nrewrite H2 in H;elim H;tauto.\ndestruct a.\ncase (divides_dec (power n n0) p);intro.\ngeneralize (prime_power p n0 n H d);intro.\nassert (n=p).\ninversion H0.\nelim H6.\nintros.\nelim H;intros.\ncase (H11 p H2);try tauto;try omega.\nexists n0;rewrite <- H3;left;trivial.\ninversion H0.\nelim (IHl H H7).\nintros;exists x;tauto.\napply gauss with (power n n0);trivial.\napply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case (eq_nat_dec (nat*nat*nat) (fun m:nat => n=m+n+n+m+m+n)).\n  intro p; rewrite <- (minus_n_O p);simpl;auto.\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].\n  destruct p as [p Hp].Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  destruct (In_dec p l).\n  left;trivial.\n  destruct a.\n  destruct p.\n  rewrite <- H.\n  destruct a.\n  rewrite <- H;simpl.\n  exists (S p);trivial.\n  destruct p.\n  rewrite <- H;simpl.\n  exists (S p);trivial.\n  destruct p.\n  rewrite <- H.\n  destruct a.\n  rewrite <- H.\n  destruct p;trivial.\n  apply nth_error_In; auto.\n  apply H1.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case (eq_nat_dec n 0);intro.\n  left;exists (S (S (S n0*nat))).\n  split;trivial.\n  destruct (H0 n).\n  left.\n  exists ((power n0)*x0);ring.\n  split;trivial.\n  apply H;apply le_n_S;trivial.\n  apply le_S;trivial.\n  apply le_trans with (S (S (S (S n0))).\n  apply le_trans with (S (S (S (S n0)))).\n  apply le_n_S;trivial.\n  apply le_S;trivial.\n  apply le_n_S;trivial.\n  apply le_trans with (S (S (S (S n0))).\n  apply le_n_S;trivial.\n  apply le_trans with (S (S (S n0))).\n  apply le_n_S;trivial.\n  apply le_n_S;trivial.\n  apply le_S;trivial.\n  apply le_trans with (S (S (S (S n0)))).\n  apply le_n_S;trivial.\n  apply le_S;trivial.\n  apply le_nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case (eq_nat_dec p 0);intro.\n  left;trivial.\n  apply (lt_wf_ind (fun n:nat => n=0 /\\ n=0)).\n  right;trivial.\n  apply (lt_wf_ind (fun n:nat => n=0 /\\ n=0)).\n  right;trivial.\n  apply (lt_wf_ind (fun n:nat => n=0 /\\ n=0)).\n  right;trivial.\n  apply (lt_wf_ind (fun n:nat => n=0 /\\ n=0)).\n  right;trivial.\n  apply (lt_wf_ind (fun n:nat => n=0 /\\ n=0)).\n  right;trivial.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case (eq_nat_dec p n0);intro.\n  left;exists (S m);simpl;rewrite plus_comm;trivial.\n  right;trivial.\n  right;trivial.\n  right;trivial.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  unfold p, q,q,q,m.\n  intros.\n  destruct (H (S m)).\n  destruct (H0 (S m)).\n  left.\n  exists (S m);trivial.\n  destruct H0.\n  destruct (H0 (S m)).\n  left.\n  exists (S m);trivial.\n  destruct H.\n  rewrite <- H0;simpl;tauto.\n  right.\n  destruct (H (S m)).\n  left.\n  exists (S m);trivial.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  destruct (le_lt_eq_dec p p).\n  destruct (le_lt_eq_dec p p).\n  destruct (le_lt_eq_dec p p).\n  left.\n  apply (le_lt_trans _ _ (le_S_n _ _ H)).\n  apply (le_lt_trans _ _ (le_S_n _ _ H)).\n  apply (le_lt_trans _ _ (le_S_n _ _ H)).\n  apply (le_S_n _ _ H).\n  apply (le_lt_trans _ _ (le_S_n _ _ H)).\n  apply (le_lt_trans _ _ (le_S_n _ _ H)).\n  apply (le_S_n _ _ H).\n  apply (le_S_n _ _ H).\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case (eq_nat_dec p n);intro.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite (plus_comm (pred (nat*nat))).\n  apply H.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\ninduction p;simpl;try tauto.\ndestruct a.\nrewrite <- H;simpl.\nexists (S p);trivial.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case H;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  case (eq_nat_dec p n0);intro.\n  right;trivial.\n  apply cons_is_wf;auto.\n  right;trivial.\n  apply cons_is_wf;auto.\n  apply incl_trans with (S (pred (nat * nat)) (pred (nat * nat))).\n  apply incl_add_r.\n  apply incl_tl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl_tl.\n  apply incl_tl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl.\n  apply incl_tl_tl_tlQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\n",
                "context_tokens": 714,
                "proof_start_offset": 13376,
                "proof_end_offset": 13646,
                "proof": "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;simpl;try tauto.\nintros;destruct a.\ninversion H0.\ncase (in_inv H);intros.\ninversion H8;rewrite <- H10;rewrite <- H11;try tauto.\napply IHl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros.\n  assert (H1 := IHn _ _ H1).\n  destruct (eq_nat_dec n 0).\n  subst.\n  rewrite H1.\n  apply H2.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H0.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_prime.\n  apply H1.\n  apply in_factor_Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros.\n  induction (infSplit_dec p n).\n  left;apply (infSplit_pop p n);trivial.\n  right; apply (infSplit_tailCP (S n) (S n));trivial.\n  right; apply (infSplit_tailCP (S n) (S n));trivial.\n  left;apply (infSplit_tailCP (S n) (S n));trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  unfold is_wf;simpl;intros.\n  assert (n=0).\n  apply (is_wf (fun p n:nat => is_wf (snd p) n)).\n  apply is_wf_ind;auto.\n  apply is_wf_ind;auto.\n  apply is_wf_ind;auto.\n  apply is_wf_ind;auto.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  simple induction l.\n  simpl;intros.\n  inversion H.\n  simpl in H.\n  destruct (In_dec (p,n) l).\n  left.\n  rewrite H;simpl;rewrite e.\n  exists (pos rmulmkposreal (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_exist (pos_alt (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S (S (S (S (S (S(S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros; elim (le_or_lt l n).\n  intros.\n  case (le_lt_or_eq _ _ H); intros.\n  apply le_lt_trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros.\n  inversion H.\n  simpl in H.\n  apply (in_or_eq H).\n  apply in_or_pos_or_pos.\n  rewrite H; simpl.\n  exists (S p).\n  split;trivial.\n  apply H.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intro l.\n  induction  l as [| p l];simpl; try tauto.\n  simpl.\n  case H; intro.\n  elim p;intros.\n  elim H1; intro.\n  elim p;intros.\n  elim (H1 p); trivial.\n  elim H2; intro.\n  elim p0; intros.\n  elim (H2 p); trivial.\n  elim (H3 p); trivial.\n  elim (H4 p); trivial.\n  elim (H5 p); trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;simpl;intros.\ncase H;intros.\nrewrite H1;simpl.\nexists (S n).\napply lt_O_n;auto.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  apply (H2 n).\n  destruct (H1 p) as [p [q [H1 H2]].\n  generalize (pos_exist_prime p n H1);intro.\n  generalize (pos_exist_prime p n H2);intro.\n  elim H; intros.\n  elim H6.\n  intros.\n  destruct (H3 p).\n  generalize (pos_exist_prime p n H1);intro.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  apply (H4 (S n0) (S n0) (S n0) H1).\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8; intros.\n  elim H8;Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  intros;apply (pos_not_exists (p,n)).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists (p,n));apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists n).\n  apply (pos_not_exists nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ";trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 13716,
                "proof_end_offset": 14282,
                "proof": "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\ninduction l;simpl;intros;try tauto.\ndestruct a.\ninversion H0;case (in_inv H);intro.\nrewrite H8 in H7;simpl in H7.\nelim (in_wf ((n0,n1)::l) p n H);trivial;intros.\nelim (mult_rel_prime q (power p n) (refactor l) H7);intros.\napply rel_prime_sym;apply power_rel_prime with n;trivial.\napply (IHl p n q m);trivial.\napply cons_is_wf;trivial.\ninversion H6;trivial.\nsimpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;try tauto.\n  intros;induction  l as [| a l Hrec].\n  simpl; tauto.\n  intros; destruct a.\n  case (H2 p H2); try tauto; try tauto.\n  case (H2 p H2); try tauto; try tauto.\n  simpl; tauto.\n  intros; elim H2; intros.\n  case (H2 p H2); try tauto; try tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\nintro.\ndestruct a.\ndestruct n.\ninversion H.\ndestruct a.\ndestruct n.\ndestruct p.\nsimpl in H0;inversion H0.\ndestruct a.\ndestruct n0.\ndestruct p.\ndestruct n0.\ndestruct p.\ndestruct (IHn p (S n0)) as (m,H3).\nsimpl in H3.\ninversion H3.\ndestruct (IHn p (S m0)) as (m,H4).\nsimpl in H4.\ninversion H4.\ndestruct (IHm p (S m0)) as (m,H4).\nsimpl in H4.\ninversion H4.\ndestruct (IHm p (S m)) as (m,H4).\nsimpl in H4.\ninversion H4.\ndestruct (IHm p (S m)) as (m,H4).\nsimpl in H4.\ninversion H4.\ndestruct (IHm p (S m)) as (m,H4).\nsimpl in H4.\ninversion H4.\ndestruct (IHm p (S m)) as (m,H4).\nsimpl in H4.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\n  intros;destruct a.\n  rewrite <- H0;simpl;auto.\n  intros; destruct a.\n  rewrite <- H0;simpl;auto.\n  apply IHl;trivial.\n  intros;destruct a.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n  intros; destruct b.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H1;simpl;auto.\n  intros;destruct b.\n  rewrite <- H1;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H1;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n  intros;destruct b.\n  rewrite <- H0;simpl;auto.\n Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\nintros;inversion H0.\ninversion H1.\ncase (in_inv H0);intros.\nrewrite <- H0;simpl.\nexists (S p);simpl;auto.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\nintros;destruct a.\ninversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros; inversion H.\nintros;inversion H.\nintros; inversion H.\nintros; inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros;inversion H.\nintros; inversion H.\nintros; inversion H.\nintros;inversion H.\nintros;Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  rewrite <- H0;simpl.\n  exists (S m);trivial.\n  exists (S m);trivial.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;try tauto.\n  intros; destruct a.\n  apply (IHp (p,m));trivial.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply (rel_prime_inv H).\n  simpl.\n  apply (rel_prime_intro H0).\n  simpl.\n  apply (rel_prime_intro H0).\n  simpl.\n  apply (rel_prime_intro H1).\n  simpl.\n  apply (rel_prime_intro H1).\n  simpl.\n  apply (rel_prime_intro H1).\n  simpl.\n  apply (rel_prime_intro H3).\n  simpl.\n  apply (rel_prime_intro H3).\n  simpl.\n  apply (rel_prime_intro H4).\n  simpl.\n  apply (rel_prime_intro H4).\n  simpl.\n  apply (rel_prime_intro H4).\n  simpl.\n  apply (rel_prime_intro H4).\n  simpl.\n  apply (rel_prime_intro H4).\n  simpl.\n  apply (rel_prime_intro H4).\n  simpl.\n  apply (rel_prime_intro H4).\n  simpl.\n  apply (rel_prime_intro H5).\n  simpl.\n  apply (rel_prime_intro H5).\n  simpl.\n  apply (relQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\nintros;inversion H.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;try tauto.\n  intros;exists (S(q,m)).\n  apply (le_lt_trans (S (S (S n))).\n  apply (le_lt_trans (S (S (S n))).\n  apply S_le_n.\n  apply IHn.\n  apply le_trans with (S (S (S n))).\n  apply le_S_n;apply le_S_n;apply le_S_n;apply le_trans with (S (S n)).\n  apply le_S_n;apply le_S_n;apply le_trans with (S (S n)).\n  apply le_S_n;apply le_S_n;apply le_trans with (S (S n)).\n  apply le_S_n;apply le_S_n;apply le_trans with (S (S n)).\n  apply le_S_n;apply le_S_n;apply le_trans with (S (S n))).\n  apply le_S_n;apply le_S_n;apply le_trans with (S (S n)).\n  apply le_S_n;apply le_S_n;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 14570,
                "proof_end_offset": 14965,
                "proof": "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\ninduction l;intro.\napply nil_is_pwd.\ndestruct a.\ninversion H.\napply cons_is_pwd;auto.\nintros;intro.\nassert (rel_prime n n).\neapply rel_prime_wf;[apply H7 | apply H].\ngeneralize (gcd_refl n);intro.\nunfold rel_prime in H8.\nassert (1=n).\neapply gcd_unique;eauto.\nrewrite <- H10 in H3;elim H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0.\n  case (in_inv H);intro.\n  generalize (in_inv H0);intro.\n  elim H0;auto.\n  apply IHl.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros.\n  inversion H.\n  apply in_cons_iff in H.\n  destruct H.\n  generalize (lt_nat_of_P p n H);intro.\n  rewrite H1 in H0.\n  apply (lt_irrefl (S (S (S n)))).\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  apply in_seq_iff in H.\n  destruct H as [H | [H | H]].\n  case (in_inv H);intros.\n  apply in_or_app;apply H0.\n  apply in_or_app;apply H0.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H0.\n  apply in_or_app; apply H0.\n  apply in_or_app; apply H0.\n  apply in_or_app; apply H0.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H0.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_or_app; apply H.\n  apply in_Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros;try tauto.\ndestruct a.\ninversion H0.\ninversion H0.\ndestruct a.\ninversion H.\napply IHl.\napply H.\napply IHl.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;try tauto.\napply list_forall2_correct;apply H.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  case (in_inv H);intros.\n  destruct a.\n  case (in_inv H0);intro.\n  rewrite H8 in H8;simpl in H8.\n  inversion H8;rewrite <- H8;rewrite <- H9;simpl;trivial.\n  apply (IHn p n0);trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  case (in_inv H);intros.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_or_eq.\n  apply in_or_app_orQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H.\n  simpl in *.\n  destruct (in_inv H0).\n  inversion H.\n  apply IHl.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H2.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_or_app.\n  apply H1.\n  apply in_orQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  apply (in_not_pwd (p,n) (pos:=pos));trivial.\n  apply (in_not_pwd (p,n) (pos:=pos));trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  unfold is_pinv.\n  intros.\n  destruct l.\n  apply In_correct.\n  apply is_pinv.\n  trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\n",
                "context_tokens": 694,
                "proof_start_offset": 15062,
                "proof_end_offset": 15834,
                "proof": "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\ninduction l;simpl;intros;try tauto.\ncase H3;intro.\nrewrite H4 in H2.\nrewrite H4 in H1;inversion H1.\ngeneralize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\nrewrite mult_comm in H2.\ngeneralize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\napply power_divides_power with p;trivial.\ndestruct p.\nelim (not_prime_zero H8).\nelim H8;omega.\ndestruct a.\ninversion H1.\napply IHl;trivial.\napply gauss with (power n0 n1);trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\napply (rel_prime_wf l p m n0 n1);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H.\n  destruct a.\n  inversion H0.\n  simpl in H1.\n  apply IHl;trivial.\n  simpl in H1.\n  apply IHn;trivial.\n  simpl in H1.\n  apply IHn;trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0.\n  apply (IHl p (succ n) (pred m) (succ n)).\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros;simpl;try tauto.\n  destruct a.\n  inversion H.\n  case (in_inv H).\n  apply (IHl p n);trivial.\n  apply (IHl p n);trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n induction l;intros.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros;simpl;try tauto.\n  apply (in_inv H1);trivial.\n  simpl in H4;inversion H4.\n  apply (in_inv H4);trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  apply  cons_is_pinv;auto.\n  apply  (IHn p n m);trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H.\n  apply (IHl p (pred p) (pred m)).\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\ninduction l;simpl;intros;try tauto.\ndestruct a.\ndestruct l.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H.\ndestruct (in_inv H0).\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H1.\ndestruct (in_inv H0).\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H0.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H3.\ninversion H1.\ninversion H3.\ninversion H1.\ninversion H1.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.Qed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  intros;unfold is_pinv in H.\n  assert (H3:=H2 H3).\n  assert (H4:=H2 H4).\n  rewrite H3 in H4;clear H4.\n  assert (H5:=H5 H6).\n  rewrite H5 in H5;clear H5.\n  assert (H6:=H6 H7).\n  rewrite H3 in H5;clear H6.\n  assert (H6:=H6 H7).\n  rewrite H5 in H6;clear H5.\n  assert (H7:=H7 H7).\n  rewrite H5 in H7;clear H7.\n  assert (H7:=H7 H7).\n  rewrite H6 in H7; clear H7.\n  assert (H8:=H7 H8).\n  rewrite H7 in H7;clear H7.\n  assert (H7:=H7 H8).\n  rewrite H7 in H7;clear H7.\n  assert (H7:=H7 H8).\n  rewrite H8 in H7;clear H7.\n  assert (H8:=H7 H8).\n  rewrite H7 in H8;clear H8.\n  assert (HQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros.\n  inversion H.\n  destruct a.\n  inversion H.\n  apply IHn.\n  apply IHl.\n  apply IHl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "actor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\n",
                "context_tokens": 691,
                "proof_start_offset": 15927,
                "proof_end_offset": 16738,
                "proof": "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\nintros l l';intro;intro;intro;intros p n;intro.\nelim (in_wf l p n H2 H);intros.\ngeneralize (factor_divides_refactor (p,n) l H2);simpl;intro.\nrewrite H1 in H5.\nassert (divides (refactor l') p).\napply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\nelim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\ncut (n=m).\nintro;rewrite H8;trivial.\napply le_antisym.\neapply prime_power_divides_refactor;eauto.\ngeneralize (factor_divides_refactor (p,m) l' H7);simpl;intro.\nrewrite <- H1 in H8.\napply prime_power_divides_refactor with p l;auto.\nelim (in_wf l' p m);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intros;simpl;try tauto.\n  case H3;intro.\n  rewrite H4 in H2;inversion H2.\n  generalize (interp_exist_neq _ _ _ H2 H2);intro.\n  rewrite mult_comm in H2.\n  generalize (interp_exist_neq _ _ H2 H2);intro.\n  assert (1=n).\n  eapply le_trans;eauto.\n  rewrite <- H4 in H3; elim H3;clear H3.\n  simpl in H2.\n  rewrite H4 in H2;inversion H2.\n  generalize (interp_exist_neq _ _ H2 H3);intro.\n  rewrite mult_comm in H2.\n  generalize (interp_exist_neq _ _ _ H2 H3);intro.\n  rewrite plus_comm in H2.\n  generalize (interp_exist_neq _ _ _ H2 H3);intro.\n  rewrite mult_comm in H2.\n  generalize (interp_exist_neq _ _ _ H2 H3);intro.\n  rewrite mult_comm in H2.\n  generalize (interp_exist_neq _ _ H2 H3);intro.\n Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  apply cons_is_qinv;auto.\n  destruct a.\n  apply cons_is_pinv;auto.\n  destruct a.\n  apply cons_is_qinv;auto.\n  apply IHl;trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  apply cons_is_ninv;auto.\n  generalize (rel_prime_power p (pos_pred x) (pos_pred x));intro.\n  rewrite mult_comm in H1;elim H1;tauto.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\ninduction l;simpl;intros;try tauto.\ncase H;intros.\nassert (In (x,n) l).\neapply (in_or_pinv _ _ _ _ H).\napply in_or_app.\napply in_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_app.\napply in_or_app.\napply in_or_app.\napply in_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply in_or_app.\napply inQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intros.\n  apply (inf_exists_is_pIn _ _ _ H2 H1).\n  apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_n;apply le_S_nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  simpl in H.\n  apply IHn.\n  simpl;apply IHn.\n  simpl;apply IHn.\n  simpl;apply IHn.\n  simpl;apply IHn.\n  simpl;apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\n  simpl; apply IHn.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  intros l l'.\n  apply (reduce_or_pEq l l');trivial.\n  apply incl_or_pEq with (l:=l) (l':=l');trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  case H3;intros.\n  apply (H3 l).\n  destruct (in_app_or_or_or_or_eq l l' H3) as (x,H4).\n  generalize (factor_or_eq_aux l l' H4);intro.\n  generalize (factor_or_eq_aux l' H4);intro.\n  generalize (factor_or_eq_aux l' H4);intro.\n  rewrite plus_comm in H5.\n  generalize (factor_or_eq_aux l' H5);intro.\n  rewrite plus_comm in H5.\n  generalize (factor_or_eq_aux l' H5);intro.\n  rewrite mult_comm in H5.\n  generalize (factor_or_eq_aux l' H5);intro.\n  rewrite mult_comm in H5.\n  generalize (factor_or_eq_aux l' H5);intro.\n  rewrite mult_comm in H5.\n  generalize (factor_or_eq_aux l' H5);intro.\n  rewrite mult_comm in H5.\n  generalize (factor_or_eq_aux lQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros.\n  case H.\n  simpl in H.\n  apply (H0 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H0 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H0 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H0 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H0 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H0 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H1 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H2 0).\n  simpl in H.\n  destruct H.\n  subst.\n  apply (H0 (S n)).\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  apply H.\n  apply H.\n  apply (H _ _ H1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 16740,
                "proof_end_offset": 16884,
                "proof": "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\ninduction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction l;simpl;intros;try tauto.\n  apply prime_power_uniqueness with (nat_of_P p);auto.\n  apply prime_power_uniqueness with (nat_of_P p);auto.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  elim (in_wf l p n H2 H0); intros.\n  apply H;trivial.\n  apply prime_power_divides_neg with p;auto.\n  destruct p.\n  elim (in_wf l p n H2 H0);intros.\n  apply H;trivial.\n  apply prime_power_divides_neg with p;auto.\n  destruct p.\n  elim (not_prime_zero H8); intro.\n  elim (not_prime_one H8).\n  elim H8; tauto.\n  elim H8; tauto.\n  elim H8; tauto.\n  elim H8; tauto.\n  elim H8; tauto.\n  elim H8; tauto.\n  elim H8; tauto.\n  elim H8; tauto.\n  elim H8; tauto.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  apply (not_and_no_pG (nat_of_P p) (nat_of_P p) (nat_of_P p) (nat_of_P p) H0);intro.\n  apply (not_and_no_and_set (nat_of_P p) (nat_of_P p) (nat_of_P p) H0);intro.\n  rewrite mult_comm in H2.\n  apply H2;trivial.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  destruct l.\n  case (in_wf l p);trivial.\n  destruct p.\n  destruct p.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  left.\n  rewrite H4 in H2;inversion H2.\n  right.\n  destruct H2.\n  generalize (factor_unique_length l H2);simpl;intro.\n  rewrite <- H4 in H2.\n  apply le_antisym.\n  eapply prime_div_trans; eauto.\n  generalize (factor_unique_nonneg l H2);simpl;intro.\n  rewrite H4 in H2.\n  apply le_antisym.\n  eapply prime_div_trans; eauto.\n  generalize (factor_unique_nonneg l H2);simpl;intro.\n  rewrite H4 in H2.\n  apply le_antisym.\n  eapply prime_div_trans; eauto.\n  generalize (factor_unique_nonneg l H2);simpl;intro.\n  rewrite H4 in H2.\n  apply le_antisym.\n  eapply prime_div_trans; eauto.\n  generalize (factor_unique_nonneg l H2);simpl;intro.\n  rewrite H4 in H2.\n  apply le_antisymQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  elim (in_wf l p n H2 H3); intros.\n  elim (in_wf l p n H3);intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H3); intros.Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l;intro.\n  generalize (factor_transitivity (fun p => is_power p (pos_of_P p)) (fun p => is_power p (pos_of_P p)) l H0);intro.\n  rewrite mult_comm in H1.\n  generalize (factor_simplify (fun p => is_power p (pos_of_P p)) (fun p => is_power p (pos_of_P p)) H1);intro.\n  rewrite mult_comm in H1.\n  generalize (H1 (pos_of_P p)) (pos_of_P p) H1);simpl;intro.\n  rewrite mult_comm in H1.\n  generalize (H2 (pos_of_P p)) (pos_of_P p) H2);simpl;intro.\n  rewrite plus_comm in H2.\n  generalize (H2 (pos_of_P p)) (pos_of_P p) H2);simpl;intro.\n  rewrite mult_comm in H2.\n  generalize (H2 (pos_of_P p)) (pos_of_P p) H3);simpl;intro.\n  rewrite mult_comm inQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intros p n.\n  elim (in_wf l p n H2 H);intros.\n  elim (in_wf l p n H2 H);intros.\n  elim (in_wf l p n H2 H3);intros.\n  elim (in_wf l p n H3 H4);intros.\n  elim (in_wf l p n H3); intros.\n  elim (in_wf l p n H4); intros.\n  elim (in_wf l p n H4); intros.\n  elim (in_wf l p n H4); intros.\n  elim (in_wf l p n H4); intros.\n  elim (in_wf l p n H4); intros.\n  apply le_antisym.\n  eapply le_trans.\n  apply H1.\n  apply H4.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  applyQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  destruct l.\n  simpl;intros.\n  case (in_wf l p);trivial.\n  elim (not_prime_two_pG l);trivial.\n  elim (not_prime_two_pG l);trivial.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intro l;intro;intro;intros p n.\n  elim (in_wf l p n H2 H);intros.\n  elim (in_wf l p n H2 H);intros.\n  apply (pwd_impl_set p l n H2);trivial.\n  apply (pwd_impl_set p l n H2);trivial.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nintros.\nunfold is_set in H.\nassert (H:=H1 (refl_equal (fst l) H)).\ndestruct H.\ndestruct H.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H0.\ndestruct H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\n",
                "context_tokens": 705,
                "proof_start_offset": 16982,
                "proof_end_offset": 17483,
                "proof": "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\nintros.\nassert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\napply factorisation_unique_upto_equiv_aux;trivial.\nassert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\napply factorisation_unique_upto_equiv_aux;auto.\napply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l;simpl;intros;simpl;try tauto.\n  destruct a.\n  left;simpl;auto.\n  left;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\n  left;simpl;auto.\n  right;simpl;auto.\n  right;simpl;auto.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\n  induction l;intros l l' H;apply app_pred with l;trivial.\n  intros.\n  apply H.\n  apply app_pred with (nat_of_P p).\n  intros.\n  apply H.\n  apply H0.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in H2.\n  apply H2.\n  apply in_map_iff in HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l';intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_ref Rsth (p:=nat) l H2);simpl;intro.\n  rewrite <- H8.\n  rewrite mult_comm.\n  apply le_trans with (p + S (S p))).\n  rewrite mult_comm.\n  apply le_n_S.\n  rewrite mult_comm.\n  apply le_n_S.\n  rewrite plus_comm.\n  apply le_n_S.\n  rewrite mult_comm.\n  apply le_n_S.\n  rewrite plus_comm.\n  apply le_n_S.\n  rewrite plus_comm.\n  apply le_n_S.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\ninduction l;simpl;intros.\nelim (in_wf l p);intro.\nrewrite H4 in H1.\ninversion H1.\nassert (H3:= H1).\nassert (H4:= H2).\napply H3;auto.\nassert (H5:= H5).\napply H4;auto.\nassert (H5:= H5).\napply H5;auto.\nassert (H5:= H5).\napply H5;auto.\nassert (H5:=H5).\napply H5;auto.\nassert (H5:=H5).\napply H5;auto.\nassert (H5:=H5).\napply H5;auto.\nassert (H5:=H5).\napply H5;auto.\nassert (H5:=H5).\napply H5;auto.\nassert (H6:=H7).\napply H5;auto.\nassert (H6:=H7).\napply H5;auto.\nassert (H7:=H7).\napply H5;auto.\nassert (H7:=H7).\napply H5;auto.\nassert (H7:=HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H;inversion H;inversion H.\n  destruct (or_dec (nat*nat) (S (length l))).\n  apply incl_refl.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_sym.\n  apply incl_Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\ninduction l;simpl;intros;try tauto.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\ninduction l;simpl;intros.\nconstructor.\nconstructor;auto.\nconstructor;auto.\nconstructor;auto.\nconstructor;auto.\nconstructor;auto.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\ninduction l;simpl;intros.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' l';intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  elim (in_wf l p n H2 H2);intros.\n  generalize (factor_divides_pos n l' H3);simpl;intro.\n  rewrite <- H4 in H4.\n  apply le_antisym.\n  eapply incl_trans;eauto.\n  apply incl_le_trans with (nat_of_P p);apply incl_le_trans with (nat_of_P p);apply incl_le_trans with (nat_of_P p);\n    auto.\n  apply (fun m n p => (n,m)); auto.\n  apply incl_le_trans with (nat_of_P p); auto.\n  apply incl_le_trans with (nat_of_P p); auto.\n  apply incl_le_trans with (nat_of_P p); auto.\n  apply incl_le_trans with (nat_of_P p); auto.\n  apply incl_le_trans with (nat_of_P p); auto.\n  apply incl_le_trans with (nat_of_Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l';intro;intro;intros p n;intro.\n  elim (in_wf l p n H2);intros.\n  generalize (factor_simplify_eq_aux p (pos_pred (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S (S (S (S (S (S(S(S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\n",
                "context_tokens": 723,
                "proof_start_offset": 17745,
                "proof_end_offset": 17899,
                "proof": "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\nintros.\ncase (factorisation n);intros;try tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\n  simple induction n.\n  intros.\n  exists 0.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.\n  apply IHn.\n  intros.Qed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  destruct (exists_power n) as (n,H).\n  exists (S n).\n  split.\n  apply (is_factority (nat*nat) (S n)).\n  intros.\n  apply H.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  destruct (exists_dec n l).\n  exists 0%nat.\n  apply is_factorisation.\n  intros; apply is_factorization.\n  intros; apply is_factorization.\n  intros; apply is_factorible; auto.\n  intros; apply is_factorible; auto.\n  intros; apply is_factorible; auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n l.\n  induction n.\n  exists 0.\n  split.\n  simpl.\n  apply lt_0n.\n  omega.\n  intros.\n  simpl.\n  apply lt_0n.\n  omega.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\n  intros.\n  destruct n.\n  exists 0.\n  apply exists_0.\n  apply exists_0.\n  apply exists_1.\n  apply exists_1.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n.\n  induction n.\n  exists 0%nat.\n  apply IHn.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\n  intro n;induction n;intros.\n  destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (H n);destruct (HQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\n  intro n.\n  exists 0%nat.\n  apply exists_0.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros;apply H;trivial.\n  exists (S (S n)).\n  apply incl_sym.\n  apply incl_comm.\n  apply incl_length;trivial.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nintros n H.\nassert (exists l' : nat, n<>0/\\exists l' : nat, n=n /\\ l=l').\napply H.\ndestruct (or_exists n).\nsplit;intros.\napply H.\nexists (pred (S n)).\nsplit;intros.\napply pred_length_or_pred.\napply H.\napply H.\nexists (pred (S n)).\nsplit;intros.\napply pred_length_or_pred.\napply H.\nexists (pred (S n)).\nsplit;intros.\napply pred_length_or_pred.\napply H.\nexists (pred (S n)).\nsplit;intros.\napply pred_length_or_pred.\napply H.\napply H.\nexists (pred (S n)).\nsplit;intros.\napply pred_length_or_pred.\napply H.\nexists (pred (S n)).\nsplit;intros.\napply pred_length_or_pred.\napply H.\nexists (pred (S n)).\nsplit;intros.\napply pred_length_or_pred.\napply H.\nexists (pred (SQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\n",
                "context_tokens": 706,
                "proof_start_offset": 17978,
                "proof_end_offset": 18273,
                "proof": "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nProof.\nunfold is_factorisation;intros.\nelim H;intros.\nelim H0;intros.\napply factorisation_unique_upto_perm;auto;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nProof.\n  intros.\n  case (factorisation n);intros.\n  destruct (factority n l) as (x,l).\n  elim (In_inv _ _ H); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H1); intro.\n  elim (In_inv _ _ H1); intro.\n  elim (In_inv _ _ H2); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _ _ H0); intro.\n  elim (In_inv _Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros;apply factor subgroup_unique_upto_permutation;intros.\n  rewrite <- H;apply is_factorks;trivial.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nintros.\nassert (H1 : forall (x n:nat)(l':list (nat*nat)),\n  (forall (x n:nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':list (nat*nat)),\n   (forall (x n':nat)(l':Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nintros.\nassert (H' := H (nat*nat) (fun x n:nat => x=n \\/ x=n) l').\ndestruct (in_factority n l) as (l1,(H1,H2)).\nassert (H' := H' (nat*nat) (fun x n:nat => x=n \\/ x=n) l').\ndestruct (in_factority n l) as (l1,(H1,H2)).\ndestruct (in_factority n l) as (l2,(H3,H4)).\ndestruct (in_factority n l2) as (l3,(H4,H5)).\ndestruct (in_factority n l3) as (l4,(H5,H6)).\nexists (fun x n:nat => x=n \\/ x=n) l).\ndestruct (in_factority n l) as (l1,(H7,H7)).\ndestruct (in_factority n l) as (l4,(H8,H8)).\ndestruct (in_factority n l3) as (l4,(H8,H9)).\ndestruct (inQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros n l l' H; exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  split;trivial.\n  apply H;auto.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nintros.\ncase (factorisation n);intros;try tauto.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nProof.\n  simple induction n;intros.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\nTheorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  unfold is_factorisation;intros.\n  elim H;intros.\n  elim H0;intros.\n  apply factorisation_unique_upto_perm;auto;congruence.\nQed.\n\n(** *)\n",
                "context_tokens": 652,
                "proof_start_offset": 18282,
                "proof_end_offset": 20069,
                "proof": "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintro.\ninduction l;simpl;intros.\nleft;exists 1;rewrite power_one;trivial.\ndestruct a.\nassert (n<>0);try omega.\ngeneralize (quo_rem_euclide n1 n H1);intro.\ncase (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\nrewrite e in H2;rewrite plus_comm in H2;simpl in H2.\ncase IHl;intros;trivial.\ninversion H;trivial.\nelim s;intro y;intro.\nrewrite H2.\nleft;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nelim p3;intros.\nelim H4;intros.\nelim H6;intros.\nelim H8;intros.\nright.\nexists p;exists q;exists r.\nrewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\nexists (k*(power n0 n1)).\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\napply rel_prime_mult;trivial.\ninversion H.\nrewrite H9 in H17.\nelim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\napply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\nrewrite plus_comm;auto with arith.\nright.\nexists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\nrewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\nexists (refactor l).\nelim (in_wf ((n0,n1)::l) n0 n1);intros.\nsplit;trivial.\nsplit;trivial.\ndestruct (remainder_euclide n1 n H1);try tauto;auto with arith.\nsplit;trivial.\napply rem_euclide.\nsplit;trivial.\ninversion H;trivial.\nsimpl;tauto.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  case (factorisation n);intros;try tauto.\n  intros.\n  case (factor subgroup n);intros;try tauto.\n  intros.\n  case (factorhyp_dec n (fun n:nat => (S n))).\n  intro.\n  left.\n  apply H1.\n  apply (H1 n).\n  apply (H1 (fun n:nat => (S n))).\n  intro.\n  apply H1.\n  apply (H1 n).\n  apply (H0 (fun n:nat => (S n))).\n  intro.\n  apply (H1 n).\n  apply (H1 (fun n:nat => (S n))).\n  intro.\n  apply (H2 n).\n  apply (H1 (fun n:nat => (S n))).\n  intro.\n  apply (H1 n).\n  apply (H2 n).\n  apply (H2 (fun n:nat => (S n))).\n  intro.\n  apply (H0 n).\n  apply (H1 n).\n  apply (H1 n).\n  apply (H1 (fun n:nat => (S n))).\n  intro.\n  apply (H1 n).\n  apply (H2 n).\n Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (factorProgram (H1 n) (H2 n) (H4 n) (H5 n) (H5 n) (H5 n) (H1 n) (H5 n) (H5 n) (H2 n) (H2 n) (H5 n) (H4 n) (H5 n) (H1 n) (H4 n) (H5 n) (H5 n) (H2 n) (H5 n) (H2 n) (H5 n) (H5 n) (H2 n) (H4 n) (H5 n) (H5 n) (H5 n) (H2 n) (H5 n) (H2 n) (H5 n) (H2 n) (H5 n) (H2 n) (H3) (H2 n) (H5 n) (H2 n) (H5 n) (H2 n) (H5 n) (H2 n) (H3 n) (H4 n) (H5 n) (H2 n) (H2 n) (H5 n) (H2 nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  destruct (factorisation n p) as (r,(r,(H1,H2)).\n  destruct (factorisation n p) as (r,(H2,H3)).\n  destruct (factorCanonical (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R) (R:=R) (R:=R) (R:=R) (R:=R) (R) (R:=R) (R:=(R) (R:=R) (R) (R:=R) (R) (R:=R) (R) (R:=R)Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (factorisation n); intros;try tauto.\n  case (factorended (is_factorization n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (factorMax (is_factority n)); intros;try tauto.\n  case (Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nintros.\nassert (H:(l=0)%nat).\n  intro;rewrite H;ring.\n  rewrite <- H1;field.\n  apply is_factorization;auto.\nassert (H2:(l=0)%nat).\n  intro;rewrite H2;field.\n  apply is_factority;auto.\n  rewrite H2;field.\n  apply is_factority;auto.\n  rewrite H2;field.\n  apply is_factority;auto.\n  rewrite H2;field.\n  apply is_factority;auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nintros n.\ndestruct (factorisation n);intros;try omega.\ndestruct H.\nsubst.\napply is_factor_infty with (1:=H1).\napply is_factor_infty with (1:=H1).\napply is_factor_infty with (2:=H2).\napply is_factor_infty with (1:=H2).\napply is_factor_infty with (2:=H1).\napply is_factor_infty with (2:=H1).\napply is_factor_infty with (2:=H2).\napply is_factor_infty with (1:=H2).\napply is_factor_modulus with (1:=H1).\napply is_factor_infty with (1:=H1).\napply is_factor_infty with (2:=H1).\napply is_factor_infty with (1:=H2).\napply is_factor_infty with (1:=H2).\napply is_factor_infty with (2:=H1).\napply is_factor_infty with (1:=H2).\napply is_factor_infty with (1:=H1).\napply is_factor_infty with (Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (factorisation n);intros.\n  case (factorisation (fun p => (fst p, S (fst p))) (snd p));intro.\n  apply (H (pred_double _ _ H0)).\n  apply (H (pred_double _ _ H0)).\n  apply (H (pred_double _ _ H0)).\n  apply (H (pred_double _ _ H0)).\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (factorizer_dec n);intros.\n  elim H0;intros.\n  elim H0;intros.\n  rewrite H0; rewrite H1; clear H0; clear H0.\n  intro.\n  elim (H0 n).\n  elim (H3 n).\n  elim (H3 n).\n  elim (H3 n).\n  apply H.\n  apply le_trans with (S (n+S (S (n+S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (factor Obligations n);intros.\n  apply (H (pred n) (S (pred n) (pred (S (S n)));auto.\n  apply (H (S (pred (S (pred n) (S (S (S (S n))))) (pred (S (S (S n)))));auto.\n  apply (H (pred (S (pred (S (S n))));auto.\n  apply (H (pred (S (pred (S (S (S n)))) (pred (S (S n)))) (pred (S (S (S (S n)))) (pred (S (S (S (S n))))) (pred (S (S n))).\n  apply H.\n  apply H.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  case (factority n);intros;try tauto.\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 0)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p + 1)).\n  apply (fun n => (pos p +Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intro.\n  induction l;simpl;intros.\n  left;exists 1;rewrite power_one;trivial.\n  destruct a.\n  assert (n<>0);try omega.\n  generalize (quo_rem_euclide n1 n H1);intro.\n  case (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\n  rewrite e in H2;rewrite plus_comm in H2;simpl in H2.\n  case IHl;intros;trivial.\n  inversion H;trivial.\n  elim s;intro y;intro.\n  rewrite H2.\n  left;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\n  elim s;intro p;intro.\n  elim p0;intro q;intro.\n  elim p1;intro r;intro.\n  elim p2;intro k;intro.\n  elim p3;intros.\n  elim H4;intros.\n  elim H6;intros.\n  elim H8;intros.\n  right.\n  exists p;exists q;exists r.\n  rewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\n  exists (k*(power n0 n1)).\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  apply rel_prime_mult;trivial.\n  inversion H.\n  rewrite H9 in H17.\n  elim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\n  apply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\n  rewrite plus_comm;auto with arith.\n  right.\n  exists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\n  rewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\n  exists (refactor l).\n  elim (in_wf ((n0,n1)::l) n0 n1);intros.\n  split;trivial.\n  split;trivial.\n  destruct (remainder_euclide n1 n H1);try tauto;auto with arith.\n  split;trivial.\n  apply rem_euclide.\n  split;trivial.\n  inversion H;trivial.\n  simpl;tauto.\n  trivial.\nQed.\n\n(** let n be a natural number and m>1 then either n=x^m or there is a prime number p and three numbers q,r and k such that n = p^(q*m+r)*k with 0<r<m and gcd(p,k)=1 *)\n",
                "context_tokens": 668,
                "proof_start_offset": 20239,
                "proof_end_offset": 20661,
                "proof": "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n m;intro H.\ncase (eq_nat_dec n 0);intro.\nleft;exists 0.\ndestruct m;simpl;try omega;trivial.\ngeneralize (factorisation_exists n n0);intro.\nelim H0;intro l;intro.\nelim p;intros.\nrewrite H2;apply wf_power_dec;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction n.\n  simpl.\n  intros.\n  destruct (H n).\n  destruct (H0 n).\n  destruct (H0 n).\n  rewrite <- (plus_n_O p) in H0.\n  rewrite (plus_comm (n * x)).\n  rewrite <- (mult_comm n p) in H0.\n  rewrite (plus_comm (n * x)).\n  rewrite mult_comm.\n  rewrite (mult_comm (n * x)).\n  rewrite mult_comm.\n  rewrite (mult_comm (n * x)).\n  rewrite <- (mult_comm (n * x)).\n  rewrite mult_comm.\n  rewrite (mult_comm (n * x)).\n  rewrite mult_comm.\n  rewrite (mult_comm (n * x)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (n * x)).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm (n * x)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (n * x)).\n  rewrite (mult_comm (n * x)).\n  rewrite (mult_comm (n *Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros.\nassert (H0 := even_odd_odd_bound n).\nassert (H2 := even_odd_bound m).\ndestruct H2 as (q,r).\nassert (H3 := even_odd_bound m).\ndestruct H4 as (q,r).\ndestruct H4 as (r,r).\ndestruct H4 as (r',r').\nexists (r',r').\nexists (r',r').\nexists (r',r').\nexists (r',r').\nexists (r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',r').\nexists (r',r',rQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  generalize (is_power_correct n m H); intro.\n  destruct (is_power_correct n m H) as (m',H).\n  exists m'; split;trivial.\n  right.\n  exists (S m'); split;trivial.\n  split;trivial.\n  apply H.\n  rewrite <- H; rewrite H1; rewrite H2;trivial.\n  apply H.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\ninduction n; intros.\nsimpl; intros.\nassert (m>1) by (unfold m, p; clear p.\ndestruct (lt_gt_dec m n) as [H|H].\nrewrite (H m); rewrite (H0 m); rewrite (H0 m); rewrite (H0 m); auto.\nassert (m>1) by (unfold m, p; clear p.\ndestruct (le_gt_dec m n) as [H|H].\nrewrite (H m); rewrite (H0 m); rewrite (H0 m); rewrite (H0 m); auto.\nassert (m>0) by (unfold m, p; clear p.\ndestruct (le_gt_dec m n) as [H|H].\nrewrite (H m); rewrite (H0 m); rewrite (H0 m); rewrite (H0 m); auto.\nassert (m>1) by (unfold m, p; clear p.\ndestruct (lt_gt_dec m n) as [H|H].\nrewrite (H0 m); rewrite (H0 m); rewrite (H0 m); auto.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction (Z_dec n m);simpl.\n  left.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assert (m=p). omega.\n  assertQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  assert (m=p).\n  {\n    apply (well_founded_induction (well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_induction (Zwf_well_founded_induction (Zwf_well_founded_induction (Zwf_well_induction (Zwf_well_founded_induction (Zwf_well_induction (Zwf_well_founded_induction (Zwf_well_induction (Ppred_well_induction (Zwf_well_founded_induction (Zwf_well_Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  induction n.\n  simpl.\n  intros.\n  destruct (H n) as (n,(q,H)).\n  generalize (factor_prime_correct n m H H0);intro.\n  destruct H0.\n  subst n.\n  rewrite (div_mod_mod n m H) in H1.\n  case (le_gt_dec n m).\n  auto with arith.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction n; simpl; intros.\n  - left;exists 1; rewrite power_one;trivial.\n  - right.\n    exists 0; rewrite power_one;trivial.\n  - right.\n    destruct (IHn (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction p.\n  simpl; intros.\n  exists (S(n+m)); simpl.\n  rewrite plus_comm.\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm n m (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_comm (p*n)).\n  rewrite (mult_Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  induction n;simpl;intros.\n  exists 0%nat; intros.\n  case (eq_nat_dec n0 n); intros.\n  right;exists 1; rewrite mult_1_r;trivial.\n  destruct (eq_nat_dec n0 n0); subst;trivial.\n  rewrite <- (mult_comm n0); rewrite (mult_comm (m+n0));rewrite (mult_comm (n+n0));trivial.\n  right.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite plus_comm;ring.\n  rewrite mult_comm; rewrite mult_comm; rewrite <- plus_comm; ring.\n  rewrite plus_comm; rewrite <- plus_comm;rewrite <- mult_assoc;ring.\n  apply le_trans with (m+n0*n); trivial.\n  rewrite mult_comm; rewrite mult_comm; rewrite mult_comm;ring.\n  apply le_trans with (m+n0*n); trivial.\n  rewrite mult_comm; rewrite mult_comm; rewrite plus_comm;ring.\n  apply le_trans with (m+n0*n); trivial.\n  rewrite multQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\n",
                "context_tokens": 252,
                "proof_start_offset": 1012,
                "proof_end_offset": 1219,
                "proof": "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nelim H0;intro q;intro.\nreplace b with (b*1);try ring.\nrewrite H1.\napply mult_le_compat;try omega.\ndestruct q;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\napply (pred_le a b).\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b; elim (Zle_lt_or_eq 0 a); intros.\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite <- (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite <- (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite <- (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewrite <- (Zabs_eq (Zabs_nat a)).\nrewrite (Zabs_eq (Zabs_nat a)).\nrewriteQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n  simple induction a; intros.\n  elim (Zle_lt_eq_dec a b).\n  left; assumption.\n  left; assumption.\n  right; assumption.\n  right; assumption.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nunfold modulo in |- *.\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite <- (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (abs_eq (abs b)).\nrewrite (Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintro a; case (le_gt_dec (S a) (S a)); auto.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintro.\napply (H (S (S (S a))).\napply le_0_n.\napply lt_O_n.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n  unfold modulo in |- *.  intros.  elim (lt_irrefl 0).  intros.\n  apply H.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b.\ncase (Zle_lt_or_eq _ _ H).\nintros H'1.\napply (H'1 (b:=a)); auto.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b; case (le_lt_or_eq a b); intros.\napply (H (S n)); auto.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nsimple induction a; auto with arith.\nintros a b H H0; case (Z_le_ge_dec a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\n",
                "context_tokens": 338,
                "proof_start_offset": 1256,
                "proof_end_offset": 1718,
                "proof": "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\nintros.\napply (lt_wf_rec a (fun a:nat =>{q : nat & {r : nat | a = b * q + r /\\ r < b}})).\nintros.\ncase (le_lt_dec b n);intro.\nelim (H0 (n-b)).\nintro q;intro.\nelim p;intro r;intro.\nexists (q+1);exists r.\nsplit;try tauto.\nrewrite (le_plus_minus b n);trivial.\nelim p0;intros.\nrewrite H1;ring.\nomega.\nexists 0;exists n.\nsplit;try tauto.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\nintros a b.\nrewrite <- egcdn_correct.\napply egcdn_aux; auto.\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\nintros.\ngeneralize (Z_eq_lt_or_eq (Z.abs_eq_lt a b) (Z.abs_eq_lt a b) (Z.abs_eq_lt a b) (Z.abs_eq_lt a b) (Z.abs_eq_lt b a) H0).\nclear H0.\ninduction  a as [| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| r| rQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros a b; case (b*q); intros q r H1.\n  elim H1; intro r.\n  elim H2; intro r.\n  elim H4; intro r.\n  elim H5; intro r.\n  rewrite H4.\n  apply Zmult_le_reg_l with b.\n  apply Zlt_le_weak; assumption.\n  assumption.\n  apply Zmult_le_reg_l with b.\n  apply Zlt_le_weak; assumption.\n  assumption.\n  apply (lt_le_trans _ _ r).\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros a b H; elim H.\n  exists (b*q); auto.\n  exists (b*q); auto.\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  elim H0; intro q; intros.\n  replace b with (b*0); try ring.\n  rewrite <- (mult_comm (b*1)).\n  rewrite (mult_comm (b*1)).\n  rewrite (mult_comm (b*1)).\n  rewrite (mult_comm (b*1)).\n  rewrite (mult_comm (b*1)).\n  rewrite (mult_comm (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_comm (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite <- (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assoc (b*1)).\n  rewrite (mult_assocQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  elim H0; intro.\n  elim H1; intro.\n  replace b with (b*1); try ring.\n  rewrite H1.\n  ring.\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros a b H.\n  elim H.\n  intros.\n  elim H0; intro q.\n  cut (b=a).\n  intro.\n  rewrite H1.\n  apply H1.\n  apply H2.\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := b).\n  apply le_lt_trans with (m := bQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H; intro q; elim H; intros.\n  elim H1; intro.\n  elim H2; intro.\n  apply (H3 (S p)).\n  apply (H3 (S p)).\n  apply (H4 (S p)).\n  apply (H5 (S p)).\n  apply (H1 (S p)).\n  apply (H2 (S p)).\n  apply (H5 (S p)).\n  apply (H1 (S p)).\n  apply (H1 (S p)).\n  apply (H1 (S p)).\n  apply (H2 (S p)).\n  apply (H1 (S p)).\n  apply (H1 (S p)).\n  apply (H1 (S p)).\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  elim H0; intro q; elim H0; intro q; elim H1; intro q; elim H2; intro q; elim H3; intro q; elim H4;\n    intro q; elim H4; intro q; elim H5; intros q H5.\n  apply (H5 (b*q)); try assumption.\n  apply (H5 (b*q)); try assumption.\n  apply (H5 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H5 (b*q)); try assumption.\n  apply (H5 (b*q)); try assumption.\n  apply (H5 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H6 (b*q)); try assumption.\n  apply (H7 (b*Qed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  elim H.\n  exists (b*q).\n  rewrite H1.\n  rewrite H1.\n  replace b with (b*q+b*q).\n  rewrite H2.\n  rewrite H3.\n  ring.\n  apply H0.\n  apply le_trans with (b*q*q); try ring.\n  apply le_mult_compat; try omega.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_trans with (b*q); try ring.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_trans with (b*q); try ring.\n  apply le_trans with (b*q); try ring.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\n",
                "context_tokens": 619,
                "proof_start_offset": 1941,
                "proof_end_offset": 2205,
                "proof": "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\nunfold quotient_euclide;unfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  case (le_lt_eq_dec a b); intro.\n  replace (b*(b*(a+b))) with ((b*(a+b))).\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = b * q + r /\\ a = b}).\n  intro.\n  case (H0 (n-b)); intro.\n  elim n; intro r; intro.\n  exists (b*q); split; try assumption.\n  rewrite H0; ring.\n  intro H1.\n  case (H1 (n-b)); intro.\n  elim n; intro r; intro.\n  exists (q+1); exists (b*q); split; try assumption.\n  rewrite H1; ring.\n  intro H2.\n  case (H2 (n-b)); intro.\n  exists (b*q); split; try assumption.\n  rewrite H2; ring.\n  intro H3.\n  case (H3 (n-b)); intro.\n  elim n; intro r; intro.\n  exists (b*q); exists (b*q); split; try assumption.\n  rewrite H3; ring.\n  intro HQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nintros.\ndestruct (mod_rem_eucl rem H) as (q,H).\nexists q; split; try tauto.\nrewrite <- H; auto.\nrewrite H; auto.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros; case (le_lt_eq_dec b n);intro.\n  rewrite (gcd_comm a b);trivial.\n  elim H; intros.\n  rewrite H1; ring.\n  intro H.\n  rewrite H1; ring.\n  intro H0; rewrite H1; ring.\n  intro H0; rewrite H1; ring.\n  intro H0; rewrite H1; ring.\n  intro H0; rewrite H1; ring.\n  intro H0; rewrite H0; ring.\n  intro H0; rewrite H0; ring.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nintros.\nelim H.\nintros r (H0,H1).\ndestruct (H0 r).\ndestruct (H1 r).\ndestruct (H1 r).\ndestruct (H2 r).\ndestruct (H2 r).\ndestruct (H2 r).\ndestruct (H2 r).\ndestruct (H2 r).\ndestruct (H2 r).\ndestruct (H2 r).\ndestruct (H3 r).\ndestruct (H3 r).\ndestruct (H2 r).\ndestruct (H2 r).\ndestruct (H3 r).\ndestruct (H3 r).\ndestruct (H3 r).\ndestruct (H3 r).\ndestruct (H4 r).\ndestruct (H5 r).\ndestruct (H5 r).\ndestruct (H5 r).\ndestruct (H5 r).\ndestruct (H5 r).\ndestruct (H5 r).\ndestruct (H5 r).\ndestruct (H6 r).\ndestruct (H6 r).\ndestruct (H6 r).\ndestruct (H6 r).\ndestruct (H6 r).\ndestruct (H6 r).\ndestruct (H6 r).\ndestruct (H6 r).\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  elim H; intro q;intro.\n  case (gcd_euclide (Zabs_eq_dec b a) H0); intro.\n  rewrite H1; ring.\n  rewrite H2; ring.\n  rewrite <- H1.\n  case (gcd_euclCR (Zabs_eq_dec b a) H0); intro.\n  rewrite H2; ring.\n  rewrite <- H1.\n  case (gcd_euclCR (Zabs_eq_dec b a) H0); intro.\n  rewrite H2; ring.\n  rewrite <- H1.\n  case (gcd_euclCR (Zabs_eq_dec b a) H0); intro.\n  rewrite H3; ring.\n  apply (euclid_lt_reg_l 2).\n  rewrite <- H2.\n  case (gcd_euclCR (Zabs_eq_dec b a) H0); intro.\n  rewrite H3; ring.\n  rewrite <- H1.\n  case (gcd_euclCR (Zabs_eq_dec b a) H0); intro.\n  rewrite H4; ring.\n  rewrite <- H4.\n  case (gcd_euclExt (Zabs_eq_dec b a) H0Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nintros.\ncase (le_lt_dec a b); intro.\ndestruct (H0 (S a) H0) as (c,(H1,H2)).\nrewrite (H1 (S (S a)) H2); assumption.\nrewrite (H1 (S (S b)) H2); assumption.\nrewrite (H1 (S (S b)) H2); assumption.\nrewrite (H1 (S (S b)) H2); assumption.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\nintros.\napply (lt_wf_rec a (fun a:nat => {q:nat & {r : nat | a = b}}}).\n intros (H1,H2).\n apply H1; try assumption.\n apply (lt_wf_rec a b (fun a:nat => {q : nat | a = b}}).\n intros (H1,H2).\n apply (le_wf_rec a b (fun a:nat => {q : nat | a = b}}).\n intros (H1,H2).\n apply (lt_wf_rec a b (fun a:nat => {q : nat | a = b}}).\n intros (H1,H2).\n apply (le_wf_rec a b (fun a:nat => {q : nat | a = b}) a b H1).\n intros (H1,H2).\n apply (le_wf_rec a b (fun a:nat => {q : nat | a = b}}).\n intros (H1,H2).\n apply (le_wf_rec a b H2).\n apply (le_wf_rec a b HQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  unfold quotient_euclide in H.\n  apply H.\n  apply H0.\n  assumption.\n  assumption.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  apply (lt_wf_rec (fun a:nat => {q : nat &  {r : nat |  a = b * q + r /\\ r < b}}}).\n  intros.\n  case (le_lt_eq_dec a b); intro.\n  left; now rewrite <- (H0 (S a) (S a)); now rewrite <- (H0 (S a)); now rewrite <- (H0 (S a));\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nintros.\napply (le_trans (fun a:nat => {q : nat &  {r : nat | a = b*(a=b*(b*q+r})}).\n  apply H0.\n apply (le_trans (fun a:nat => {q : nat &  {r : nat |  a = b*(a*q+r))}).\n  rewrite <- H0.\n  apply (lt_wf_rec a (fun a:nat => {q : nat &  {r : nat | a = b*(a+r)))}).\n  rewrite <- (plus_comm (a*q)).\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = b*(a+r))) _.\n  rewrite <- (plus_comm (a*q)).\n  rewrite <- (plus_comm (a*q)).\n  apply (lt_wf_rec a (fun a:nat => {q : nat &  {r : nat | a = b*(a+r))) _).\n  rewrite <- (plus_comm (a*q)).\n  apply (lt_wf_rec a (fun a:nat => {q : nat &  {Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2233,
                "proof_end_offset": 2442,
                "proof": "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\nProof.\nunfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat &  {r < b}) (fun a:nat => {q : nat &  {r < b}}}).\n  intros.\n  elim H0; intro.\n  elim (H0 (n-b)) (H0 (n-b)) (H0 (n-a))).\n  intro r; case r; intros.\n  exists (r + (n-a)); auto with arith.\n  elim H0; intros.\n  exists (r + (n-a)); auto with arith.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  apply (prim_gcd_mod_gcd_div b a H (pos_div b a H)).\n  unfold mul in H.\n  generalize (pos_div_eucl31 b (pos_div b a H)).\n  case (gcd_eucl31 b (pos_div b a H)).\n  intro r; intro.\n  elim r; intro.\n  cut (pos_div b a = b).\n  intro.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  discriminate H.\n  trivial.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold pow_eucl31; unfold pow_eucl31; intros.\n  generalize (pos_bound_pos (pos_bound_pos (pos_bound_pos (pos_bound a b H))).\n  rewrite H; auto with arith.\n  generalize (pos_bound_pos (pos_bound_pos (pos_bound a H))).\n  rewrite H; auto with arith.\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_wf_rec a (fun a:nat => a + 1)).\n  apply (lt_Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  elim H; intro q; intro.\n  elim (H1 q); intros.\n  rewrite H0 in H.\n  rewrite (H1 (S q)).\n  auto.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros a b; case (le_lt_eq_dec b 0); intro.\n  elim (H (n-b)); intro.\n  elim (H0 (n-b)); intro.\n  elim (H0 (n-b)); intro.\n  elim (H1 (n-b)); intro.\n  elim (H2 (n-b)); intro.\n  elim (H3 (n-b)); intro.\n  elim H1; intro.\n  exists (S p); exists (S p).\n  split; try assumption.\n  rewrite (plus_comm n); rewrite (plus_comm m); rewrite (plus_comm m); reflexivity.\n  apply H1; assumption.\n  intro; case (le_lt_eq_dec m (S p)); intro.\n  elim (H0 (n-b)); intro.\n  elim (H3 (n-p)); intro.\n  elim (H4 (n-p)); intro.\n  elim (H5 (S p)); intro.\n  elim H1; intro.\n  rewrite <- H1; rewrite <- H4; rewrite <- H4; rewrite <- H5; assumption.\n  intro; case (le_lt_eq_dec m (SQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  generalize (euclide a b H); intros.\n  elim (H (n-b)).\n  intro q;intro.\n  elim p; intro r.\n  exists (p*p); auto.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold quotient_euclite; unfold Rsqr_euclOr; intros.\n  case (dist_cmp_0_dec a b H); intro.\n  elim (H (n-b)).\n  intro q; intro.\n  case (dist_cmp_0_dec a b H); intro.\n  elim H1; intro.\n  apply (H1 (n-b)).\n  replace b with (b*(a+b)).\n  apply (H0 (n-b)).\n  apply (H1 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H1 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (n-b)).\n  apply (H2 (Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros a b H.\n  elim (H (S a) (S b) H).\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (gcd_eucl rem_euclore a b H); intros.\n  exists (q*1); exists r.\n  split; try split; try assumption.\n  rewrite (mult_comm a b);trivial.\n  rewrite H1.\n  apply (lt_wf_rec b (fun a:nat => a<b)); try assumption.\n  rewrite (mult_comm b a);trivial.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  destruct (H b H0); [ elim H | apply H0].\n  destruct (H0 (n-b) H); [ elim H | apply H0].\n  destruct (H0 (n-b) H); [ elim H | apply H0].\n  elim H; intros.\n  rewrite H1; ring.\n  apply (H0 (n-b) H0 H1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\n",
                "context_tokens": 700,
                "proof_start_offset": 2478,
                "proof_end_offset": 3403,
                "proof": "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros.\nrewrite H1 in H0.\ncase (lt_eq_lt_dec q q');intro.\ncase s;intro.\nrewrite (le_plus_minus q q') in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (b*(q'-q)+r' = r).\napply plus_reg_l with (b*q).\nrewrite plus_assoc;trivial.\nassert (0<(q'-q));try omega.\nassert (b<=b*(q'-q));try omega.\ncase (mult_O_le b (q'-q));intro;try omega.\nrewrite mult_comm;trivial.\nsplit;try tauto.\nrewrite <- e in H0.\nsymmetry;apply plus_reg_l with (b*q);trivial.\nrewrite (le_plus_minus q' q) in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (r'=(b*(q-q')+r)).\napply plus_reg_l with (b*q').\nrewrite plus_assoc;trivial.\nassert (0<(q-q'));try omega.\nassert (b<=b*(q-q'));try omega.\ncase (mult_O_le b (q-q'));intro;try omega.\nrewrite mult_comm;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (H (a*q) (b*q) (a*q) (b*q) (r*q) (r*q) (r*q) (r*q) H); intros.\n  generalize (H (a*q) (b*q) (b*q) (r*q) (r*q) (r*q) H); intros.\n  generalize (H (a*q) (b*q) (r*q) (r*q) (r*q) (r*q) (r*q) H); intros.\n  generalize (H (a*q) (b*q) (a*q) (b*q) (r*q) (r*q) (r*q) H); intros.\n  generalize (H (a*q) (b*q) (b*q) (a*q) (r*q) (r*q) (r*q) H); intros.\n  generalize (H (a*q) (b*q) (a*q) (b*q) (r*q) (r*q) (r*qQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (H a b r q r' H0 H1 H2).\n  destruct r; intros.\n  elim H1; intro.\n  elim H2; intro.\n  assumption.\n  auto.\n  auto.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros a b q r q r' H H0 H1 H2.\n  apply H.\n  apply H1;assumption.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (pos_bound_or_eq a b H); intros.\n  elim H; intros.\n  assumption.\n  intros r q r q r' r' r' r'' r' r'' H H0 H1 H2 H3 H4 H5.\n  rewrite H3 in H4.\n  rewrite <- H4 in H5.\n  rewrite <- H4 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5.\n  rewrite <- H5 in H5Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros a b q r q r' r' H H0 H1 H2.\n  rewrite <- (Z.mul_comm r q r r).\n  apply Z.mul_add_cancel_r; try assumption.\n  destruct r;intro r';rewrite <- H1; ring.\n  intro r'; rewrite <- H1; ring.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros a b q r q r' r'' H H0 H1 H2.\n  case (lt_eq_dec a b);intro.\n  elim (H0 (S (S (S (S a))) (S (S (S b))) (S (S (S b))) (S (S (S a))); auto.\n  intro q; rewrite H0; ring.\n  intro q; rewrite H1; ring.\n  intro q; rewrite H1; ring.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros a b q r q r' r' H H0 H1 H2.\n  apply (egcdn_wf_rec a b H H0 H1 H2 H3 H4).\n  apply (egcdn_wf_rec a b H H1 H3 H4).\n  apply (egcdn_wf_rec a b H1 H2 H3 H4).\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  generalize (abs_div_euclrem a b H); intros.\n  generalize (abs_div_euclide a b H); intros.\n  generalize (div_euclide b b H); intros.\n  elim (H1 (q*a)); intros.\n  exists (q*a); trivial.\n  exists (q*a); trivial.\n  exists (q*a); trivial.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros a b q r q r' q r' Hr Hr Hr Hr Hr.\n  unfold mul in Hr.\n  rewrite Hq, <- Hr, <- Hr, <- Hr.\n  rewrite Hr, <- Hr, <- Hr, <- Hr.\n  simpl; auto.\n  apply mul_le_compat_r; auto.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros a b q r q r' r' H H0.\n  case (le_lt_dec a 0); intro.\n  elim (H0 (n-a)); intro r'.\n  apply (lt_wf_rec a (fun a:nat => {q : nat &  {r : nat | a = b * q + r}}}).\n  intro q; elim (H0 (S p)); intro r'.\n  elim H0; intro.\n  elim H1; intro r'.\n  elim (H1 (S q)); intro r''.\n  elim (H0 (S q)); intro r''.\n  elim (H0 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H2 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H1 (S q)); intro r''.\n  elim (H1 (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \n",
                "context_tokens": 721,
                "proof_start_offset": 3449,
                "proof_end_offset": 4020,
                "proof": "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\nintros.\nred.\nsplit;intro.\ngeneralize (quo_rem_euclide a b H);intro.\ngeneralize (rem_euclide a b H);intro.\nelim H0;intro q;intro.\nassert (a=b*q+0).\nrewrite plus_comm;simpl;trivial.\nassert (0<b);try omega.\ngeneralize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\nintros;tauto.\ngeneralize (quo_rem_euclide a b H).\nrewrite H0;rewrite plus_comm;simpl.\nintro;exists (quotient_euclide a b H);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H.\n  case (le_lt_eq_dec 0 a); intro.\n  elim H; intro.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H1; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\n  rewrite <- H2; ring.\nQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H.\n  case (le_lt_eq_dec _ _ H); intro.\n  rewrite (le_plus_minus q' q) in H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite <- (abs_div_eucl31 a b H0 H).\n  apply egcdn; try assumption.\n  rewrite <- (abs_div_eucl31 a b H0).\n  change (a*(b*(q-q)) with (a*q).\n  rewrite (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite <- (mult_comm (a*q)).\n  rewrite (mult_comm (a*q)).\n  rewrite (mult_comm (aQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H0 in H.\n  case (lt_eq_lt_dec q (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H0.\n  case (le_eq_lt_dec (a*b) (b*q));intro.\n  rewrite <- (Zmult_comm a b).\n  apply (mul_reg_l (a*b) (b*q));intro;try omega.\n  rewrite <- (Zmult_comm a b).\n  apply (Zplus_reg_l (a*b) (b*q));intro; try omega.\n  rewrite <- H1.\n  apply (Zplus_reg_l (a*b) (b*q));intro; try omega.\n  rewrite H1; ring.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec b (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S (S (S(S (S(S (S (S(S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite <- H1 in H.\n  case (le_eq_lt_dec a b); intro.\n  rewrite <- (H1 b) in H.\n  generalize (H1 b H0);intro.\n  case (eq_lt_eq_dec a b); intro.\n  rewrite <- H2 in H.\n  apply (H1 b H0).\nQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H.\n  case (lt_eq_lt_dec q p);intro.\n  case a; intro.\n  rewrite (le_plus_minus q (p-q)) in H; try (auto with arith).\n  rewrite (mult_comm p) in H; try (auto with arith).\n  rewrite plus_comm in H.\n  rewrite plus_comm in H.\n  rewrite <- H.\n  replace (p+(p-q)) with p.\n  rewrite mult_plus_distr_l.\n  rewrite (mult_comm p).\n  rewrite (mult_comm q).\n  rewrite (mult_comm q).\n  rewrite mult_comm.\n  rewrite <- mult_plus_distr_l.\n  rewrite (mult_comm q).\n  rewrite mult_comm.\n  rewrite <- (mult_comm p).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm q).\n  rewrite (mult_comm q).\n  rewrite mult_comm.\n  rewrite (mult_comm q).\n  rewrite (mult_comm q).\n  rewrite mult_comm.\n  rewrite (mult_comm p).\n  rewrite mult_comm.\n  rewrite (mult_comm p).\n  rewriteQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H.\n  case (lt_eq_lt_dec q q);intro.\n  case (lt_eq_lt_dec q q);intro.\n  case (le_eq_lt_dec q q);intro.\n  rewrite H1 in H1.\n  generalize (pos_bound_pos_bound b (pos_bound_pos b (pos_bound_pos b (pos_bound_pos b (pos_bound b (pos_bound b (pos_bound b (pos_bound b))))) H0); intro.\n  rewrite H1 in H1.\n  case (lt_eq_lt_dec q q);intro.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  generalize (pos_bound_pos_bound b (pos_bound_pos b (pos_bound b (pos_bound b (pos_bound b (pos_bound b))))) H1); intro.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H1 in H.\n  case (le_eq_lt_dec a b); intro.\n  elim H; intro.\n  rewrite H1 in H.\n  rewrite (H0 b).\n  apply (le_not_eq (S a) (S b)).\n  rewrite H0; ring.\n  rewrite <- H0; ring.\n  apply (le_not_eq (S b) (S b)).\n  rewrite H0; ring.\n  rewrite <- H0; ring.\n  apply (le_not_eq (S b)); auto.\n  apply le_lt_trans with (S (S (S a))); auto.\n  rewrite H0; ring.\n  apply (le_not_eq (S b)); auto.\n  apply le_lt_trans with (S (S a)); auto.\n  rewrite H0; ring.\n  rewrite <- H0; ring.\n  apply (le_not_eq (S b)); auto.\n  apply lt_le_trans with (S (S a)); auto.\n  rewrite H0; ring.\n  apply (le_not_eq (S a)); auto.\n  apply lt_le_trans with (S (S b));Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\n",
                "context_tokens": 735,
                "proof_start_offset": 4055,
                "proof_end_offset": 4426,
                "proof": "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\nintros.\ncase (eq_nat_dec b 0).\ncase (eq_nat_dec a 0);intros.\nrewrite e;left;apply zero_max_div.\nright;rewrite e;intro.\nelim H;intro q;intro.\nsimpl in H0;apply n;trivial.\nintro.\ncase (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros.\n  destruct (Even_dec a b) as [H|H].\n  left; exists 1; trivial.\n  right; exists 1; trivial.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  elim H1; intro.\n  elim H1; intro.\n  assumption.\n  intros.\n  elim H2; intro.\n  elim H2; intro.\n  assumption.\n  elim H3; intro.\n  assumption.\n  intros.\n  elim H4; intro.\n  assumption.\n  intros.\n  elim H5; intro.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.\n  elim H5; intro.\n  assumption.Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  assert (H3 := even_odd a b H);intro.\n  elim H3; intro.\n  exists (S a).\n  rewrite H3; auto.\n  rewrite <- (mult_comm a (S b)).\n  rewrite <- H3.\n  simpl; auto.\n  rewrite <- (mult_comm b (S b)).\n  rewrite <- H3.\n  simpl; auto.\n  rewrite <- (mult_comm b (S a)).\n  rewrite H3; simpl; auto.\n  rewrite <- (mult_comm a (S b)).\n  rewrite <- H3.\n  simpl; auto.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros; elim H; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p; intro.\n  apply (p _ (p' * p' * p')).\n  apply H0; auto.\n  elim p; intro.\n  elim p0; intro.\n  elim p0; intro.\n  elim p0; intro.\n  apply (p _ (p' * p' * p')).\n  apply H1; auto.\n  apply (p' _ (p' * p' * p' * p')).\n  apply H0; auto.\n  apply (p' * p' * p' * p').\n  apply H0; auto.\n  apply (p' * p' * p' * p').\n  apply H0; auto.\n  apply (p' * p' * p' * p').\n  apply H0; auto.\n  apply (p' * p' * p' * p').\n  apply H0; auto.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize (gcd_gcd_pos a b H); intros.\n  elim H; intro.\n  rewrite (H1 (S b) H1 H2 H4) in H0.\n  rewrite H0 in H0.\n  case (le_lt_eq_dec b (S b)).\n  intro.\n  elim H0; intro.\n  rewrite H1; rewrite (H1 (S b) H1 H2) in H0.\n  generalize (gcd_gcd_pos a b H0); intro.\n  elim H0; intro.\n  rewrite H1; rewrite (H1 (S b) H2) in H0.\n  generalize (gcd_gcd_pos a b H0); intro.\n  elim H0; intro.\n  rewrite H1; rewrite H2; rewrite H3; rewrite H4; auto.\n  intro; exists (quotient_euclBy a b H);trivial.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (le_lt_eq_dec a b); intro.\n  case (le_lt_eq_dec a b); intro.\n  case (le_lt_eq_dec b a); intro.\n  generalize (pos_pos_pos a); omega.\n  generalize (pos_pos_pos a); omega.\n  generalize (pos_pos_pos a); omega.\n  generalize (pos_pos_pos a); omega.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros.\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  rewrite H0; simpl; trivial. }\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  rewrite H0; simpl; trivial. }\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  rewrite H0; simpl; trivial. }\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  rewrite H0; simpl; trivial. }\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  rewrite H0; simpl; trivial. }\n  assert (H:(b<>0)%positive).\n  { apply (H (gcd a b)). }\n  rewrite H0; simpl; trivial. }\n  assert (H:(b<>0)%positive).\n  { applyQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intro.\n  generalize (pos_bound_bound a b H);intro.\n  elim H; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p; intro.\n  elim p0; intro.\n  elim p0; intro.\n  elim p0; intro.\n  elim p1; intro.\n  elim p2; intro.\n  elim p1; intro.\n  elim p3; intro.\n  elim p4; intro.\n  elim p4; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p6; intro.\n  elim p5; intro.\n  elim p5; intro.\n  elim p6; intro.\n  elim p6; intro.\n  elim p7; intro.\n  elim p5; intro.\n  elim p7; intro.\n  elim p6; intro.\n  elim p7Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  destruct (H (b*q) H0) as (b,(H1,H2)).\n  rewrite H1 in H1.\n  case (gcd_eucl rem_eucl ropp a b H1); intro.\n  case (gcd_eucl rem_eucl rmul a b H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul a b H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul a b H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  case (gcd_eucl rem_eucl rmul b a H1); intro.\n  caseQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  apply (H1 (S (S b)) (S (S b))).\n  apply H.\n  apply (H1 (S (S b))).\n  apply H0.\n  apply le_trans with (b*q).\n  rewrite plus_comm;simpl; trivial.\n  rewrite plus_comm;simpl; trivial.\n  apply le_plus_compat; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\n",
                "context_tokens": 685,
                "proof_start_offset": 4561,
                "proof_end_offset": 4980,
                "proof": "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\nintros.\ninduction m.\nright;intros;inversion H0.\ncase (H m);intro.\nleft;exists m;split;try (auto with arith).\ncase IHm;intro.\nelim s;intro n0;intro.\nleft;exists n0;split;[omega | tauto].\nright;intros.\ninversion H0;trivial.\napply n0;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m n).\n  intros.\n  case (eq_nat_dec m n).\n  intros.\n  case (eq_nat_dec m n); intros.\n  elim H1; intro.\n  rewrite e.\n  apply H1; assumption.\n  intro; absurd (m=n); try omega.\n  case (eq_nat_dec m n); intros.\n  apply H1; assumption.\n  apply H1; assumption.\n  intro; absurd (m=n); try omega.\n  case (eq_nat_dec m n); intros.\n  apply H2; assumption.\n  apply H1; assumption.\n  intro; absurd (m=n); try omega.\n  case (eq_nat_dec m n); intros.\n  apply H1; assumption.\n  apply H1; assumption.\n  apply H1; assumption.\n  intro; absurd (m=n); try omega.\n  case (eq_nat_dec m n); intros.\n  apply H1; assumption.\n  apply H1; assumption.\n  apply H1; assumption.\n  apply H1; assumption.\n  intro; absurd (m=n); try omega.\n  case (eq_Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0); intros.\n  rewrite e;right; trivial.\n  destruct (eq_nat_dec m 0); [|left]; intros.\n  generalize (le_or_lt_dec m 0);intro.\n  generalize (le_lt_trans m 0 (le_S_le_dec m (S_le_dec m (S_le_dec m (S_le_dec m (S_le_dec m (S_le_dec m (S_le_dec m (S_le_dec m (S_le_dec m (S_le_eq_dec m (S_le_eq_dec m (S_le_eq_dec m (S_le_eq_dec m (S_le_eq_dec m (S_le_eq_dec m (S_le_eq_eq_dec m (S_eq_eq_eq_dec m (S_le_eq_eq_dec m (S_le_eq_eq_dec m (S_le_eq_dec m (S_le_eq_eq_eq_dec m (S_eq_eqQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  destruct (dec_dec (P n) (eq_nat_dec m n)).\n  left;intros.\n  generalize (H1 m H2); clear H1.\n  destruct (dec_dec (P n) (eq_nat_dec m n)); auto.\n  right; intros.\n  destruct (eq_nat_dec (headCP (P n))); auto.\n  left; intros.\n  generalize (H2 m H2); clear H2.\n  destruct (eq_nat_dec (headCP (P m))); auto.\n  left; intros.\n  apply H; auto.\n  right; intros.\n  generalize (H2 m H2); clear H2.\n  destruct (eq_nat_dec (headCP (P m))); auto.\n  right; intros.\n  apply H; auto.\n  right; intros.\n  destruct (eq_nat_dec (headCP (P m))); auto.\n  right; intros.\n  apply H; auto.\n  right; intros.\n  destruct (eq_nat_dec (headCP (P m))); auto.\n  left; intros.\n  destruct (eq_nat_dec (headCP (P m))); auto.\n  right; intros.\n  apply H; autoQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m 0).\n  case (eq_nat_dec m 0); intros.\n  left.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0); intros.\n  left.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0);intros.\n  left.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0);intros.\n  left.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0); intros.\n  right.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0); intros.\n  right.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0); intros.\n  left.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0); intros.\n  right.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0); intros.\n  right.\n  generalize (le_refl m).\n  case (eq_nat_dec m 0); intros.\n  left.\n  generalize (le_refl m).\n  caseQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  elim H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  Proof.\n    intros.\n    case (eq_nat_dec n (Zsqrt_dec n (converges_dec m n))).\n    intros.\n    elim (eq_nat_dec (Zsqrt_dec m (Psub_dec m (mingroupP_dec m (mingroupP_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m ( using_dec m (generalize m ( using_dec m (generalize m (generalize m)))).\n    intros;apply H; auto.\n    apply H; auto.\n    intro; exists (S m); split; auto.\n    intros; apply H; auto.\n  Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  destruct (dec_dec (P n) (P (S m))) as (m,(H1,H2)).\n  left.\n  apply H1.\n  apply le_lt_trans with m; auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\n  apply le_lt_trans with (m + S m); auto.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  destruct (le_dec n m); [left | right].\n  apply (H _ H1 H2).\n  apply (H _ H1 H2).\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec m n);intros.\n  left.\n  apply (H (S m));auto with arith.\n  right; apply (H (S m));auto with arith.\n  right;apply (H (S m));auto with arith.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (eq_nat_dec n 0).\n  case (eq_nat_dec n 0).\n  intros.\n  generalize (le_refl n H0).\n  rewrite H0;rewrite (le_plus_minus q n).\n  apply le_plus_le_compat.\n  apply le_minus.\n  apply le_plus_le_compat.\n  apply le_minus.\n  apply le_n_Sn.\n  apply le_trans with (m:=n); trivial.\n  apply le_plus_le_compat.\n  apply le_plus_le_compat.\n  apply le_trans with (m:=n); trivial.\n  apply le_plus_le_compat.\n  apply le_minus.\n  apply le_trans with (m:=n); trivial.\n  apply le_plus_le_compat.\n  apply le_minus.\n  apply le_trans with (m:=n); trivial.\n  apply le_plus_le_compat.\n  apply le_minus.\n  apply le_n_Sn.\n  apply le_n_Sn.\n  apply le_plus_le_compat.\n  apply le_minus.\n  apply le_plus_le_compat.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\nLemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  induction m.\n  right;intros;inversion H0.\n  case (H m);intro.\n  left;exists m;split;try (auto with arith).\n  case IHm;intro.\n  elim s;intro n0;intro.\n  left;exists n0;split;[omega | tauto].\n  right;intros.\n  inversion H0;trivial.\n  apply n0;omega.\nQed.\n\n(** forall n, either forall p, p<>1 /\\ p<>n -> not(p | n) or there is p such that p<>1 and p<>n and p | n *) \n",
                "context_tokens": 706,
                "proof_start_offset": 5092,
                "proof_end_offset": 5809,
                "proof": "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\nintros.\ncase (dec_impl_lt_dec (fun p => (p<>1)/\\(divides n p))) with n;intros.\ncase (divides_dec n n0);intro.\ncase (eq_nat_dec n0 1);intros.\nright;intro;tauto.\nleft;tauto.\nright;tauto.\nelim s;intros.\nleft;exists x.\nsplit;try tauto.\nsplit;try tauto.\nomega.\ncase (eq_nat_dec n 0);intro.\nrewrite e;left;exists 2.\nsplit;try (intro;discriminate).\nsplit;try (intro;discriminate).\napply zero_max_div.\nright;intros.\ncase (lt_eq_lt_dec p n);intro.\ncase s;intro;[red in n0;intro;apply n0 with p;tauto | auto].\nintro;generalize (divides_le n p n1 H1);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (le_or_lt p n) as [H|H].\n  left;intros;inversion H.\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H0.\n  left;intros;inversion H1.\n  left;intros;inversion H1.\n  right;intros;inversion H1.\n  left;intros;inversion H1.\n  left;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  left;intros;inversion H1.\n  left;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  left;intros;inversion H1.\n  left;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  left;intros;inversion H1.\n  left;intros;inversion H1.\n  left;intros;inversion H1.\n  right;intros;inversion H1.\n  left;intros;inversion H1.\n  right;Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  induction n.\n  left;intros.\n  case (H m);intro.\n  left;intros;inversion H0.\n  left;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  left;intros;inversion H1.\n  apply n0;omega.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (eq_nat_dec p n); intros.\n  left;exists n;split;try (auto with arith).\n  right;intros.\n  apply (H p).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~0).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~0).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~0).\n  apply le_lt_trans with (p~0).\n  apply le_lt_trans with (p~1).\n  apply le_lt_trans with (p~1).\n  apply le_lt_transQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (le_or_lt p n) as [H|H].\n  left;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.\n  left;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right; intros;inversion H.\n  left;intros;inversion H.\n  right;introsQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  elim (le_or_lt n p);intros.\n  left;intros n H; inversion H.\n  left;intros n H; inversion H.\n  left;intros n H; inversion H.\n  right;intros n H; inversion H.\n  right; intros n H; inversion H.\n  right;intros n H; inversion H.\n  right;intros n H; inversion H.\n  left;intros n H; inversion H.\n  left;intros n H; inversion H.\n  left;intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  left; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  left; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.\n  right; intros n H; inversion H.Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  inversion H.\n  left;intros;inversion H0.\n  case (eq_nat_dec p n);intros.\n  apply H.\n  left;intros.\n  apply H.\n  left;intros.\n  apply H.\n  right;intros.\n  apply H0.\n  left;intros.\n  apply H.\n  right;intros.\n  apply H.\n  apply H.\n  left;intros.\n  apply H0.\n  left;intros.\n  apply H.\n  apply H.\n  left;intros.\n  apply H.\n  apply H0.\n  right;intros.\n  apply H0.\n  apply H.\n  left; intros.\n  apply H0.\n  apply H.\n  apply H0.\n  right; intros.\n  apply H0.\n  apply H1.\n  left; intros.\n  apply H.\n  apply H0.\n  left; intros.\n  apply H.\n  apply H.\n  apply H1.\n  right; intros.\n  apply H.\n  apply H0.\n  apply H0.\n  right; intros.\n  apply H.\n  apply H0.\n  left; intros.\n  apply H.\n  apply H.\n  apply H0.\n  right; intros.Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (p==1) as [p' [Hpp' Hpp']].\n  apply Hqp';auto.\n  apply Hpp';auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (p p) as [p|p].\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H0.\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  right;intros;inversion H0.\n  right;intros;inversion H0.\n  apply n0;omega.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros; generalize (pos_bound n p H);intro.\n  destruct H.\n  left;intros; inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H0.\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H0.\n  left;intros;inversion H0.\n  left;intros;inversion H0.\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H0.\n  right;intros;inversion H.\n  right;intros;inversion H0.\n  left;intros;inversion H.\n  right;intros;inversion H0.\n  right;intros; inversion H0.\n  right; intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  induction n.\n  right;intros.\n  apply H;auto.\n  right;intros;inversion H0.\n  right;intros;inversion H0.\n  right;intros;inversion H0.\n  left;intros.\n  apply H;auto.\n  right;intros;inversion H0.\n  left;intros.\n  apply H;auto.\n  right;intros;inversion H0.\n  left;intros.\n  apply H;auto.\n  right;intros;inversion H0.\n  left;intros.\n  apply H;auto.\n  right;intros;inversion H0.\n  left;intros.\n  apply H;auto.\n  right;intros.\n  apply H;auto.\n  right;intros.\n  apply H;auto.\n  apply H;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\n",
                "context_tokens": 382,
                "proof_start_offset": 1408,
                "proof_end_offset": 2212,
                "proof": "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_square;trivial.\nexists (k*(square b)).\nrewrite <- H2;ring.\nelim H3;intro n_a;intro.\nrewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\nassert (k*(b*b)=p*(n_a*n_a)).\napply mult_lemma6 with p.\nintro H5;rewrite H5 in H;apply not_prime_zero;trivial.\nrewrite mult_assoc;rewrite H2;ring.\nassert (divides b p).\napply prime_square;trivial;unfold square.\napply gauss with k.\napply rel_prime_sym;trivial.\nexists (n_a*n_a);trivial.\nassert (p=1).\nunfold rel_prime in H1.\nelim H1;intros.\napply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nelim H;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b c d H_neq H_neq H_neq.\n assert (H_neq0 : 0 < p).\n apply lt_le_trans with (k*p)%nat.\n assumption.\n apply lt_le_trans with (k*p)%nat.\n assumption.\n apply le_trans with (k*p)%nat.\n assumption.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\ninduction p as [| p IHp| p IHp| p IHp| ]; intros p [| p| p| p] Hp;\n  try discriminate Hp;\n  [ rewrite (sqrt_neg_1 p) | rewrite (sqrt_neg_2 p) ].\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b.\n functional induction (P_p (P_p (P_p (P_p (P_p (P_p (S p)))).\n apply IHp.\n apply IHp.\n assumption.\n intros.\n apply IHp.\n assumption.\n intros.\n apply IHp.\n assumption.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n simple induction p.\n simpl.\n intros.\n apply False_ind.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (S p)).\n simpl.\n apply (H (Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b; unfold rel_prime.\n case (gcd_divisors p k); intros.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n applyQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\ninduction p; simpl; intros; auto with zarith.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nsimple induction p.\n simpl in |- *.\n intros p IH p IH p IH p IH p IH p IH p IH p IH p IH p.\nelim (le_lt_eq_dec 0 p).\n(* 0 < p *)\n intros p IH p IH p IH p IH p IH p IH p.\nelim (le_lt_eq_dec 0 p).\n(* 1 < p *)\nintros p IH p IH p IH p IH p IH p.\nelim (le_lt_eq_dec 0 p).\n(* 1 < p *)\nintros p IH p IH p IH p IH p IH p.\nelim (le_lt_eq_dec 0 p).\n(* 1 < p *)\nintros p IH p IH p IH p IH p IH p.\nelim (le_lt_eq_dec 0 p).\n(* 1 < p *)\nintros p IH p IH p IH p IH p IH p.\nelim (le_lt_eq_dec 0 p).\n(* 1 < p *)\nintros p IH p IH p IH p IH p IH p IH p IH p.\nelim (le_lt_eq_dec 0 p).\n(* 1 <Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b.\nrewrite <- (sqrt_prime_inc p k a b).\nfield.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n apply sqrt_prime_irrat_aux.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\ninduction p; simpl; auto.\ndestruct a as [p|p]; simpl; auto.\ndestruct b as [p|p]; simpl; auto.\ndestruct p as [p|p]; simpl; auto.\ndestruct (Pos.pred_double p); simpl; auto.\ndestruct (Pos.pred_double p); simpl; auto.\ndestruct (Pos.pred_double p); simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "t (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\nLemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\n",
                "context_tokens": 696,
                "proof_start_offset": 2307,
                "proof_end_offset": 3364,
                "proof": "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\nintro.\nrewrite H3 in H5.\nreplace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\nrewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\nassert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\napply mult_lemma6 with (square (gcd a b)).\nunfold square.\ngeneralize (gcd_non_zero (gcd a b) a b H1 H2);intro.\nintro;apply H6.\ncase (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\nrewrite <- H5;ring.\napply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros; elim H; intros.\n  exists (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  elim H.\n  intros.\n  exists 1.\n  apply sqrt_prime_irrat_aux.\n  assumption.\n  intros.\n  elim H2.\n  intros.\n  elim H3; intro n_c.\n  rewrite H4 in H2; rewrite square_mult_lemma in H2; unfold square in H2.\n  elim H2.\n  intros.\n  elim H3; intro n_c.\n  rewrite H5 in H3; rewrite square_mult_lemma in H3; unfold square in H3.\n  elim H3.\n  intros.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply lt_le_trans with (S (pred (S (S n)))).\n  apply lt_pred_n_n.\n  apply H8.\n  apply lt_le_trans with (S (pred (S (S n)))).\n  apply le_pred_n_n.\n  apply H8.\n  apply lt_le_trans with (S (pred (S (S n)))))).\n  apply lt_pred_n_n.\n  apply H8.\n  apply lt_le_trans with (S (pred (S (S (S nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  assert (H := even_exists_factor_prime p a b H).\n  elim H; intros.\n  apply sqrt_prime_factor_prime_factor_prime_factor; assumption.\n  elim H; intros.\n  exists (k*(k*k)).\n  rewrite <- H2; ring.\n  elim H0; intros.\n  apply sqrt_prime_factor_prime_factor; assumption.\n  apply H1; assumption.\n  exists (k*k); rewrite <- H2; ring.\n  apply div_prime_factor_prime_factor; assumption.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  assert (H := sqrt_prime_merat p k a b).\n  destruct H as [H|H].\n  apply sqrt_prime_rerat.\n  destruct (interp_non_zero p) as [H|H].\n  apply sqrt_prime_merat.\n  destruct (interp_non_zero p) as [H|H].\n  apply sqrt_prime_merat; trivial.\n  destruct (interp_non_zero p) as [H'|H'].\n  apply sqrt_prime_melog; trivial.\n  apply sqrt_prime_melog; trivial.\n  apply sqrt_prime_sym; trivial.\n  rewrite <- H'; field.\n  apply sqrt_prime_melog; trivial.\n  apply sqrt_prime_sym; trivial.\n  rewrite <- H'; field.\n  apply sqrt_prime_sym; trivial.\n  rewrite <- H'; field.\n  apply sqrt_prime_sym; trivial.\n  apply sqrt_prime_sym; trivial.\n  apply sqrt_prime_sym; trivial.\n  apply sqrt_prime_sym; trivial.\n  apply sqrt_prime_sym; trivial.\n  apply sqrt_prime_sym; trivial.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  unfold sqrt, sqrt.\n  case (Pnot_prime p); intro.\n  rewrite H.\n  rewrite <- H0; reflexivity.\n  rewrite <- H1; reflexivity.\n  apply sqrt_prime_factor; assumption.\n  apply sqrt_prime_factor; assumption.\n  apply sqrt_prime_factor; assumption.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  elim H; intros.\n  exists (S(k*(k*k)); rewrite H1; ring.\n  exists (S(k*k)); rewrite H1; ring.\n  exists (S(k*k)); rewrite H1; ring.\n  exists (S(k*k)); rewrite H1; ring.\n  exists (S(k*k)); rewrite H1; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H2; ring.\n  exists (S(k*k)); rewrite H1; ring.\n  exists (S(Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  assert (H := even_lt p).\n  elim H; intro.\n  apply prime_square;trivial.\n  rewrite <- H1; ring.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply H; assumption.\n  apply sqrt_prime_factor.\n  apply HQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  elim (not_or_lt k a); intros.\n  rewrite <- H1; apply sqrt_prime_merat.\n  rewrite H0; apply sqrt_prime_merat.\n  apply H; assumption.\n  apply sqrt_prime_merat.\n  apply H; assumption.\n  apply sqrt_prime_merat.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  unfold is_prime in H.\n  elim H; intros.\n  apply (H3 p); trivial.\n  apply (H1 p).\n  apply (H1 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H1 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H1 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H1 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 p).\n  apply (H2 pQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  case (is_prime_ulp (S p) (S p)) ; intros.\n  rewrite H0 in H0.\n  discriminate.\n  elim H0; intros.\n  apply prime_prime_factor_prime_irrat_aux.\n  apply H1; assumption.\n  elim H0; intros.\n  apply prime_prime_factor_prime_cross_log_aux.\n  apply H1; assumption.\n  elim H0; intros.\n  apply prime_prime_factor_prime_cross_log_aux.\n  apply H1; assumption.\n  elim H0; intros.\n  apply prime_prime_factor_prime_cross_log_aux.\n  apply H1; assumption.\n  elim H1; intros.\n  apply prime_prime_factor_prime_cross_log_aux.\n  apply H1; assumption.\n  elim H1; intros.\n  apply prime_prime_factor_prime_cross_log_aux.\n  apply H2; assumption.\n  elim H1; intros.\n  apply prime_prime_factor_prime_cross_log_aux.\n  apply H1; assumption.\n  elim H1; intros.\n  apply prime_prime_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\n",
                "context_tokens": 720,
                "proof_start_offset": 3417,
                "proof_end_offset": 3629,
                "proof": "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\nintros.\nreplace p with (p*1);try (auto with arith).\napply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\nassert (H := sqrt_prime p H).\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassert (H' := sqrt_prime p H').\nassertQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\nassert (H := sqrt_prime a H).\nrewrite <- (sqrt_prime a H); auto.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\nunfold sqrt.\ndestruct (lt_ge_dec (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S (S(S (S (S (S (S(S (S(S (S (S(S(S(S(S(S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H1 H2));intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H2));intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H2);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H2);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H2);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H2);intro.\n  generalize (gcdQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\napply div_unique with (q:=1); trivial.\napply (pos_bound_divide p p); trivial.\napply (pos_bound_divide p q); trivial.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros.\n  generalize (sqrt_prime_cross_log p (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcdQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\nassert (H : forall (a b:nat)(p:p), p<a -> p<b -> p<b -> p<b).\nintros.\nassert (H0 : forall (a b:nat)(p:p), p<a -> p<b -> p<b).\nintros.\nassert (H1 : forall (a b:nat)(p:p), p<b -> p<b -> p<b).\nintros.\nassert (H2 : forall (a b:nat)(p:p), p<a -> p<b -> p<b).\nintros.\nassert (H3 : forall (a b:nat)(p:p), p<a -> p<=b -> p<b).\nintros.\nassert (H4 : forall (a b:nat)(p:p), p<a -> p<b -> p<b).\nintros.\nassert (H4 : forall (a b:nat)(p:p), p<a -> p<b -> p<b).\nintros.\nassert (H4 : forall (a b:nat)(p:p), p<a -> p<b -> pQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\nassert (H := sqrt_prime p); unfold sqrt; clear p; intros a b H.\nelim (le_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n (* b=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt b a); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (lt_or_lt b a); intros.\n(* a=b *)\nelim (lt_or_lt a b); intros.\n(* a=b *)\nelim (ltQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\nassert (H : forall (a b:nat)(p:nat),\n     (a + b - p + b) = (a + b - p) * p + b).\n  intros a b.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm b a) at 1.\n  rewrite (mult_comm b a) at 1.\n  rewrite <- (mult_comm a b) at 1.\n  rewrite (mult_comm b a) at 1.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm (a + b)) at 1.\n  rewrite <- (mult_comm a b) at 1.\n  rewrite (mult_comm (a + b)) at 1.\n  rewrite (mult_comm b a) at 1.\n  rewrite (mult_comm b a) at 1.\n  rewrite (mult_comm b a) at 1.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm a b) at 1Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nintros.\napply sqrt_prime.\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 (pos_sub_prime_factor p 2 n))).\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 n)).\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 n)).\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 n)).\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 n)).\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 n)).\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 n)).\nrewrite <- (sqrt_prime_factor p 2 (pos_sub_prime_factor p 2 n)).\nrewrite <- (sqrt_prime_factor p 2 n).\nrewrite <- (sqrt_prime_factor p 2 n).\nrewrite <- (sqrt_prime_factor p 2 n).\nrewrite <- (sqrt_prime_factor p 2 n).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3719,
                "proof_end_offset": 3854,
                "proof": "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\nintros.\napply sqrt_prime;trivial.\napply is_prime_2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  replace p with (p*(2*(square p) * (2*(square p))).\n  apply sqrt_2_rolog; trivial.\n  apply sqrt_2_sqrt; trivial.\n  apply sqrt_2_sqrt; trivial.\n  apply sqrt_2_sqrt; trivial.\n  apply sqrt_2_sqrt; trivial.\n  apply sqrt_2_sqrt; trivial.\n  apply sqrt_2_sqrt; trivial.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_2_repalog;trivial.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n  apply sqrt_2_sqrt_spec.\n Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros;unfold sqrt.\n  generalize (sqrt_up_2_alt p q H);intro.\n  assert (p<>0).\n  apply sqrt_2_le;auto with arith.\n  apply (sqrt_sqrt_spec p q H0);apply sqrt_2_le;auto with arith.\n  apply (sqrt_sqrt_spec p q H0);apply sqrt_2_le;auto with arith.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  replace p with (p*(2*(square p) * (2*(square p) * (2*(square p) * (2*(square p) * (2*(square p) * (2*(square p) * (2*(square p)))%R.\n  apply sqrt_2_irrat;trivial.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_2_*2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2*(2))))))))).\n  apply sqrt_2_compat; auto with real.\n  apply sqrt_2_le; auto with real.\n  apply sqrt_2_le; auto with real.\n  apply sqrt_2_le; auto with real.\n  apply sqrt_2_le; auto with real.\n  apply sqrt_2_le; auto with real.\n  apply sqrt_2_le; auto with real.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  assert (H := sqrt_2_up p q H).\n  rewrite <- sqrt_2_up; trivial.\n  apply (sqrt_prime (2 * p) (2 * p) + (2 * p) * (2 * q)).\n  apply sqrt_2_le_1; assumption.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_2_up_is_gcd;trivial;apply sqrt_2_up_2.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  destruct (sqrt_div_2_inf p q) as (q,Hq).\n  destruct (sqrt_div_2_inf p q) as (q',Hq').\n  apply mul_1_r.\n  apply mul_2_r.\n  apply mul_2_r.\n  apply mul_2_r.\n  apply mul_2_r.\n  apply mul_2_r.\n  apply mul_le_mono_nonneg_l; auto with arith.\n  apply mul_le_mono_nonneg_l; auto with arith.\n  apply mul_le_mono_nonneg_l; auto with arith.\n  apply mul_le_mono_nonneg_l; auto with arith.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  rewrite <- (sqrt_spec q (2*(square q) (2*(square q) (2*(square q) (2*(square q) (2*(square q) (2*(square q) (2*(square q) (S q)))))).\n  apply sqrt_2_irlog;trivial;apply sqrt_2_up; assumption.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_2_irrat;trivial;apply sqrt_2_irlog;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": ".\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\n",
                "context_tokens": 694,
                "proof_start_offset": 3878,
                "proof_end_offset": 5151,
                "proof": "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_power with n;trivial.\ngeneralize (power_divides_lemma1 r p H1);intro.\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite <- H4;exists (q*k*(power b n));ring.\nassert (divides b p).\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite power_mult_lemma1 in H4.\nassert ((power p n)=(power p (r+(n-r)))).\nrewrite <- le_plus_minus;try (auto with arith).\nrewrite H7 in H4;rewrite power_plus_lemma1 in H4.\nassert ((power p r)<>O).\nintro.\napply not_prime_zero.\nassert (p=O).\napply power_zero with r;trivial.\nrewrite H9 in H;trivial.\nrewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\nassert (divides (power p (n-r)) p).\napply power_divides_lemma1;apply minus_lt_lemma1;trivial.\napply prime_power with n;trivial.\napply gauss with k;try (apply rel_prime_sym;trivial).\nrewrite H9;apply divides_mult;trivial.\nelim H3;intros.\nelim H;intros.\napply H9;apply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  replace p with (p*k*(pow p 1) + (pow p 1))%Z by ring.\n  rewrite (mult_comm (2*2)) at 1.\n  rewrite (mult_comm (2*2)) at 1.\n  rewrite (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2*2)) at 1.\n  rewrite <- (mult_comm (2Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply sqrt_prime_merat_aux;trivial.\n  apply is_prime_div.\n  apply is_prime_div.\n  apply is_prime_mul.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply sqrt_prime_irrat;trivial.\n  apply (sqrt_prime_irrat_aux p k a b n r (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S (S (S (S (S (S (S (S(S(S(S(S (S(S(S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply (sqrt_prime_merat_aux p k (le_le_S_le_trans _ _ _ r (le_le_S_le_trans _ _ _ r (le_le_S_le_trans _ _ _ r (le_le_S_le_trans _ _ r (le_le_S_le_trans _ _ r r (le_le_S_le_trans _ _ r r (le_le_S_le_trans _ _ r r (le_le_S_le_trans _ _ r r (le_le_S_le_trans _ r r r (le_le_S_le_trans _ _ r r (le_le_S_le_trans _ r r (le_le_S_le_trans _ r r r (le_le_S_le_trans _ _ r (le_le_S_le_trans _ _ r r (le_le_S_le_trans _ r r r (le_le_S_trans _ r r (le_le_trans _ r r (le_le_Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nintros.\napply sqrt_nonneg_bound;trivial.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  replace p with ((p*k*(pow p k)+p)).\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  replace p with (p*k*(pow p k)+p).\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  replace p with (p*k*(pow p k)+p).\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  apply (well_founded_induction_type (fun a b => a=b)).\n  intros.\n  apply (well_founded_induction_typeQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nintros.\nassert (a=3).\napply sqrt_even;trivial.\nassert (H:=sqrt_even a b);omega.\nassert (a=2).\nassert (a=2).\n apply sqrt_odd;trivial.\nassert (b<>0).\n apply sqrt_odd;trivial.\nassert (b=2).\n apply sqrt_even;trivial.\nassert (b<>0).\n apply sqrt_even;trivial.\nassert (0<0).\n apply sqrt_odd;trivial.\nassert (b<>0).\n apply sqrt_even;trivial.\nassert (0<=0).\n apply sqrt_even;trivial.\nassert (b<>0).\n apply sqrt_even;trivial.\nassert (0<2).\napply sqrt_even;trivial.\nassert (b<>0).\n apply sqrt_even;trivial.\nassert (b<>0).\n apply sqrt_odd;trivial.\nassert (0<=0).\n apply sqrt_odd;trivial.\nassert (b<>0).\n apply sqrt_even;trivial.\nassert (0<2).\n apply sqrt_even;trivial.\nassert (b=2).\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  generalize (sqrt_prime_irrat p k a b);intro.\n  generalize (sqrt_prime_irlog p k a b);intro.\n  destruct (sqrt_prime_irlog p k a) as (q,H').\n  generalize (sqrt_prime_irlog p k a b H');intro.\n  generalize (sqrt_prime_crosslog p k a b);intro.\n  generalize (sqrt_prime_crosslog p k a b);intro.\n  generalize (sqrt_prime_crosslog p k a b);intro.\n  destruct (sqrt_prime_crosslog p k a) as (q,H').\n  generalize (sqrt_prime_crosslog p k a b);intro.\n  destruct (sqrt_prime_crosslog p k a) as (q,H').\n  generalize (sqrt_prime_crosslog p k a b H'); intro.\n  generalize (sqrt_prime_crosslog p k a b H'); intro.\n  generalize (sqrt_prime_crosslog p k a b); intro.\n  generalize (sqrt_prime_crosslog p k a b H');intro.\n  generalize (sqrt_prime_crosslog p k a b H'); introQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_even_2.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_even;trivial.\n  apply is_prime_1;trivial.\n  apply is_prime_2;trivial.\n  apply is_prime_1;trivial.\n  apply is_prime_2;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\nLemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_power with n;trivial.\n  generalize (power_divides_lemma1 r p H1);intro.\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite <- H4;exists (q*k*(power b n));ring.\n  assert (divides b p).\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite power_mult_lemma1 in H4.\n  assert ((power p n)=(power p (r+(n-r)))).\n  rewrite <- le_plus_minus;try (auto with arith).\n  rewrite H7 in H4;rewrite power_plus_lemma1 in H4.\n  assert ((power p r)<>O).\n  intro.\n  apply not_prime_zero.\n  assert (p=O).\n  apply power_zero with r;trivial.\n  rewrite H9 in H;trivial.\n  rewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\n  assert (divides (power p (n-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\n",
                "context_tokens": 698,
                "proof_start_offset": 5286,
                "proof_end_offset": 6579,
                "proof": "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\nassert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\nassert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\nrewrite power_mult_lemma1 in H8;rewrite H8 in H4.\nrewrite power_mult_lemma1 in H9;rewrite H9 in H4.\nrewrite mult_lemma7 in H4.\nassert ((power (gcd a b) n)<>O).\nintro.\ngeneralize (power_zero n (gcd a b) H10);intro.\napply (gcd_non_zero (gcd a b) a b);trivial.\ngeneralize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\nfold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\napply nth_root_irrat_aux;trivial.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  assert (n<>0).\n  apply lt_le_trans with (1:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  apply le_trans with (2:=H).\n  applyQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  destruct (p?= 0) as [p0|p0].\n  apply H; auto.\n  apply H; auto.\n  apply H0; auto.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  assert (H := even_div_eucl p).\n  assert (H := even_div_eucl p).\n  assert (H := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_div_eucl p).\n  assert (H' := even_divQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  assert (H := even_even_cor p).\n  destruct (even_odd_cor p) as [p0 [q0 H]].\n  rewrite <- (mult_1_r q0 p) in H; clear H.\n  destruct (odd_odd_cor p) as [p0 [q0 H]].\n  rewrite <- (mult_1_r q0 p) in H; clear H.\n  destruct (even_odd_cor p) as [p0 [q0 H]].\n  rewrite <- (mult_1_r q0) in H; clear H.\n  destruct (odd_odd_cor p) as [p0 [q0 H]].\n  rewrite <- (mult_1_r q0) in H; clear H.\n  destruct (odd_odd_cor p) as [p0 [q0 H]].\n  rewrite <- (mult_1_r q0) in H; clear H.\n  destruct (odd_odd_cor p) as [p0 [q0 H]].\n  rewrite <- (mult_1_r q0) in H; clear H.\n  destruct (odd_odd_cor p) as [p0 [q0Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  assert (exists n, (a*n+r)*(S n)).\n  apply H;exists n;trivial.\n  rewrite (mult_comm _ (S n)).\n  apply div_le_mono_l;assumption.\n  apply div_le_mono_l;assumption.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  assert (H := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  destruct (even_factor p) as (q,(q,(H1,H2)).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).\n  assert (H' := even_odd_factor p).Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  destruct (le_gt_cases 0 k).\n  subst k.\n  rewrite (H2 n) in H; discriminate.\n  rewrite H2; trivial.\n  omega.\n  omega.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  assert (exists n, (a+n)*(a+n)).\n  apply sqrt_up_lt;trivial.\n  assert (H3:=H3 p).\n  assert (H4:=H4 p).\n  assert (H4:=H4 p).\n  assert (H5:=H5 p).\n  assert (H6:=H5 p).\n  assert (H7:=H7 p).\n  assert (H8:=H7 p).\n  assert (H8:=H7 p).\n  assert (H8:=H7 p).\n  assert (H8:=H7 p).\n  assert (H8:=H7 p).\n  assert (H9:=H7 p).\n  assert (H9:=H7 p).\n  assert (H8:=H7 p).\n  assert (H8:=H7 p).\n  assert (H9:=H7 p).\n  assert (H9:=H7 p).\n  assert (H10:=H7 p).\n  assert (H10:=H7 p).\n  assert (H10:=H7 p).\n  assert (H10:=H7 p).\n  assert (H10:=H7 p).\n  assert (H10:=H7Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  generalize (sqrt_up_inf p a b n r H H0); intro.\n  elim H2; intro q; intros.\n  rewrite H3 in H0.\n  rewrite H4 in H0.\n  rewrite <- H4;trivial.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4;auto.\n  rewrite H4Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  assert (H1:=H).\n  assert (H2:=H).\n  apply (pow_le_lin_r (S p) (S p) (S p) H1 H2).\n  rewrite <- H2.\n  apply pow_lt_lin_r with (S p); trivial.\n  rewrite <- H1.\n  apply pow_lt_lin_r with (S p); trivial.\n  apply pow_lt_lin_r with (S p); trivial.\n  apply pow_lt_lin_r with (S p); trivial.\n  rewrite <- H2.\n  apply pow_lt_lin_r with (S p); trivial.\n  rewrite <- H1.\n  apply pow_lt_lin_r with (S p); trivial.\n  rewrite <- H2.\n  apply pow_lt_lin_r with (S p); trivial.\n  rewrite <- H2.\n  apply pow_lt_lin_r with (S p); trivial.\n  rewrite <- H1.\n  apply pow_lt_lin_r with (S p); trivial.\n  apply pow_lt_lin_r with (S p); trivial.\n  rewrite <- H2.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\nTheorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\n  assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\n  assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\n",
                "context_tokens": 691,
                "proof_start_offset": 6627,
                "proof_end_offset": 7532,
                "proof": "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nrewrite power_plus_lemma1 in H4.\nassert (divides a (power p q)).\napply prime_power_qn with n;try (auto with arith);try omega.\nexists ((power p r)*k*(power b n)).\nrewrite <- H4;ring.\nassert (0<n);try omega.\nelim H5;intro a';intro.\nrewrite H7 in H4.\nrewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\nassert ((power p (q*n))<>0).\nintro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\nrewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\ngeneralize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\nfold (power p r * k * power b n <> power a' n).\napply nth_root_irrat;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r (H,H).\nassert (H:=gcd_is_gcd a b).\ndestruct (le_gt_dec n 0).\nrewrite <- (mult_comm (S n)).\nrewrite H, <- (mult_comm (S n)).\nrewrite H.\napply add_reg_l with (r*k*(div p q) + (S n)).\nring.\nrewrite <- (mult_comm (S n)).\nrewrite H.\napply mul_reg_l with (r*k*(div p q) + (S n)).\nring.\nrewrite <- (mult_comm (S n)).\nrewrite H, <- (mult_comm (S n)).\nrewrite H.\napply mul_reg_l with (r*k).\nring.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nintros p k a b n q r H.\ndestruct (le_gt_dec 0 0) as [H|H]; [left|right]; trivial.\nrewrite <- (mult_comm (a*q)).\nrewrite <- (mult_comm (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (mult_assoc (a*q)).\nrewrite <- (multQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nintros p k a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H; rewrite <- H0; rewrite H1; ring.\nintros a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H; rewrite H1; ring.\nintros a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H; rewrite H1; ring.\nintros a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H; rewrite <- H0; ring.\nintros a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H; rewrite <- H0; ring.\nintros a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H; rewrite <- H0; rewrite H1; ring.\nintros a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H; rewrite H1; ring.\nintros a b n q r; case (le_gt_dec n 0); intro.\nrewrite <- H;Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r H1 H2 H3.\nunfold sqrt in H3.\ndestruct (le_lt_dec (q*n) + (q*n)) as [H4|H4];\n  [ rewrite H4; rewrite H4; ring|idtac].\nassert (H5: (1<0<0)%nat).\n  apply Rmult_le_compat_r; apply H1 | rewrite <- H4; ring ].\ndestruct (le_lt_dec (q*n)) as [H5|H5];\n  [rewrite H5; rewrite H5; ring|idtac].\nassert (H5: (0<0)%nat).\n  apply Rmult_le_compat_r; apply H1 | rewrite <- H5; ring].\ndestruct (le_lt_dec (q*n)) as [H5|H5];\n  [rewrite H5; rewrite H5; ring|idtac].\nassert (H5: (1<0)%nat).\n  apply Rmult_le_compat_r; apply H1 | rewrite <- H5; ring].\ndestruct (le_lt_dec (q*n)) as [Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nintros.\nassert (H:=sqrt_is_gcd a b);intro.\nassert (H':=sqrt_is_gcd b p);intro.\nassert (H':=sqrt_is_gcd a b);intro.\nassert (H':=sqrt_is_gcd b a);intro.\nassert (H':=sqrt_is_gcd b a);intro.\nassert (H':=sqrt_is_gcd b a H');intro.\napply (gcd_is_gcd b a);trivial.\nassert (H':=sqrt_is_gcd b a b H');intro.\napply (gcd_is_gcd b a b);trivial.\nassert (H':=sqrt_is_gcd b a);intro.\nassert (H':=sqrt_is_gcd b a H');intro.\nassert (H':=sqrt_is_gcd b a b H');intro.\napply (gcd_is_gcd b a b);trivial.\napply (gcd_is_gcd b a);trivial.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd (gcd a b) a b H0);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H5);intro.\n  generalize (gcd_is_gcd (gcd a b) a b H0);intro.\n  generalize (gcd_is_gcd (gcd (gcd a b) a b H5);intro.\n  generalize (gcd_is_gcd (gcd a b) a b H5);intro.\n  generalize (gcd_is_gcd (gcd (gcd a b) a) a b H5);intro.\n  generalize (gcd_is_gcd (gcd (gcd a b) a) a b H5);intro.\n  generalize (gcd_is_gcd (gcdQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros p k a b n q r Hr.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b q);intro.\n  generalize (gcd_is_gcd a q);intro.\n  generalize (gcd_is_gcd b q);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a b H5);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a (gcd_div_r (gcd a b) a b H5));intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a (gcd_div_r (gcd a b) a b H5));intro.\n  generalize (gcd_is_gcd a q);intro.\n  generalize (gcd_is_gcd (gcd a b) a (gcd_div_r (gcd a b) a (gcd_div_r (gcd a b) a H5));intro.\n  generalize (gcdQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r Hr.\nassert (Hp : (0 < p*q)%nat) by (unfold q; trivial; apply le_n_O).\nassert (Hp' : (0 < p*q)%nat) by (unfold q; trivial; apply le_n_O).\ndestruct (lt_ge_dec n q) as [LT|LT].\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (S q)).\nrewrite (eq_sym (SQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r Hr.\nassert (H := le_0_sqr p).\nassert (H' := le_0_sqr p).\nassert (H' := le_0_sqr p).\nassert (H' := le_0_sqr p).\nassert (H' := le_sqr p).\nrewrite le_sqr.\nrewrite H'.\nassert (H' := le_sqr p).\nrewrite <- (lt_sqr p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_S_n.\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_trans with (2:=p).\napply le_S_n.\napply le_trans with (2:=p).\napplyQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nintros p k a b n q r.\napply gcd_unique.\napply gcd_compat_l.\napply gcd_refl.\nintros.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_trans with (gcd (gcd a b) (gcd a b)).\napply gcd_div_r.\napply gcd_div_r.\napply gcd_div_r.\napply gcd_div_r.\napply gcd_div_r.\napply gcd_div_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": " b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\nTheorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  rewrite power_plus_lemma1 in H4.\n  assert (divides a (power p q)).\n  apply prime_power_qn with n;try (auto with arith);try omega.\n  exists ((power p r)*k*(power b n)).\n  rewrite <- H4;ring.\n  assert (0<n);try omega.\n  elim H5;intro a';intro.\n  rewrite H7 in H4.\n  rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\n  assert ((power p (q*n))<>0).\n  intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\n  rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\n  generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\n  fold (power p r * k * power b n <> power a' n).\n  apply nth_root_irrat;trivial.\nQed.\n\n(** let x and n be two numbers such that n > 0, then either the n-th root of x is a natural number of it is not rationnal *)\n",
                "context_tokens": 706,
                "proof_start_offset": 7659,
                "proof_end_offset": 8047,
                "proof": "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\nintros.\ncase (is_power_m_dec x n H);intro;try tauto.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nright;intros.\nassert (x=(power p (q*n+r))*k);try tauto.\nrewrite H1;apply nth_root_irrational;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nintros.\nrewrite <- (Nat2Z.inj_iff n (q*n)) in H.\nrewrite <- (mult_assoc (power p (q*n)) (q*n)) in H.\nrewrite <- (mult_assoc (S n)) in H.\nrewrite (mult_assoc (S n)) in H.\napply le_S_n.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nintros.\nrewrite (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite (fun x n => match x with O => a | S n => a end).\nrewrite <- (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite <- (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite <- (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite <- (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite <- (fun x n => match x with O => a | S n => a | S n => a end).\nrewrite <-Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  generalize (div_mod_two_p n (q*n)).\n  apply H0.\n  exists (S (q*n)).\n  rewrite H3; ring.\n  replace (S (q*n)) with (S (q*n)).\n  rewrite H4; ring.\n  generalize (mult_lemma1 (S q) (S (q*n))).\n  omega.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  rewrite (mult_comm x), (mult_comm y).\n  assert (H1: forall a b n, 0 < a -> a < b -> a < b -> a < b -> a < b).\n  intros.\n  apply (H (S n)).\n  generalize (div_mod_eq _ _ H1 H2); intro.\n  rewrite (mult_comm x), (mult_comm y).\n  assert (H3: forall a b n, a < b -> a < b -> a < b -> a < b -> a < b).\n  intros.\n  apply (H (S n)).\n  apply (H (S n)).\n  apply (H2 (S n)).\n  apply H2.\n  apply (H2 (S n)).\n  apply H1.\n  apply (H2 (S n)).\n  apply H1.\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply H3.\n  apply (H2 (S n)).\n  apply H1.\n  apply (H2 (S n)).\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nintros.\nrewrite <- (mult_assoc (S n) (S n)).\nrewrite <- (mult_assoc (S n) (S n)).\nrewrite (mult_comm (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (mult_assoc (S n)).\nrewrite <- (Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  assert (H0: 0<=x).\n  apply (fun x => 0) in H1; try omega.\n  simpl; intros.\n  apply (H x0) in H0; auto.\n  simpl; intros.\n  apply (H x0) in H0; auto.\n  simpl; intros.\n  apply (H0 x0) in H0; auto.\n  simpl; intros.\n  apply (H x0) in H0; auto.\n  simpl; intros.\n  apply (H x0) in H0; auto.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  rewrite H.\n  rewrite H.\n  rewrite H0.\n  pattern n at 2; rewrite (mult_comm (2*n))).\n  rewrite <- (mult_assoc (2*n)).\n  rewrite H.\n  rewrite pow_add.\n  apply pow_pos.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros; apply (is_even_correct (Z.pos n)).\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  rewrite power_plus_lemma1 in H4.\n  assert (H4 := H1 (S n)).\n  apply H1.\n  apply H2.\n  apply le_trans with (S n); auto with arith.\n  apply H0.\n  apply le_trans with (S n); auto with arith.\n  apply H0.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  destruct (le_gt_dec x y) as [H|H].\n  subst.\n  apply H;trivial.\n  apply (H (S n)).\nQed."
                ]
            }
        ]
    }
}