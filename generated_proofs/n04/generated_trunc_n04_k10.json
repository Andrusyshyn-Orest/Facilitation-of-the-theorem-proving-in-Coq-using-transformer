{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 8,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "4e154ffa2a043091b2d240a2894abe0458287b1f"
    },

    "projects": {
        "weak-up-to": [
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    ",
                "context_tokens": 440,
                "proof_start_offset": 1443,
                "proof_end_offset": 1519,
                "proof": "Lemma weak_refl: forall x, Weak T x x.\nProof.\nintro x; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold not in |- *; intros l.\n      apply (IH x); auto.\n      Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    intros; induction 1; simpl; intros; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros x H; induction x; simpl; auto.\n      intros x H; simpl in H; auto.\n      intros x H; simpl in H; auto.\n      intros x H; simpl in H; auto.\n      intros x H; simpl in H; auto.\n      intros x H; simpl in H; auto.\n      intros x; simpl in H; auto.\n      intros x0 H; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x; simpl in H; auto.\n      intros x0 H; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0 H; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0 H; simpl in H; auto.\n      intros x0 H; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0; simpl in H; auto.\n      intros x0; simpl inQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof. intros x y H.\n    apply H.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold no_ax.\n      intros x0 H1.\n      unfold vis in H2.\n      unfold vis in H2.\n      unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2.\n      unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2.\n      unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2.\n      unfold vis in H2. unfold vis in H2. unfold vis in H3. unfold vis in H3. unfold vis in H2. unfold vis in H3. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2.\n      unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2. unfold vis in H2Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction x.\n      intros x H; destruct x; simpl in *; tauto.\n      intros; tauto.\n      intros; tauto.\n      intros; tauto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction x; intuition; subst; auto.\n      Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    induction x; simpl; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    unfold all_assoc.\n    unfold all_assoc.\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct y as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct y as [|y]; simpl in *; try (constructor; auto).\n    destruct x as [|y]; simpl in *; try (constructor; auto).\n    destruct x as [|y y]; simpl in *; try (constructor; auto).\n    destruct y as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|x y]; simpl in *; try (constructor; auto).\n    destruct y as [|x y]; simpl in *; try (constructor; auto).\n    destruct x as [|Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    unfold stronger in |- *; simpl in |- *; intros.\n    elim (L a); auto.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    ",
                "context_tokens": 473,
                "proof_start_offset": 1555,
                "proof_end_offset": 1835,
                "proof": "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply S_star with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros x y l z l.\n    induction l; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro x; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros. simpl; auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 561,
                "proof_start_offset": 1841,
                "proof_end_offset": 2069,
                "proof": "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\nexists x; auto.\nexists y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct l; simpl; intros x' y' R; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct x; simpl; auto. Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l z y H H; induction l; simpl; auto.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star withQed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; auto.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros; simpl; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l z z Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz Hz HzQed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l z; simpl; auto.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l z H; simpl; auto. Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct l; simpl; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l z H H0 H1; simpl; auto.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    ",
                "context_tokens": 633,
                "proof_start_offset": 2075,
                "proof_end_offset": 2206,
                "proof": "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\nProof.\nintros l x y H.\napply weak_tau with y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x y l; destruct l; simpl; intros y z Z.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with yQed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H; destruct l; simpl; intros z Hz; case Hz.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y z Hz.\n      destruct x; simpl; intros x' Hz; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y l; destruct l; simpl; auto.\n      exists y; auto.\n      exists y; auto.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x y l; destruct l; simpl; auto.\n      apply S_star with y; assumption.\n      exists x; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; auto.\n      exists y; auto.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y l; destruct l; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x y l; destruct l; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros; destruct l; simpl; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y y z H; elim H; intros y z Hz; elim H; intros y z Hz Hz.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    ",
                "context_tokens": 677,
                "proof_start_offset": 2212,
                "proof_end_offset": 2502,
                "proof": "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H; simpl; auto.\n      apply S_star with y; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H.\n      apply functional_tau with y; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H H.\n      apply (H x); auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l y l H; destruct l; simpl; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H H.\n      apply (proj1 (proj2 (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj _ _conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conjconj (conj (conj (conj (conj (conj _conj (conj (conjconj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conjconj (conj (conj (conj (conj (conj (conj (conj (conj (conjconj (conj (conj (conj (conj (conj (conj (conj (conj (conjconj (conj (conj (conj (conj (conj (conj (conjconj (conj xconj (conj (conjconjconj (conj (conj (conjconj (conj xconj (conj (conjconj (conj (conj (conj (conj xconj (conj (conj (conj (conjconj (conj (conj (conj (conj (conj (conj (Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H; simpl; intros z.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H H.\n      apply (IH _ H).\n      apply (IH _ _ H).\n      apply (IH _ _ H).\n      apply (IH _ _ H).\n      apply (IH _ _ H).\n      apply (IH _ _ H).\n      apply (IH _ H).\n      apply (IH _ H).\n      apply (IH _ _ H).\n      apply (IH _ H).\n      apply (IH _ _ H).\n      apply (IH _ _ H).\n      apply (IH _ _ H).\n      apply (IH _ H).\n      apply (IH _ _ H).\n      apply (IH _ _ H).\n      apply (IH _ H).\n      apply (IH _ H).\n      apply (IH _ _ H).\n      apply (IH _ H).\n      apply (IH _ _ H).\n      apply (IH _ H).\n      apply (IH _ _ H).\n      apply (IH _ H).\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star with y; auto.\n      apply S_star withQed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l y H; destruct l; simpl; intros x z Hz.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y z H; destruct l; simpl; intros z Hz; inversion Hz.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": ".\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply star_trans with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply star_trans with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 718,
                "proof_start_offset": 2508,
                "proof_end_offset": 2853,
                "proof": "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct XY as [ w XW WY ].\ndestruct WY as [ t WT TY ].\nexists w; auto.\nexists t; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y z H; destruct l; simpl; intros x y z Y Z.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with x; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with x; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with y; assumption.\n      apply star_trans with x; assumption.\n      apply star_trans with y; assumption.\n      apply starQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y z H; destruct l; simpl; intros x y Hz; inversion Hz.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y z Hz.\n      destruct l; simpl; intros x y z Hz; auto.\n      apply S_star with y; assumption.\n      apply S_star with x; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y H0; destruct l; simpl; intros x z X.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_starQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y H.\n      apply (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (HQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l z H.\n      apply lt_refl.\n      apply le_trans with y; assumption.\n      destruct Y as [Y YY WZ WZ WZ WZ WYY WYY WYYY WYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYQed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y z H H; destruct l; simpl; intros y z Hz.\n      apply S_star with x y z; trivial.\n      apply S_star with y; trivial.\n      apply S_star with y; trivial.\n      apply S_star with y; trivial.\n      apply S_star with y; trivial.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y H.\n      apply (well_founded_ind _ _ _ H0 H).\n      exists x; auto.\n      apply S_star with y; assumption.\n      exists x; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y z H.\n      apply le_trans with x; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros l x y H H.\n      apply H; apply H; auto.\n    Qed."
                ]
            }
        ],
        "buchberger": [
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\n",
                "context_tokens": 38,
                "proof_start_offset": 167,
                "proof_end_offset": 590,
                "proof": "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0; [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nunfold app; intros A B f b.\nunfold app; intros A B f b.\nrewrite (add_comm a); auto.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nunfold In.\nintros.\napply map_in; auto with *.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  unfold In, In, In, In, In in |- *.\n  elim (in_map f a).\n  intros a b.\n  rewrite <- (map_iff f a).\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_in.\n  apply map_inQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros.\nunfold In, In, In, In, In, In, In, In, In, In, In, In, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H,Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.\napply in_map_iff in H.Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f x xs f x xs f xs f ys f ys f ys xs f ys xs f ys f ys xs ys f ys f ys xs ys f ys f ys xs ys f ys f ys ys ys f ys f ys ys f ys ys f ys ys ys xs ys f ys ys ys f ys ys ys ys ys ys ys f ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ysQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nsimple induction xs; simpl in |- *.\nelim (in_map f (fun a : A => b = f a).\nintro; elim (in_map f (fun a : A => b = f a)).\nintro; elim (in_map f (fun a : A => b = f a)).\nintro; elim (in_map f (fun a : A => b = f a).\nintro; elim (in_map f (fun a : A => b = f a)).\nintro; elim (in_map f (fun a : A => b = f a).\nintro; elim (in_map f (fun a : A => a = f a)).\nintro; elim (in_map f (fun a : A => b = f a) (fun a : A => b = f a)).\nintro; elim (in_map f (fun a : A => a = f a)).\nintro; elim (in_map f (fun a : A => a = g a) (fun a : A => b = f a)).\nintro; elim (in_map f (fun a : A => a = a) (fun a : AQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f a b xs f g a b xs f a xs f a xs f a xs f g xs f xs f xs f a xs f xs ys f xs ys.\n  intros A B f xs f g xs f g xs ys f xs ys f xs ys f ys f ys xs ys f ys f ys xs ys f ys ys ys f ys ys ys f ys ys ys ys ys xs ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ys ysQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f x xs.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in H.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in H.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in |- *.\n  unfold In in H.\n  unfold In in |- *.\n  unfold In in |-Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  simple induction xs; intros; simpl in |- *; try assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\n",
                "context_tokens": 214,
                "proof_start_offset": 592,
                "proof_end_offset": 803,
                "proof": "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a0 H'0 H'1; elim H'0; intros H'2; clear H'1;\n auto.\nintros a0 H' H'0; elim H'0; intros H'0; clear H'1;\n auto.\nintros a0 H'0 H'1; elim H'0; intros H'2; clear H'1 H'1; clear H' H'0;\n auto.\nintros a0 H'1 H'1; elim H'1; intros H'2; clear H'0; intros H'2; clear H'0;\n auto.\nintros a0 H'1 H'0 H'1; elim H'1; intros H'2; clear H' H'2; \n auto.\nintros a0 H' H'1; elim H'0; intros H'1; clear H'0;\n auto.\nintros a0 H'0; elim H'0; intros H'3; clear H'0; intros H'2 H'4; clear H'0;\n auto.Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H'0; elim H'0; intros H'1; elim H'0; clear H'1; intros H'2; clear H'1;\n auto.\nintros a0 H' H'0; elim H'0; intros H'2; clear H'1;\n auto.\nintros a0 H'1 H'0; elim H'0; intros H'2; clear H'0; intros H'2; elim H'0; intros H'3 H'3; clear H'0;\n auto.\nintros a0 H'1; elim H'0; intros H'1; clear H' H'2; elim H'0; intros H'2; clear H'3;\n auto.\nintros a0 H'0 H'1; elim H'0; intros H'3; clear H'3 H'4;\n auto.\nintros a'1; elim H'0; intros H'4; clear H'1; intros H'3 H'4; clear H'4;\n auto.\nintros a0 H'1 H'2; elim H'0; intros HQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f a l1 l2; elim xs; simpl in |- *; auto.\nintros a0 l1 l2; elim xs; simpl in |- *; auto.\nintros a1 a2 E H'0; elim H'0; intros H'1; clear H'0; \n intros a1 H'2 H'2; elim H'0; intros H'1; clear H'2; \n intros a1 E; elim H'2; intros H'2; clear H'1; \n intros a0 H'2; elim H'2; intros H'2; clear H'2; \n intros a0; elim H'2; intros H'3; clear H'2; \n intros a0 H'4; elim H'3; intros H'2; clear H'3; \n intros a1 H'4; elim H'3; intros H'4; clear H'5; \n intros a1 H'3; elim H'5; intros H'6; clear H'6; \n intros a0 H'5; elim H'2; intros H'3 H'5; clear H'5; \n intros a1 H'4Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a0 H' H'0; elim H'; intros H'0 H'0 H'1; clear H'0 H'1; \n auto.\nelim H'; intros a0; elim H'0; intros H'0 H'2; clear H'0; \n auto.\napply map_app; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim xs; simpl in |- *; auto.\nintros a0 E; elim H'; auto.\nintros a0 E; elim H'0; intros H'1; clear H'0; intros H'2; clear E H'0; \n auto.\nintros a0 E; elim H'1; intros H'1; elim H'2; intros H'3; clear H'0; \n auto.\nintros a0 E; elim H'1; intros H'1 H'2; clear H'1; intros H'2; clear E H'1; \n auto.\nintros a0 H'1 H'2; elim H'2; intros H'2; clear E1; intros H'2; elim H'2; intros H'2; clear E2; \n auto.\nintros a0 H' H'1; elim H'3; intros H'3; clear E2; \n auto.\nintros a0 E; elim H'2; intros H'2; clear E1; intros H'2; clear E2;\n auto.\nintros a0 H'2 H'2; elim H'4Qed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l2; simpl in |- *; auto.\nintros a a0 H'0; elim H'0; intros H'1; clear H'1; intros H'2; clear H' H'1; \n auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim xs; simpl in |- *; auto.\nintros a l1 l2; elim l1; simpl in |- *; auto.\nintros a0 l2 H'1; elim H'0; intros H'2; clear H'0; elim H'0; intros H'2 H'2; clear H'1; \n auto.\nintros a0 a0 H'0; elim H'0; intros H'2; elim H'3; clear H'2; intros H'3; clear H'3 H'3; \n auto.\nintros a0 H'1 H'2; elim H'3; intros H'3; clear H'4; intros H'4 H'4; \n auto.\nintros a0 H'1 H'3; elim H'4; intros H'4 H'5; elim H'5; intros H'5; clear H'5; \n auto.\nintros a0 H' H'1 H'1; elim H'3; intros H'5; clear H'5;\n auto.\nintros a0 H' H'2; elim H'3; intros HQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H'; elim H'1; intros H'2; elim H'2; clear H'2; intros H'3; elim H'3; clear H'4; intros H'4 H'5; clear H'4;\n auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2 H'1.\nelim (map_app f l1); simpl in |- *; auto.\nintros a0 H'0; elim H'; intros a0 H'0; elim E; intros a0 H' H'0; clear E;\n auto.\nintros a0 H' H'0; elim E; intros a0 H'0; elim E; intros a0 H'1 H'0; clear E0.\nexists a; split; auto.\nintros a0 H'0; elim E; intros a0 H'0 H'1; elim E; intros a0 H'0 H'1; clear E0;\n auto.\nintros a0 H'0; elim H'; intros a0 H'1 H'2; elim E; intros a0 H'2 H'2; clear E0;\n auto.\nintros a0 H'0; elim E; intros a0 H'2; clear E0;\n auto.\nintros a0 H'1 H'2; elim E; intros a0 H'2 H'3; clear E0;\n auto.\nintros a0 H'1 HQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a0 E; elim E; auto.\nintros a0 E; elim E; intros H'0; elim E; intros H'0; clear E0; clear E0; auto.\nintros a0 E; elim E; intros H'0; elim E; intros H'0 H'0; clear E0; intros H'0; clear E0; \n auto.\nintros a0 E; elim E; intros H'0 H'0; clear E0; intros H'0 H'0; clear E0; \n auto.\nintros a0 E; elim E; intros H'0; clear E0; auto.\nintros a0 E; elim E; intros H'0; clear E0; intros H'0; elim E; intros H'1 H'0; clear E0; intros H'1; clear E0; \n auto.\nintros a0 E; elim E; intros H'0; clear E0; intros H'0 H'0 H'1; clear E0; \n auto.\nintros a0 E; elim E; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 805,
                "proof_end_offset": 1093,
                "proof": "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l1; elim l2; simpl in |- *; auto.\nintros a l1 l2 H' H'1; elim H'; auto.\nintros a l2 H' H'1; elim H'; auto.\nintros a l2 H'2; elim H'; auto.\nintros a0 H'1 H'2; elim H'; auto.\nintros a1 H'2 H'2 H'3; elim H'3; auto.\nintros a1 H'2; elim H'3; auto.\nintros a1 H'2; elim H'3; auto.\nintros a0 H'2 H'3 H'3; elim H'3; auto.\nintros a0 H'3 H'3; elim H'3; auto.\nintros a0'3 H'4; elim H'4; auto.\nintros a0 H'4; elim H'4; auto.\nintros a0 H'4; elim H'4; auto.\nintros a0' H'4; elim H'4; auto.\nintros a1 H'4 H'5; elim H'4; auto.\nintros aQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H'0; elim H'0; intros H'1; clear H'2; auto with datatypes.\nintros a0 H'0; elim H'1; intros H'2; clear H'0; intros H'2; clear H'3 H'3; clear H'1; intros H'3 H'2; clear H'3 H'3 H'4; clear H'4; intros H'3 H'4 H'4; clear H'3 H'4; intros H'4 H'5 H'6; clear H'6 H'4; intros H'6; clear H'7 H'7 H'8;\n auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l1; elim l1; simpl in |- *; auto.\nintros a l2; elim l2; simpl in |- *; auto with datatypes.\nintros a0 l2; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 l2 H'1; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 l2; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 l1 H'2; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 l2; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 l2; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 l2 H'3; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 l2 H'4; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 l2 H'3 H'4; elim H'4; simpl in |- *; auto with datatypes.\nintros a0 l2 H'4; elim H'4; simpl in |- *; auto with datatypesQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a l2; elim l2; simpl in |- *; auto.\nintros a l1 H'1 H'1 H'2; elim H'2; intros H'2; clear H'1; auto.\nintros a l2 H'2; elim H'3; intros H'3; clear H'4; auto.\nintros a' H'2 H'4; elim H'4; intros H'4 H'5; clear H'4; auto.\nintros a' H'2 H'3 H'4; elim H'5; intros H'4; clear H'6; auto.\nintros a'2 H'3; elim H'5; intros H'4; clear H'4; auto.\nintros a'3 H'4; elim H'5; intros H'6; clear H'5; auto.\nintros a'5; elim H'6; intros H'7; clear H'7 H'6; auto.\nintros a'3 H'5; elim H'7; intros H'7; clear H'Qed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l1 H'1; elim H'; auto.\nintros a0 a0 H'0; elim H'0; intros H'1 H'2; elim H'0; intros H'2 H'3; clear H'2; clear H'0; \n auto.\nintros a0 H' H'0; elim H'0; intros H'3; elim H'1; intros H'3; clear H'1; \n auto.\nintros a0 H'0 H'1; elim H'1; intros H'2; clear H'2 H'0; \n auto.\nintros a0 H'2; elim H'2; intros H'3; clear H'2; \n auto.\nintros a0 H'2; elim H'2; intros H'4; clear H' H'4; clear H'1; \n auto.\nintros a0 a0 H'2; elim H'2; intros H'4; clear H'3 H'4; intros H'4; clear H'5; \n auto.\nintros aQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l l1; elim l2; simpl in |- *; auto with datatypes.\nintros a l1 H' H'0; elim H'0; auto.\nintros a l1 l2; elim H'1; simpl in |- *; auto with datatypes.\nintros a l1 H'1; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 l1 H'2; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 l1 H'2; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 l2 H'2; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'3; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'2; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'3; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'3; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'2; elim H'3; simpl in |- *; auto with datatypes.Qed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l; elim H'; auto with datatypes.\nintros a l1; elim H'; auto with datatypes.\nintros a0; elim H'; auto with datatypes.\nintros a0; elim H'; auto.\nintros a0 H'1; elim H'2; auto with datatypes.\nintros a0; elim H'2; auto with datatypes.\nintros a0; elim H'; auto with datatypes.\nintros a0 H'2; elim H'3; auto with datatypes.\nintros a0; elim H'2; auto with datatypes.\nintros a0 H'2; elim H'4; auto with datatypes.\nintros a0 H'2; elim H'3; auto with datatypes.\nintros a0 H'3; elim H'3; auto with datatypes.\nintros a0 H'3; elim H'3; auto with datatypes.\nintros a0 H'4; elim H'4; auto with datatypes.\nintros a0 H'4; elim H'4; auto with datatypes.\nintros a0 H'4; elim H'4;Qed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l1; simpl in |- *; auto with datatypes.\nintros a H' H'0 H'0; elim H'0; intros H'0; clear H'0 H'0; clear H'0 H'0; \n auto with datatypes.\nintros a H'0 H'0 H'0; elim H'0; intros H'0; clear H'0 H'0;\n auto with datatypes.\nintros a0 H'0 H'1; elim H'0; intros H'0 H'0 H'1; clear H'0; intros H'1 H'1 H'2; clear H'0; \n auto with datatypes.\nintros a0 H'0 H'0 H'1; elim H'1; intros H'1 H'2; clear H'1;\n auto with datatypes.\nintros a0 H'0; elim H'0; intros H'1; elim H'0; clear H'0; intros H'0; clear H'0; \n auto with datatypes.\nintros a0 H'1 H'1 H'2; elim H'1; intros H'2; clearQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l1; simpl in |- *; auto with datatypes.\nintros a H'0; elim H'1; auto with datatypes.\nintros a0 l' H'0; elim H'1; intros H'2 H'2; clear H'1; auto with datatypes.\nintros a0 l' H'1 H'2; elim H'2; auto.\nintros a0 a1 H'0 H'2; elim H'2; intros H'3 H'3; clear H'3; auto with datatypes.\nintros a0 H'2 H'2; elim H'3; intros H'3 H'4 H'4; clear H'4; intros H'4 H'4; clear H'4; auto with datatypes.\nintros a0 H'3 H'3; elim H'3; intros H'4; clear H'4; elim H'5; intros H'6; clear H'4; auto with datatypes.\nintros a0 H'5; elim H'5; intros H'5; clear H'5; intros H'5 H'6; elim H'5;\n intros a0Qed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a H' H'0; elim H'0; intros H'2; clear H'0; intros H'2; clear H'2;\n intros H'0; elim H'0; intros H'3; clear H'0; intros H'4; clear H'0;\n intros H' H'0; elim H'0; intros H'4; clear H'0; elim H'0; intros H'3 H'3; clear H'0;\n intros H'2 H'4; elim H'0; intros H'5; clear H'3; intros H'5; clear H' H' H'1;\n elim H'0; intros H'3; clear H'4; intros H'5 H'5; clear H'4;\n intros H'6; elim H'6; intros H'5; clear H'6;\n intros H'6 H'6; elim H'6; intros H'6; clear H'6; intros H'6; clear H'7;\n intros H'7; elim H'5; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\n",
                "context_tokens": 414,
                "proof_start_offset": 1095,
                "proof_end_offset": 1340,
                "proof": "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto with arith.\nintros a l H' H'0; rewrite <- H'0; auto with arith.\nintros a l H'0; elim a; simpl in |- *; auto with arith.\nintros a l H' H'1; elim a; simpl in |- *; auto.\nintros a H'0 H'1; elim a; simpl in |- *; auto with arith.\nintros a l H' H'1; elim a; simpl in |- *; auto with arith.\nintros a l H'1; rewrite <- H'1; auto with arith.\nintros a l H'1; rewrite <- H'1; auto with arith.\nintros a l H'1; elim a; simpl in |- *; auto with arith.\nintros a l' H'1; elim a; simpl in |- *; auto with arith.\nintros a' H'1; elim a; simpl in |- *; auto with arith.\nintros a l' H'2; elim a; simpl in |- *; auto with arith.\nintros a' H'2; elim a; simpl in |- *; auto with arith.\nintros a a'Qed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' H'1; rewrite <- H'; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l0 H'1 H'2; elim H'1; auto with datatypes.\nintros a0 a0 H'1 H'2; elim H'1; auto with datatypes.\nintros a0 H'2; elim H'1; auto.\nintros a0 H'2 H'2; elim H'2; auto with datatypes.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'2; elim H'2; auto with datatypes.\nintros a0 H'2; elim H'2; auto with datatypes.\nintros a0 H'2; elim H'2; auto with datatypes.\nintros a0 H'3; elim H'2; auto with datatypes.\nintros a0 H'2; elim H'3; auto with datatypes.\nintros a0 H'2 H'3 H'3; elim H'3; auto with datatypes.\nintros a0 H'3 H'3 H'4; elim H'3; auto with datatypes.\nintros a0 H'3; elim H'3; autoQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H'1 H'1; elim l; simpl in |- *; auto.\nintros a l0 H'1 H'2; elim H'1; simpl in |- *; auto.\nintros a l0 H'2 H'2 H'2; elim H'1; simpl in |- *; auto.\nintros a0 H'2; elim H'1; simpl in |- *; auto.\nintros a0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 a0 H'2; elim H'2; simpl in |- *; auto.\nintros a0 H'2; elim H'2; simpl in |- *; auto.\nintros a0 H'2; elim H'1; simpl in |- *; auto.\nintros a0 H'2; elim H'3; simpl in |- *; auto.\nintros a0 H'3; elim H'4; simpl in |- *; auto.\nintros a0 H'2; elim H'3; simpl in |- *; auto.\nintros a0 H'2; elim H'3; simpl in |- *;Qed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H' H'0 H'1 H'0; rewrite <- H'0; simpl in |- *; auto.\nintros a l0 H' H'1; rewrite <- H'0; simpl in |- *; auto.\nintros a l0 H' H'0 H'2; rewrite <- H'0; simpl in |- *; auto.\nintros a0 H'0 H'1; rewrite <- H'0; simpl in |- *; auto.\nintros a0 a0 H' H'2; rewrite <- H'0; simpl in |- *; auto.\nintros a0 H'0; rewrite <- H'0; simpl in |- *; auto.\nintros a0 H'1 H'2; rewrite <- H'0; simpl in |- *; auto.\nintros a0 H'1; rewrite <- H'0; simpl in |- *; auto.\nintros a0 H'1; rewrite <- H'0; simpl in |- *; auto.\nintros a0 a0 H'1; rewrite <- H'0; simpl in |- *; auto.\nintros a0 H'1; rewrite <-Qed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H' H'0; elim H'0; simpl in |- *; auto.\nintros a H'0; elim H'0; intros H'1; elim H'0; simpl in |- *; auto.\nintros a0 a0 H'1; elim H'1; simpl in |- *; auto with datatypes.\nintros a0; elim H'1; simpl in |- *; auto with datatypes.\nintros a0 H'1; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 H'2; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'2; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'2; elim H'2; simpl in |- *; auto with datatypes.\nintros a0 H'1; elim H'1; simpl in |- *; auto with datatypes.\nintros a0 H'2; elim H'3; simpl in |- *; auto with datatypes.\nintros a0 H'2; elim H'2; simpl in |- *; auto with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H'; rewrite <- H'; simpl in |- *; auto.\nintros a l H'0 H'1; elim H'0; intros H'2; clear H'0; auto.\nintros a l0 H'1; rewrite <- H'; simpl in |- *; auto.\nintros a l0 H'0 H'1; rewrite <- H'0; simpl in |- *; auto.\nintros a l0 H' H'1; rewrite <- H'; simpl in |- *; auto.\nintros a l0 H'1; rewrite <- H'0; simpl in |- *; auto.\nintros a0 l0 H'1; rewrite <- H'; simpl in |- *; auto.\nintros a0 H'1; rewrite <- H'1; simpl in |- *; auto.\nintros a0 l0 H'2; rewrite <- H'0; simpl in |- *; auto.\nintros a0 l0 H'0; rewrite <- H'0; simpl in |- *; auto.\nintros a0 l0 H'1 H'1; rewrite <- H'0; simpl in |- *; auto.Qed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l H' H'0; elim H'; intros H'0; elim H'0; auto with datatypes.\nintros a H' H'0; elim H'0; intros H'1; elim H'2; intros H'2; clear H'2; intros H'1 H'2; clear H'0; auto with datatypes.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' H'0; elim H'0; intros H'0 H'0; elim H'0; intros H'1; clear H'0 H'0; elim H'0; intros H'2; elim H'1; intros H'2; clear H'0; intros H'2; clear H'0; intros H'3; clear H'3; intros H'2 H'4; clear H'0; intros H'4; elim H'0; intros H'4; clear H'0; intros H'4; clear H'6 H'4; intros H'4;\n elim H'2; intros H'4; clear H'4; intros H'5; elim H'4; intros H'5; clear H'5; intros H'6; elim H'7; intros H'6; clear H'7;\n intros H'5 H'6; elim H'7; intros H'5; clear H'6; intros H'8; elim H'7; intros H'6; clear H'6; intros H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\nLemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.\n\n",
                "context_tokens": 524,
                "proof_start_offset": 1342,
                "proof_end_offset": 1509,
                "proof": "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros A a l H'.\napply rev_in with (A := A); auto.\nrewrite (rev_involutive l); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a0 H'1; elim H'2; intros H'2; clear H'2; elim H'3;\n auto.\nintros a0 H'2; elim H'2; intros H'3; elim H'4; intros H'4; elim H'5; intros H'4; elim H'6;\n intros H'6 H'6; elim H'6; intros H'6; elim H'7; intros H'7 H'8; elim H'8; intros H'6; elim H'7; intros H'8; elim H'8; intros H'8; elim H'9; intros H'9; elim H'7; intros H'8; elim H'8; intros H'9; elim H'8; intros H'8; elim H'9;\n intros H'8; elim H'9; intros H'9 H'9; elim H'9; intros H'8 H'8; elim H'10; intros H'9; elim H'9; intros H'9; elim H'9; intros HQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a0 l1 H'2; elim H'3; auto.\nintros a0 H'0 H'0; elim H'4; intros H'4; elim H'4; intros H'4; clear H'5; clear H'5; intros H'5 H'5; clear H'6; intros H'5 H'5; clear H'5; intros H'5 H'6 H'5; clear H'6; intros H'6 H'6; clear H'7; intros H'8 H'6 H'7; clear H'6 H'7 H'7; intros H'10 H'8; elim H'8; clear H'7; intros H'7 H'9 H'9 H'10; clear H'7 H'7; intros H'8 H'7 H'8; clear H'9; intros H'9; elim H'7;\n [ intros a0 H'5; clear H'7 H'9 H'9 H'8; clear H'10 H'9 H'9; intros H'Qed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a0 H'1; elim H'0; auto.\nintros a0 H'1; elim H'1; auto.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'1; elim H'2; auto.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'3; elim H'2; auto.\nintros a0 H'3; elim H'2; auto.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'3; elim H'3; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 H'3; elim H'3; auto.Qed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto with datatypes.\nintros a l0 H'1; elim H'2; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 H'2 H'3; elim H'3; auto.\nintros a0 a1 H'3 H'3 H'4; elim H'4; auto.\nintros a0 H'3; elim H'3; auto.\nintros a1 H'4; elim H'5; auto.\nintros a0 H'4; elim H'4; auto.\nintros a0 H'5; elim H'5; auto.\nintros a0 H'2; elim H'4; auto.\nintros a0 H'3; elim H'5; auto.\nintros a0 H'4; elim H'5; auto.\nintros a0 H'5 H'5 H'6; elim H'6; auto.\nintros a0 H'6; elim H'6; auto.\nintros a0 H'5 H'6; elim H'7; auto.\nintros a0 H'6;Qed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a0 H'0 H'0 H'1; rewrite <- H'1; simpl in |- *; auto.\nintros a0 l0 H'0 H'2; rewrite <- H'1; simpl in |- *; auto.\nintros a0 H'1 H'1; rewrite <- H'1; simpl in |- *; auto.\nintros a0 l0 H'1; rewrite <- H'1; simpl in |- *; auto.\nintros a0 H'0 H'2; rewrite <- H'1; simpl in |- *; auto.\nintros a0 l0 H'0; rewrite <- H'1; simpl in |- *; auto.\nintros a0 H'1 H'1 H'2 H'3; rewrite <- H'1; simpl in |- *; auto.\nintros a0 H'1 H'3 H'3 H'1 H'2 H'3 H'3; rewrite <- H'1; simpl in |- *; auto.\nintros a0 H'1 H'2; rewrite <- H'1; simpl in |- *; auto.\nintros a0 H'2; rewriteQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'0; simpl in |- *; auto.\nintros a0 H'0; elim H'1; simpl in |- *; auto.\nintros a0 l0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'0 H'1 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'0; elim H'1; simpl in |- *; auto.\nintros a0 H'0; elim H'2; simpl in |- *; auto.\nintros a0 a0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'1 H'1; elim H'2; simpl in |- *; auto.\nintros a0 a0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'0; elim H'2; simpl in |- *; auto.\nintros a0 H'0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'1 H'1; elimQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l H; elim a; simpl in |- *; auto.\nintros a0 a0 H' H'1; elim a0; intros H'2; elim a0; intros H'2; clear a0 H'2.\nelim (in_app_or _ _ _ H'0); simpl in |- *; auto.\nintros a0 H'2; elim a0; intros H'2; elim a0; intros H'3; elim H'3;\n auto.\nintros a0 H'2; elim a0; intros H'3; elim a0; intros H'3; clear H'3; intros H'4; elim H'4; intros H'4; clear H'4; intros H'4; elim H'5;\n auto.\nintros a0 H'2; elim a0; intros H'4; elim a0; intros H'4; elim H'6;\n auto.\nintros a0 H'5; elim a0; intros H'4; elim H'4; intros H'5; clear H'5; intros H'7; elim H'7; intros H'7 H'8;Qed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'1; elim H'2; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 l0 H' H'3; elim H'3; auto.\nintros a0 l0 H'3; elim H'4; auto.\nintros a0 l0 H'2; elim H'3; auto.\nintros a0 H'2; elim H'4; auto.\nintros a0 H'3; elim H'4; auto.\nintros a0 l0 H'3; elim H'4; auto.\nintros a0 H'5 H'4; elim H'4; auto.\nintros a0 H'1 H'2; elim H'5; auto.\nintros a0 H'2; elim H'4; auto.\nintros a0 H'4; elim H'5; auto.\nintros a0 H'5 H'4; elim H'5; auto.\nintros a0 H'2; elim H'4; auto.\nintros a0 l0 HQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'1; elim l0; simpl in |- *; auto.\nintros a0 l0 H' H'1; rewrite <- H'; auto.\nintros a0 l0 H'2; elim H'2; auto.\nintros a0 l0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 l0 H'2; elim H'2; simpl in |- *; auto.\nintros a0 H'1; elim H'2; simpl in |- *; auto.\nintros a0 H'2; elim H'2; simpl in |- *; auto.\nintros a0 H'2; elim H'2; simpl in |- *; auto.\nintros a0 a0 H'1; elim H'3; simpl in |- *; auto.\nintros a0 H'2; elim H'2; simpl in |- *; auto.\nintros a0 l1; elim HQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a0 H'0; elim H'2; auto.\nintros a0 H'0 H'0; elim H'2; auto.\nintros a0 H'1; elim H'2; auto.\nintros a0 H'1 H'2; elim H'2; auto.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'1; elim H'2; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 H'1; elim H'3; auto.\nintros a0 H'2; elim H'3; auto.\nintros a1 H'2; elim H'3; auto.\nintros a0 H'2 H'2; elim H'3; auto.\nintros a0 H'2; elim H'2; auto.\nintros a0 H'2; elim H'3; auto.\nintros a0 H'3; elim H'3; auto.\nintros a1 H'2; elim H'3; auto.\nintros a' H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 163,
                "proof_start_offset": 1031,
                "proof_end_offset": 1124,
                "proof": "Definition zeroP : Term -> Prop.\nProof.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition zeroP : Term -> Prop.\nDefinition normal_mon (a b : M) :=\n  fun x => forall x y, x = y.\n\nEnd Term.\n\nSection Term.\n\nVariable U : Type.\n\nVariable U : Type.\n\nDefinition is_mon (a b : M) : M :=\n  fun x y => forall y, is_mon a b.\n\nDefinition is_mon (a b : M) : M :=\n  fun x y => forall y, is_mon a b.\n\nLemma is_mon_mon_mon_mon_mon_mon : forall a b, is_mon a b.\nProof.\n  unfold is_mon, is_mon, is_mon, is_mon, is_mon, is_mon, is_mon, is_mon, is_mon, is_mon, is_mon, is_mon, and_mon, is_mon, and_mon, and_mon, and_mon, and_mon, and_mon, and_mon, and_mon, andmon_mon, and_mon, and_mon, andmon_mon, andmon, andmon_mon, andmon_mon, andmon_Defined.",
                    "Definition zeroP : Term -> Prop.\nDefinition sub_type : Type :=\n  forall x y : Term,\n  forall x y : Term,\n  forall x y : Term,\n  forall x y : Term,\n  forall y : Term,\n  forall y : Term,\n  forall y : Term,\n  forall y : Term,\n  forall (x y : Term) (y : Term),\n  forall (x y : Term),\n  forall y : Term,\n  forall y : Term,\n  forall x y : Term,\n  forall (x y : Term),\n  forall (x y : Term),\n  forall y : Term,\n  forall (x y : Term),\n  forall (x y : Term),\n  forall y : Term,\n  forall y : Term, forall (x y : Term) (y : Term),\n  forall x : Term,\n  forall x y : Term, forall y : Term,\n  forall x : Term, forall y : Term,\n  forall x : Term, forall y : Term,\n  forall y : Term, forall y : Term,\n  forall y : Term,\n  forall y : Term, forall y : Term,\n  forall y : Term, forall y : Term, forall y : Term,\n  forall y : Term, forall y : TermDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition UnitP := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\n\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\n\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).\nDefinition isP : Prop := Build_mon (fun _ => R) (only parsing).Defined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition sub := sub (fun x => r) (at level 50).\n\nDefinition sub := sub (fun x => r) (at level 50).\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.\nDefinition sub := sub.Defined.",
                    "Definition zeroP : Term -> Prop.\nDefinition SubLoad (T : Type) (c : @term T) :=\n  match c with\n    | left _ => true\n    | right _ => true\n    | left _ => true\n    | right _ => false\n    end.\n\nEnd Term.\n\nSection Term.\n\nVariable A : Type.\n\nDefinition sub_term (A : Type) (c : @term A) :=\n  match c with\n    | left _ => true\n    | right _ => true\n    | right _ => false\n    | right _ => false\n    | right _ => false\n    end.\n\nDefinition sub_term (A B : Type) (c : @term A) : @term A.\n\nLemma sub_term A B (f : @term A) : @term A (term A).\nProof.\n  unfold sub_term.\n  unfold subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subterm, subtermDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition isP : Term -> Prop :=\n  forall x, isP x -> isP x -> isP x.\n\nDefinition isP : Term -> Prop :=\n  forall x, isP x -> isP x.\n\nDefinition isP : Term -> Prop := forall x, isP x -> isP x.\nDefinition isP : Term -> Prop := forall x, isP x.\n\nDefinition isP : Term -> Prop := forall x, isP x -> isP x.\n\nDefinition isP : Term -> Prop := forall x, isP x -> isP x.\n\nDefinition isP : Term -> Prop := forall x, isP x -> isP x.\n\nDefinition isP : Term -> Prop := forall x, isP x.\n\nDefinition isP : Term -> Prop := forall x, isP x -> isP x.\n\nDefinition isP : forall x : Term -> Prop, isP x -> isP x.\n\nDefinition isP : Term -> Prop := forall x, isP x -> isP x.\nDefinition isP : Term -> Prop := forall x, isP x.\nDefinition isP : Term -> Prop := forall x, isDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition fun_sort (x y : Term) := {sort y : Term -> Term -> Term -> Term -> Term.\n\nDefinition fun_sort (x y : Term) (m : Term) : Term -> Term -> Term -> Term.\n\nDefinition fun_sort (x y : Term) (m : Term) : Term -> Term -> Term -> Term.\n\nDefinition fun_sort (x y : Term) (m : Term) (m : Term) : Term -> Term -> Term.\n\nDefinition fun_sort (x y : Term) (m : Term) : Term := fun_sort x => fun_sort x y m => fun_sort x y m => fun_sort => fun_sort x y m => fun_sort y m => fun_sort => fun_sort x m => fun_sort x y m => fun_sort => fun_sort x m => fun_sort_sort (fun_sort (fun_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (of_sort (Defined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition is_cst {A} (a b : bool) : A :=\n  fun (x : A) => exists y : A, a = y.\n\nDefinition is_cst {A} (a b : bool) :=\n  fun (x : A) => exists y : A, a = y.\n\nDefinition is_cst {A} (a b : bool) : A :=\n  fun (x : A) => exists y : A, a = y.\n\nDefinition is_cst {A} (a b : bool) : A :=\n  fun (x : A) => exists y : A, a = y.\n\nLemma is_cst {A} (a b : bool) : a = a.\nProof.\nunfold is_cst; case: a.\ncase: a.\ncase: a.\n2: a.\n2: (a1 b).\ncase: b.\n2: (a2 b).\n2: (a2 b).\n2: (a2 b).\n2: (a2: b).\n2: (a2 b).\n2: (a2: b).\n2: (a2:Defined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition is_mon (a : term) : Prop :=\n  let (a : term) :=\n    (a : term) in\n    (a : term) := fun (a : term) => a.\n\nLemma is_mon_mon_mon : forall a : term, is_mon a -> is_mon a.\nProof.\nintros a b H; elim H; auto.\nDefined.",
                    "Definition zeroP : Term -> Prop.\nDefinition emptyP : Term -> Prop := forall x, R x.\n\nDefinition emptyP : Term -> Prop :=\n  forall x y : Term, R x y -> E x.\n\nDefinition emptyP : Term -> Prop := forall x y : Term, R x y.\n\nDefinition emptyP : Term -> Prop := forall x y : Term, R x y -> E y.\nDefinition emptyP : Term -> Prop := forall x y : Term, R x y.\nDefinition emptyP : Term -> Prop := forall x : Term, R x y.\n\nDefinition emptyP : Term -> Prop := forall x y : Term, R x y -> Prop.\nDefinition emptyP : Term -> Prop := forall x y : Term, R x y -> Prop.\nDefinition emptyP : Term -> Prop := forall x y : Term, R x.\nDefinition emptyP : Term -> Prop := forall x : Term, R x y -> Prop.\nDefinition emptyP : Term -> Prop := forall x : Term, R x x.\nDefinition emptyP : Term -> Prop := forall x : Term, R x y -> Prop.\nDefinition emptyP : Term -> Prop := forall x : Term, Prop.\nDefinitionDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \n",
                "context_tokens": 197,
                "proof_start_offset": 1127,
                "proof_end_offset": 1265,
                "proof": "Definition eqTerm : Term -> Term -> Prop.\nProof.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eqTerm : Term -> Term -> Prop.\n\n(* Eval vm_compute in the type of type *)\n\n(* Eval vm_compute in the type *)\n\nDefinition eq_term := fun _ => eq_term.\n\nDefinition eq_term (n : nat) : Prop :=\n  fun _ => eq_term (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m)) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m)) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eq_term (n := m) (fun _ => eqDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\napply (fun A => T).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'; case H'.\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\napply (fun x => R x).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n\nDefinition Term_prod (A : Type) (f : Term) : Prop :=\n  forall x y, E x y -> forall y, E x y -> E y.\nintros H'; case H'.\nintros a H'0 H'1; exact (eqA a).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'; case H'.\nintros a H'; case H'.\nintros a H'2; case H'.\nintros a H'2; case H'.\nintros a H'3; case H'.\nintros a H'2; case H'.\nintros a H'2 H'2 H'3 H'3; case H'.\nintros a'2 H'3 H'4 H'3; case H'.\nintros a'3 H'4 H'4 H'4 H'5 H'5 H'5 H'6 H'7; case H'.\nintros a'4 H'4; case H'3.\nintros a'4 H'6; case H'5'.\nintros a'5; case H'6; case H'5; intros H'6 H'6; case H'6'.\nintros a'6; case H'6'.\nintros a'7 H'5 H'6 H'6; case H'6'.\nintros a'5 H'7; case H'6.\nintros a'6 H'6 H'7; case H'6'.\nintros a'7 H'8;Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n\nDefinition SubProd (n : nat) :=\n  fun n => True.\n\nDefinition eq_prod (A : Type) (a : A) (a : A) : A :=\n  fun n => True.\nDefinition sub_prod (A : Type) (a : A) (a : A) : A :=\n  fun n => True.\n\nDefinition sub_prod (A : Type) (a : A) : A :=\n  fun n => False.\nDefinition sub_prod (A : Type) (a : A) : A :=\n  fun n => 0.\n\nDefinition sub_prod (A : Type) (a : A) (a : A) (a : A) : A :=\n  fun n => True.\n\nDefinition sub_prod (A : Type) (a : A) (a : A) (a : A) (a : A) : A :=\n  fun n =>\n    forall n : nat, P n -> P n -> P n.\n\nDefinition sub_prod (A : Type) (a : A) (a : A) (a : A) (a : A) : A :=\n  fun n : nat => P n.Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n(* The following definitions of the following definitions *)\n\nSection Term.\n  Context {T : Type} (p : Type) (p : p) (p : p) (p : p) (p : p) (p : p) :=\n  match p, p with\n    | p => P\n    | p => P\n    | p => P\n    end.\n\n  Definition SubFun (x : Term) : Prop :=\n  match p with\n    | p, p => P\n    | p => P\n    end.\n\n  Definition SubFun (x : Term) (p : p) : p = p :=\n  match p, p, p with\n    | p, p => P\n    | p, p => P\n    end.\n\n  Definition SubFun (x : Term) : Prop :=\n  match p, p with\n    | p, p => P\n    | p => P\n    end.\n\n  Definition SubFun (x : Term) : Prop :=\n  match p, p with\n    | p, p => P\n    | p, p => P\n    end.\n\n  Definition SubFun (x : Term) : Prop :=\n  match p, p with\n    | p, p => P\n    | p, p => p\n    | p =>Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\n\n(* The [op1] is a given a relation *)\nDefinition Acc (U : Type) := forall x y z : Term, Acc (fun y => x = y) z.\nDefinition Acc_Acc (U : Type) := forall x y : Term, Acc (fun y => x = y) z.\n\nLemma Acc_Acc_Acc_Acc : forall x y z : Term, Acc (fun y z : Term) => Acc (fun y z : Term => Acc (fun y z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun y z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : Term) => Acc (fun z : TermDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; red in |- *; red in |- *; red in |- *; red in |- *; intros; red in |- *; red in |- *; intros; red in H'0; red in |- *; intros.\n(* In this case it is not in the x0; case x0; case x0; intros.\n(* In this case x0 is a0; case x0; intros.\n(* In this case, x0 is a0; case x0; intros.\n(* In this case a0; case x0; intros.\n(* In this case x0; case x1; intros.\n(* In this case a0; case x0; intros.\n(* In this case x0; case x0; intros.\n(* In this case x0; case x0; intros.\n(* In this case x0; case x0; intros.\n(* In this case x0; case x0; intros.\n(* In this case x0; case x0; intros.\n(* In this case x0; case x0; intros.\n(* In this case x0; case x0; intros.\n(* In this case x0; case x0; intros.Defined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 259,
                "proof_start_offset": 1315,
                "proof_end_offset": 1416,
                "proof": "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intros.\nexact (eqA a a'0); auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intros.\nexact (eqA a a' H').\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nintros H'; case H'.\nintros a H' H'2; elim H'2.\nintros a' H'2; elim H'2.\nintros a' H'2 H'3; elim H'3.\nintros a'2 H'3 H'3 H'3; elim H'2.\nintros a'2 H'3 H'4; elim H'3.\nintros a' H'3 H'4; elim H'3.\nintros a'2 H'3 H'3 H'5; elim H'4.\nintros a'3 H'4 H'4 H'5.\nintros a'4 H'5 H'5; elim H'3.\nintros a'3 H'5 H'6; elim H'6; intros H'5; elim H'4.\nintros a'4 H'5 H'6 H'6; elim H'7.\nintros a'6 H'5 H'5.\nintros a'5 H'6 H'7 H'8 H'6 H'6; elim H'7.\nintros a'7 H'8; elim H'7Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intros; elim H'3.\nintros b; elim H'4; intros H'5; elim H'5; intros H'5; elim H'6; intros H'5; elim H'5; intros H'5; elim H'6; intros H'6; elim H'6;\n intros H'5; elim H'6; intros H'6; elim H'7; intros H'6 H'6; elim H'6; intros H'6; elim H'6; intros H'6;\n intros H'7 H'6 H'8; elim H'6; intros H'6 H'7; elim H'7; intros H'6; elim H'7; intros H'6; elim H'7; intros H'6 H'8; elim H'8; intros H'8; elim H'7;\n intros H'8; elim H'8; intros H'8; elim H'8; intros H'8 H'8 H'9; elim H'10; intros HQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intros H'1; apply (eqA a a');\n auto with arith.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred red in |- *; red in |- *; red in |- *; red in |- *; intros H'1; exact (eqA a a').\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\n  red |- *.\nintros H'; case H'; auto.\nintros a H'1 H'2; case H'2.\nintros a' H'2; case H'3.\nintros b' H'3 H'3; elim H'3.\nintros b' H'3 H'4; case H'4.\nintros b' H'4 H'4 H'4 H'5.\nintros b'4 H'6 H'5 H'5 H'5.\nintros b'5 H'4 H'6 H'5 H'6 H'6 H'6.\nintros b'7 H'6 H'7 H'7 H'7 H'8; case H'5.\nintros b'5 H'8; case H'7.\nintros H'8; case H'5.\nintros b'5 H'6 H'7 H'7 H'8 H'10; case H'5.\nintros b'6 H'6 H'7 H'7 H'8 H'8.\nintros b'8 H'8; case H'9; intros H'9; case H'9.\nintrosQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intros.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; red in |- *; intros; red in |- *; red in |- *; red in |- *; intros; red in |- *; red in |- *; red in |- *; red in |- *; intros; red in H0.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nintros H'; case H'; case H'.\nintros a H'0; case H'0; intros H'0 H'1; case H'0; intros H'0 H'2.\nintros b H'0 H'1; elim H'0; intros H'1 H'2; case H'0; intros H'0 H'2; case H'0; intros H'2 H'2; case H'0; intros H'2 H'3; case H'0; intros H'1 H'3 H'3; case H'0; intros H'3; case H'3; intros H'3 H'3 H'4 H'5; case H'4; intros H'5 H'3 H'3 H'4; case H'5; intros H'5; case H'4; intros H'4 H'5; case H'0; intros H'5 H'4 H'6; case H'5; intros H'6 H'5; case H'6; intros H'5; case H'6; intros H'6; case H'6; intros H'6; case H'6;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 293,
                "proof_start_offset": 1419,
                "proof_end_offset": 1578,
                "proof": "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintros x; case H'1; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x H'; case H'.\nintros a H'1; case H'2.\nintros a H'1 H'1; case H'2; case H'2.\nintros a' H'2; case H'2; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nred in |- *.\nintros x; case H'; case H'2; simpl in |- *; auto.\nintros x0 H'2; case H'3; simpl in |- *; auto.\nintros x0 H'3; case H'4; simpl in |- *; auto.\nintros x0 H'4; case H'4; simpl in |- *; auto.\nintros x0 H'4; case H'5; simpl in |- *; auto.\nintros x0 H'5 H'5; case H'5; simpl in |- *; auto.\nintros x0 H'5; case H'5; simpl in |- *; auto.\nintros x0 H'6; case H'5; simpl in |- *; auto.\nintros x0 H'5; case H'5; simpl in |- *; auto.\nintros x0 H'5; case H'6; simpl in |- *; auto.\nintros x0 H'5; case H'5; simpl in |- *; auto.\nintros x0 H'5; case H'6; simpl in |- *; auto.\nintros x0 H'5; case H'6; simpl in |-Qed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x H'; case H'; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; intros H'; case H'.\nintros a H'1 H'2; case H'1.\nintros a' H'1; case H'2; case H'2; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x H'; case H'; intros H'2; exact (eqA a x).\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y H'0; case H'.\nintros a'0; elim H'.\nintros a'0 H'1; elim H'.\nintros a'0 H'2; apply (eqA a' a') in H'.\nintros a' H'2; elim H'.\nintros a'0 H'3 H'4 H'5; apply (eqA a'0' a').\nintros a'1 H'2 H'3 H'3 H'4; apply (eqA a'0' a'); auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case H'; case H'; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nintros a H'1; case H'2.\nintros b H'1; case H'2; auto.\nintros b H'3; case H'2; case H'4; auto.\nintros b H'3; case H'4; auto.\nintros b H'4; case H'4; auto.\nintros b H'4; case H'4; auto.\nintros b H'5; case H'5; auto.\nintros b H'5 H'5; case H'5; auto.\nintros b H'5; case H'5; auto.\nintros b H'5; case H'4; auto.\nintros b H'5; case H'5; auto.\nintros b'5; case H'5; auto.\nintros b'5; case H'5; auto.\nintros b'5; case H'6; auto.\nintros b'5; case H'5; auto.\nintros b'5; case H'6; auto.\nintros b'5; case H'5; auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 350,
                "proof_start_offset": 1581,
                "proof_end_offset": 1788,
                "proof": "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *; red in |- *.\nintros x y H'0; case H'0; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y; case H'; case H'; auto.\nintros x H'0; case H'; auto.\nintros x0 H'1; case H'; auto.\nintros H'0; case H'; auto.\nintros x0 H'1; case H'; auto.\nintros H'1; case H'; auto.\nintros x0 H'2; case H'0; auto.\nintros x0; case H'1; auto.\nintros x0; case H'2; auto.\nintros x0 H'1; case H'2; auto.\nintros x0 H'1 H'2; case H'2; auto.\nintros x0 H'2 H'3; case H'3; auto.\nintros x0 H'1 H'2; case H'3; auto.\nintros x0 H'1; case H'2; auto.\nintros x0 H'1 H'2; case H'2; auto.\nintros x0 H'2; case H'2; auto.\nintros x0 H'2; case H'3; auto.\nintros x0 H'2Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nintros x y H'0; case H'0; simpl in |- *; auto.\nintros x y H'0 H'1; case H'1; simpl in |- *; auto.\nintros x y H'1; case H'2; simpl in |- *; auto.\nintros x y0 H'0 H'1; case H'2; simpl in |- *; auto.\nintros x y H'1 H'2; case H'0; simpl in |- *; auto.\nintros x0 H'1 H'2; case H'3; simpl in |- *; auto.\nintros x0 H'1; case H'2; simpl in |- *; auto.\nintros x0 H'2; case H'4; simpl in |- *; auto.\nintros x0 H'2; case H'3; simpl in |- *; auto.\nintros x0 H'1; case H'2; simpl in |- *; auto.\nintros x0 H'3; case H'3; simpl in |- *; auto.\nintros x0 H'1; case HQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *; red in |- *; red in |- *; red in |- *; intros.\napply (ENot_trans x y); auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y H'0; case H'; intros H'1; exact (eqA_sym _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y H'0; case y; simpl in |- *; auto.\nintros x y z H'0 H'0; case H'0; simpl in |- *; auto.\nintros x y0 H'0; elim H'1; simpl in |- *; auto.\nintros x y z H'0 H'0; case H'0; simpl in |- *; auto.\nintros y0 H'0 H'1; case H'0; simpl in |- *; auto.\nintros y0 H'0 H'0; case H'0; simpl in |- *; auto.\nintros y0 H'0 H'1; case H'0; simpl in |- *; auto.\nintros x0 H'1; case H'0; simpl in |- *; auto.\nintros x0 H'0; case H'0; simpl in |- *; auto.\nintros x0 H'1 H'2; case H'0; simpl in |- *; auto.\nintros x0 H'0; case H'0; simpl in |- *; auto.\nintros x0 H'1 H'1 H'1; case H'0; simpl in |- *;Qed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y H'; case H'; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 435,
                "proof_start_offset": 1838,
                "proof_end_offset": 1917,
                "proof": "Definition T2M : Term -> mon n.\nProof.\nintros t; case t; intros a m; exact m.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition T2M : Term -> mon n.\n  Proof.\n    red in |- *; intros x y z; case z; simpl in |- *; intuition.\nDefined.",
                    "Definition T2M : Term -> mon n.\n \nTheorem eq_prod_sym : reflexive Term.\nred in |- *.\nintros x y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := a0); auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros x y; case x; simpl in |- *; auto.\nintros x y z; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros x y z; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n  Proof.\n    intros x y z; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros x y; case z; simpl in |- *; auto.\nintros x y z; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n \nTheorem U : forall (x y z : Term) (x y z : Term) (y z : Term) (y z : Term),\n (forall x y z : Term, Term_prod t t) (y z) ->\n M1 M2 M2 M2 M2 M2 M3 M3 M3 M4 M4 M5 M5 M5 M6 M7 M6 M7 M7 M10 M7 M9 M12 M13 M13 M13 M13 M13 M13 M13 M13 M13 M13 M13 M13 M13 M13 M14 M13 M14 M14 M14 M13 M13 M14 M13 M13 M13 M13 M13 M14 M13 M13 M13 M13 M13 M13 M13 M13 M14 M13 M13 M13 M13 M13 M13 M13 M13 M13 M13 M14 M13 M13 M14 M13 M14 M14 M14 M13 M13 M14 M14 M13 M14 M13 M14 M14 M13 M14 M14 M14 M14 M14 M13 M14 M13 M14 M14 M14 M14 M13 MDefined.",
                    "Definition T2M : Term -> mon n.\n \nTheorem not_trans : forall x y z : Term, (P x y) -> x.\nintros x y z; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\n  Proof.\nintros x y H'; case x; simpl in |- *; auto.\napply (eqA_trans _ _ _ _ _ cs); auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply (R2M1M2M2M2M3M3M3M3M3M3M4M3M4M3M4M4M5M6M4M7M8M6M8M7M7M9M9M8M9M9M7M9M9M9M9M9M7M8M9M9M9M9M9M9M9M9M9M9M8M9M9M9M9M9M9M9M9M9M9M10M9M9M9M9M9M9M9M9M13M9M9M9M9M9M1M9M9M9M9M9M9M9M9M9M9M9M9M9M9M9M9M9M9M9M9M11M9M9M9M9M9M9M9M9M9M0M9M9M9M9M9M9M9M9M9M9M9M8M9M9M9M9M9M8M9MDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 522,
                "proof_start_offset": 2133,
                "proof_end_offset": 2190,
                "proof": "Lemma eqT_refl : reflexive _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros a b H'; case b; simpl in |- *; intros; case b; simpl in |- *; intros; case b; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros a b; elim H'; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y H'0; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; intros a H'0; exact (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nred in |- *.\nintros x y; case y; simpl in |- *; intros a0 H'0; case H'0; simpl in |- *; intuition.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case z; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y H'; case x; simpl in |- *; intros a H'0.\nred in |- *; intros a' H'0; case H'0; simpl in |- *; intuition.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x; case x; simpl in |- *; intros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 543,
                "proof_start_offset": 2193,
                "proof_end_offset": 2249,
                "proof": "Lemma eqT_sym : symmetric _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nred in |- *; red in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 564,
                "proof_start_offset": 2252,
                "proof_end_offset": 2364,
                "proof": "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; red in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \n",
                "context_tokens": 601,
                "proof_start_offset": 2367,
                "proof_end_offset": 2492,
                "proof": "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'0 H'1; rewrite H'1'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; intros a b H'0 H'0; case H'0; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H' H'1; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros x b; case z; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "**********************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \n",
                "context_tokens": 618,
                "proof_start_offset": 2495,
                "proof_end_offset": 2864,
                "proof": "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H'; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H'; elim H'; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H'; elim H'.\nintros a b; elim H'.\nintros a b; elim H'.\nintros a b H'0; elim H'.\nintros a b H'0; elim H'.\nintros a b H' H'0 H'1 H'1; elim H'.\nintros a b H'0 H'1; elim H'2'.\nintros a b H'0 H'1 H'1; elim H'.\nintros a b H'0 H'1 H'2 H'2; elim H'.\nintros a b H'1 H'2; elim H'.\nintros a b' H'1 H'2 H'2; elim H'.\nintros a b H'1 H'2 H'2; elim H'.\nintros a b' H'0; elim H'.\nintros a b H'0 H'0; elim H'.\nintros a b' H'0 H'2 H'1 H'2; elim H'.\nintros a b'0 H'0 H'0 H'1 H'2; elim H'.\nintros a b'0 H'1 H'2; elim H'.\nintros aQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H'; case E; intros a b; exact (eqA a b); auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H'; case H'.\nintros x y H'0 H'1; case H'0; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y H'; case x; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "****)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \n",
                "context_tokens": 735,
                "proof_start_offset": 2867,
                "proof_end_offset": 3131,
                "proof": "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case x; simpl in |- *; intros H'0 H'1; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'0 H'1; clear H'1; auto.\nright; red in |- *; intros H'1 H'2; elim H'1; intros H'2 H'3 H'4; clear H'2; auto.\nright; red in |- *; intros H'2; elim H'3; intros H'2; elim H'3; intros H'3 H'4; clear H'3 H'1; auto.\nright; red in |- *; intros H'3 H'3; elim H'3; intros H'4 H'4; clear H'4; auto.\nright; red in |- *; intros H'4; elim H'3; intros H'4 H'4; clear H'4; auto.\nright; red in |- *; intros H'4; elim H'4; intros H'4; clear H'6; auto.\nright; red in |- *; intros H'6; elim H'4; intros HQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\napply (eqA_refl _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros x y H'; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nintros b1 b2 c; case b1; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros x; case y; simpl in |- *; intuition.\napply (E.eq_dec b3 b2); intros A B B C D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D DQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 745,
                "proof_start_offset": 3134,
                "proof_end_offset": 3267,
                "proof": "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x y H' H' H'0; rewrite H'0; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x y; case z; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x y; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x y H; case x; simpl in |- *; intuition.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \n",
                "context_tokens": 740,
                "proof_start_offset": 3270,
                "proof_end_offset": 3522,
                "proof": "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; intros H' H'0; rewrite H'0; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case b; simpl in |- *.\nintros b H'; case b; simpl in |- *; auto.\nintros b H'0; case b; simpl in |- *; auto.\nintros b H'0 H'0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *.\nintros b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case b; simpl in |- *.\nintros b b H' H'0 H'1 H'0; elim H'0; intros H'1 H'2; elim H'1; intros H'2; elim H'1; intros H'2; clear H'2 H'2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3524,
                "proof_end_offset": 3738,
                "proof": "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case b; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 757,
                "proof_start_offset": 3790,
                "proof_end_offset": 3932,
                "proof": "Definition plusTerm : Term -> Term -> Term.\nProof.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition plusTerm : Term -> Term -> Term.\nProof.\n  intros a b H'; elim a; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nProof.\n  intros a b H'; elim (eqA_dec a b); intros a b H'0; elim (eqA_dec a b); intros a b H'0 H'1 H'1; clear H'1 H'1 H'2 H'3; clear H'1 H'2 H'3 H'2 H'3 H'4; clear H'2 H'3 H'3 H'2'3 H'4 H'4 H'5 H'4 H'4 H'5 H'6 H'6 H'6 H'6 H'6 H'7 H'7 H'8 H'7 H'7 H'8 H'8; clear H' H'1 H'2 H'3 H'2 H'3 H'6 H'7 H'7 H'8 H'8 H'8 H'8; clear H' H'2 H'3 H'3 H'4 H'7 H'8; clear H'0 H' H'3 H'7 H'8 H'8 H'10 H'10 H'11 H'11 H'12 H'13 H'13 H'15 H'14Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\n  Proof.\n    intros a b H' H'0; red in |- *; intros a'0 H'1; elim H'0; intros H'0; elim H'0; intros H'1; elim H'0; intros H'2; elim H'2; intros H'2; elim H'3; intros H'3; elim H'4; intros H'3; elim H'4; intros H'4; elim H'3; intros H'4; elim H'4; intros H'5 H'6; elim H'6; intros H'6; elim H'4; intros H'6; elim H'7; intros H'6; elim H'7; intros H'7; elim H'7; intros H'7; elim H'7; intros; elim H'7; intros H'7 H'7; elim H'7; intros H'9 H'7; elim H'9; intros H'7; elim H'9; intros H'8 H'9; elim H'9; intros H'8 H'10 H'8; elim H'8; intros H'9; elim H'8; introsDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nred := fun a b : Term -> Term.\nintros a b H; case b; simpl in |- *; intros H'1 H'1; case b; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nProof.\n  intros a b H'; case b; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nProof.\n  intros a b H'; case b; simpl in |- *; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n  Proof.\nintros a b H' H'0; red in |- *; intros H'; elim H'; intros H'0 H'0; elim H'; intros H'1 H'1; elim H'0; intros H'1 H'2; elim H'0; intros H'2 H'2; elim H'0; intros H'3 H'4; elim H'3; intros H'2; elim H'2; intros H'3 H'3; elim H'2; intros H'4 H'3 H'3; elim H'3; intros H'4 H'4 H'4; elim H'5; intros H'4 H'5; elim H'6; intros H'4; elim H'6; intros H'4 H'6; elim H'6; intros H'6 H'5; elim H'6; intros H'6 H'6 H'6 H'7; elim H'7; intros H'7; elim H'6; intros H'6 H'7; elim H'7; intros H'7 H'6 H'7; elim H'7; intros H'7 H'6 HDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nProof.\n  intros a b; case b; simpl in |- *; intros H'0; elim H'; intros H'0; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nProof.\n  unfold plusTerm in |- *; intros a b H'0; elim H'; intros H'0; apply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\nred := fun x y => ~ IsEq a b.\nintros a b H' H'0; red in |- *; intros H'0.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Defined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 3982,
                "proof_end_offset": 4281,
                "proof": "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros b H'0; elim H'0; intros b4; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *.\nintros b1 b2; case b2; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0 H'0; red in |- *; intros a b'0; elim b;\n apply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros b H' H'0; case b; intros b3 c4; case b; intros b4; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H' H'0; red in |- *; intros H'0.\napply (E_comp_annihilant_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros; elim H'; intros H'0; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'0 H'0; case y; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros a b c1 c3 H'0 H'1; red in |- *; intros a b c3 H'0 H'0; red in |- *; intros a0 H'1;\n try (apply add_Term_r with (a := b0); auto).\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H'; case H'; intros b3; case H'; intros b4; case H'; intros b4; case H'; intros b4; case H'4; intros b4; case H'4; intros b4; case H'5; intros b5; case H'5; intros b5; case H'5; intros b5; case H'5; intros b5; case H'6; intros b5; case H'5; intros b6; case H'5; intros b7; case H'6; intros b5; case H'6; intros b5; case H'5; intros b7; case H6; intros b6; case H'6; intros b7; case H6; intros b6; case H'7; intros; case H'6; intros; case H'7; intros; case H'5; intros; case H6; intros; case H'6; intros; case H6; intros; case H6; intros; case H6; intros; case H6; intros; case H7; intros; case H6; intros; case H6; intros; case H6; intros;Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 4284,
                "proof_end_offset": 4653,
                "proof": "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H2; case m1; simpl in |- *; auto.\nintros a1 m2 H1 m2 H2 H3; case m1; simpl in |- *; auto.\nintros a2 m1 m2 H3 H3; case m1; simpl in |- *; auto.\nintros a2 m1 m2 H3 H4; case m1; simpl in |- *; auto.\nintros a2 m2 m2 H3; case m1; simpl in |- *; auto.\nintros a1 m2 m2 H4; case m1; simpl in |- *; auto.\nintros a1 m2 m2 H4; case m2; simpl in |- *; auto.\nintros a1 m2 m2 H4; case m2; simpl in |- *; auto.\nintros a1 m2 m2 H4; case m2; simpl in |- *; auto.\nintros a1 m2 H4; case m2; simpl in |- *; auto.\nintros a2 m3 H4; case m2; simpl in |- *; auto.\nintros a1 mQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H' H'0 H'0; red in |- *; intros H'1 H'2; elim H'; intros H'2; clear H'2;\n elim H'1; intros H'2 H'3; clear H'3;\n clear H' H'1 H'3 H'3 H'4 H'4; clear H' H'3; \n intros H'3 H'4 H'4 H'4; clear H'4 H'4 H'4 H'6 H'4; clear H' H' H'4 H'4 H'4; \n case b; simpl in |- *; auto.\nintros a1 m2 m2 H'4; case b; simpl in |- *; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a1 m2 a1 m2 H2; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H H'; case b; simpl in |- *; auto.\nintros b H'; case b; simpl in |- *; auto.\nintros a2 m2 H' H'0 H'1; split; auto.\nintros a2 m2 H'1 H'2; split; auto.\nintros a3 m2 a3 H'1 m2; split; auto.\nintros a3 m2 H'1 m3 H'2; split; auto.\nintros a3 m3 m3 H'1 H'3; split; auto.\nintros a4 m3 m3 H'3 H'4 H'3 H'4; split; auto.\nintros a3 m4 m4 H'3 H'4; split; auto.\nintros a3 m4 H' H'4; split; auto.\nintros a3 m4 m4 H'1 H'4; split; auto.\nintros a4 m3 m4 H'4 H'4 H'4; split; auto.\nintros a4 m5 m4 H'4 H'4; split; auto.\nintros a4 m4 m4 H'4 H'4Qed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4656,
                "proof_end_offset": 4853,
                "proof": "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a1 m1 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA a2 a2); auto.\napply (eqA_trans _ _ _ _ _ cs) with (y := plusA0 a2 a2); auto.\napply (eqA_trans _ _ _ _ _ _ csy); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a1 m1 m2 H2; case b; simpl in |- *; auto.\nintros a2 m1 m2 H2; case b; simpl in |- *; auto.\nintros a1 m1 m2 H3; case b; simpl in |- *; auto.\nintros a1 m1 m2 H3; case b; simpl in |- *; auto.\nintros a1 m2 m2 H3; case b; simpl in |- *; auto.\nintros a1 m2 m2 H3; case b; simpl in |- *; auto.\nintros a2 m1 m2 H4; case b; simpl in |- *; auto.\nintros a1 m2 m2 H4; case b; simpl in |- *; auto.\nintros a1 m2 m2 H4; case b; simpl in |- *; auto.\nintros a1 m2 m3 H4; case b; simpl in |- *; auto.\nintros a1 m2 m3 H4; case b; simpl in |- *; auto.\nintros a1 m2 m3 H4; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\n  intros a b c H; case b; simpl in |- *; auto.\nintros a1 m2 m2 H H2 H3; case b; simpl in |- *; auto.\nintros a1 m2 H3 H3 H4; case b; simpl in |- *; auto.\nintros a1 m1 m2 H4 H4 H4; case b; simpl in |- *; auto.\nintros a1 m2 H4 H4 H4; case b; simpl in |- *; auto.\nintros a1 m2 H4 H4; case b; simpl in |- *; auto.\nintros a1 m1 m2 H4 H5; case b; simpl in |- *; auto.\nintros a1 m2 H4; case b; simpl in |- *; auto.\nintros a1 m2 m2 H5 H4; case b; simpl in |- *; auto.\nintros a1 m2 m2 H4; case b; simpl in |- *; auto.\nintros a1 m2 H5; case b; simpl in |- *; auto.\nintros a1 m2 H5 H6; case b; simpl in |- *; auto.\nintros a1 m2 m3 HQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a b1 m2 H1 m2 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ cs) with (y := plusA0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA1 a2); auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA1 a2 a2); auto.\napply (eqA_trans _ _ _ _ cs) with (y := plusA1 a2); auto.\napply (eqA_trans _ _ _ cs) with (y := plusA2 a2 a3); auto.\napply (eqA_trans _ _ _ cs y _ _ _ _ cs) with (y := plusA2 a3); auto.\napply (eqA_trans _ _ _ cs y _ _ _ cs) with (y := plusA1 a3); auto.\napply (eqA_trans _ _ cs y); auto.\napply (eqA_trans _ _ _ cs y); auto.\napply (eqA_transQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\napply (eqA_trans _ _ _ _ _ _ cs) with (y := plusA0 a); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; case b; simpl in |- *; auto.\nintros a1 m1 m1 H0; case b; simpl in |- *; auto.\nintros a1 m2 m2 H0; case b; simpl in |- *; auto.\nintros a1 m2 H' H'1 H'1; case b; simpl in |- *; auto.\nintros a1 m2 m2 H'1 H'2; case b; simpl in |- *; auto.\nintros a1 m2 m2 H'1 H'1; case b; simpl in |- *; auto.\nintros a2 m2 m2 H' H'1 H'2; case b; simpl in |- *; auto.\nintros a2 m1 m2 H' H'2 H'3; case b; simpl in |- *; auto.\nintros a2 m2 m2 H'1 H'2; case b; simpl in |- *; auto.\nintros a2 m2 m2 H'2 H'3 H'1 H'2; case b; simpl in |- *; auto.\nintros a2 m2 m3' H'2; case b; simpl in |- *; auto.Qed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H0; case b; simpl in |- *; auto.\nintros a1 m1 m2 H2; case b; simpl in |- *; auto.\nintros a1 m2 H1; case b; simpl in |- *; auto.\nintros a1 m2 m1 H2; case b; simpl in |- *; auto.\nintros a1 m1 m2 H2; case b; simpl in |- *; auto.\nintros a1 m1 m2 H2; case b; simpl in |- *; auto.\nintros a1 m1 m2 H1; case b; simpl in |- *; auto.\nintros a1 m2 m2 H2; case b; simpl in |- *; auto.\nintros a1 m2 m2 H2; case b; simpl in |- *; auto.\nintros a1 m2 m2 H2; case b; simpl in |- *; auto.\nintros a1 m2 m2 H3; case b; simpl in |- *; auto.\nintros a1 m1 m2 H3; case b; simpl in |- *; auto.\nintros a2 m2 m1 H3; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4856,
                "proof_end_offset": 5053,
                "proof": "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 737,
                "proof_start_offset": 5056,
                "proof_end_offset": 5201,
                "proof": "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case b; simpl in |- *; auto.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5204,
                "proof_end_offset": 5341,
                "proof": "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m2; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; case b; simpl in |- *; auto.\nintuition.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m2 H; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case n; simpl in |- *; auto.\nintros m1 m2 H1; case n; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m2; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5344,
                "proof_end_offset": 5481,
                "proof": "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 a b c; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 a b c; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "P b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 714,
                "proof_start_offset": 5484,
                "proof_end_offset": 5775,
                "proof": "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n \nintros a0 a1 b0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n  intros a0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n  intros a0 a0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n  intros a0 a0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n  intros a0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n  intros a0 b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n  intros m1 a0 H; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n \nintros m1 a1 m2 H0; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\n  intros a0 a0; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ", c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_assoc :\n forall a a0 A1 : Term,\n eqT A1 a0 ->\n eqT a a0 ->\n eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.\n \n",
                "context_tokens": 718,
                "proof_start_offset": 5778,
                "proof_end_offset": 6007,
                "proof": "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a b c d; case a; case b; case c; case d; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\n  intros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nintros a0 a0 m1 m2 H0 H1 H2; split; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\n  intros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case b; simpl in |- *; auto.\nQed."
                ]
            }
        ],
        "dblib": [
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\n",
                "context_tokens": 535,
                "proof_start_offset": 2012,
                "proof_end_offset": 2137,
                "proof": "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nsimpl_lift_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor.\n  apply (exp_subst T e x).\n  constructor.\n  apply (exp_subst T e x).\n  constructor.\n  apply (exp_subst T e x).\n  constructor.\n  apply (exp_subst T e x). constructor.\n  apply (exp_subst T e x). constructor.\n  apply (exp_subst T e x). constructor.\n  apply (exp_subst T e x). constructor.\n  apply (exp_subst T e x). constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor.\n  apply (exp_subst T e x). constructor. constructor. constructor. constructorQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor.\n  apply (proj2_sig w k x); auto.\n  apply (proj2_sig w k x); auto.\n  apply (proj2_sig w k x); auto.\n  apply (proj2_sig w k x); auto.\n  apply (proj2_sig w k x); auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor. apply trans. apply trans. apply trans. apply h. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply trans. apply H. apply trans. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply H. apply trans. apply H. apply trans. apply H. apply H. apply trans. apply H. apply H. apply trans. apply H. apply H. apply trans. apply H. apply H. apply H. apply trans. apply H. apply H. applyQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor. apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eq.\n  apply trans_eqQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor.\n  apply (IHidden_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term_term.\nProof.\n  constructor.\n  apply (@IHidden_term_term_term_term_term_term_term_term_term_term_term_term.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor.\n  apply trans_eq with (f := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := fun w => v) (g := funQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.\n  apply IHSassign.Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor. apply (IHTyping x k).\n  constructor.\n    apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.\n  apply (IHTyping x k); constructor.Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. red_eq. apply red_eq. apply red_eq. red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. red_sym. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_eq. apply red_Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  constructor.\n  prove_fo'.\n  apply apply IHe.\n  assumption.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 583,
                "proof_start_offset": 2139,
                "proof_end_offset": 2442,
                "proof": "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  applyQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  rewrite lift_lift_hyps. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  induction 1.\n  - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n            - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n         Qed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  apply (env_subst_lift_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_typeQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  induction 1; intros.\n  - rewrite lift_lift_goal.\n    simpl_lift_goal. reflexivity.\n  - rewrite lift_lift_goal. reflexivity.\n    simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  induction 1; intros.\n  + simpl_lift_goal.\n    + simpl_lift_goal.\n      + simpl_lift_goal.\n      + simpl_lift_goal.\n      simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_lift_goal.\n        simpl_hyps.\n        simpl_lift_goal.\n        simpl_lift_goal.Qed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  constructor.\n  - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n        - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n        - constructor.\n      - constructor.\n        - constructor.\n      - constructor.\n      - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n        - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n            - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          -Qed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  induction 1; auto.\n  apply (IHApp t1 t2); auto.\n  apply (IHApp t1 t2); auto.\n  apply (IHApp t1 t2); auto.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  constructor.\n  (* In, the expression [auto] to [auto] to [auto] to [auto] to [auto] to [auto] to [auto] to [auto] to [auto]\n   [auto] to [auto] to [auto] to [auto] to [auto] to [auto] *)\n\nLemma lift_T_App:\n  forall w k t1 t2, lift w k (TVar y k t2) = TApp (lift w k t1) (lift w k t1) (lift w k t1).\nProof.\n  constructor.\n  (* In, and the goal is a hypothesis. *)\n  constructor.\n  (* In, the goal. *)\n  constructor.\n  (* In, we have a hypothesis *)\n  constructor.\n  (* In, the hypothesis, we can be used to be a hypothesis to show that [auto] to [auto] to [auto] to [auto] to [auto] to [auto]\n   [auto] to [auto] to [auto]\n   [auto] and [auto] to [auto] to [auto]\n   [auto] to [auto] to [auto]\n   [auto] and [Qed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros.\n  apply H.\n  eapply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "uijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 659,
                "proof_start_offset": 2444,
                "proof_end_offset": 2565,
                "proof": "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  induction t; simpl_lift_goal.\n  reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  unfold lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, lift, liftQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  simpl_lift_hyps. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  (* [simpl_lift_goal] *)\n  eauto with arith.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  rewrite lift_T.\n  auto with arith.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  unfold lift in *.\n  do_lift_goal.\n  do_simpl_lift_goal.\n  do_simpl_lift_goal.\n  do_simpl_lift_goal.\n  do_simpl_lift_goal.\n  do_simpl_goal.\n  do_simpl_lift_goal.\n  do_simpl_lift_goal.\n  do_simpl_lift_goal.\n  do_simpl_lift_goal.\n  do_simpl_goal.\n  do_simpl_goal.\n  do_simpl_lift_goal.\n  do_simpl_goal.\n  do_simpl_lift_goal.\n  do_simpl_goal.\n  do_simpl_lift_goal.\n  do_simpl_goal.\n  do_simpl_goal.\n  do_simpl_goal.\n  do_simpl_hyp.\n  do_simpl_goal.\n  do_simpl_hyp.\n  do_simpl_goal.\n  do_simpl_goal.\n  do_simpl_goal.\n  do_simpl_hyps.\n  do_simpl_hyps.\n  do_simpl_hyps.\n  do_simpl_goal.\n  do_simpl_goal.\n  do_simpl_goal.\n  doQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  (* [simpl_lift_goal] *)\n  eauto with subst.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 695,
                "proof_start_offset": 2567,
                "proof_end_offset": 2693,
                "proof": "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\nintros.\nsimpl_subst_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  induction k; intros.\n  - destruct x; simpl_lift_goal.\n    - destruct x; simpl_lift_goal.\n      - destruct x; simpl_lift_goal.\n      - destruct x; simpl_lift_goal.\n      - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x; simpl_lift_goal.\n        - destruct x;Qed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  constructor.\n  solve_eq_tac.\n  apply subst_T.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tac.\n  solve_eq_tacQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  induction k; intros.\n  + simpl_lift_goal. reflexivity.\n  + simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  induction k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct k; simpl_lift_goal.\n  destruct kQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewrite subst_lift_goal.\n  rewriteQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  auto with simpl_lift.\n  intros.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_goal.\n  auto with subst_lift_hyps.\n  auto with subst_lift_goal.\n  auto with subst_liftQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  unfold subst_idx.\n  induction k; simpl_lift_goal.\n  rewrite subst_term_cons. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  induction k; simpl_lift_goal.\n  auto with arith.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  unfold subst_term in H.\n  destruct (X.eq_dec k x x).\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversionQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 702,
                "proof_start_offset": 2695,
                "proof_end_offset": 2838,
                "proof": "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  induction 1.\n  - simpl_lift_goal.\n      constructor.\n    + simpl_lift_goal.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructor.\n      constructorQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_list_gen] *)\n  do_tac.\n  (* [simpl_list_goal] *)\n  do_tac.\n  (* [simpl_lift_goal] *)\n  do_tac.\n  (* [simpl_list_gen_goal] *)\n  do_tac.\n  (* [simpl_list_gen_goal]Qed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  induction 1; intros.\n  simpl_lift_goal.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.\n  solve_intro.Qed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  (* [simpl_lift_goal] *)\n  auto with arith.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  induction k; simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  induction k; simpl_lift_goal.\n  apply subst_TApp with (App (App t1 t2 t2) (subst k t2 t2) (subst k t2 t2).\n  induction k; simpl_lift_goal.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n Qed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  (* [simpl_lift_goal] *)\n  unfold subst_lift_hyps. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 2840,
                "proof_end_offset": 2975,
                "proof": "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  apply subst_TVar.\n  intros. simpl_lift.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_hyps.\n  intros. simpl_lift_goal.\n  intros. simpl_eq_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_lift_goal.\n  intros. simpl_goalQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  induction k; intros.\n  (* simpl_lift *)\n  eapply subst_TVar.\n  eapply subst_T.\n  apply subst_T.\n  apply subst_T.\n  eapply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.Qed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  induction k.\n  - simpl_subst_goal.\n    constructor.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_T.\n    apply subst_Qed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_T.\n  apply subst_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3574,
                "proof_end_offset": 3768,
                "proof": "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lift_subst.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; red; intros.\n  red; intros.\n  red; red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; intros.\n  red; red; introsQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. simpl_subst_hyps. reflexivity.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. simpl_subst_hyps. reflexivity.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  induction t1; intros; simpl_subst_hyps.\n  exists x.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapply red_rule.\n  eapplyQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  eapply red_env; eauto with arith pts.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  induction 1.\n  - constructor.\n  - constructor.\n  - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n    - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n      - constructor.\n        - constructor.\n        - constructor.\n        - constructor.\n          - constructor.\n          - constructor. auto.\n        - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n        - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n            - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n          - constructor.\n            - constructor.\n            - constructor.\n            - constructor.\n            - constructor.\n          - constructor.\n            - constructor.\n            - constructor.\n          - constructor.\n          - constructor.\n            - constructor.\n            - constructor.\n            - constructor.\n            - constructorQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros.\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skip *)\n  (* skipQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  induction t1; intros.\n  (* todo: because the form of the context *)\n  destruct t1 as [x2 x3].\n  (* TODO: this goal for the context *)\n  destruct t1 as [x3 x4].\n  (* todo: this term of the context *)\n  destruct t2 as [x3 x4].\n  (* todo: the hypothesis *)\n  destruct t2 as [x4 x5].\n  (* todo: the context *)\n  destruct t2 as [x4 x6].\n  (* TODO: the context *)\n  destruct t2 as [x4 x6].\n  (* TODO: the context *)\n  destruct t2 as [x5 x5].\n  (* todo: the goal is the context *)\n  destruct t1 as [x5 x7].\n  (* TODO: the goal with this hypothesis *)\n  destruct t2 as [x6 x6].\n  (* TODO: this goal with the goal with H : context *)\n  destruct t2 as [x6 x7] |- _ ] =>\n  (* TODO: this context *)\n  destruct t2 as [x5 x6].\n  (* todo: this tactic to get the context *)\n  destruct t2 as [x5 x7Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. simpl_subst_hyps. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4003,
                "proof_end_offset": 4153,
                "proof": "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\nintros.\ninversion_closed.\neauto using closed_var.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto withQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  destruct (TVar 0) eqn:E.\n  - destruct (TVar 0) eqn:E.\n    - destruct (TVar 0) eqn:E.\n    - destruct (TVar 0) eqn:E.\n      - destruct (TVar 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:E.\n        - destruct (T.Var 0) eqn:Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros. simpl_subst_goal.\n  inversion_clear.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  auto with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H1 with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H1 with lift_subst.\n  apply H1 with lift_subst.\n  apply H1 with lift_subst.\n  apply H0 with lift_subst.\n  apply H1 with lift_subst.\n  apply H1 with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H1 with lift_subst.\n  apply H0 with lift_subst.\n  apply H1 with lift_subst.\n  apply H0 with lift_subst.\n  apply H0 with lift_subst.\n  apply H1 with lift_subst.\n  apply H0 with lift_subst.\n  apply H1 with lift_subst.\n  apply H1 with lift_Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst; simpl_hyps.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  econstructor; eauto with lift_subst.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_lift.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros. simpl_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor;Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros. simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4155,
                "proof_end_offset": 4297,
                "proof": "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_closed_closed_closed_closed_closed.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_closed_closed_closed_closed_closed.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction 1; intros.\n  - auto with closed.\n  - auto with closed.\n  - auto with closed.\n  - auto with closed.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_type_Qed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n Qed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\nProof.\n  intros. inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed.\n  eauto with lift_closed_closed_closed_closed_closed_closed_closed.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  induction 1; intros. inversion_closed_ind. eauto with lift_subst. eauto with lift_lift. eauto with lift_subst. eauto with lift_lift. eauto with lift_subst. eauto with lift_lift. eauto with lift_lift. eauto with lift_subst. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. auto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. eauto with lift_lift. auto with lift_lift. eauto with lift_lift. eauto with lift_lift. auto with lift_lift. auto with lift_lift. eautoQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_closed_type. eauto using closed_var.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4299,
                "proof_end_offset": 4441,
                "proof": "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed_cs. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed_lc_T.\n  assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed_closed_type_type_type. auto.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  econstructor; eauto with lift_subst.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto with lift_subst.\n  econstructor; eauto withQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed_subst.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed_inversion_clear.\n  inversion_closed_clear_inversion_clear_inversion_clear H.\n  inversion_closed_inversion_clear H0.\n  inversion_closed_clear H.\n  inversion_closed_clear H0.\n  inversion_closed_inversion_clear H1.\n  inversion_closed_clear H0.\n  inversion_closed_inversion_clear H0.\n  inversion_closed_clear H1.\n  inversion_closed_clear H0.\n  inversion_closed_inversion_clear H0.\n  inversion_closed_clear H0.\n  inversion_closed_inversion_clear H1.\n  inversion_closed_subst_closed_inversion_clear H0.\n  inversion_closed_closed_inversion_clear H.\n  inversion_closed_clear H0.\n  inversion_closed_clear H0.\n  inversion_closed_closed_inversion_clear H0.\n  inversion_closed_closed_inversion_clear H0.\n  inversion_closed_inversion_closed_clear H1.\n  inversion_closed_clear H0.\n  inversion_closed_closed_inversion_clear H.\n  inversion_closed_closed_inversion_clear H0.Qed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed_inversion H. eauto using closed_var_subst_exp.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed_subst.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal.\n  econstructor; eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_subst.\n  eauto with lift_substQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4443,
                "proof_end_offset": 4580,
                "proof": "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_closed_T. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_closed_inversion_closed_inversion_clear_clear.\n  inversion_closed_inversion_clear_clear.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_type. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_type_type_type. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_closed_T. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_subst. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_closed_T. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_open_tm_wrt_exp.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed_type. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 4621,
                "proof_end_offset": 4884,
                "proof": "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\ninduction 1; intros; subst; inversion_closed; try construction_closed.\neauto using @subst_preserves_closed with typeclass_instances.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed_lc. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_lc_Qed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed_T. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_type. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed_T. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed_closed_closed_closed_closed_closed.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed_closed_closed_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ht:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\n",
                "context_tokens": 702,
                "proof_start_offset": 5750,
                "proof_end_offset": 5972,
                "proof": "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lookup_insert insert_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion_closed.\n  apply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion_closed_closed_closed_closed. assumption.\n  eapply H0.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H3.\n  eapply H1.\n  eapply H3.\n  eapply H3.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H3.\n  eapply H3.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H2.\n  eapply H3.\n  eapply H3.\n  eapply H3.\n  eapply H4.\n  eapply HQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion_closed.\n  inversion_closed_closed.\n  apply H.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion_closed.\n  eapply H.\n  apply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapplyQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; auto.\n  + intros.\n    + intros.\n    + intros.\n    + intros.\n    + intros.\n      apply H.\n      apply H.\n      eapply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n      apply HQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  intros.\n  inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift; auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H1.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H1.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversionQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros. inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "---------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 6096,
                "proof_end_offset": 6487,
                "proof": "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\ndo 5 intro; intro h; dependent induction h; intros; simpl_subst_goal; try solve [ econstructor; eauto using weakening with insert_insert ].\nunfold subst_idx.\ndblib_by_cases; lookup_insert_all; eauto with j.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; inversion_closed.\n  (* The same value of the value *)\n  inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H1.\n  inversionQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; inversion_clear H0.\n  (* no rule *)\n  destruct (t1 t2) as (t2 & t2 & t2 & t2 & t3 & t3 & t3 & t3 & t3 & t3 & t3 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t4 & t5 & t4 & t4 & t5 & t4 & t5 & t5 & t4 & t4 & t5 & t4 & t5 & t6 & t5 & t4 & t4 & t5 & t5 & t6 & t5 & t6 & t4 & t5 & t6 & t5 & t5 & t5 & t6 & t5 & t6 & t5 & t5 & t6 & t6 & t5 & t6 & t6 & t6 & t8 & t6 & t6 & t6 & t7 & t10 & t11 & t11 & t12 & t11 & t12 & t13Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; inversion_clear H0.\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t1).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t1).\n  apply (H x t2).\n  apply (H x t).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t2).\n  apply (H x t).\n  apply (H x t).\n  apply (H x t2).\n  apply (H x t).\n  apply (HQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed.\n  subst; inversion_closed_closed_closed_closed_closed_closed_closedQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros. inversion_closed_closed.\n  apply (closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closed_closed_closed_closed_closed_closed).\n  apply (closed_closed_closedQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.Qed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros. inversion_closed_closed.\n  inversion_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed_closed.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\nLemma substitution:\n  forall E x t2 T1 T2,\n  j (insert x T1 E) t2 T2 ->\n  forall t1,\n  j E t1 T1 ->\n  j E (subst t1 x t2) T2.\nProof.\n  do 5 intro; intro h; dependent induction h; intros; simpl_subst_goal;\n  (* General rule. *)\n  try solve [ econstructor; eauto using weakening with insert_insert ].\n  (* Case TVar. *)\n  unfold subst_idx. dblib_by_cases; lookup_insert_all; eauto with j.\nQed.\n\n(* The typing judgement is preserved by reduction. Note that this is\n   proved for an arbitrary environment [E]: we do not restrict our\n   attention to closed terms. *)\n\n",
                "context_tokens": 699,
                "proof_start_offset": 6659,
                "proof_end_offset": 6974,
                "proof": "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\ninduction 1; intros ? ? h; subst; dependent destruction h; eauto with j.\nmatch goal with h: j _ (TAbs _) _ |- _ => inversion h; clear h; subst end.\neauto using substitution.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion H; subst; subst; auto.\n  (* Case \"typing_typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\". *)\n  (* Case \"typing_abs\".\n    (* Case \"typing_abs\".\n    Case \"typing_abs\".\n      (* Case \"typing_abs\". *)\n    (* Case \"typing_abs\".\n      (* Case \"typing_abs\".\n      (* Case \"typing_abs\".\n      (* Case \"Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  (* progress *)\n  destruct (IH t1 t2); simpl_lift_goal;\n  (* first hypothesis is a term *)\n  simpl_lift_goal;\n  (* first hypothesis, we use [E] and [E] in the\n   first term [E]. *)\n  simpl_lift_goal;\n  (* first hypothesis [E] in the hypothesis. *)\n  simpl_lift_goal;\n  (* first hypothesis *)\n  simpl_lift_goal;\n  (* hypothesis [E] in the hypothesis. *)\n  simpl_lift_goal;\n  (* hypothesis *)\n  simpl_lift_goal;\n  (* first hypothesis [E] in the hypothesis. *)\n  simpl_lift_goal;\n  (* hypothesis [E] on the hypothesis. *)\n  simpl_lift_goal;\n  (* hypothesis *)\n  simpl_lift_goal;\n  (* hypothesis for hypothesis hypothesis, in the hypothesis. *)\n  simpl_lift_goal;\n  (* hypothesis for hypothesis for hypothesis. *)\n  simpl_lift_goal;\n  (* hypothesis for hypothesis. *)\n  simpl_lift_goal;\n  (* hypothesis *)\n  simpl_lift_goal;\n  (* hypothesis *)\n  simpl_Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion H; subst; simpl_lift;\n  econstructor; eauto with lookup_insert_value;\n  intros; subst; simpl_lift_right;\n  intros; subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_right;\n  subst; simpl_lift_lift_right;\n  subst; simpl_lift_lift;\n  subst; simpl_lift_right;\n  subst; simpl_lift_lift_right;\n  subst; simplQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion_clear H.\n  unfold subst_idx.\n  eapply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_lift; auto.\n  (* An_typing *)\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typing_preservation; eauto with pts.\n  eapply typingQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  unfold type_of in |- *.\n  induction t1; intros; inversion_clear H.\n  (* Case \"typing_inversion_clear H0\".\n    (* Case \"typing_inversion_clear H0\". *)\n    (* Case \"typing_inversion_clear H0\".\n    (* Case \"typing_inversion_clear H0\". *)\n    (* Case \"typing_inversion H0\". *)\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\". *)\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\". *)\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\". *)\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\". *)\n    (* Case \"typing_inversion H0\". *)\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\".\n    (* Case \"typing_inversion H0\".\n    Case \"typing_inversion H0\".\n      (* Case \"typing_inversion H0\".\n      (* Case \"typing_inversion HQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion H; subst; auto with pts.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto.\n  (* In environment *)\n  unfold subst_idx; unfold_idx; unfold_term; simpl_env; simpl_env_env_var;\n  unfold_of_env; simpl_env;\n  unfold_of_env; simpl_env;\n  unfold_of_env; simpl_env_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_var;\n  unfold_of_env; simpl_env_varQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion H; subst; eauto with pts.\n  inversion H; subst; auto with pts.\n  inversion H; subst; eauto with pts.\n  inversion H; subst; auto with pts.\n  inversion H; subst; auto with pts.\n  inversion H; subst; auto with pts.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. inversion H. subst.\n  (* ADMITTED *)\n  clear H0.\n  induction H0.\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)\n  inversion H0. subst.\n  (* ADMITTED *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bounded version of this\n   notion. Perhaps by chance, the basic laws that relate [lookup], [insert],\n   and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\n",
                "context_tokens": 639,
                "proof_start_offset": 3688,
                "proof_end_offset": 3780,
                "proof": "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction 1; intros; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; intros.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simplQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\ndestruct x; destruct x; destruct x; destruct y; destruct y; destruct y; destruct y; destruct y; destruct y; destruct y; destruct y; destruct y; destruct z; destruct y; destruct z; destruct y; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z;Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simplQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  destruct x.\n  + destruct x.\n    + destruct x.\n    + destruct x.\n    + destruct x.\n      + destruct x.\n      + destruct x.\n      + destruct x.\n      + destruct x.\n        + destruct x.\n        + destruct x.\n        + destruct x.\n        + destruct x.\n        + destruct x.\n        + destruct x.\n        + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n          + destruct x.\n         Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; auto; intros; omega.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; intros.\n  + inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n    inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n    inversion H; subst.\n  + inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n  + inversion H; subst.\n    inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst;\n    inversion H; subst.\n    inversion H; subst;\n    inversion H; subst.\n  + inversion H; subst.\n  + inversion H; subst.\n    inversion H; subst.\n  + inversion H; subst.\n    inversion H; subst.\n    inversion H; subst;\n    inversion H; subst.\n    inversion H; subst;\n    inversion H; subst;\n    inversion H; substQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 656,
                "proof_start_offset": 3782,
                "proof_end_offset": 3886,
                "proof": "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "=>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 4202,
                "proof_end_offset": 4306,
                "proof": "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  unfold raw_insert.\n  destruct (insert_one p e) as [f e].\n  simpl in *.\n  rewrite one_plus_x_one_right in *.\n  repeat rewrite one_plus_x_one_right in H.\n  repeat rewrite one_plus_x_one_right in H.\n  repeat rewrite one_plus_x_one_right in H.\n  repeat rewrite one_plus_x_one_right in H.\n  repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right in H. repeat rewrite one_plus_x_one_right inQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  assert (x <= e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%nat by omega.\n  assert (x <> e)%natQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  rewrite <- (insert_one_eq_one_left (f a) e).\n  rewrite <- (insert_one_neq_one_right (f a) e).\n  rewrite <- (insert_one_neq_one_right (f a) e).\n  rewrite <- (insert_one_neq_one_left (f a) e).\n  rewrite <- (insert_one_neq_one_right (f a) e).\n  rewrite <- (insert_one_neq_one_right (f a) e).\n  rewrite <- (insert_one_neq_one_right (f a) e).\n  rewrite <- (insert_one_neq_one_one_right (f a) e).\n  rewrite <- (insert_one_neq_one_right (f a) e)).\n  rewrite <- (insert_one_neq_one_right (f a) e)).\n  rewrite <- (insert_one_neq_one (f a) e).\n  rewrite <- (insert_one_neq_one_right (f a) e).\n  rewrite <- (insert_one_neq_one (f a) e)).\n  rewrite <- (insertQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 4308,
                "proof_end_offset": 4484,
                "proof": "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nintros.\ndestruct e; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct e; auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  apply raw_insert_insert_iff.\n  intros.\n  destruct e.\n  auto.\n  apply raw_insert_insert_iff in H0; auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. apply raw_insert_inv_left with o e; auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. omega.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  unfold raw_insert_right, raw_insert, raw_insert, raw_insert_insert.\n  destruct o e; simpl; try congruence.\n  rewrite one_one_eq_one_right_one_right_right_one_left_one_right_one_right_one_right_right_one_right_one_right_one_right_one_one_one_one_right_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_Qed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  assert (H: forall x, raw_insert (S x) o e = lookup (S x) e).\n  { apply fold_right; auto. }\n  assert (H: forall x, raw_insert (S x) o e = lookup (S x) e).\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. } }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. } }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto. }\n    { apply fold_right; auto.Qed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  apply raw_insert_NoDup.\n  applyQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  apply raw_insert_in_one.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4545,
                "proof_end_offset": 4773,
                "proof": "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\nunfold empty; intros; destruct x.\nrewrite raw_insert_zero in *.\ncongruence.\nrewrite raw_insert_successor in *.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. unfold equal; intros.\n  destruct (find x e) as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [x|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [y|e].\n  apply equal_insert_iff in H; auto.\n  destruct e as [y|e].\n Qed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply equal_insert_inv; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  apply insert_insert_left; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  rewrite <- insert_node_iff; repeat rewrite add_add_l_reverse_left; repeat rewrite add_add_r_r_left; repeat rewrite add_add_r_left; repeat rewrite add_add_r_left; repeat rewrite add_add_r_r_left; repeat rewrite add_add_distr_left; repeat rewrite add_add_r_left; repeat rewrite add_add_assoc; repeat rewrite add_add_distr_r_left; repeat rewrite add_add_r; repeat rewrite add_add_assoc; repeat rewrite add_add_distr_l; repeat rewrite add_add_distr_r; repeat rewrite add_add_distr_r; repeat rewrite add_add_distr_l; repeat rewrite add_add_distr_r; repeat rewrite add_add_r; repeat rewrite add_add_distr_r; repeat rewrite add_add_distr_r; repeat rewrite add_add_assoc; repeat rewrite add_add_distr_r; repeat rewrite add_add_distr_r; repeat rewrite add_add_distr_r; repeat rewrite add_add_distr_r; repeat rewrite addQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  induction e; simpl; intros; auto.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\n  apply equal_insert_r.\n  apply equal_insert_left.\n  apply equal_insert_left.\n  apply equal_insert_right.\n  apply equal_insert_left.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_left.\n  apply equal_insert_left.\n  apply equal_insert_left.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_left.\n  apply equal_insert_left.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_left.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_left.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insert_right.\n  apply equal_insertQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_l.\n  rewrite empty_eq_insert_l.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_l.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_l.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_l.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_r.\n  rewrite empty_eq_insert_l.Qed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\n\n  destruct e; reflexivity.\n  destruct e; reflexivity.\n  destruct e; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 4908,
                "proof_end_offset": 5022,
                "proof": "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\ndestruct x; simpl; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  apply lookup_empty_iff in H. congruence.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  unfold lookup; intros.\n  destruct x; congruence.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  unfold lookup; intros. destruct x.\n  rewrite raw_insert_empty. auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  unfold lookup; intros.\n  destruct x; simpl.\n  destruct x; auto.\n  destruct x; destruct x; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  induction e; simpl; intros; intros.\n  rewrite raw_insert_iff in H0. congruence.\n  destruct x; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  unfold lookup; destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros; destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_empty.\n  rewrite lookup_Qed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  unfold lookup, lookup, lookup, lookup; simpl.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite (find_insert_inv _ _ _ H).\n  rewrite lookup_insert_spec in H.\n  destruct (eq_dec x e).\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct (eq_dec e e); try contradiction.\n  rewrite lookup_insert_spec in H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_spec in H.\n  destruct H.\n  rewrite lookup_insert_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "aw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\n",
                "context_tokens": 686,
                "proof_start_offset": 5024,
                "proof_end_offset": 5158,
                "proof": "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\ndestruct x; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; destruct a; reflexivity.\n  rewrite lookup_empty_empty_r in H.\n  rewrite lookup_empty_r in H.\n  rewrite lookup_empty_r in H.\n  rewrite lookup_empty_empty_r in H.\n  rewrite lookup_empty_r in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_r in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_r in H.\n  rewrite lookup_empty_r in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_spec in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n  rewrite lookup_empty_iff in H.\n Qed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros; destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  apply lookup_empty_Some in H.\n  rewrite <- lookup_empty_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookupQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  induction x; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; auto.\n  destruct a; auto.\n  destruct a; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a; autoQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  apply lookup_empty_equal.\n  rewrite lookup_empty_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.Qed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  rewrite H.\n  apply lookup_empty_empty_equal.\n  apply lookup_empty_equal.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros.\n  destruct a; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\n",
                "context_tokens": 685,
                "proof_start_offset": 5160,
                "proof_end_offset": 5335,
                "proof": "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\ndestruct e.\ndo 2 rewrite lookup_empty_None.\nreflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction 1; intros; congruence.\n  destruct x; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  unfold lookup; intros.\n  rewrite lookup_empty_iff in H. congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction e; intros; simpl; congruence.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction e; simpl; congruence.\n  destruct e; auto.\n  destruct e; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros; destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  induction e; simpl; intros.\n  simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\n",
                "context_tokens": 661,
                "proof_start_offset": 5471,
                "proof_end_offset": 5755,
                "proof": "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\ninduction x; intros; destruct y; destruct e; simpl; try solve [ elimtype False; omega | eauto with omega ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. destruct x; simpl; congruence.\n  rewrite lookup_empty_iff.\n  reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  induction e; simpl; congruence.\n  simpl; congruence.\n  apply lookup_empty_iff in H; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  unfold lookup; rewrite lookup_empty_equal. reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  induction x; simpl; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  induction s; simpl; reflexivity.\n  rewrite lookup_empty_iff; reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  unfold lookup; intros.\n  apply lookup_empty_for_unit.\n  apply lookup_empty_for_eq.\n  rewrite find_add_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H0 by omega.\n  rewrite lookup_empty_iff in H1 by omega.\n  rewrite lookup_empty_Qed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. unfold lookup; simpl; auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. destruct x; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\nLemma lookup_insert_bingo:\n  forall A x y (o : option A) e,\n  x = y ->\n  lookup x (raw_insert y o e) = o.\n(* Hence, [lookup x (insert y a e) = Some a]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 6812,
                "proof_end_offset": 7137,
                "proof": "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\nintros.\ndestruct_lift_idx.\nrewrite lookup_insert_old by omega.\nf_equal.\nomega.\nrewrite lookup_insert_recent by omega.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; simpl; auto.\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n  destruct e; simpl; try solve [auto].\n Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; try solve [inversion H; omega].\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.\n  rewrite lookup_empty_iff.Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; simpl; congruence.\n  rewrite lookup_empty_iff in *. congruence.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct y; simpl; try solve [inv H].\n  destruct z; simpl; try solveQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; simpl; try solve [inversion H].\n  rewrite lookup_empty_empty_iff in H.\n  rewrite lookup_empty_empty_iff in H.\n  destruct y; simpl; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; simpl; congruence.\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n  destruct a; simpl; try solve [omega].\n Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct z; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct z; simpl; try solve [inversion H].\n  destruct z; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct z; simpl; try solve [inversion H].\n  destruct z; simpl; try solve [inversion H].\n  destruct z; simpl; try solveQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; simpl; auto; try solve [inversion H0; inv H0].\n  rewrite lookup_empty_iff. rewrite H0.\n  auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  induction x; intros; destruct y; simpl; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct x; simpl; try solve [inversion H; inversion H; subst; simpl; auto].\n  do 2 (rewrite lookup_empty_equal).\n  rewrite lookup_empty_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_equal.\n  rewrite lookup_empty_empty_equal.\n  rewrite lookup_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Proof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7969,
                "proof_end_offset": 8070,
                "proof": "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros.\ndestruct a; simpl; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct x; destruct y; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct y; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; tryQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct f; simpl; auto.\n  destruct f; simpl; auto.\n  destruct f; simpl; auto.\n  destruct f; simpl; auto.\n  destruct f; simpl; auto.\n  destruct f; simpl; auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros.\ndestruct (map_empty A B f g); auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  unfold map_empty.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_right by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_insert by auto.\n  rewrite lookup_insert_insert by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_insert by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_local by auto.\n  rewrite lookup_insert_insert by auto.\n  rewrite lookup_insert by auto.\n  rewrite lookup_insert_insert by auto.\n  rewrite lookup_insert by auto.\n  rewrite lookup_insert_insert by auto.\n  rewrite lookup_insert_insert by auto.\n  rewrite lookup_insert_node by auto.\n  rewrite lookup_insert by auto.\n  rewriteQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct x; simpl in *; try solve [inversion H].\n  destruct x; try solve [inversion H].\n  rewrite lookup_insert_rec_eq; auto.\n  rewrite lookup_insert_rec_eq. auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct x; destruct x; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct z; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct z; simpl; try solve [auto].\n  destruct z; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct y; simpl; try solve [auto].\n  destruct z; simpl; try solve [auto].\n  destruct z; simplQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct x; simpl; auto.\n  destruct x; try solve [inversion H].\n  simpl.\n  rewrite lookup_insert_null by omega.\n  rewrite lookup_insert_empty_spec by omega.\n  rewrite lookup_insert_spec by omega.\n  rewrite lookup_insert_val by omega.\n  rewrite lookup_insert_insert by omega.\n  rewrite lookup_insert_key by omega.\n  rewrite lookup_insert_insert_spec by omega.\n  rewrite lookup_insert_val by omega.\n  rewrite lookup_insert_insert by omega.\n  rewrite lookup_insert_insert by omega.\n  rewrite lookup_insert_value by omega.\n  rewrite lookup_insert_insert by omega.\n  rewrite lookup_insert by omega.\n  rewrite lookup_insert_insert_value by auto.\n  rewrite lookup_insert_spec by omega.\n  rewrite lookup_insert_value by (auto).\n  rewrite lookup_insert_insert by (auto).\n  rewrite lookup_insert_insert by omega.\n  rewrite lookup_insert_insert by omega.\n  rewrite lookup_insert by omega.\n  rewrite lookup_insert_insert by omega.\n  rewrite lookup_insert_insert by (auto).\n  rewrite lookup_Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct x; simpl; intros.\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destruct x; simpl; try solve [inversion H].\n  destructQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  destruct (find_insert_inv _ _ v); [contradiction | omega ].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "p x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 8203,
                "proof_end_offset": 8423,
                "proof": "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; solve [ eauto | congruence ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct (eq_dec (f x) (f x)) as [x' [x' [y' [y' [y' [y' [y' [z' [y' [z' [y' [y' [y' [y' [y' [y' [y' [y' [z' [y' [y' z' [y' [y' [y' [y' [y' [z' [y' [z' [z' [y' [y' [z'z' [z' z' [z' [z' [z'z' [y' [z' [z'z' [z' [z' [z' z' [z' [z'z' z' [z' [z'z' [z'z' [z'z' [z'z' z' z' [z' z' [z' z' [z' z' z' [z' z' z' z' z' z' [z' [z' [z' [z' z' z' [z' z' [z' [z'Qed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl; auto.\n  apply lookup_empty_1.\n  destruct (lookup x e); auto.\n  unfold lookup; intros.\n  apply lookup_empty_2.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_lookup; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl; auto.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_same.\n  rewrite lookup_insert_app.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_empty.\n  rewrite lookup_insert_insert_empty.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_insert.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_insert_singleton.\n  rewrite lookup_insert_empty.\n  rewrite lookup_insert_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_insert_singleton.\n  rewrite lookup_Qed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl; try solve [auto].\n  + destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; try solve [auto].\n    destruct x; simpl; tryQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  induction x; intros; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct y; simpl; auto.\n  destruct x; simpl; auto.\n  destruct y; simpl; auto.\n  destruct x; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simpl; auto.\n  destruct y; simplQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros A B x e.\n  induction x; intros; simpl; auto.\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solve [inversion H].\n  destruct e; try solveQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl; auto; try solve [auto].\n  + rewrite lookup_insert_aux.\n      rewrite lookup_insert_spec in H by omega. f_equal.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec by omega.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec in H by omega.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_spec.\n      rewrite lookup_insert_Qed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl; auto.\n  destruct x; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x;Qed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros A B x e f Hf.\n  eapply lookup_empty.\n  eauto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 8425,
                "proof_end_offset": 8665,
                "proof": "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [ congruence | eauto ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl; auto.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl; auto.\n  apply lookup_empty.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a; simpl in *; subst;\n  try solve [inversion H; auto].\n  destruct b; simpl in *; subst;\n  solve [inversion H].\n  destruct b; simpl in *; subst;\n  try solve [inversion H; subst;\n  rewrite lookup_insert_rec_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_spec.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_insert_eq.\n  rewrite lookup_insert_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_insert_eq.\n  rewrite lookup_insert_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_insert_eq.\n  rewrite lookup_insert_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_eq.\n  rewrite lookup_insert_insert.\n  rewrite lookup_insert_insert_eqQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; inv H.\n  destruct x; try solve [auto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl in *; subst;\n  try solve [auto | congruence].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].\n  destruct x; try solve [auto].Qed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl; auto.\n  destruct a; auto.\n  destruct a; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros A B x e H0; destruct e as [ | [? | ]? | [? | ]? | ]? | ]?? | ]? | ]??????? | ]?????? | ]???????? ] =>\n    rewrite lookup_insert_local' by (auto);\n    try match goal with\n    | [ H: Some _ |- _ => injection H; intro H; subst; clear H\n  end.\n\nLtac lookup_empty :=\n  match goal with\n    | |- (fun x => lookup_empty _ _ = Some _ |- _ => contradiction\n    | |- (fun x => lookup_empty _ = Some _ |- _ => contradiction\n    | _ => auto\n    | |- (fun x => lookup_empty _ = Some _ |- _ => contradiction\n    | |- (fun x => lookup_empty _ = Some _ |- _ => contradiction\n    | |- (fun x => lookup_empty _ = Some _ |- _ => contradiction\n    | |- (fun x => lookup_empty _ x = Some _ |- _ => contradiction\n    | |- (fun x => lookup_empty _ = Some _ |- _ => contradiction\n    | |- (fun x =>Qed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e; simpl in *; try solve [auto | congruence].\n  rewrite lookup_lookup_spec in H.\n  rewrite lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_lookup in H.\n  rewrite lookup_lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_cons in H.\n  rewrite lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup_lookup in H.\n  rewrite lookup_lookup_lookup_lookup_nil in H.\n  rewrite lookup_lookup_lookup in H.\n  rewrite lookup_lookup_lookup_Qed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a; destruct a; simpl; try solve [rewrite lookup_insert_aux_spec;\n  [auto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; inv H.\n  simpl; auto.\n  rewrite lookup_empty_iff by omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\n",
                "context_tokens": 663,
                "proof_start_offset": 9140,
                "proof_end_offset": 9636,
                "proof": "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\nintros ? k s.\ngeneralize s k; clear s k.\ninduction s; intros.\ndestruct k; [ | elimtype False; omega ].\nreflexivity.\ndestruct k.\nreflexivity.\ndestruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | ]?? | ]; simpl in *; subst;\n    try contradiction (apply insert_insert_left _ _ _ _ _ H);\n    try contradiction (apply insert_insert_right _ _ _ _ _ H);\n    try contradiction (apply insert_insert_right _ _ _ _ _ _ H);\n    try contradiction (apply insert_right _ _ _ H);\n    try contradiction (apply insert_right _ _ _ H);\n    try contradiction (apply insert_right _ _ _ _ H);\n    try contradiction (apply insert_right _ _ _ H);\n    try contradiction (apply insert_right _ _ _ _ H);\n    try contradiction (apply insert_right _ _ _ H);\n    try contradiction (apply insert_right _ _ _ _ _ H);\n    try contradiction (apply insert_right _ _ _ H);\n    try contradiction (apply insert_right _ _ _ _ H);\n    try contradiction (apply insert_right _ _ _ H);\n    try contradiction (apply insert_right _ _ _ _ _ _ H);\n    try contradiction (apply insert_right _ _ _ _ _ H);\n    try contradiction (apply insert_right _Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; destruct e as [ | [ | ] | | ] ]; simpl in *; subst; try solve [\n    congruence].\n  destruct e as [ | [ | ] | | ]? ]; simpl in *; subst; try solve [\n    congruence].\n  destruct e as [ | [ | ] | | | ]? | ]? ]; simpl in *; subst; try solve [\n    congruence.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  unfold insert, insert_insert in *.\n  unfold insert_insert.\n  destruct (insert_insert k a e) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k a) eqn:H; try solve [inv H].\n  destruct (insert_insert k aQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; destruct e as [ | [ | ]?? | ]; simpl in *; subst;\n    try solve [\n    auto;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try congruence;\n    try solve [ congruence;\n    try congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try solve [ congruence;\n    try congruence;\n    try solve [solve [ congruence;\n    try congruence;\n    try solve [\n  try solve [ congruence;\n  try solve [\n  try solve [ congruence;\n  try solve [ congruence;\n  try solve [\n  try solve [\n  try solve [ congruence;\n  try solve [\n  try solve [solveQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; destruct e as [ | [ | [ | ] ]; simpl in *;\n    try solve [ congruence; simpl in *; subst; try solve [ congruence];\n    try solve [ congruence].\n  destruct e as [ | [ | [ | ]? | ]? | ]? | [ | ]? | | ]? | ]? | [ | [ | ]? | [ | ]? | ]? | | [ | ]? | ]? | | | [ | ]? | ]? | [ | | | ]? | [ | | | ]? ]? |? | [ | ]? | | | ]? | [ | | ]? | [ | ]? | | [ | ]? | | | [ | | | ]? | [ | ] ]? | | | [ | | | ]? | [ | | | | | | ]? | | | | | | | ]? | [ | ]? | [ | ]? | | | | | | | | ]? | | | | | [ | ]? | | | | | | | | ]? | | | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; destruct e as [ | [ | | ] | ]?? ]; simpl in *; subst;\n    try solve [ congruence].\n  destruct e as [ | [ | ]? | ]; simpl in *; subst;\n    try solve [ congruence].\n  destruct e as [ | [ | [ | ]? | ]? | ]? ]; simpl in *; subst;\n    try solve [ auto].\n  destruct e as [ | [ | ]? | ]? | ]? | ]; simpl in *; subst;\n    try solve [ congruence].\n  destruct e as [ | [ | ]? | | ]? | ]? ]; simpl in *; subst;\n    try solve [ reflexivity].\n  destruct e as [ | [ | ]? | ]? |? | ]? |? | ]? |? |?? | ] => simpl in *; subst;\n    try solve [ congruence | reflexivity].\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; destruct e; [ | | destruct e; simpl in *; subst; try solve [ congruence].\n  destruct e as [ | [ | ] eqn:?; simpl in *; subst; try solve [ congruence].\n  destruct e as [ | [ | ] eqn:?; simpl in *; subst; try solve [ destruct e as [ | ] | ] ]; simpl in *; subst; try solve [destruct e as [ | ] | [ | ] | ] ]; simpl in *; subst; try solve [destruct e as [ | ] | ] eqn:?; simpl in *; subst; try solve [destruct e as [ | ] | ] ] | ] ]; simpl in *; subst;\n    try solve [destruct e as [ | ] | ] | [ | ] ] | ]; simpl in *; subst; try solve [destruct e as [ | ] ]; try solve [destruct e as [ | ] | ] ] | ] ]; simpl in *; subst;\n    try solve [destruct e as [ | ] ] | ] ]; simpl in *; subst;\n    try solve [destruct e as [ | ] | [ | ] ]; simpl in *; subst; try solve [destruct e as [ | ] | ] | ]; simpl in *; subst;\n    try solve [Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  rewrite insert_insert_insert_node_inv.\n  rewrite insert_insert_node_spec.\n  rewrite insert_insert_node_node_spec.\n  rewrite insert_insert_node_node_spec.\n  rewrite insert_node_node_node_spec.\n  rewrite insert_node_node_node_node_spec.\n  rewrite insert_node_node_node_node_node_node_spec.\n  rewrite insert_node_node_node_node_node_node_node_node.\n  rewrite insert_node_node_node_node_node_node_node_node_node_node_node_node.\n  rewrite insert_node_node_node_node_node_node_node_node_node_node_node_node_node.\n  rewrite insert_node_node_node_node_node_node_node_node_node.\n  rewrite insert_node_node_node_node_node_node_node_node_node_node.\n  rewrite insert_node_node_node_node_node_node_node_node_node_node_node.\n  rewrite insert_node_node_node_Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | | ]; simpl in *; subst; try solve [ inversion H; subst;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    try congruence;\n    tryQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  assert (forall x, k <> x -> In x l -> In x l -> In x l) by (intros; destruct e as [ | [ | ] | ] ]; simpl in *; subst; try solve [\n    try solve [ congruence]\n    try solve [ intro; congruence].\n  simpl in *; subst; try solve [ intro; destruct e as [ | [ | ] | ]? ]; simpl in *; subst; try solve [ intro; try solve [ intro; try contradiction].\n  simpl in *; subst; try solve [ intro; try contradiction].\n  simpl in *; subst; try solve [ intro; try contradiction].\n  simpl in *; subst; try solve [ intro; try contradiction].\n  simpl in *; subst; try contradiction].\n  simpl in *; subst; try solve [ intro; try contradiction].\n  simpl in *; subst; try solve [ intro; try contradiction].\n  simpl in *; subst; try contradiction.\n  simpl in *; subst; try contradiction.\n  simpl in *; try contradiction; try solve [ intro; try contradiction].\n  simpl in *; subst; try contradiction.\n  simpl in *; subst; try contradiction.\n  simpl in *; try contradiction.\n  simpl in *; subst; try contradiction.\n  simpl in *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\n",
                "context_tokens": 669,
                "proof_start_offset": 9794,
                "proof_end_offset": 10236,
                "proof": "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\nintros.\ndestruct (le_gt_dec k s).\nrewrite lift_idx_old by assumption.\neauto using insert_insert.\nrewrite lift_idx_recent by assumption.\nreplace k with (1 + (k - 1)) in * by omega.\nrewrite <- insert_insert by omega.\ndo 2 f_equal.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct a.\n  destruct a; auto.\n  destruct a.\n  destruct a; auto.\n  destruct a.\n  destruct b; auto.\n  destruct a; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b;Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction x; intros; simpl; auto.\n  (* Subk *)\n  destruct k; [elimtype False; omega | omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega | omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omega].\n  (* Subk *)\n  destruct k; [elimtype False; omegaQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | ]; simpl in *; subst;\n    try congruence.\n  (* Subk *)\n  destruct k; [ | elimtype False; omega | elimtype False; omega ].\n  (* Subk *)\n  destruct k; [ elimtype False; omega | elimtype False; omega ].\n  (* Subk *)\n  destruct k; [ elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega | elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega | elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega | elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega | elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega | elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtypeQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction x; intros; destruct e; try solve [inversion H].\n  (* In *)\n  destruct (H k); simpl in *; subst; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct k; try solve [inversion H].\n  (* In *)\n  destruct kQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction a; intros; simpl in *; auto.\n  destruct k.\n  unfold insert_insert k a (insert k a) (insert k a) b e) in *; auto.\n  destruct k; [contradiction | simpl in *; subst; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; subst; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; subst; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; subst; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; subst; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; subst; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; subst; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; try solve [contradiction | congruence].\n  (* Subk *)\n  destruct k; [contradiction | simpl in *; try solve [contradiction | congruence].\n  (* Subk *)\n  destructQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction x; intros; auto; inv H.\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* Subk *)\n  destruct k; [congruence | elimtype False; omega].\n  (* SubkQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction x as [ | [ | | ] | ]; simpl in *; try solve [ intro; subst;\n    try solve [ intro; try solve [ intro; try solve [ intro; try solve [ intro; try solve [ intro; try solve [ intro; try contradiction] | intro; try contradiction] | intro; try contradiction] | intro; try contradiction] | intro; try contradiction] | intro; try contradiction] | intro; try contradiction; intro; try contradiction;\n    try solve [ intro; try contradiction] | intro; try contradiction] | intro; try contradiction] | intro; try contradiction] | intro; try contradiction].\n  (* Subaction *)\n  destruct k; [ auto | congruence] *)\n  destruct k; [contradiction | contradiction].\n  (* Subactions *)\n  destruct k; [contradiction | contradiction].\n  (* Subactions *)\n  destruct k; [contradiction | contradiction].\n  (* Subactions *)\n  destruct k; [contradiction | contradiction].\n  (* Subactions *)\n  destruct k; [contradiction | contradiction].\n  (* Subactions *)\n  destruct k; [contradiction | contradiction].\n  (* Subactions *)\n  destruct k; [contradiction | contradiction].\n  (* Subactions *)\n  destruct kQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction a; intros; simpl; auto;\n    try congruence.\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omega].\n  destruct k; [congruence | elimtype False; omegaQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction x; intros; simpl; try solve [apply H; auto].\n  (* Subk *)\n  destruct k; [ | elimtype False; omega].\n  (* Subk *)\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].\n  destruct k; auto.\n  destruct k; [apply H; auto|].\n  destruct k; [apply H; auto|].Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros; unfold insert, insert, insert; intros.\n  destruct k; [ | elimtype False; omega].\n  (* Subk *)\n  destruct k; [ elimtype False; omega|].\n  (* Subk *)\n  destruct k; [ elimtype False; omega|].\n  (* Subk *)\n  destruct k; [ elimtype False; omega|].\n  (* Subk *)\n  destruct k; [ elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)\n  destruct k; [elimtype False; omega|].\n  (* Subk *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "kup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 10854,
                "proof_end_offset": 10989,
                "proof": "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct x; destruct e; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct e; [ intro; simpl; auto|].\n  destruct e; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; simpl; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  rewrite insert_insert; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct x; destruct e; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct a.\n  destruct a.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert_insert _ _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert_insert _ _ _ _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _ _ _ _ _ _ H0); subst.\n  destruct (insert_insert_insert _ _ _ _ _ _Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction x; intros.\n  - simpl.\n    unfold insert_insert, insert_insert.\n    rewrite insert_insert_insert by auto.\n    rewrite insert_insert_insert by auto.\n    destruct (is_insert_insert_insert' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction x; intros.\n  - destruct e; [ | apply insert_insert_uniq; auto ].\n    - destruct e; [ | apply insert_insert_uniq; auto].\n    - destruct e; [ | apply insert_insert_insert_insert_uniq; auto ].\n      rewrite insert_insert by auto.\n      destruct e; [apply insert_insert_insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_insert_uniq; auto |].\n      destruct e; [apply insert_insert_insert_insert_uniq; autoQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct e; [destruct e; [destruct e; try congruence]; simpl in *; subst;\n    try congruence.\n  destruct e; [destruct e; try congruence]; simpl in *; subst;\n    try congruence;\n    try congruence.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros; unfold insert_insert; intros.\n  destruct (eq_dec e e a) as [ | [ | ] | [ | ] | [ | [ | ] | [ | ] | [ | ] | [ | ] ] | [ | ] | [ | ] | [ | ] | [ | ] | [ | ] | [ | ] | ] | [ | ] | [ | ] | ] | [ | ] | [ | ] | | [ | ] | [ | ] | ] | [ | [ | ] | | ] ] | [ | [ | ] ] | [ | ] | [ | ] ] | [ | ] | [ | ] | [ | ] | [ | ] | ] | ] | [ | [ | ] ] | [ | ] ] | [ | ] | [ | ] ] | [ | ] | [ | ] | [ ] ] | ] | [ | ] | | [ | ] | [ | ] ] | ] | [ | ] ] | [ | [ ] | ] | | [ ] ] ] | [ | [ ] | ] | [ | ] | [ | ] | [ | ] | [ | ] | ] | ] | [ | ] | [ |Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction x; intros; destruct e; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\n",
                "context_tokens": 697,
                "proof_start_offset": 11139,
                "proof_end_offset": 11446,
                "proof": "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\nintros.\nassert (lookup x (insert x a1 e1) = Some a1).\neauto using lookup_insert_bingo.\nassert (lookup x (insert x a2 e2) = Some a2).\neauto using lookup_insert_bingo.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  induction 1; intros; simpl; auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct a1; destruct e; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  unfold insert.\n  destruct (eq_dec a1); auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct a1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A a1 a2 e2 a3.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct e; simpl in *; subst; auto.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct e1; [constructor | constructor].\n  + destruct e1; [constructor | constructor].\n    + destruct e1; [constructor | constructor].\n    + destruct e2; [constructor | constructor].\n      + destruct e2; [constructor | constructor].\n      + destruct e2; [constructor | constructor].\n      + destruct e2; [constructor | constructor].\n      * destruct e2; [constructor | constructor].\n        * destruct e2; [constructor | constructor].\n        * destruct e2; [constructor | constructor].\n        * destruct e2; [constructor | constructor].\n          * destruct e2; [constructor | constructor].\n          * destruct e2; [constructor | constructor].\n          * destruct e2; [constructor | constructor].\n          * destruct e2; [constructor | constructor].\n          * destruct e2; [constructor | constructor].\n          * destruct e2; [constructor | constructor].\n          * destruct e2; [constructor | constructor].\n            * destruct e2; constructor.\n            * destruct e2; [constructor | constructor].\n            * destruct e2; [constructor | constructor].\n            * destruct e2; [constructor | constructor].\n            * destruct e2; [constructor | constructor].\n           Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 11448,
                "proof_end_offset": 11778,
                "proof": "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\ninduction x; simpl; intros.\ncongruence.\ndestruct e1; destruct e2; match goal with h: _ = _ |- _ => injection h; clear h; intros end; f_equal; try congruence; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction a1; intros; simpl; congruence.\n  destruct a1; simpl; congruence.\n  destruct a2; simpl; congruence.\n  destruct a2; simpl; congruence.\n  destruct a2; simpl; congruence.\n  destruct a1; simpl; congruence.\n  destruct a2; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruence.\n  destruct a3; simpl; congruenceQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x a1 e2) by auto using lookup_insert_by_inversion_clear_clear_clear_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_cons_consQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction 1; intros; simpl; auto.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction 1; intros; simpl; auto.\n  rewrite insert_insert_insert_1; auto.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_insert_spec.\n  rewrite insert_insert_insert_spec.\n  rewrite insert_insertQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  destruct a1; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction a1; intros.\n  + destruct e; [auto | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [reflexivity | elimtype False; omega].\n    rewrite insert_insert_null; [Qed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction x; intros; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x a1 e2 = Some b). eauto using lookup_insert_b.\n  congruence.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction x; intros.\n  + simpl.\n    rewrite insert_insert_insert_in_null in H.\n    destruct H; auto.\n    + simpl.\n      rewrite insert_insert_in_null in H.\n      destruct H; auto.\n      + simpl.\n      rewrite insert_insert_in_null in H.\n      destruct H; auto.\n        destruct H; auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  induction x; intros; inv H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\nLemma insert_eq_insert_2:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  forall b,\n  insert x b e1 = insert x b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\n",
                "context_tokens": 658,
                "proof_start_offset": 12207,
                "proof_end_offset": 13770,
                "proof": "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\ninduction x1; intros.\ndestruct x2; [ omega | ].\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e2; [ congruence | ].\nsubst.\nsimpl.\nexists e2.\nexists x2.\nexists 0.\neauto.\ndestruct x2.\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e1; [ congruence | ].\nsubst.\nexists e1.\nexists 0.\nexists x1.\nsplit.\neauto.\nsplit.\neauto.\nsplit.\neauto.\ndblib_by_cases.\nomega.\ndo 2 rewrite raw_insert_successor in *.\nassert (xx: x1 <> x2).\nomega.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros h ?; generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]] end.\ndestruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\ndestruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\nexists (o :: e).\nexists (S y1).\nexists (S y2).\nsplit.\nsimpl.\ncongruence.\nsplit.\nsimpl.\ncongruence.\nsplit.\neapply translate_lift with (k := 1).\neauto.\ndblib_by_cases; omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  - destruct e1; destruct e2;\n    match goal with\n    | [ H: _ = _ |- _ ] => clear H; subst;\n      match goal with\n        | [ H: _ = _ |- _ ] => clear H; subst; clear H;\n        match goal with\n        | [ H: _ = _ |- _ ] => clear H; subst\n        end;\n      repeat match goal with\n        | [ H: _ = _ |- _ ] => clear H; subst;\n        match goal with\n        | [ H: _ = _ |- _ ] => clear H; subst; clear H\n        end;\n      repeat match goal with\n        | [ H: _ = _ |- _ => clear H; subst; clear H\n        end;\n      repeat match goal with\n        | [ H: _ = _ |- _ ] => clear H; subst\n        end;\n      repeat match goal with\n        | [ H: _ = _ |- _ ] => clear H\n        end;\n      repeat match goal with\n        | [ H: _ = _ |- _ ] => clear H\n        end;\n      repeat match goal with\n        | [ H: _ = _ |- _ => clear H\n        end;\n      repeat matchQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  destruct e2; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros; try congruence.\n  destruct e2; try congruence.\n  destruct e2; try congruence.\n  destruct e1; try congruence.\n  destruct e2; try congruence.\n  destruct e2; try congruence.\n  destruct e2; try congruence.\n  destruct e2; try congruence.\n  destruct e3; try congruence.\n  destruct e2; try congruence.\n  destruct e2; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e2; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n  destruct e3; try congruence.\n Qed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  destruct e1; simpl; auto.\n  destruct e1; destruct e1; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e1; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simplQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 a1 a2) by (apply insert_eq_insert_2; auto).\n  assert (lookup x1 a2 e1 = insert x1 a2).\n    eauto using lookup_eq_insert_1; auto.\n  assert (lookup x1 a2 e2 = insert x1 a2).\n    eauto using lookup_eq_insert_1; auto.\n  assert (lookup x1 a2 e2) by (apply insert_eq_insert_3; auto).\n  assert (lookup x1 a2 e3) by (apply insert_eq_insert_2; auto).\n  assert (lookup x1 a2 e3) by (apply insert_eq_insert_3; auto).\n  assert (lookup x1 a2 e3) by (apply insert_eq_insert_2; auto).\n  assert (lookup x1 a2 e3) by (apply insert_eq_insert_3; auto).\n  assert (lookup x1 a3 e2 e3) by (apply insert_eq_insert_3; auto).\n  assert (lookup x1 a3 e3) by (apply insert_eq_insert_Qed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (insert x a1 e2 = insert x1 a2 e2) by auto.\n  subst.\n  assert (insert x a1 e2 = insert x1 a1 e2). eauto using insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (insert x1 a2 a2 = insert x1 a2 e2).\n  {\n    assert (insert x1 a2 e2) by auto using insert_eq_insert_iff; auto using insert_left_insert_iff, insert_eq_insert_iff, insert_eq_iff.\n    assert (insert x1 a2 e2) = insert x1 a2).\n      {\n      assert (insert x1 a2) by auto using insert_right_insert_iff, insert_iff, insert_or_eq.\n      assert (insert x1 a2 e2) by auto using insert_right_iff, insert_iff, insert_iff, insert_in_iff, insert_in_iff.\n      assert (insert x1 a2) by auto using insert_right_iff, insert_in_iff, insert_in_iff, insert_in_iff, insert_in_iff, insert_in_iff, insert_in_iff, insert_in_in_iff, insert_in_iff, insert_in_iff, insert_in_iff, insert_in_in_iff, insert_in_iffQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  destruct e2; simpl; congruence.\n  destruct e2; simpl; congruence.\n  destruct e2; simpl; congruence.\n  destruct e2; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e4; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e3; simpl; congruence.\n  destruct e4; simpl; congruence.\n  destruct e3; simpl; congruence.\n Qed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; simpl; intros.\n  + simpl; auto.\n    simpl; auto.\n    destruct e1; destruct e1; destruct e2; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e4; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e4; destruct e4; destruct e3; destruct e4; destruct e4; destruct e4; destruct e3; destruct e4; destruct e4; destruct e3; destruct e4; destruct e4; destruct e3; destruct e4; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e4; destruct e3; destruct e3; destruct e4; destruct e3;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 13903,
                "proof_end_offset": 14163,
                "proof": "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e; auto.\n  destruct e1; auto.\n  destruct e2; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e2; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n  destruct e3; auto.\n Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros.\n  + exists e; auto.\n    exists e; auto.\n    exists e; auto.\n    exists e0; auto.\n  + exists e; auto.\n    exists e0; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  destruct e1; [ congruence | ].\n  subst. simpl. rewrite remove_insert_tl.\n  destruct e2; [ congruence | ].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e2; [ congruence | ].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e2; [ congruence | congruence ].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e2; [ congruence | congruence].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e3; [ congruence | congruence].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e3; [ congruence | congruence ].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e3; [ congruence | congruence ].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e3; [ congruence | congruence].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e3; [ congruence | congruence].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e3; [ congruence | congruence].\n  subst. simpl. rewrite find_insert_tl.\n  destruct e3Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; simpl; intros.\n  + destruct e2; [ congruence | congruence].\n  + destruct e1; [ congruence | congruence].\n    destruct e2; [ congruence | congruence].\n    destruct e2; [ congruence | congruence].\n    destruct e2; [ congruence].\n    destruct e2; [ congruence | congruence].\n    destruct e3; [ congruence | congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence | congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e4; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e4; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3; [ congruence].\n    destruct e3;Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  destruct e0; [ congruence | congruence | congruence ].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence | congruence ].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n  destruct e0; [ congruence | congruence].\n  subst. simpl in *.\n Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f a e H.\n  destruct e; simpl; auto.\n  intros a b.\n  destruct e0; [ congruence | congruence ].\n  rewrite raw_insert_inv in *. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_inv in H. rewrite raw_insert_Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  do 2 rewrite insert_insert_inv. auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B x a e e f e.\n  induction x; intros; try congruence.\n  apply insert_left with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  apply insert_right with (f := 0).\n  applyQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; simpl in *; try congruence.\n  destruct e0; [ congruence | congruence].\n  destruct e0; [ congruence | congruence].\n  destruct e0; [ congruence | congruence].\n  destruct e0; [ congruence | congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence | congruence].\n  destruct e0; [ congruence | congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence | congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct e0; [ congruence].\n  destruct eQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction f; intros; simpl.\n  rewrite raw_insert_cons.\n  rewrite raw_insert_cons.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insert_insert_null.\n  rewrite raw_insertQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 14224,
                "proof_end_offset": 14387,
                "proof": "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\nintros; subst.\neapply map_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros.\n  rewrite Forall_insert_iff.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eq.\n  apply map_insert_eqQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  simpl; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simpl; auto.\n  destruct e0; simplQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; auto.\n  intros. destruct x; simpl in *; [discriminate | discriminate].\n  destruct e; simpl in *; [discriminate | discriminate].\n  destruct e; simpl in *; [discriminate | discriminate].\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; auto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; auto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.Qed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  apply in_insert_iff in H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct H; destruct HQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  simpl; auto.\n  rewrite IHs. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; subst; auto.\n  rewrite IHl.\n  apply IHl.\n  apply IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHlQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; auto.\n  destruct e; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e4; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e4; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct eQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 14681,
                "proof_end_offset": 14953,
                "proof": "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros A B f x e a e.\n  induction e; intros; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros A B f x e e x e.\n  induction x; intros; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.Qed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  destruct e; [congruence | destruct e; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminate; try discriminateQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros A B f x e x e.\n  induction e; simpl; eauto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct eQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite <- (insert_insert x _ _ _ _ _ _ H); auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite <- map_insert_inv; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x; simpl; auto.\n  destruct x0; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; unfold map_raw_insert.\n  destruct x; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 15074,
                "proof_end_offset": 15327,
                "proof": "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite map_rev.\n  destruct (list_rev _ (map_rev _ _)) eqn:E; auto.\n  destruct (list_rev _ _) eqn:E; auto.\n  rewrite map_rev.\n  destruct (list_rev _ _) eqn:E; auto.\n  destruct (list_rev _ _) eqn:E; auto.\n  rewrite map_rev.\n  destruct (list_rev _ _)) eqn:E; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; simpl; eauto.\n  rewrite <- map_concat; reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_insert_rev.\n  destruct a; simpl; eauto.\n  rewrite map_insert_Qed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros A B f g h h; induction h; simpl; eauto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; destruct e; simpl; eauto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; simpl; eauto.\n  rewrite map_insert_or.\n  replace (map_insert x (map f e) (map f e) = map h e.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.Qed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  destruct e; simpl; auto.Qed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite e. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 679,
                "proof_start_offset": 15329,
                "proof_end_offset": 15636,
                "proof": "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction x; intros;\n    try match goal with\n    | id: list _ |- _ => destruct o; inv H\n    end;\n    try match goal with\n      | id: list _ |- _ => destruct o; inv H\n      end;\n      try match goal with\n        | id: list _ |- _ => destruct o; inv H; inv H\n        end; try constructor;\n      try match goal with\n        | id: list _ |- _ => destruct o; inv H\n        end;\n      try match goal with\n        | id: list _ |- _ => destruct o; inv H\n        end;\n      try match goal with\n        | id: list _ |- _ => destruct o\n        | id = id |- _ => inv H\n        end; try match goal with\n        | id: list _ |- _ => destruct o eqn:?; inv H\n        end;\n      try match goal with\n        | id: list _ |- _ => destruct o eqn:?; inv H\n        end;\n      try match goal with\n        | id: list _ |- _ => destruct o eqn:?; inv H\n        end;\n        try match goal with\n        | id: list _ |- _ => destruct o eqn:?; inv H\n        end;\n        try match goal with\n        | id: list _Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite map_insert; reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; auto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destruct e; simpl; eauto.\n  destructQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite <- map_insert; reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction x; intros; simpl; auto.\n  destruct e; simpl; auto.\n  rewrite map_insert; reflexivity.\n  rewrite map_insert; reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction x; intros; destruct e; simpl in *; auto; try discriminate.\n  apply map_concat; auto.\n  apply map_concat_map; auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; destruct e; simpl; auto.\n  destruct e; simpl; auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction x; intros; simpl; auto.\n  rewrite map_insert_eq.\n  destruct (f1 f2); auto.\n  destruct (f2 f3); auto.\n  destruct (f3 f3); auto.\n  destruct (f3 f3); auto.\n  destruct (f3 f3); auto.\n  destruct (f3 f3); auto.\n  destruct (f3 f3); auto.\n  destruct (f3 f4); auto.\n  destruct (f3 f4); auto.\n  destruct (f3 f4); auto.\n  destruct (f3 f4); auto.\n  destruct (f3 f4); auto.\n  destruct (f4 f5); auto.\n  destruct (f5 f5); auto.\n  destruct (f4 f5); auto.\n  destruct (f5 f5); auto.\n  destruct (f4 f5); auto.\n  destruct (f4 f5); auto.\n  destruct (f5 f5); auto.\n  destruct (f5 f5); auto.\n  destruct (f5 f5); auto.\n  destruct (f5 f5); auto.\n  destruct (f5 f5); auto.\n  destruct (f5Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction f; intros;\n    try match goal with\n      | id: option _ |- _ => destruct o; simpl; eauto using list_map_trans; eauto using list_map_r.\n  Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction g1; intros;\n    try match goal with\n    | id: option _ |- _ => destruct o; try discriminate; clear id\n    end.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 15638,
                "proof_end_offset": 15887,
                "proof": "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\neauto using map_map_exchange, @lift_lift.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o; auto end.\n  destruct o; simpl; eauto.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with f_equal.\n  destruct o; simpl; eauto with fQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o; try constructor; auto end.\n  destruct o; try constructor; auto.\n  destruct o; try constructor; auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o as [ o | id ];\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try matchQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n    try solve [constructor; auto with typeclass_instances | apply map_lift_right].\n  apply map_insert_ind.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?X => destruct o; simpl in X; try contradiction;\n  try match goal with |- _ => destruct o; try contradiction;\n  end.\n  match goal with |- _ => destruct o end; f_equal; auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?X = _ => destruct o; auto end.\n  destruct o; auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try solve [rewrite map_insert; reflexivity].\n  destruct e; simpl; eauto with f_equal; eauto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl; eauto with arith.\n  simpl; eauto with arith.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?X => destruct o; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; inv X; invQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?X => destruct o; try discriminate;\n  try discriminate; try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 15889,
                "proof_end_offset": 16144,
                "proof": "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\nintros.\nrewrite map_insert.\nf_equal.\neapply map_map_exchange.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros;\n  try solve [inversion H1; subst;\n  try solve [inversion H2; subst;\n  try solve [inversion H2; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H2; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H2; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H2; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H2; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1; subst;\n  try solve [inversion H1Qed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros; destruct e; simpl; eauto with arith.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o; try discriminate end;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;\n  try discriminate;Qed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o; auto end; try match goal with |- _ => destruct o end; try match goal with |- _ => destruct o end; try match goal with |- _ => destruct o end end end; try match goal with |- _ => destruct o end end; try match goal with |- _ => destruct o end; try match goal with H end end; try match goal with |- _ => destruct o end; try match goal with H end end; try match goal with |- _ => destruct o end; try match goal with H end end end; try match goal with H end; try match goal with H end; try match goal with H end; try match goal with H end end; try match goal with H end; try match goal with H end; try match goal with H end end; try match goal with H end; try match goal with H end; try match goal with H end; try match goal with H end; try match goal with H end; try match goal with H end; try match goal with H end; try match goal with H end end; try match goal with H end; try match goal with H end end; try match goal with HQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; eauto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; eauto.\n  destruct (in_dec x e); intros; subst; eauto.\n  destruct (in_dec x e); intros; subst; eauto.\n  destruct (in_dec x e); intros; subst; eauto.\n  destruct (in_dec x e); intros; subst; eauto.\n  destruct (in_dec x e); intros; subst; eauto.\n  destruct (in_dec x e); intros; eauto.\n  destruct (in_dec x e); intros; subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); subst; eauto.\n  destruct (in_dec x e); substQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; auto.\n  rewrite map_insert_map_spec; auto.\n  intros; simpl; eauto.\n  intros; simpl; eauto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros;\n  try solve [rewrite map_insert; reflexivity | rewrite map_insert_map; reflexivity].\n  rewrite map_insert_map; reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; eauto with map.\n  apply map_insert_map.\n  intros; simpl; auto with map.\n  apply map_insert_map with (f := fun x => f (insert x a e)) (map f e)).\n  apply map_insert_map.\n  intros; simpl; auto with map.\n  apply map_insert_map with (f := fun x => f (insert x a e)) (map f e)).\n  apply map_insert_map with (f := fun x => f (insert x a e)) (map f e)).\n  apply map_insert_map with (f := fun x => f (insert x a e)) (map (fun x => f (insert x a e))) (map (f (insert x a e)) (map f e)).\n  apply map_insert_map with (f := fun x => f (insert x a e) (map (insert x a e)) (map (insert x e f e)) (map (insert x e f e))).\n  apply map_insert_map with (f := fun x => f (insert x e (insert a e) (map (insert x e e)) (Qed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o; auto end.\n  rewrite map_insert_map_app.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite mapQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 16146,
                "proof_end_offset": 16393,
                "proof": "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with\n    | id: option _ |- _ => destruct o;\n    simpl; eauto with f_equal;\n    try match goal with\n        | id: option _ |- _ => destruct o\n        end;\n    simpl; eauto with f_equal;\n    try match goal with\n        | id: option _ |- _ => destruct o\n        end;\n      simpl; eauto with f_equal;\n      try match goal with\n        | id: option _ |- _ => destruct o\n        end;\n      simpl; eauto with f_equal;\n      try match goal with\n        | id: option _ |- _ => destruct o\n        end;\n        simpl; eauto with f_equal;\n        try match goal with\n        | id: option _ |- _ => destruct o\n        end;\n        simpl; eauto with f_equal;\n        try match goal with\n          | id: option _ |- _ => destruct o\n        end;\n        simpl; eauto with f_equal;\n        try match goal with\n        | id: option _ |- _ => destruct o\n        end;\n        simpl; eauto with f_equal;\n        try match goal with\n        | id: option _ |- _ => destruct o\n        end;\n        simpl; eauto with fQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  eapply map_insert_map; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_Qed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  apply map_concat_r.\n  rewrite map_insert_map.\n  apply map_concat_r.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert.\n  rewrite map_insert_map.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert_map.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert_map.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert_insert.\n  rewrite map_insert_map.\n  rewrite map_insert_map.\n  rewrite map_insert_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewriteQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction e; intros;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [inversion H; subst;\n  try solve [Qed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction f; intros; destruct e;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivity; reflexivity;\n  try solve [rewrite map_insert; reflexivityQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction e; intros;\n    try solve [simpl; auto | simpl; auto].\n  solve [simpl; auto].\n  solve [simpl; auto].\n  solve [simpl; auto].\n  solve [simpl; auto].\n  solve [simpl; auto].\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros A B f g.\n  induction e; intros; simpl; eauto.\n  apply map_app_iff; auto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_map_concat.\n  apply map_map_app_r.\n  eapply map_map_forall; eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with |-?A => destruct X as [a' | id] => destruct X as [a' | id] end;\n  try match goal with |-?A => destruct X as [a' id] end;\n  try match goal with |-?A = _ => destruct X as [a' id] end;\n  try match goal with |-?A = _ => destruct X as [a' id] end;\n  try match goal with |-?A =?A =?B => destruct X as [a' id] end;\n  try match goal with |-?A =?B => destruct X as [a' id] end;\n  try match goal with |-?A =?B => destruct X as [a' id] end;\n  try match goal with |-?A =?B => destruct X as [a' id] end;\n  try match goal with |-?A =?B => destruct X as [a' id] end;\n  try match goal with |-?A =?B => destruct X as [a' id] end;\n  try match goal with |-?A =?B => destruct X as [a' id] endQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 16555,
                "proof_end_offset": 16676,
                "proof": "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; intros; simpl; auto.\n  destruct o; destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o eqn:?;\n  try match goal with |- _ => destruct o eqn:?; inv H end;\n  try match goal with H: _ |- _ => destruct o eqn:?; inv H end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with H: _ |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with\n  | |- _ => destruct o eqn:?\n  end;\n  try match goal with |- _ => destruct o eqn:?\n  end;\n  try match goal with H: _ |- _ => destruct o eqn:?\n  end;Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o; auto end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o;\n  try match goal with |- _ => destruct o end end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with H: _ |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  tryQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction x; intros; simpl; auto with typeclass_instances.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction f; intros;\n  try match goal with |- _ => destruct o as [ | id] => destruct o; simpl; auto end.\n  destruct o; simpl; eauto with f_equal.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; intros;\n  try solve [inversion X; subst;\n  try solve [inversion X; subst; auto].\n  destruct X; simpl; eauto.\n  destruct X; simpl; eauto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction f; intros;\n  try match goal with |- context [f] => destruct o as (g a) end;\n  try match goal with |- context [f?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?f?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?g] => destruct o as (g a) end;\n  try match goal with |- context [f?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?g?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?g] => destruct o; try discriminate end;\n  try match goal with |- context [f?g?g] => destruct o end;\n  try match goal with |- context [f?g?g] => destruct o; try discriminate end;Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction a; intros; try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;\n  try reflexivity;Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction f; intros;\n  try match goal with\n    | id: option _ |- _ => destruct o; auto end;\n  try match goal with\n    | id: option _ |- _ => destruct o; try destruct o; auto\n    end;\n  try match goal with\n    | id: option _ |- _ => destruct o; try destruct o; auto\n    | id: option _ |- _ => destruct o; try destruct o; auto\n    end;\n  try match goal with\n    | id: option _ |- _ => destruct o; try destruct o; try destruct o; auto\n    | id: option _ |- _ => destruct o; try destruct o; auto\n    end;\n  try match goal with\n    | id: option _ |- _ => destruct o; try destruct o; auto\n    end;\n  try match goal with\n    | id: option _ |- _ => destruct o; try destruct o; try destruct o; auto\n    end;\n  try match goal with\n    | id: option _ |- _ => destruct o; try destruct o; try destruct o; auto\n    end;\n  try match goal with\n    | id: option _ |- _ => destruct o; try destruct o; try destruct o; auto\n    end;\n  tryQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  induction e; intros;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with H end;\n  try match goal with |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with H : _ |- _ => destruct o end;\n  try match goal with H : _ |- _ => destruct o end;\n  try match goal with |- _ => destruct o end;\n  try match goal with H : _ |- _ => destruct o end;\n  try match goal with H : _ |- _ => destruct o endQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\n",
                "context_tokens": 725,
                "proof_start_offset": 16726,
                "proof_end_offset": 16875,
                "proof": "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros;\n  try solve [simpl; rewrite IHl; auto | f_equal].\n  rewrite IHl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros;\n  try solve [rewrite <- IHl; auto].\n  rewrite map_map_app.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o as [| id]\n    end;\n    try match goal with\n    | id: option _ |- _ => destruct o asQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  rewrite fold_insert. f_equal.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.\n  rewrite fold_right.Qed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_concat; eauto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros; simpl; eauto with set.\n  rewrite <- fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_map.\n  rewrite fold_insert_insert.\n  rewrite fold_insert_insert_map.\n  rewrite fold_insert_insert_map.\n  rewrite fold_insert_rightQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  destruct x; simpl; auto.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewriteQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f e. induction e; simpl; intros; auto.\n  destruct o; simpl; eauto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f e; induction e; intros;\n    try match goal with |- _ => destruct o end;\n    simpl; eauto with typeclass_instances.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct o eqn:?H end;\n  try match goal with |- context [o] => destruct oQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\n",
                "context_tokens": 704,
                "proof_start_offset": 17224,
                "proof_end_offset": 17518,
                "proof": "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\nintros ? ? ? ? ? init step.\ninduction e; simpl.\neapply init.\neapply step.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros;\n  try match goal with |- context [ e] => destruct o;\n    try match goal with\n      | id: context [ e with _ = _ |- _] => destruct o\n      end;\n    try match goal with\n      | id: context [ e = _ |- _] => destruct o; clear id\n      end;\n    try match goal with\n      | id: context [ e = _ |- _ ] => destruct o; clear id\n      end;\n    try match goal with\n      | id: context [ e = _ |- _ ] => destruct o; clear id\n      end;\n    try match goal with\n      | id: context [ e = _ |- _ ] => destruct o; clear id\n      end;\n    try match goal with\n      | id: context [ e = _ |- _ ] => destruct o; clear id\n      end;\n    try match goal with\n      | id: context [ e = _ |- _ ] => destruct o; clear id\n      end;\n    try match goal with\n      | id: context [ e = _ |- _ ] => destruct o; clear id\n    end;\n    try match goal with\n      | id: context [ e = _ |- _ ] => destruct o; clear id\n      end;\n    tryQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B f Hf.\n  destruct o; simpl; auto with typeclass_instances.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros; simpl; eauto with typeclass_instances.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B f Hf.\n  destruct (fold_right f f Hf) as (f & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g & g g & g & g & g & g & g & g g & g & g & g g & g g & g & g & g & g & g & g g & g & g & g g & g & g g & g & g g & g & g & g g g g & g & g g & g g & g g & g & g g g g g & g & g g & g g g g & g g & g & g & g g g & g g g & g g g g & g g & g g g g g g g g g g g & g g g & g g g g g g & g g g g g g g g & g & g g g g g g g g gQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n  intros.\n  apply fold_right.\n Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B f Hf.\n  induction e; intros;\n  try match goal with |-?X => destruct o as?X; destruct o;\n    try match goal with |-?X1?X2 => destruct X1 as?X2; destruct X2 as?X3; destruct X3 as?X4; destruct X4 as [X4 X5; destruct X5 as [?X5 X5];\n    try match goal with H :?X2 |- _ => destruct X1 as X3; destruct X4 as [X5 X5; destruct X5 as [X6 X5; destruct X6; destruct X4; destruct X4; destruct X4; destruct X5 as [X5 X5; destruct X5; destruct X5; destruct X5; destruct X4; destruct X6; destruct X5; destruct X6; destruct X5; destruct X6; destruct X5; destruct X6; destruct X5; destruct X6; destruct X7; destruct X7; destruct X5; destruct X7; destruct X7; destruct X8; destruct X6; destruct X7; destruct X5; destruct X7; destruct X7; destruct X7Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B f Hf e.\n  induction e; intros;\n  try match goal with |-?x?y?y?y?y?y?y?y?y?y?y?y?y?y?z?z?z?z?z?z?z?z?z?z?z?z?z?z?z?z?z?z?z?z?z zz?z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z z zQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B f Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf HfQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros;\n  try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o; subst id\n    end;\n    try match goal with\n    | id: _ |- _ => destruct o;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ion e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 17848,
                "proof_end_offset": 17982,
                "proof": "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_monotonic.\n  rewrite length_Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; intros;\n  try apply map_app; auto with *.\n  apply map_app_nil; auto with *.\n  apply map_app_app_r; auto with *.\n  apply map_app_app_r; auto with *.\n  apply map_app_app_r; auto with *.\n  apply map_app_app_r; auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  apply length_monotonic.\n  intros; eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapply nth_monotonic.\n  eapplyQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl.\n  destruct e; simpl; eauto.\n  destruct e; simpl.\n  eapply IH; eauto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; intros;\n    try match goal with |- _ => destruct o eqn:?H; simpl in H end;\n    try match goal with |- _ => destruct o eqn:?H; inv H end;\n    try match goal with |- _ => destruct o eqn:?H; inv H end;\n    try match goal with |- _ => destruct o eqn:?H; inv H end;\n    try match goal with |- _ => destruct o eqn:?H end;\n    try match goal with |- _ => destruct o eqn:?H end;\n    try match goal with |- _ => destruct o eqn:?H end;\n    try match goal with H : _ |- _ => destruct o eqn:?H end;\n    try match goal with H : _ |- _ => destruct o eqn:?H end;\n    try match goal with |- _ => destruct o eqn:?H end;\n    try match goal with H : _ |- _ => destruct o eqn:?H; inv H end;\n    try match goal with |- _ => destruct o eqn:?H end;\n    try match goal with H : _ |- _ => destruct o eqn:?H end;\n    try match goal with H : _ |- _ => destruct o eqn:?H end;\n    try match goal with HQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  revert k. induction e; intros;\n  try match goal with |-?A => destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; try destruct o; tryQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A B f k1 k2 Hf1 Hf2 Hf3 Hf3 Hf4 Hf3 Hf4 Hf4 Hf5 Hf5 Hf4 Hf4 Hf5 Hf5 Hf5 Hf6 Hf5 Hf5 Hf6 Hf5 Hf6 Hf7 Hf6 Hf7 Hf7 Hf7 Hf8 Hf7 Hf7 Hf8 Hf7 Hf7 Hf8 Hf8 Hf8 Hf8 Hf8 Hf7 Hf7 Hf7 Hf8 Hf8 Hf9 Hf9 Hf8 Hf8 Hf7 Hf8 Hf8 Hf8 Hf8 Hf7 Hf7 Hf8 Hf7 Hf8 Hf8 Hf8 Hf8 Hf9 Hf8 Hf8 Hf9 Hf7 Hf8 Hf7 Hf8 Hf8 Hf7 Hf8 Hf9 Hf8 Hf8 Hf7 Hf8 Hf8 Hf8 Hf8 Hf8 Hf9 Hf8 Hf9 Hf8 Hf7 Hf8 Hf9 Hf9 Hf8 Hf7 Hf8 Hf8 Hf8 Hf8 Hf8 Hf9 Hf10 Hf9 Hf9 Hf9 Hf10 Hf8 Hf9 Hf8 Hf9 Hf8 Hf9 Hf8 Hf10 Hf8 Hf8 Hf9 Hf8 Hf10 Hf9 Hf8 Hf8 Hf9 Hf9 Hf9 Hf10 Hf9 Hf8Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  induction e; simpl; auto.\n  eapply init.\n  eapply init.\n  eauto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A B f k1 k2.\n  destruct k; simpl; eauto with arith.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonic.\n  apply length_monotonicQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; intros; simpl; auto.\n  eapply init.\n  apply init.\n  eapply init.\n  eauto.\n  eapply init.\n  eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 17984,
                "proof_end_offset": 18200,
                "proof": "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\ninduction e; simpl; intros.\neapply lookup_empty_None.\ndestruct x; [ omega | ].\nsimpl.\neapply IHe.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  eapply get_map_incl; eauto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  eapply add_len_length; eauto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  induction e; intros.\n  apply map_ext.\n  apply map_ext_map.\n  apply map_ext_incl.\n  apply map_ext_map_incl.\n  apply map_ext_map_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_ext_incl.\n  apply map_extQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  unfold lookup; intros.\n  rewrite fold_right.\n  intros.\n  simpl.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n  intros.\n  rewrite fold_right.\n Qed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  rewrite <- map_map_iff.\n  rewrite <- map_map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_iff.\n  rewrite map_Qed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  induction e; intros;\n  simpl.\n  eapply nth_complete; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 18306,
                "proof_end_offset": 18753,
                "proof": "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\nintros.\ncase (le_gt_dec k x); intro; try tauto.\nassert (lookup x e = None).\neapply lookup_beyond_length.\nomega.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  eapply lookup_empty_iff; eauto.\n  destruct x; [omega | ].\n  simpl. eapply lookup_empty_iff; eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  rewrite <- beq_nat_false; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; intros.\n  simpl; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; intros;\n  inv H.\n  eapply IHn; eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct x; simpl.\n  eapply IHn.\n  eapply IHn.\n  eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_iff; eauto.\n  destruct x; [omega | ].\n  eapply IHn; eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct x; destruct e; [ | simpl].\n  apply IHn.\n  apply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHn.\n  eapply IHnQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct (eq_dec e); [ auto | ].\n  simpl. eapply lookup_empty_None.\n  destruct x; [ omega | ].\n  simpl.\n  eapply IHn. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_empty_inv in H.\n  eapply lookup_emptyQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "*)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\n",
                "context_tokens": 698,
                "proof_start_offset": 18862,
                "proof_end_offset": 18957,
                "proof": "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\nsimpl.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  eapply lookup_empty_inv_inv; eauto.\n  eapply lookup_empty_inv_inv; eauto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction n; simpl; intros.\n  eapply IHn; eauto.\n  omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite length_empty.\n  destruct (eq_dec k x); intro; try tauto.\n  (* By case, [k < k] *)\n  assert (lookup x e = None). eapply lookup_bodyproof; eauto.\n  (* If we want to do not want to be a variable, it. *)\n  assert (lookup x e = None). eapply lookup_bodyproof; eauto.\n  (* If [lookup] is not\n   [k < k] is not in [k] in the [k <= k] is a good.\n   In k. *)\n  assert (lookup x e = None). eapply lookup_bodyproof; eauto.\n  eapply lookup_bodyproof; eauto.\n  (* If [lookup] is the [k] is in the [lookup] *)\n  assert (lookup x e = None). eapply lookup_bodyproof; eauto.\n  eapply lookup_bodyproof; eauto.\n  eapply lookup_bodyproof; eauto.\n  eapply lookup_bodyproof; eauto.\n  eapply lookup_bodyproof; eauto.\n  eapply lookup_bodyproof; eauto.\n  eapply lookup_bodQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite <- minus_succ. auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite length_empty.\n  rewrite length_empty.\n  destruct (lt_dec k x); [omega | omega].\n  simpl; auto.\n  unfold fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_right. apply fold_Qed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl.\n  unfold length.\n  destruct (zlt k 0); simpl.\n  apply Nat.add_0_r.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  eapply IHn; eauto.\n  rewrite <- beq_nat_refl.\n  eapply IHn; eauto.\n  rewrite <- beq_nat_refl.\n  eapply IHn; eauto.\n  rewrite <- beq_nat_refl.\n  eapply IHn; eauto.\n  rewrite beq_nat_refl.\n  eapply IHn; eauto.\n  rewrite beq_nat_refl.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  rewrite beq_nat_refl.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapply IHn; eauto.\n  eapplyQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  eapply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n Qed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  apply length_empty.\n  intros.\n  unfold length, length.\n  apply length_empty.\n  destruct (le_gt_dec k x); intro; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_gt_dec k x); subst; try tauto.\n  destruct (le_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "tion principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 19259,
                "proof_end_offset": 19333,
                "proof": "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  induction j; simpl; intros.\n  apply Pos.max_l.\n  apply Pos.max_l.\n  apply Pos.max_r.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  assert (i = i). apply (IHn _ _ _ _ H).\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k x); try omega.\n  destruct (le_gt_dec k xQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  unfold mymax in *.\n  remember (max_signed i j) as j.\n  destruct j; try congruence.\n  rewrite!split_signed_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; try omega.\n  rewrite!split_signed_eq; tryQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  unfold mymax. intros. apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=n0).\n  apply Nat.le_trans with (n:=n0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=0).\n  apply Nat.le_trans with (n:=n0).\n  apply Nat.le_trans with (nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  unfold mymax.\n  unfold mymax in *.\n  destruct (le_ge_dec i j).\n  destruct (le_gt_cases i j).\n  + apply mymax_l. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  unfold mymax in *; intros.\n  destruct j; [omega | apply mymax_r_r_iff].\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).\n  pose proof (is_max m n).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 19335,
                "proof_end_offset": 19409,
                "proof": "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  apply mymax_r_r_reverse. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. rewrite mymax_r in j.\n  unfold mymax_max.\n  unfold mymax.\n  unfold mymax.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax_max.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  rewrite mymax.max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.max.\n  unfold mymax.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.max.\n  unfold mymax.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  unfold mymax.max.\n  rewrite mymax.max_max.\n  unfold mymax.\n  rewrite mymax_max.\n  unfold mymax.\n  unfold mymax.\n  rewrite mymax.max.Qed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  apply mymax_r; auto.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  destruct (eq_dec j 0); [ | [ | [ | ] | [ | [ | [ | ] | [ | ] | [ | [ | ] | [ | ] | [ | ] | [ | ] | [ | [ | ] ] | [ | ] | [ | ] | [ | ] ] | [ | [ | ] ] | [ | ] | [ | ] | ] | [ | ] | [ | ] | [ ] | ] | [ | ] | [ | ] ] ] | [ | [ | ] | [ | ] ] | [ | ] | [ | ] | ] ] | [ | ] | [ | ] | [ | ] | [ | ] | ] ] | [ | [ | ] ] | [ | ] | [ | ] | ] ] | [ | [ | ] | ] | [ | ] | [ | ] ] ] | [ | [ | ] ] ] | [ | ] | [ | ] ] | [ | ] | [ | ] | ] ] | [ | [ | ] ] | [ | ] ] ] ] | [ | [ | ] | ] | [ | ] ] | [ | ] | [ | ] ] | [ |Qed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  unfold mymax.\n  unfold mymax.\n  intros.\n  destruct (le_gt_dec k x); try tauto.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. unfold mymax_r. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  apply mymax_r.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  apply mymax_r.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  unfold mymax.\n  intros. rewrite mymax_l.\n  eapply mymax_l_le_compat; eauto.\n  eapply mymax_l_lt_compat; eauto.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. apply mymax_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\n",
                "context_tokens": 705,
                "proof_start_offset": 19590,
                "proof_end_offset": 19888,
                "proof": "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\ninduction x; simpl; intros; subst.\nmymax.\ndestruct e; simpl.\nmymax.\nerewrite IHx by reflexivity.\nsimpl.\nmymax.\nerewrite IHx by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. unfold mymax.\n  destruct (max_lt_dec k x); try tauto.\n  rewrite 2!andb_true_iff.\n  replace (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 0 1 (nth 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 0 (nth 0 0 (nth 0 0 (nth 0 0 (nth 0 0 (nth 0 (nth 0 (nth 0 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 0 0 (nth 0 (nth 0 0 0 0 (nth 0 0 0 (nth 0 (nth 0 0 0 (nth 0 0 (nth 0 0 (nth 0 (nth 0 0 0 0 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 0 (nth 0 0 0Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  assert (forall x e, length e = length e -> length (raw_insert x e e) = (1 + k) = mymax (1 + k) (1 + x).\n  { intros.\n      apply (conj_insert_case x e e e) ; auto.\n      }\n      { intros.\n        apply (conj_insert_case x e e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e) ; auto. }\n      { intros.\n        apply (conj_insert_case x e) ; auto. }\n      { intros.\n        apply (conj_insert_case x eQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_max_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply mymax_r.\n  apply myQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  assert (x = k). eapply Nat.add_le_lt_lt_dec; eauto.\n  destruct (lt_lt_dec k x); try omega.\n  congruence.\n  simpl. omega.\n  destruct (lt_dec k x); try omega.\n  congruence.\n  destruct (lt_dec k x); try congruence.\n  destruct (lt_dec k x); try congruence.\n  congruence.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. unfold mymax.\n  destruct (le_gt_dec k x); simpl.\n  eapply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. unfold mymax.\n  apply (proj1_sig _ _ _ _ _ _ H H0).\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  destruct x as [x y] eqn:H.\n  destruct (lt_gt_dec k x); [rewrite 2!andb_true_iff_iff_iff | ].\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax in *.\n  destruct n; auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  assert (forall i j, mymax i j < n -> mymax j <= k -> mymax j <= i < n) by omega.\n  assert (forall i, mymax i j < n -> mymax j <= n -> mymax j <= i <= n) by omega.\n  assert (forall j, mymax j < n -> mymax j <= n -> mymax j <= n) by omega.\n  assert (forall j, mymax j < n -> mymax j <= n -> mymax j <= n) by omega.\n  assert (forall j, mymax j < n -> mymax j <= n -> mymax j <= n) by omega.\n  assert (forall j, mymax j < n -> mymax j <= n -> mymax j < n -> mymax j <= n) by omega.\n  assert (forall j, mymax j <= n -> mymax j < n -> mymax j < n -> mymax j < n -> mymax j < n -> mymax j < n) by omega.\n  assert (forall j, mymax j < n -> mymax j < n -> mymax j < n -> mymax j < n ->Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  apply mymax_r.\n  rewrite 2!andb_true_iff in H0.\n  rewrite 2!andb_false_iff in H1.\n  rewrite 2!andb_false_iff in H1. rewrite 2!andb_false_iff in H1.\n  rewrite 2!andb_false_iff in H1. rewrite 2!andb_false_iff in H1.\n  rewrite 2!andb_false_iff in H1. rewrite 2!andb_true_iff in H1. rewrite 2!andb_false_iff in H1.\n  rewrite 2!andb_true_iff in H1. rewrite 2!andb_false_iff in H1. rewrite 2!andb_true_iff in H1.\n  rewrite 2!andb_false_iff in H1. rewrite 2!andb_false_iff in H1. rewrite 2!andb_false_iff in H1. rewrite 2!andb_true_iff in H1. rewrite 2!andb_false_iff in H1. rewrite 2!andb_false_iff in H1.\n  rewrite 2!andb_true_iff in H1. rewrite 2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 19928,
                "proof_end_offset": 20142,
                "proof": "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\nintros.\nerewrite length_insert_general by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  unfold length, length.\n  intros.\n  rewrite (IH _ _ _ _ _ _ H).\n  apply length_insert_strong. omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  apply length_insert_compat.\n  destruct e; simpl; unfold mymax.\n  rewrite rev_insert_length.\n  apply length_insert_compat.\n  destruct e; simpl; simpl; auto.\n  rewrite rev_insert_length.\n  destruct e; simpl; simpl; auto.\n  apply length_insert_no_r.\n  destruct e; simpl; auto.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl; auto.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl; auto.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl; auto.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl; auto.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl; auto.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl; auto.\n  unfold mymax.\n  rewrite rev_insert_length.\n  destruct e; simpl; auto.\n  unfold mymaxQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  induction n; simpl; intros.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  destruct (lt_gt_dec k x); [ | simpl; auto ].\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_true_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_true_iff.\n  rewrite 2!andb_true_iff.\n  rewrite 2!andb_true_iff.\n  rewrite 2!andb_true_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_true_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_true_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2!andb_false_iff.\n  rewrite 2Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros. unfold length.\n  induction x; simpl; intros.\n  simpl.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert_insert.\n  apply length_insert.\n  apply length_insert.\n  apply length_insert_strong.\n  apply length_insert.Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  apply (IH _ _ _ _ H); auto.\n  destruct e; simpl.\n  rewrite rev_insert_in.\n  apply rev_insert_general; auto.\n  destruct e; simpl.\n  apply rev_insert_general; auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  apply length_insert.\n  destruct e; simpl.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros; try discriminate.\n  simpl.\n  rewrite 2! app_length.\n  rewrite length_rev.\n  apply length_insert_general.\n  rewrite 2! app_length.\n  rewrite <- rev_length.\n  apply length_insert_general.\n  rewrite 2! app_length.\n  rewrite 2! app_length.\n  rewrite <- app_length.\n  apply length_insert_general.\n  rewrite 2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n  2! app_length.\n Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  apply length_insert_strong; auto.\n  apply length_insert_strong; auto.\n  apply length_insert_strong; auto.\n  apply length_insert_strong; auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  apply length_insert_strong.\n  destruct e; simpl; intros; try discriminate.\n  eapply IHn; simpl; intros; try discriminate.\n  apply IHmax_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 20163,
                "proof_end_offset": 20345,
                "proof": "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. unfold length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. unfold length.\n  destruct e; simpl.\n  unfold length.\n  rewrite <- rev_insert_length.\n  unfold rev.\n  rewrite rev_insert_length.\n  rewrite rev_insert_length.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_insert_length.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewrite rev_rev.\n  rewriteQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. apply length_insert_in. auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. rewrite length_insert_length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite lengthQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. rewrite length_insert_length.\n  apply length_insert_compat.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply lengthQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  rewrite length_insert_local by trivial.\n  apply length_insert_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_acc_Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. unfold length. destruct e; simpl; auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. apply length_insert_general.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  apply length_insert_acc_r.\n  rewrite <- length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insertQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. unfold length, length; intros.\n  unfold rev, length, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev.\n(*  rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev.\n(*  rev rev, rev, rev,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 20347,
                "proof_end_offset": 20541,
                "proof": "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. unfold length. rewrite rev_insert_length in * by reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. apply length_insert_general; simpl.\n  rewrite rev_insert_by_end.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. unfold length.\n  rewrite length_insert_strong by trivial.\n  rewrite length_insert_strong by trivial.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. unfold length; simpl.\n  apply length_insert_abstract.\n  unfold length.\n  destruct e; simpl.\n  rewrite <- nth_insert_Forall by reflexivity.\n  unfold length; simpl.\n  rewrite length_insert by reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. unfold length, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, rev, revQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  destruct (lt_gt_dec k x); intros.\n  apply length_insert_strong in * ; omega.\n  apply length_insert_left_strong in * ; omega.\n  + apply length_insert_split_strong. omega.\n  + apply length_insert_strong_strong_strong in * by omega.\n  + apply length_insert_strong_strong in * ; omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite length_insert_length in * by trivial.\n  apply mymax_r.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  unfold length, length.\n  induction e; simpl; intros.\n  apply length_insert_1.\n  rewrite length_insert by auto.\n  simpl. rewrite length_insert_length by omega.\n  simpl.\n  unfold length.\n  destruct (insert x l) eqn:H; auto.\n  simpl.\n  apply length_insert_length.\n  apply length_insert_tl.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. unfold length. rewrite <- length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n Qed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. unfold length; rewrite length_insert_length in * by omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 718,
                "proof_start_offset": 20543,
                "proof_end_offset": 20777,
                "proof": "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert.\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert.\n  rewrite length_insert_case with (n := 0).\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert_case with (n := 0).\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert_case_strong with (n := 0).\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert_case_strongQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. eapply length_insert_local; eassumption.\n  unfold length. rewrite length_insert_length.\n  erewrite length_insert by reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. rewrite length_insert in * ; mymax.\n    unfold rev.\n    rewrite rev_insert_no_length; reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. unfold length. rewrite rev_insert_reverse; auto.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite length_insert_local by reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. rewrite length_insert_null in H.\n  destruct H.\n  destruct H.\n  destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  apply rev_insert_no_overlap in H. destruct H.\n  apply rev_insert_no_overlap in H. destruct H.\n  rewrite rev_insert_null_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.\n  rewrite rev_insert_null in H. destruct H.Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. apply length_insert_aux.\n  apply length_insert_spec.\n  apply length_insert_case.\n  apply length_insert_strong.\n  apply length_insert_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n  apply length_insert_length.\n Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. unfold length in *. rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. unfold length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. unfold length. rewrite length_insert_split in H.\n  unfold rev_insert.\n  rewrite length_insert_length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert_length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert_length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert_length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 20858,
                "proof_end_offset": 21019,
                "proof": "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\ninduction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. unfold length_map; simpl; intros.\n  unfold length_map.\n  erewrite length_insert_length by reflexivity.\n  unfold length_map.\n  rewrite length_insert by reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. eapply length_rev.\n  rewrite length_insert_length.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite length_insert.\n  rewrite lengthQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. eapply length_insert_local.\n  apply length_insert_case with (n:=n).\n  rewrite length_insert_general by reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite length_insert. apply length_length_eq. apply length_map_map_compat.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  rewrite length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  rewrite length_rev.\n  apply length_rev.\n  rewrite length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_rev.\n  apply length_revQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite length_map_length; auto.\n  rewrite length_map_length; auto.\n  rewrite length_map_length; auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. unfold length_map.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map_length.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map_length.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map_length.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. unfold length_map.\n  destruct e; simpl; trivial.\n  apply length_insert_strong in * mymax_max.\n  * mymax.\n  * mymax.\n  * mymax.\n    * mymax.\n      * mymax.\n      * mymax.max.\n      * mymax.max.\n      * mymax.max.\n      * mymax.max.\n      * mymax.max.\n        * mymax.max.\n        * mymax.max.max.\n        * mymax.max.\n        * mymax.max.\n        * mymax.max.\n        * mymax.max.max.\n        * mymax.max.max.\n          * mymax.max.max.\n          * mymax.max.\n          * mymax.max.max.\n            * mymax.max.max.\n          * mymax.max.\n          * mymax.max.\n            * mymax.max.\n            * mymax.max.\n            * mymax.max.\n            * mymax.max.\n            * mymax.max.\n            * mymax.max.\n            * mymax.max.\n            * mymax.max.\n            * mymaxQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite length_rev.\n  rewrite length_rev.\n  induction e; simpl; intros.\n  f_equal.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  destruct e; simpl; intros.\n  f_equal.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite length_rev.\n  rewrite lengthQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite length_insert in * ; mymax.\n  rewrite length_insert_length in * ; mymax.\n  rewrite length_insert_length in * mymax.\n  rewrite length_insert_length in * mymax.\n  rewrite length_insert_length in * mymax.\n  rewrite length_insert_length.\n  rewrite length_insert_length in * mymax.\n  rewrite length_insert_length in * mymax.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length in * mymax.\n  rewrite length_insert_length in * mymax.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n  rewrite length_insert_length.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 21021,
                "proof_end_offset": 21185,
                "proof": "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\nintros.\nrewrite length_map_general.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. apply length_map_tl.\n  rewrite length_map_length.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n Qed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. eapply length_map_compat; try eassumption. apply mymax_r.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| [ | a IH]; simpl; auto.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply length_map_ext.\n  apply lengthQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. eapply length_map_ext; eauto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_Qed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. erewrite length_map_length; try eassumption.\n  apply length_map_length; try eassumption.\n  apply length_map_length; try eassumption.\n  apply length_map_length.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. rewrite length_map_length; simpl.\n  rewrite length_map_length.\n  rewrite length_map.\n  rewrite length_map_length.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite lengthQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros.\n  erewrite length_map_length; try reflexivity.\n  unfold length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_map.\n  rewrite length_mapQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. unfold length. rewrite length_map_length in * by omega.\n  unfold length. rewrite length_map_length in * by omega.\n  unfold length in *.\n  rewrite length_map_length in * by omega.\n  unfold length in *.\n  rewrite length_map in * by omega.\n  unfold length in *.\n  rewrite length_map_length in * by omega.\n  unfold length in *.\n  rewrite length_map_length in * by omega.\n  unfold length in *.\n  rewrite length_map_length in * by omega.\n  unfold length in *.\n  rewrite length_map in * by omega.\n  unfold length in *.\n  destruct (length_length _ _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length _ * length_length) by omega.\n  unfold length.\n  rewrite length_map.\n  unfold length in *.\n  rewrite length_map_length in * by omega.\n  unfold length.\n  rewrite length_map_length in * by omegaQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| n]; simpl; intros; congruence.\n  destruct e as [| n]; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\n",
                "context_tokens": 690,
                "proof_start_offset": 21885,
                "proof_end_offset": 22104,
                "proof": "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\ndo 6 intro.\nintros hlookup ? ?.\nrewrite <- hlookup.\nsymmetry.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  induction e; simpl; intros; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree, agree, agree, agree, agree, agree, agree, agree, agree, agree, and, and, and\n  and and and\n  and and and and and the value of value. *)\n\nLemma agree_below:\n  forall A (e : env A) (e : env A),\n  agree (add x e1) e = Some a ->\n  agree (add x e1) e2.\nProof.\n  intros. rewrite agree_below; auto.\n  rewrite agree_below; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x e2).\n  rewrite <- (add_init x eQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- map_map_rev by auto.\n  rewrite map_map_rev by auto.\n  rewrite map_map_rev by auto.\n  rewrite map_map_rev by auto.\n  rewrite map_map_rev by auto.\n  rewrite map_map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev by auto.\n  rewrite map_rev byQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  induction e as [|x y IH]; simpl; intros.\n  + unfold agree.\n    rewrite H.\n    rewrite H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewriteQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (init_map_general (fun x => x) k = Some (map f e2).\n  unfold agree; simpl; intros.\n  apply agree_below.\n  apply agree_above.\n  apply agree_above.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. eapply agree_above_bound; eauto.\n  eauto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (in_all _ H).\n  apply agree_below.\n  apply agree_above.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_above.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_above.\n  apply agree_below.\n  apply agree_above.\n  apply agree_below.\n  apply agree_above.\n  apply agree_above.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_above.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_above.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n  apply agree_below.\n Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive. rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive. rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive. rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  rewriteQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (add_full f e1 e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e1).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e1).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e1).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_full f e2).\n  rewrite <- (add_fullQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ". mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 22183,
                "proof_end_offset": 22313,
                "proof": "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. rewrite map_concat. symmetry.\n  auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  do 6 intro. apply agree_empty_right.\n  eauto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  do 6 intro.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  apply agree_add.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  do 6 intro.\n  rewrite <- (add_comm _ _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_comm _ H).\n  rewrite <- (add_commQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  do 6 intro. rewrite <- H.\n  rewrite map_insert_left.\n  eauto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  do 6 intro.\n  rewrite (rank_add_0_r x); rewrite (rank_add_r x); rewrite (rank_add_r x); rewrite (rank_add_r x); rewrite (rank_add_r x); rewrite (rank_add_r x); rewrite (rank_add_r x); rewrite (rank_add_r x); rewrite (rank_add x); rewrite (rank_add_r x); rewrite (rank_add x); rewrite (rank_add_r x); rewrite (rank_add x); rewrite (rank_add_r x); rewrite (rank_add_r x); rewrite (rank_add x); auto.\n  rewrite (rank_add x y); rewrite (rank_add_r x); rewrite (rank_add x y); rewrite (rank_add_r x); rewrite (rank_add x); rewrite (rank_add_r x); auto.\n  rewrite (rank_add_r x); rewrite (rank_add x y); rewrite (rank_add x); auto.\n  rewrite (rank_add_r x); rewrite (rank_add x); rewrite (rank_add_r x); autoQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  do 4 intro.\n  rewrite <- (add_comm _ e0). auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. rewrite agree_empty_left.\n  auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. rewrite <- H.\n  apply agree_empty_left.\n  eauto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  do 6 intro. rewrite <- map_lookup. symmetry.\n  eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 22315,
                "proof_end_offset": 22446,
                "proof": "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\n  rewrite agree_empty_right. apply agree_empty_right.\n  apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_left. apply agree_empty_right. apply agree_empty_left. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_left. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_add_right. apply agree_empty_right. apply agree_empty_left. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_empty_right. apply agree_add_right. apply agree_empty_right. apply agree_add_right. apply agree_empty_right. apply agree_empty_right. apply agreeQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree, agree. intros. unfold agree. intros. destruct H as [v' H'].\n  exists (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P x))))))))))\n  as [p' H'].\n  exists (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P x)))))))))\n  with (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (P (PQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros. apply agree_empty_right.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\n  rewrite <- H. auto.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros.\n  destruct (H a); auto.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros. unfold agree.\n  apply agree_empty_right; auto.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros. apply agree_empty_right. apply agree_empty_right.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree, agree. intros. destruct (peq e e) as [e [e [H1 [H1 [H2 [H3 [H4 [H4 H4]]].\n  rewrite H4 in H4.\n  rewrite H4 in H4.\n  rewrite H5 in H4.\n  rewrite H4 in H4.\n  rewrite H5 in H4.\n  rewrite H4 in H4.\n  rewrite H6 in H4.\n  rewrite H4 in H5.\n  rewrite H5 in H5.\n  rewrite H5 in H4.\n  rewrite H4 in H5.\n  rewrite H5 in H5.\n  rewrite H6 in H4.\n  rewrite H5 in H4.\n  rewrite H5 in H4.\n  rewrite <- H5 in H6.\n  rewrite <- H4 in H6.\n  rewrite <- H6 in H6.\n  rewrite <- H6 in H7.\n  rewrite <- H6 in H7.\n  rewrite <- H7 in H7.\n  rewrite <- H6 in H8.\n  rewrite <- H7 in H7.\n  rewrite <- H7 in H8.\n  rewrite <- H7 in H7.\n  rewrite <-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "te length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\n",
                "context_tokens": 668,
                "proof_start_offset": 22562,
                "proof_end_offset": 22977,
                "proof": "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\nunfold agree.\ndo 8 intro.\nintros n ?.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; do 2 lookup_insert; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  unfold agree. intros.\n  destruct (is_empty_left _ _ H0).\n  apply agree_add_right; auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  applyQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. intros. elimtype False. omega. omega.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. elimtype False. omega. omega.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. apply agree_insert_right.\n  eapply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agree_insert_right.\n  apply agreeQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. intros. unfold agree. intros. destruct (is_empty_equal _ H0).\n  rewrite <- H0. apply agree_union_right; auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. intros. destruct (is_insert x e1).\n  assert (forall o x e, In e1 e2 -> In e2 k) -> In e1 e2).\n  { intros. apply agree_insert_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_rightQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insert.\n  apply agree_insertQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. intros. elimtype False.\n  omega.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct (valid_atom e1 e2) as [p [??]].\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewrite agree_insert_r.\n  rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  ",
                "context_tokens": 692,
                "proof_start_offset": 23694,
                "proof_end_offset": 23786,
                "proof": "Lemma osub_None: forall o, osub o None.\nProof.\nunfold osub.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold os. intros. destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.\n      destruct o.Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold os. intros. elimtype False. omega.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold os_h. intros. apply os_ub_None.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_step.\n    apply os_Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros. destruct o as [|a1 a2].\n    unfold ge; intros. elimtype False. omega.\n    intros. omega.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold os.\n    intros. elimtype False. omega.\n    apply (init_mem_step_total_dec o1 o1).\n    apply (init_mem_step_total_total_dec o1).\n    apply (init_mem_step_total_total o1).\n    apply (init_mem_step_total_total o1).\n    apply (init_mem_step_total_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_mem_step_total o1).\n    apply (init_memQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold os.\n    unfold os.\n    unfold os.\n    destruct (eq_dec o1 o2); [ case (eq_dec o1); [ case (eq_dec o2); [ case (eq_dec o2); [ case (eq_dec o2); [ case (eq_dec o1); [ case (eq_dec o2); [ case (eq_dec o2); [ case (eq_dec o2); [ case (eq_dec o2); [ case (eq_dec o2); [ case (eq_dec o2); case (eq_dec o1); [ case (eq_dec o2); [ case (eq_dec o2); [ case (eq_dec o2); case (eq_dec o3); [ case (eq_dec o2); [ case (eq_dec o2); case (eq_dec o2); [ case (eq_dec o2); case (eq_dec o2); [ case (eq_dec o2); case (eq_dec o2); [ case (eq_dec o2); case (eq_dec o2); case (eq_dec o2); [ case (Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold os. intros. inversion H; subst.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n    Proof.\n      intros.\n      apply (well_founded_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wfQed.",
                    "Lemma osub_None: forall o, osub o None.\n    Proof.\n    intros o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o oQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    induction o1; intros.\n    + (* Base case *)\n      intros k. apply sig_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind with_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind with_ind_ind_indQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  ",
                "context_tokens": 707,
                "proof_start_offset": 23790,
                "proof_end_offset": 23970,
                "proof": "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\nProof.\nunfold osub.\nintros ? ? ? ? h.\ninjection h; clear h; intro; subst; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold os.\n    destruct o. auto.\n    unfold os.\n    rewrite (mem_semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_spec s).\n    rewrite (semantics_semantics_Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Proof.\n    unfold os.\n    intros.\n    destruct o.\n    destruct o.\n    + destruct o.\n      + destruct o.\n      + destruct o.\n      + destruct o.\n        + destruct o.\n        + destruct o.\n        + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destruct o.\n          + destructQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  Proof.\n    intros o.\n    unfold os.\n    unfold os.\n    intros.\n    specialize (H1 o).\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct oQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold os.\n    unfold os.\n    unfold os.\n    intros.\n    destruct o as [m1 o2 o2] eqn:H;\n    [apply os_ok | apply os_ok | apply os_ok | apply os_ok | apply os_ok | apply os_ok_ok ]; auto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold os_ub.\n    unfold os_ub.\n    unfold os_ub.\n    unfold os_inc.\n    unfold os_inc.\n    apply os_refl.\n    unfold os_inc.\n    apply os_refl.\n    unfold os_inc.\n    apply os_refl.\n    unfold os_inc.\n    apply os_refl.\n    unfold os_one.\n    apply os_refl.\n    unfold os_one.\n    apply os_refl.\n    unfold os_inc.\n    apply os_refl.\n    unfold os_one.\n    apply os_refl.\n    unfold os_one_one.\n    apply os_refl.\n    unfold os_one.\n    apply os_refl.\n    unfold os_one.\n    apply os_one_one_side.\n    unfold os_one.\n    apply os_refl.\n    unfold os_one_one.\n    apply os_one.\n    apply os_one_one_side.\n    apply os_one_one_side.\n    apply os_one_side.\n    apply os_one_side.\n    apply os_one_side.\n    apply os_one_one_side.\n    apply os_one_side.\n    apply osQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  (* Subjecting the type of an environment. *)\n\n  Lemma os_order_Out:\n    forall o, reg o1 o2 -> o2 = o2.\n  Proof.\n    unfold os_order in *.\n    do 2 intro.\n    apply (init_mem_empty_left _ _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_left _ _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_right _ _ _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_right _ _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_right _ _ _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_right _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_right _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_right _ _ _ _ _ _ H).\n    do 2 intro.\n    apply (init_mem_empty_right _ _ _ _ _ H).\n    do 2 intro.\n    apply (init_memQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold os.\n    intros. destruct (ex_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold os.\n    intros. generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalize dependent o.\n    generalizeQed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n\n  (* Subnecting the type of the following lemma. *)\n\n  Lemma os_ok_Some:\n    forall a2 a3, sub a1 a3 -> s1 a3.\n  Proof.\n    unfold os_to_equiv in *.\n    destruct (eq_dec a2 a3) as [s2 s3].\n    set (a1 := fun a3 => a3 a4).\n    set (a1 := fun a3 => a3).\n    set (a3 := fun a4 => a4).\n    set (a3 := fun a5 => a4).\n    set (a1 := fun a4 => a4).\n    set (a5 := fun a5 => a5).\n    set (a5 := fun a5 => a6).\n    set (a6 := fun a5 => a6).\n    set (a5 := fun a5 => a5).\n    set (a6 := fun a5 => a5).\n    set (a5 := fun a5 => a5).\n    set (a5 := fun a5 => a5).\n    set (a5 := fun a5 => a5).\n    set (a6 := fun a5 => a5).\n    set (Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold os.\n    intros.\n    apply sig_ext_ext_nil_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_right_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "----------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  ",
                "context_tokens": 738,
                "proof_start_offset": 23974,
                "proof_end_offset": 24170,
                "proof": "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\nProof.\nunfold osub.\nintros ? h.\ngeneralize (h _ eq_refl).\nclear h.\nintros [ a1 [ ? ? ]].\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os. intros.\n    destruct p.\n    - apply os_inc_Some in H. apply os_ok in H.\n      destruct H as [h0 [h0 [h1 [h2 [h4 [h4 [h5 [h5 [h4 [h6 [h5 [h6 h6 [h6 [h6 h5 h6 [h6 [h7 h6 h6 h7 h7 h9 h9 h9 h10 h10 h10 h10 h10 h10 h10.\n  Proof.\n    unfold os_h in *. intros.\n    destruct p.\n    - apply os_h_None in H.\n      destruct p.\n        apply os_ok in H.\n      destruct p.\n        apply os_ok in H.\n        apply os_ok in H.\n        destruct p.\n        apply os_ok in H.\n        destruct p.\n        apply os_ok in H.\n        destruct p.\n        apply os_ok in H.\n        destruct p.\n        apply os_ok in H.\n        destruct p.\n        apply os_ok in H.\n        destruct p.\n        apply os_ok in H.\n        destruct p.\n        apply osQed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os.\n    intros.\n    apply os_ub_Some_Some in H.\n    unfold os.\n    apply os_inc_Some in H.\n    unfold os.\n    apply os_inc_Some in H.\n    unfold os.\n    apply os_inc_Some in H.\n    unfold os.\n    apply os_inc_ok in H.\n    unfold os.\n    apply os_ok in H.\n    unfold os.\n    apply os_inc_ok in H.\n    unfold os.\n    apply os_ok in H.\n    unfold os_ok in H.\n    unfold os.\n    apply os_ok in H.\n    unfold os_ok in H.\n    unfold os_ok in H.\n    apply os_ok in H.\n    unfold os_ok in H.\n    unfold os_ok in H.\n    unfold os_ok in H.\n    unfold os_ok in H.\n    apply os_ok in H.\n    unfold os_ok in H.\n    unfold os_ok in H.\n    unfold os_ok in H.\n    apply os_ok in H.\n    unfold os_ok in H.\n    unfold os_ok in H.\n    apply os_ok in H.Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os.\n    intros. generalize (H a1 a2).\n    case (eq_dec a2); [ case (eq_dec a1); [ case (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); case (eq_dec a3); [ case (eq_dec a4); [ case (eq_dec a3); [ case (eq_dec a3); case (eq_dec a3); [ case (eq_dec a3); case (eq_dec a3); [ case (eq_dec a3); auto; case (eq_dec a4); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_decQed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os.\n    intros. destruct (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a2); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a4); case (eq_dec a4); [ case (eq_dec a3); [ case (eq_dec a3); [ case (eq_dec a3); case (eq_dec a3 a3); [ case (eq_dec a3); case (eq_dec a4); [ case (eq_dec a3); [ case (eq_dec_4 a4); [ case (eq_dec a4); case (eq_dec4 a4); case (eq_dec a5); [ case (eq_dec a5); case (eq_Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os.\n    intros. apply os_in_one_and; auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os. intros. inversion H.\n    rewrite <- H. auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os. intros. inversion h.\n    apply os_h_Some; auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os. intros. inversion h; subst; auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os.\n    intros. destruct a1 as [b2 [r2 [??]].\n    exists a2; exists a2; exists a3; exists a3; exists a4; exists a4; exists a5; exists a4; exists a4; exists a4; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a6; exists a5; exists a5; exists a7; exists a5; exists a5; exists a5; exists a6; exists a5; exists a5; exists a5; exists a6; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a6; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a6; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; exists a5; existsQed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold os.\n    unfold os_ub.\n    simpl.\n    destruct (eq_dec x1); [ case (eq_dec x1); [ case (eq_dec x2); [ case (eq_dec x1); [ case (eq_dec x2); [ case (eq_dec x2); [ case (eq_dec x1); [ case (eq_dec x3); [ case (eq_dec x2); [ case (eq_dec x3); [ case (eq_dec x2); [ case (eq_dec x3); case (eq_dec x3); [ case (eq_dec x3); [ case (eq_dec x4); [ case (eq_dec x4); [ case (eq_dec x4); case (eq_dec x5); [ case (eq_dec x4); case (eq_dec x5); case (eq_dec x4); [ case (eq_dec x5); case (eq_dec x5); case (eq_dec x5); [ case (eq_dec x5); case (eq_dec x5);\n [ case (eq_dec x5); case (eqQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 24174,
                "proof_end_offset": 24381,
                "proof": "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\nProof.\nintros.\ndestruct o1.\neauto.\nelimtype False.\neauto using osub_None_Some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os.\n    destruct (st1 a2).\n    destruct (st2 a3).\n    destruct (st2 a3 a4).\n    destruct (st2 a4 a4).\n    destruct (st2 a4 a4).\n    destruct (st3 a4 a5).\n    destruct (st3 a5 a4).\n    destruct (st3 a5 a5 a5).\n    destruct (st3 a5 a5).\n    destruct (st3 a5 a5 a7).\n    destruct (st3 a5 a5).\n    destruct (st4 a5 a5).\n    destruct (st3 a5 a5).\n    destruct (st3 a5 a5).\n    destruct (st4 a5 a5).\n    destruct (st3 a5 a5).\n    destruct (st5 a5 a5).\n    destruct (st6 a5 a5).\n    destruct (st4 a5 a6).\n    destruct (st4 a5 a6).\n    destruct (st5 a6 a5).\n    destruct (st4 a5 a6).\n    destruct (st5 a5 a6).\n    destruct (st4 a5 a5).\n    destruct (st5 a6 a5Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os.\n    intros.\n    generalize (h _ eq_refl).\n    unfold os.\n    destruct (h eq_refl).\n    destruct (h eq_refl).\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    destruct (h eq_refl).\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_refl).\n    simpl in H.\n    destruct (h eq_Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os. intros. inversion h; subst; eauto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. unfold os.\n    destruct (h _ eq_refl) as [x1 [??]].\n    congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os.\n    intros. inversion H; subst.\n    inversion H; subst; auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os.\n    intros. unfold os.\n    destruct (eq_dec x1); [ right | right];\n    [ right | right];\n    [ right; right; split; right; split; auto; intro;\n      | right; split; intro;\n        | right; split; intro;\n        | right; split; intro;\n          | right; split; intro;\n          | right; split; intro;\n          | right; split; intro;\n          | right; split; intro;\n          | right; split; intro;\n          | right; split; intro;\n            | right ]; intro;\n            | right; split; intro;\n            | right; split; intro;\n            | right; split; intro;\n            | right; intro; split;\n            | right; split; intro;\n            | right; split ]\n          | right; intro; apply (P := P) ] ]\n        | right; intro;\n          | right; split; intro;\n          | right; split; intro;\n            | right; split; intro;\n          | right; split; intro;\n            | left; split; intro;\n            | right; split; intro;\n              | right; split; intro;\n            | left; split; introQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os.\n    destruct (h_exists a2 a3); auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os.\n    intros. rewrite (h _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _ eq_refl).\n    rewrite (h_equal _Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os_h in H.\n    generalize (h _ eq_refl). clear h. intros.\n    rewrite <- H0. clear H. intros a2.\n    rewrite <- H0. clear H0. intros a1. rewrite <- H0. clear H1. intros a2.\n    rewrite <- H0. clear H. intros a2. rewrite <- H0. clear H0. intros. rewrite <- H1. clear H0. intros a1. rewrite <- H0. clear H1. intros a2. rewrite <- H1. clear H0. intros a2. rewrite <- H1. clear H0. intros. rewrite <- H0. clear H0. intros a1. rewrite <- H0. clear H0. intros a2. rewrite <- H0. clear H0. intros a2. rewrite <- H1. clear H0. intros a2. rewrite <- H1. clear H0. intros a2. rewrite <- H1. clear H0. intros a1. rewrite <- H. clear H0. intros a1. rewrite <- H1. clear H0. intros a2. rewrite <- H0. clear H. intros a2. rewrite <-Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold os.\n    intros.\n    destruct (eq_dec o); [ left | right];\n      [ left; reflexivity | right];\n      left; reflexivity | right; reflexivity].\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  ",
                "context_tokens": 744,
                "proof_start_offset": 24601,
                "proof_end_offset": 24690,
                "proof": "Lemma osub_reflexive: forall o, osub o o.\nProof.\nunfold osub.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os.\n    intros.\n    generalize (h2 eq_refl). clear h1. intros.\n    generalize (h2 eq_refl). clear h2. intros.\n    generalize (h2 eq_refl). clear h2. intros.\n    generalize (h2 eq_refl). clear h2. intros.\n    generalize (h1 eq_refl). clear h2. intros.\n    generalize (h2 eq_refl). clear h3. intros.\n    generalize (h2 eq_refl). clear h2. intros.\n    generalize (h2 eq_refl). clear h2. intros.\n    generalize (h2 eq_refl). clear h3. intros.\n    generalize (h2 eq_refl). clear h2. intros.\n    generalize (h2 eq_refl). clear h3. intros.\n    generalize (h3 eq_refl). clear h3. intros.\n    generalize (h3 eq_refl). clear h3. intros.\n    generalize (h3 eq_refl). clear h3. intros.\n    generalize (h3 eq_refl). clear h3. intros.\n    generalize (h3 eq_refl). clear h3. intros.\n    generalize (h2 eqQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os_h, os.\n    intros o. simpl.\n    rewrite (h_eq o). reflexivity.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros.\n    destruct o; eauto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os.\n    destruct o. auto.\n    apply os_refl_equal_refl_equal_trans with o.\n    apply os_refl_equal_refl_equal_trans with o.\n    apply os_refl_equal_refl_equal_trans with o.\n    apply os_refl_equal_trans with o.\n    apply os_refl_equal_trans with o.\n    apply os_trans_refl_trans with o.\n    apply os_trans_refl_equal_trans with o.\n    apply os_refl_equal_trans with o.\n    apply os_refl_equal_trans with o.\n    apply os_refl_equal_trans with o.\n    apply os_one_equal_trans with o.\n    apply os_one_equal_trans with o.\n    apply os_refl_equal_trans with o.\n    apply os_one_trans with o.\n    apply os_one_trans with o.\n    apply os_one_equal_trans with o.\n    apply os_one_one_equal_side_trans with o.\n    apply os_one_side_trans with o.\n    apply os_one_one_side_trans with oQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os.\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n    rewrite (update_com o).\n   Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os.\n    intros.\n    generalize (h _ eq_refl).\n    intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (heq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (heq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (h eq_refl). intro.\n    generalize (hQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os.\n    unfold os_ub.\n    simpl. intros. apply os_one_equal. apply os_one_identity.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os.\n    destruct o as [m1 o2] eqn:E; simpl; intros.\n    destruct o1 as [m2] eqn:E; simpl; intros.\n    destruct o1 as [m2] eqn:E; simpl; intros.\n    destruct o1 as [m2] eqn:E; simpl in *.\n    destruct o1 as [m2] eqn:E; simpl in *; intros.\n    destruct o2 as [m2|] eqn:E; simpl in *.\n    destruct o2 as [m2|] eqn:E; simpl; intros.\n    destruct o2 as [m2|] eqn:E; simpl in *; subst.\n    destruct o2 as [m3|] eqn:E; simpl in *.\n    destruct o2 as [m3|] eqn:E; simpl in *; subst.\n    destruct o1 as [m2|] eqn:E; simpl in *.\n    destruct o2 as [m3|] eqn:E; simpl in *; subst.\n    destruct o2 as [m3|] eqn:E; simpl in *; subst.\n    destruct o1 as [m3|] eqn:E; simpl in *; subst.\n    destruct o3 as [m3Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n    Proof.\n      intros o. inversion H; subst.\n    inversion H.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst; eauto.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H; subst; eauto.\n    inversion H;Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold os. intros. destruct o.\n    unfold os_h, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr, pr pr, pr, pr, pr, pr, pr pr, pr, pr, pr, pr pr, pr, pr, pr, pr, pr pr, pr, pr pr, pr pr pr, pr pr, pr, pr pr pr, pr pr, pr pr, pr pr pr, pr, pr pr pr, pr pr pr pr pr pr, prQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  ",
                "context_tokens": 745,
                "proof_start_offset": 24694,
                "proof_end_offset": 24813,
                "proof": "Lemma subsume_reflexive: forall e, subsume e e.\nProof.\nunfold subsume.\neauto using osub_reflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os.\n    intros.\n    destruct o. simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destruct o.\n    simpl.\n    destructQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n    destruct o.\n    destruct o.\n    unfold os.\n    destruct o.\n    unfold os.\n   Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os_order.\n    split; auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os_ub.\n    unfold os_ub.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold osh.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold osh.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold os_h.\n    unfold osQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os.\n    simpl.\n    intros.\n    destruct o. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os_ub.\n    destruct o.\n    unfold os_ub.\n    destruct o.\n    unfold os_ub.\n    destruct o.\n    unfold os_ub.\n    destruct o.\n    unfold os_sp; destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp.\n    destruct o.\n    unfold os_sp.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp.\n    destruct o.\n    unfold os_sp in *.\n    destruct o.\n    unfold os_sp in *.\n    destruct o.\n    unfold os_sp in *.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp_new.\n    destruct o.\n    unfold os_sp.\n    destruct o.\n    unfold os_sp_new.\n    destruct oQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os_ub.\n    intros.\n    destruct o.\n    inversion H.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os.\n    intros. unfold os.\n    apply os_inc_Some in H.\n    apply os_step_refl in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_Some in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply os_ok_None in H.\n    apply osQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os.\n    intros. unfold os.\n    simpl.\n    destruct o.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heq_refl). clear h.\n    generalize (heqQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold os.\n    unfold os.\n    intros.\n    generalize (h _ eq_refl).\n    generalize (h eq_refl).\n    generalize (h eq_refl).\n    generalize (h eq_refl).\n    generalize (heq_refl).\n    generalize (h eq_refl).\n    generalize (h eq_refl).\n    generalize (heq_refl).\n    generalize (h eq_refl).\n    generalize (heq_refl).\n    generalize (h eq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n    generalize (heq_refl).\n   Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  ",
                "context_tokens": 729,
                "proof_start_offset": 24817,
                "proof_end_offset": 25084,
                "proof": "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\nProof.\nunfold osub.\nintros ? ? ? hs1 hs2 a3 h3.\ngeneralize (hs2 _ h3); intros [ a2 [ h2 ? ]].\ngeneralize (hs1 _ h2); intros [ a1 [ h1 ? ]].\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    unfold os.\n    intros o1 o.\n    generalize (h_eq_refl o1). clear h1.\n    generalize (h_eq_refl o1). clear h1.\n    generalize (h_eq_refl o1). clear h1.\n    generalize (h_eq_refl o1). clear h2.\n    generalize (h_eq_refl o1). clear h2.\n    generalize (h_eq_refl o1). clear h2.\n    generalize (h_eq_refl o1). clear h1.\n    generalize (h_eq_refl o1). clear h2.\n    generalize (h_eq_refl o1). clear h2.\n    generalize (h_eq_refl o1). clear h2.\n    generalize (h_eq_refl o1). clear h1.\n    generalize (h_eq_refl o1). clear h1.\n    generalize (h_eq_refl o1). clear h2. clear h1.\n    generalize (h_eq_refl o1). clear h2. clear h1.\n    generalize (h_eq_refl o1). clear h1. clear h1.\n    generalizeQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os_ub. intros.\n    destruct o1.\n    split.\n    - exists a. split.\n      - exists a. split.\n      - exists a. split.\n      - exists a. split.\n        - exists a. split.\n        - exists a.\n        split.\n        - exists a.\n        exists a. split.\n        - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - exists a.\n          split.\n          - existsQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub.\n    unfold os_ub.\n    unfold os.\n    unfold os_ub.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_h.\n    rewrite os_Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    intros.\n    destruct o1.\n    - (* Subizes the case *)\n    - (* Subizes the equality of the equality of the equality of equality of the equality of equality *)\n    - (* Subizes the equality of equality *)\n    - (* Subizes the equality of equality *)\n    - (* Subizes the equality of equality *)\n    - (* Subizes the equality *)\n    - (* Subizes the equality *)\n      - (* Subizes a equality *)\n      - (* Subizes the equality *)\n      - (* Subizes the equality *)\n        - (* Subizes a equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes the equality *)\n        - (* Subizes theQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    destruct o1 as [x1 o2 o2]; auto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    intros.\n    generalize (h_eq (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal_equal (refl_equal (refl_equal (refl_equal (refl_equal_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal (refl_equal_equal (refl_equal (refl_equal_equal))) (refl_equal (refl_equal_equal (refl_equal_equal (refl_equal (refl_equal (refl_equal (refl_equal _)).\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    intros o1 o2 o3 o3 o4.\n    unfold os2.\n    unfold os2.\n    generalize (h1 o2 o3 o3); clear o3 o3 o4 o5 o6 o6 o6 o7 o6 o7 o9 o9 o9 o10 o14 o9 o15 o14 o14 o14 o15 o14 o14 o14 o14 o14 o14 o14 o14 o14 o15 o15 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o15 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 o14 oQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    induction o1.\n    - apply os_incr.\n    - apply os_refl_equal_refl_equal_refl_equal_equal_refl_equal_equal_refl_equal_equal_refl_equal_equal_refl_equal_equal_refl.\n    - apply os_one_equal_equal_equal_refl_equal_refl_equal_equal_equal_refl_equal_equal_refl_equal_equal_refl_equal_equal_refl_equal_equal_equal_equal_refl_equal_equal_equal_refl_equal_equal_equal_equal_refl_equal_equal_equal_equal_equal_refl_equal_equal_equal_equal_refl.\n    - apply os_ok_refl_equal_equal_equal_refl_equal_equal_equal_equal_refl_equal_equal_equal_equal_refl_equal_equal_equal_equal_sym_equal_refl_equal_equal_equal_refl_equal_equal_equal_equal_equal_refl_equal_equal_equal_equal_refl_equal_equal_equal_refl_equal_equal_refl_equal_Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    intros o1 o2 o3.\n    generalize (h2 o3 o3).\n    generalize (h3 o3 o3).\n    generalize (h3 o3 o3).\n    generalize (h3 o3 o4 o3).\n    generalize (h3 o3 o3).\n    generalize (h4 o3 o3).\n    generalize (h3 o3 o4 o4).\n    generalize (h4 o3 o4 o5 o6).\n    generalize (h3 o4 o3).\n    generalize (h3 o5 o4 o4).\n    generalize (h4 o5 o5 o5).\n    generalize (h5 o2).\n    generalize (h3 o3 o3).\n    generalize (h4 o4 o4).\n    generalize (h4 o4 o4).\n    generalize (h5 o4 o5 o6).\n    generalize (h3 o4 o5).\n    generalize (h4 o4 o5 o4).\n    generalize (h4 o5 o2).\n    generalize (h5 o5 o6 o4).\n    generalize (h4 o4 o5 o5).\n    generalize (h4 o3 o4).\n    generalizeQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold os.\n    intros.\n    generalize (h_eq o1 o1 o2).\n    generalize (h_eq o1 o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o1).\n    generalize (h_eq o2 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o2 o2).\n    generalize (h_eq o1 o1).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o2 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o1 o2).\n    generalize (h_eq o2 o2).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  ",
                "context_tokens": 730,
                "proof_start_offset": 25088,
                "proof_end_offset": 25260,
                "proof": "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\nProof.\nunfold subsume.\neauto using osub_transitive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume_equivalence.\n    destruct e1; destruct e2; [eexists; eauto|].\n    apply os_le_trans with e1; [|eexists; eauto].\n    apply os_le_trans with e2; [|eexists; eauto].\n    apply os_le_trans with e2; [|eexists; eauto].\n    apply os_le_trans with e3; [|eexists; eauto].\n    apply os_le_trans with e3; [|eexists; eauto].\n    apply os_le_trans with e3; [|eexists; eauto].\n    apply os_lt_trans with e3; [|eexists; eauto].\n    apply os_le_trans with e3; [|eexists; eauto].\n    apply os_lt_trans with e3; [|eexists; eauto].\n    apply os_le_trans with e3 [|eexists; eauto].\n    apply os_le_trans with e3; [|eexists; eauto].\n    apply os_le_trans with e3; [|eexists; eauto].\n    apply os_le_trans with e3 [|eexists; eauto].\n    apply os_le_trans with e3 [|eexists; eauto].\n    apply os_lt_trans with e3 [|eexistsQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold os.\n    induction e1; intros; [split1 | [split2 | split3 | apply os_refl_equal2].\n    repeat (split3; [split3 | apply os_refl_equal2].\n    repeat (split3; [split3 | apply os_refl_equal3].\n    repeat (split3; [split3 | apply os_refl_equal3].\n    repeat (split3; [split3 | apply os_refl_equal3].\n    repeat (split3; [split3 | apply os_refl_equal3].\n    repeat (split3; [split3 | apply os_refl_equal4]].\n    repeat (split3; [split3 | apply os_one_equal4].\n    repeat (split3; [split3 | apply os_refl_equal3].\n    repeat (split3; [split3 | apply os_one_side3].\n    repeat (split3; [split3 | apply os_refl_equal3].\n    repeat (split3; [split3 | apply os_one_side4].\n    repeat (split3; [split3 | apply os_one_side3].\n    repeat (split3; [Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume_order, e1.\n    generalize (val_eq_dec e1). intros.\n    generalize (val_eq_dec e1); intro.\n    generalize (val_eq_dec e1); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2); intro.\n    generalize (val_eq_dec e2Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold os_order'.\n    intros.\n    unfold os_order', os_order'.\n    rewrite e2.\n    rewrite e2.\n    rewrite e2.\n    apply os_ub_Some with o; [apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l ]; apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | apply l | applyQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold os.\n    intros.\n    generalize (eq_refl_equal_equal_refl_equal_equal_refl_equal_equal_equal_equal_refl_equal_equal_equal_refl_equal_equal_equal_equal_equal_refl.\n    apply os_in_refl_equal_equal_equal_refl_equal_equal_equal_equal_equal_equal_refl_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal__equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal_equal__equal_equal_equal__equal_equal_equal_equal_Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros o1 o2 o3.\n    unfold os.\n    unfold os.\n    intros.\n    destruct o1 as [p' [??]]].\n    generalize (pp_exists o2 o3); intro [a1 [? [? [??]]].\n    generalize (pp_exists o3 o3); intro [a1 [? [? [??]]].\n    generalize (pp_exists o4 o4); intro [a2 [? [??]]].\n    generalize (pp_exists o4 o3); intro [a2 [? [??]]].\n    generalize (pp_exists o4 o4); intro [a1 [??]].\n    generalize (pp_exists o4 o4); intro [a1 [? [? [??]].\n    generalize (pp_exists o4 o4); intro [a2 [? [??]]].\n    generalize (pp_exists o4 o4); intro [a2 [??]].\n    generalize (pp_exists o4 o4); intro [a1 [??]].\n    generalize (pp_exists o4 o5); intro [a2 [??]].\n    generalize (pp_exists o4 o5); intro [a1 [??]].\n    generalize (pp_exists o5 o5); intro [a1 [??]].\n    generalize (pp_exists o5 o5Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold os.\n    intros e1 e2.\n    generalize (H0 _ _ H1); intro.\n    generalize (H0 _ H0); intro.\n    generalize (H0 _ _ H0); intro.\n    generalize (H0 _ H1); intro.\n    generalize (H0 _ _ H0); intro.\n    generalize (H0 _ H1); intro.\n    generalize (H1 _ H0); intro.\n    generalize (H1 _ H1); intro.\n    generalize (H1 _ _ H0); intro.\n    generalize (H0 _ _ H0); intro.\n    generalize (H1 _ H); intro.\n    generalize (H1 _ _ H0); intro.\n    generalize (H0 _ H0); intro.\n    generalize (H0 _ H0); intro.\n    generalize (H1 _ H0); intro.\n    generalize (H0 _ _ H1); intro.\n    generalize (H0 _ H0); intro.\n    generalize (H1 _ H0); intro.\n    generalize (H1 _ _ H1); intro.\n    generalize (H0 _ H); intro.\n    generalize (H1 _ _ H0); intro.\n    generalize (HQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    unfold os.\n    unfold os.\n    generalize (l o1 o2); intros.\n    generalize (pp1 o2); intros [a2 [? [? [??]].\n    generalize (pp2 o1); intros [a2 [??]].\n    generalize (pp2 o1); intros [a2 [? [??]].\n    generalize (pp2 o a1); intros [a3 [a3 [??]].\n    generalize (pp2 o a3); intros [a3 [??]].\n    generalize (pp2 o a3); intros [a3 [??]].\n    generalize (pp2 o a1); intros [a3 [??]].\n    generalize (pp2 o a3); intros [a3 [??]].\n    generalize (pp2 o a3 a3); intros [a3 [a3 [??]].\n    generalize (pp2 o a3); intros [a3 [??]].\n    generalize (pp2 o a3); intros [a4 [??]].\n    generalize (pp2 o a3); intros [a3 [??]].\n    generalize (pp2 o a3); intros [a4 [??]].\n    generalize (pp2 o a3); intros [a4 [a5 [??]].\n    generalize (pp2 o a3); introsQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume_equivalence.\n    intros.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o2.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o2.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o2.\n    destruct o1.\n    destruct o1.\n    destruct o1Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold osub.\n    intros e1 o1 o2 o3.\n    unfold os2.\n    simpl.\n    destruct o2 as [r1 [? [??]].\n    generalize (join_com _ _ _ _ _ _ _ _ _ _ H1); intros [a2 [? [??]]]].\n    generalize (join_com _ _ _ _ _ _ H1); intros [a2 [? [? [??]]]].\n    generalize (join_com _ _ _ _ _ _ _ H1); intros [a3 [? [? [? [? [??]]]].\n    generalize (join_com _ _ _ _ _ _ _ H2); intros [a3 [a3 [H4 [H5 H6]]].\n    generalize (join_com _ _ _ _ _ H2); intros [a3 [H6 [? [? [? [? [??]]]].\n    generalize (join_com _ _ _ _ H6); intros [a3 [H6 [??]].\n    generalize (join_com _ _ _ _ _ _ _ H2); intros [a4 [H5 [? [??]]]].\n    generalize (join_com _ _ _ H5); intros [a3 [H6 [??]]]].\n    generalize (join_com _ _ _ _ H6); intros [Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  ",
                "context_tokens": 722,
                "proof_start_offset": 25323,
                "proof_end_offset": 25471,
                "proof": "Lemma subsume_empty: forall e, subsume e (@empty _).\nProof.\nunfold subsume.\nintros.\nrewrite lookup_empty_None.\napply osub_None.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume_empty.\n    intros.\n    generalize (H _ _ H). clear H. intros.\n    generalize (H _ _ H). clear H0. intros.\n    generalize (H _ H). clear H0. intros.\n    generalize (H _ H). clear H0. intros.\n    generalize (H _ _ H H). clear H0. intros.\n    generalize (H _ H). clear H0. intros.\n    generalize (H _ _ H0). clear H1. intros.\n    generalize (H _ H H0). clear H0. intros.\n    generalize (H _ _ H0). clear H0. intros.\n    generalize (H _ _ H0). clear H0. intros.\n    generalize (H _ _ H0). clear H0. intros.\n    generalize (H _ _ H0). clear H0. intros.\n    generalize (H _ H). clear H0. intros.\n    generalize (H _ H0). clear H0. intros.\n    generalize (H _ _ H0). clear H0. intros.\n    generalize (H _ _ H H0). clear H0. intros.\n    generalize (H _ H0). clear H0. intros.\n   Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume_empty.\n    intros e e1 e2.\n    generalize (f_equal e1 e2). clear e1. intros.\n    generalize (f_equal e1 e2). intro.\n    generalize (f_equal e1 e1). intro.\n    generalize (f_equal e1 e1). intro.\n    generalize (f_equal e2). intro.\n    generalize (f_equal e1 e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e2). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e2). intro.\n    generalize (f_equal e2). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_equal e1). intro.\n    generalize (f_Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold os.\n    unfold os.\n    apply (mk_empty_right_r E).\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume_empty.\n    apply (mk_empty_r e1).\n    destruct e2 as [v1 [v2 [??]]]].\n    generalize (join_refl _ _ _ _ _ H0); intros [a1 [v2 [??]]]].\n    generalize (join_refl _ _ _ _ H0); intros [a1 [v2 [? [? [??]]]].\n    generalize (join_refl _ _ _ H0); intros [a2 [v3 [v3 [??]]]].\n    generalize (join_refl _ _ _ _ H0); intros [a2 [v3 [??]].\n    generalize (join_refl _ _ _ _ H0); intros [a2 [v3 [? [??]]]].\n    generalize (join_refl _ _ _ _ H1); intros [a2 [v3 [??]]]].\n    generalize (join_refl _ _ H0); intros [a2 [? [??]].\n    generalize (join_refl _ _ _ _ _ H0); intros [a2 [? [? [??]]]].\n    generalize (join_refl _ _ _ H0); intros [a2 [??]].\n    generalize (join_refl _ _ H0); intros [a2 [??]].\n    generalize (join_refl _ _ _ HQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume_empty.\n    unfold make_empty.\n    rewrite (@empty_env_iff _ _ _ _ _ _ _ H H); intros [a2??H2|H3].\n    destruct o1 as [x2 [? [? [? [? [? [??]]]].\n    unfold os2.\n    generalize (join_refl _ _ _ _ _ H1); intros [a2 | [? [? [??]]]].\n    unfold os2.\n    generalize (join_refl _ _ _ H); intros [a3 [? [? [??]]]].\n    unfold os2.\n    generalize (join_refl _ _ _ H); intros [a1 [? [??]]]].\n    unfold os2.\n    generalize (join_refl _ _ H); intros [a2 [??]].\n    unfold os2.\n    generalize (join_refl _ _ _ H); intros [a3 [? [??]]]].\n    unfold os2.\n    generalize (join_refl _ _ _ _ _ H); intros [a2 [H3 [? [??]]]].\n    unfold os2.\n    generalize (join_refl _ _ _ _ H); intros [a1 [??]].\n    unfold os2.\n    generalize (join_refl _ _ _ H); intros [a2 [? [??]].\n    unfold osQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold os.\n    intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_refl e); intros.\n    generalize (eq_reflQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume_empty.\n    destruct e; auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume_empty.\n    auto using os.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume_empty.\n    intros.\n    generalize (H (f1 o2); intro [a1 [a2 [H2 [H3 [H3 [H4 [H4 [H4 [H5 H5 [H5 H5 [H6 H7 [H6 H7 H6 H8]]]]]].\n    generalize (H2 (f2 o3); intro [a3 [H5 [H5 H7 H7 H7 H7 H8]].\n    generalize (H2 (f2 o3 o3); intro [a3 [H7 H7 H7 H7 H8]].\n    generalize (H4 (f2 o3 o4)); intro [a3 [H7 H7 H8]].\n    generalize (H3 (f2 o3 o3)); intro [a4 [H7 H8 H8]].\n    generalize (H3 (f3 o3 o4); intro [a4 [H7 H7 H8]].\n    generalize (H3 (f3 o4 o5); intro [a5 H7 H7 | H7 H7]].\n    generalize (H4 (f3 o5 o5); intro [H7 H7 H8Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold os.\n    intros e e e1 e2.\n    generalize (H e2); intros [a2 [a3 [b3 [H4 [H4 H5]]].\n    generalize (H e2); intros [a3 [H5 [H5 [H6 H5]]].\n    generalize (H e2); intros [a3 [H6 [H6 H6]]].\n    generalize (H e3); intros [a4 [H6 [H6 H6 H6]]].\n    generalize (H e2); intros [a4 [H6 [H6 H6]]].\n    generalize (H e2); intros [a5 [H6 H6]].\n    generalize (H e); intros [a5 [H6 H6 H7]].\n    generalize (H e4); intros [a6 [H7 H7]].\n    generalize (H e4); intros [a5 [H7 H7 | H7]].\n    generalize (H e4); intros [a6 [H7 H7]].\n    generalize (H e4 e H); intros [a5 [H7 H7]].\n    generalize (H e3); intros [a6 [H7 H7];\n    generalize (HQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "nment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  ",
                "context_tokens": 714,
                "proof_start_offset": 25554,
                "proof_end_offset": 25976,
                "proof": "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\nProof.\nunfold subsume.\ndo 7 intro.\nintros n.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; repeat lookup_insert; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_insert.\n    intros. unfold bind.\n    destruct e1 as [x2????x3?y3?y3?y4?z4?y4?y5?y4?z6?z5?z8?z8?z8z8?z9?z8?z9?z9?z9?z8z9 z9z9 z10z9 z9 z11 z11 z11 z12 z11 z12 z11 z13 z13 z13 z14 z15 z14 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z16 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z16 z15 z15 z15 z15 z15 z15 z15 z15 z15 zQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold clean_ub.\n    intros.\n    generalize (H _ o1 o1 o2).\n    generalize (H o1 o1); intros [a2 [H1 H2]].\n    generalize (H o1 o1); intros [a1 [H2 H2].\n    generalize (H o2); intros [a2 [H3 H3];\n    generalize (H o1 o1); intros [a2 [H3 H3]].\n    generalize (H o1); intros [a2 H3 | [H3 H4]].\n    generalize (H o1 o1); intros [a2 H3|H4].\n    generalize (H o1); intros [a3 H4 | H5];\n    generalize (H o1); intros [a3 H5 | H5];\n    generalize (H o2); intros [a4 H5 | H6];\n    generalize (H o1); intros [a4 H5 | idtac];\n    generalize (H o1); intros [a1 H6 | idtac];\n    generalize (H o1); intros [a3 H5 | idtac];\n    generalize (H o1); intros [a1 | idtac];\n    generalize (H o1Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_body.\n    intros.\n    generalize (equiv_refl _ _ _ _ H H); intros [a1 [a2 [a2 [? [? [??]]]].\n    generalize (equiv_refl _ _ H); intros [a1 [a2 [a3 [a3 [b3 [b5 [b6 [b6 [b6 [c6 [c7 [b7 [c7 [b8 [b9 [b7 [c9 [b9 [b7 [b11 [b10 [c9 [c10 [b11 [b7 [c7 [c7 [c9 [c9 [c9c9 [c8c10 [b8 [c9 [c9 [c9 [c9 [c9 [c10 [c10 [c9 [c9 [c9 [c9 [c10c9 [c9 [c10 [c10 [c9 [c9 [c9 [c9 [c9c10 [c9 [c9c10 [c9 [c10 [c9 [c9 [c9 [c9c9 [c9 [c9c9c9 [c9 [Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_lower; simpl.\n    rewrite (insert_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_right.\n    destruct e1; [constructor|constructor|constructor|constructor|constructor]|constructor|constructor].\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_right.\n    rewrite (H0 _ _ H1); auto.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_funspec. intros. rewrite (get_insert_right_iff _ _ _ _ _ _ H).\n    destruct o1; [ | inv H].\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ H). clear H.\n    generalize (eq_refl _ _ H). clear H.\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eq_refl _ _ _ H).\n    generalize (eq_refl _ _ H).\n    generalize (eqQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_right.\n    induction e1.\n    auto.\n    destruct o1.\n    inversion H1.\n    destruct o1.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructor.\n    constructorQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_right. rewrite insert_spec.\n    destruct (eq_dec e1); auto.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume_funspec.\n    rewrite (insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_insert_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ".\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 25980,
                "proof_end_offset": 26219,
                "proof": "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\nProof.\ndo 3 intro.\nintros h1 h2.\nintro n.\ndestruct n.\neauto.\ndo 2 rewrite lookup_successor.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    intros.\n    destruct o1 as [|x y]; [ case (eq_dec x x); [case (eq_dec x x); [case (eq_dec x y); [case (eq_dec x y); [case (eq_dec x y); [case (eq_dec y x); [case eq_dec; auto|].\n    case (eq_dec x y); [case eq_dec y); [case eq_dec x; auto|].\n    destruct o1 as [|x y]; case eq_dec; [case eq_dec x y; auto|].\n    { case eq_dec y; [case eq_dec x y); [case eq_dec x y; auto|].\n    { case eq_dec; [case eq_dec y; auto|].\n      { case eq_dec y; [case eq_dec x y; auto|].\n        { case eq_dec y; [case eq_dec x y; auto|].\n        { case eq_dec x; [case eq_dec x y; auto|].\n        { case eq_dec x; [case eq_dec x y; auto|].\n        { case eq_dec y; [caseQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    simpl.\n    intros.\n    apply (mk_funspec_nil _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    intros o e1 e2.\n    generalize (eq_refl _ _ e2). clear e2. intros.\n    generalize (eq_refl _ e1). clear e2. intros.\n    generalize (eq_refl _ e1); clear e2. intros.\n    generalize (eq_refl _ e2). clear e1. intros.\n    generalize (eq_refl _ e1). clear e1. intros.\n    generalize (eq_refl _ e1). intro. clear e2.\n    generalize (eq_refl _ e2). clear e2. intros.\n    generalize (eq_refl _ e1). clear e2. intros.\n    generalize (eq_refl _ e1). clear e2. intros.\n    generalize (eq_refl _ e1). intro. clear e1. intro e2. clear e2. intros.\n    generalize (eq_refl _ e1). clear e2. intros e1.\n    generalize (eq_refl _ e1). intro. clear e2. intro e2.\n    generalize (eq_refl _ e1). clear e2. intros e2.\n    generalize (eq_refl _ e1). intro eQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    simpl.\n    auto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_spec.\n    unfold make_insert, make_insert.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_spec.\n    rewrite <- insert_specQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    unfold make_funspec.\n    simpl.\n    rewrite lookup_insert; auto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold start_state.\n    unfold subsume_funspec.\n    rewrite <- (mk_funspec_cons o e1 e2).\n    unfold_x, insert_lower.\n    rewrite <- (mk_funspec_cons o e1 e2).\n    unfold_x, insert_lower.\n    rewrite <- (mk_funspec_cons o e2 e3).\n    unfold_x, insert_lower.\n    rewrite <- (mk_funspec_cons o e2).\n    unfold_x, insert_lower.\n    rewrite <- (mk_funspec_cons o e1).\n    rewrite <- (mk_funspec_cons o e2).\n    rewrite <- (mk_funspec_cons o e2).\n    rewrite <- (mk_funspec_cons o e1).\n    rewrite <- (mk_funspec_cons o e1).\n    rewrite <- (mk_funspec_cons o e1).\n    rewrite <- (mk_funspec_cons o e2).\n    rewrite <- (mk_funspec_cons o e2).\n    rewrite <- (mk_funspec_cons o e2).\n    rewrite <- (mk_funspec_cons o e1).\n    rewrite <- (mk_funspec_cons o e2).\n    rewrite <- (Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    intros.\n    destruct (eq_dec o e1); [apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply H | apply HQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    intros.\n    destruct e1 as [x [x' [x' [y' [y' [y' [y' [y' [y' [y' [y' [y' [z' [y' [y' [z' [y' [y' [y' [y' [z' [y' [z' [z' [z' [z' [z' [z' [z' [z'z' [z' [z' [z' z' [z' [z' [z' z' [z'z' [z' [z' z'z' [z' [z' [z' [z' z' z' z' z' [z' [z' z' [z' [z' [z' z' z' [z'z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z' z'' z' z' z' z' z'' z' z'' z' z' z'' z' z''Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume_funspec.\n    unfold make_funspec.\n    rewrite (mk_insert_left _ _ _ _ _ _ _ _ H0); intros;\n    (* In the case, [lookup_insert_left] *)\n    repeat (split; auto).\n    (* In the case, [lookup_right] *)\n    repeat (split; auto).\n    (* In the case, [lookup_right] is defined *)\n    repeat (split; auto).\n    (* In the case, the case *)\n    repeat (split; auto).\n    (* In this case *)\n    repeat (split; auto).\n    (* In the case, [lookup_right] is a. *)\n    repeat (split; auto).\n    (* In the case, we have the case, we must have the case. *)\n    repeat (split; auto).\n    (* In this case, we need to do not need to write to prove that we have the case. *)\n    repeat (split; auto).\n    (* In the case, we need to have a case, we have the case, we have the case. *)\n    repeat (split; auto).\n    (* In this case, this case, we do not need to the case, the case, we donQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  ",
                "context_tokens": 719,
                "proof_start_offset": 26223,
                "proof_end_offset": 26458,
                "proof": "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\nProof.\ndo 4 intro.\nintro h.\nsplit.\neapply (h 0).\nintro n.\neapply (h (1 + n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_funspec.\n    intros o e1 e2 e2 e3.\n    generalize (spec_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_funspec, sig.\n    destruct e1.\n    auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_funspec. intros. destruct o1.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_true by auto.\n    rewrite if_true by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_true by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_true by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_true by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n    rewrite if_true by auto.\n    rewrite if_false by auto.\n    rewrite if_false by auto.\n   Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_funspec.\n    repeat match goal with\n      | |- context [ e1, e2] =>\n      match e2 with\n      | _ =>\n      let e2 := fresh \"e2\" in\n      let e3 := fresh \"e3\" in\n      let e3 := fresh \"e4\" in\n      let e4 := fresh \"e4\" in\n      let e4 := fresh \"e5\" in\n      let e4 := fresh \"e5\" in\n      let e4 := fresh \"e5\" in\n      let e4 := fresh \"e4\" in\n      let e4 := fresh \"e4\" in\n      let e4 := fresh \"e5\" in\n      let e4 := fresh \"e6\" in\n      let e5 := fresh \"e5\" in\n      let e5 := fresh \"e5\" in\n      let e4 := fresh \"e5\" in\n      let e6 := fresh \"e6\" in\n      let e6 := fresh \"e6\" in\n      let e6 := fresh \"e6\" in\n      let e6 := fresh \"e6\" in\n      let e6 := fresh \"e5\" in\n      let e6 := fresh \"e5\" in\n     Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_funspec.\n    intros o1 o2 o2.\n    case (eq_dec o1 o2); [ intros [a2 [a2 [s3 [s4 [s5 [s5 [s5 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s6 [s7 [s7 [s6 [s6 [s6 [s6 [s7 [s7 [s6 [s6 [s6 [s7 [s7 [s7 [s7 [s6 [s7 [s7 [s7 [s8 [s7 [s8 [s7 [s9 [s7 [s7 [s9 [s9 [s7 [s9 [s10 [s7 [s7 [s7 [s9 [s7 [s7 [s9 [s9 [s7 [s9 [s8 [s9 [s9 [s9 [s9 [s9 [s9Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_funspec in *.\n    destruct o1.\n    auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_cons.\n    do 4 intro.\n    rewrite <- insert_node_cons_inv_inversion_clear o1.\n    rewrite insert_node_cons_inversion_clear o1.\n    rewrite insert_node_cons_inv_inversion_clear o2.\n    rewrite insert_node_cons_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_invQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume_funspec.\n    simpl. intros. destruct o1 as [x2|x2?x3?y3?y3?y4] |- _ =>\n    apply eq_refl_equal_refl_equal_refl_equal_equal_refl_equal_equal_refl_equal_equal_equal_refl.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold os.\n    destruct e2 as [p1' [? [??]].\n    rewrite lookup_and. auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros. unfold subsume_cons.\n    destruct o1.\n    + destruct o1.\n      * destruct o1.\n      * destruct o1.\n        * destruct o1.\n          * destruct o1.\n          * destruct o1.\n          * destruct o1.\n            * destruct o1.\n            * destruct o1.\n            * destruct o1.\n            * destruct o1.\n            * destruct o2.\n            * destruct o1.\n            * destruct o1.\n            * destruct o1.\n              * destruct o1.\n            * destruct o1.\n            * destruct o1.\n              * destruct o1.\n              * destruct o2.\n              * destruct o2.\n              * destruct o1.\n              * destruct o2.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o2.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o2.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.\n              * destruct o1.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  Lemma subsume_cons_cons_inversion:\n    forall o1 o2 e1 e2,\n    subsume (o1 :: e1) (o2 :: e2) ->\n    osub o1 o2 /\\\n    subsume e1 e2.\n  Proof.\n    do 4 intro. intro h.\n    split.\n    eapply (h 0).\n    intro n. eapply (h (1 + n)).\n  Qed.\n\n  Lemma subsume_insert_inversion:\n    forall e1 x a2 e2,\n    subsume e1 (insert x a2 e2) ->\n    exists f1 a1,\n    e1 = insert x a1 f1 /\\\n    subsume f1 e2 /\\\n    sub a1 a2.\n  Proof.\n    (* Really painful. *)\n    induction e1; simpl; intros.\n    (* Base. *)\n    elimtype False.\n    match goal with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  ",
                "context_tokens": 708,
                "proof_start_offset": 27904,
                "proof_end_offset": 28289,
                "proof": "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\nProof.\nintros ? hf ? ? hs.\nintros ? b2 hlm2.\ngeneralize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]].\nsubst.\ngeneralize (hs _ _ hl2); intros [ a1 [ ? ? ]].\neauto using lookup_map_some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    unfold subsume_map.\n    do 3 intro h1.\n    destruct e1; [inversion H1; [inversion H2 | [inversion H2 | [inversion H2 | inversion H3 | inversion H4 | inversion H4 | inversion H4 | inversion H5 | inversion H4 | inversion H4 | inversion H5 | inversion H4 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H6 | inversion H5 | inversion H5 | inversion H6 | inversion H5 | inversion H5 | inversion H5 | inversion H6 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H5 | inversion H6 | inversion H6 | inversion H5 | inversion H5 | inversion H5Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold subsume_map. do 2 intro.\n    destruct x.\n    simpl in *.\n    rewrite H.\n    destruct x.\n    simpl in *.\n    rewrite <- H.\n    destruct x.\n    simpl in *.\n    rewrite <- H0.\n    destruct (eq_dec x1 (f a2)).\n    simpl in *.\n    rewrite <- H0.\n    destruct x.\n    simpl in *.\n    rewrite H0.\n    destruct (eq_dec x1 (f a2)).\n    simpl in *.\n    rewrite <- H0.\n    destruct (eq_dec x2 (f a2)).\n    simpl in *.\n    rewrite H0.\n    destruct (eq_dec x1 (f a2)).\n    simpl in *.\n    rewrite <- H0.\n    destruct (eq_dec x2 (f a2)).\n    simpl in *.\n    rewrite <- H0.\n    destruct (eq_dec x2 (f a2)).\n    simpl in *.\n    rewrite <- H0.\n    destruct (eq_dec x1 (f a2)).\n    simpl in *.\n    rewrite <- H0.\n    destruct x0.\n    simpl in *.\n    rewrite <- H0.\n    destruct (eq_dec x1 (f a2)).Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    induction e1; simpl; intros.\n    (* The [lookup] is a function *)\n    simpl in *.\n    destruct (eq_dec x1 a2); [ | [ | split]; auto].\n    (* case of [lookup_inversion h1] *)\n    simpl in *.\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_dec x1 a2); [ | split]; auto.\n    (* case *)\n    destruct (eq_decQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    do 2 intro.\n    apply (h x).\n    intro n.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destruct H.\n    apply H.\n    destructQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    do 3 intro.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct eQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct e1; simpl in *;\n      generalize (H (H a2); clear e1 e2; intros [e [e2 [e3 [e3 [e4 [e4 [e5 [e5 [e4 [e6 [e5 [e6 [e6 [e6 [e6 [e6 [e6 [e7 [e5 [e7 [e7 [e8 [e7 [e6 [e9 [e7 [e6 [e7 [e8 [e7 [e7 [e7 [e7 [e8 [e8 [e8 [e7 [e7 [e8 [e9 [e8 [e10 [e8 [e8 [e7 [e7 [e8 [e9 [e7 [e9 [e8 [e9 [e8 [e8 [e9 [e10 [e9 [e8 [e9 [e9 [e9 [e9 [e7 [e9 [e9 [e9 [e10 [e9 [e7 [e7 [e9 [e10 [e9 [e9 [e10 [eQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    do 3 intro.\n    destruct e1 as [[s1 s2] | s2] | s2] | s3].\n    + rewrite <- H1. auto.\n    + rewrite <- H1. auto.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    unfold subsume_map.\n    do 2 eexists.\n    rewrite bind_insert_null.\n    solve [auto].\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    do 3 intro.\n    destruct e1; try solve [auto|auto].\n    destruct e1; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e3; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e3; try solve [auto].\n    destruct e3; try solve [auto].\n    destruct e3; try solve [auto].\n    destruct e3; try solve [auto].\n    destruct e3; try solve [auto].\n    destruct e2; try solve [auto].\n    destruct e3; tryQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros.\n    unfold sub.\n    destruct e1; auto.\n    rewrite (proj1_sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig_sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig_sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig sig (sig (sig (sig (sig (sig (sig (sig_sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sig (sigQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 29118,
                "proof_end_offset": 29198,
                "proof": "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  destruct e1; try solve [rewrite <- beq_nat_refl | rewrite <- beq_nat_refl].\n  simpl. rewrite <- beq_nat_refl.\n  simpl. rewrite <- beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl. simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl. simpl. rewrite beq_nat_refl. simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl. simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl. simpl. rewrite beq_nat_refl. simpl. rewrite beq_nat_refl. simpl. rewrite beq_nat_refl.\n  simpl. rewrite beq_nat_refl. simplQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  induction e1; simpl; intros; inversion e2; subst; simpl; auto.\n  destruct e1; auto.\n  destruct e2; simpl; auto.\n  destruct e2; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e2; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n  destruct e3; simpl; auto.\n Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction 1; simpl; intros.\n  rewrite IHl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros n H; induction e1; intros; simpl in *;\n      try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [simpl in *; try solve [ simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [ simpl in *; try solve [ simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simpl in *; try solve [simplQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  rewrite <- (andp_adjoint _ _ _ _ hl).\n  apply H.\n  apply H.\n  apply (IHl _ _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHl _ hl).\n  apply (IHlQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  assert (forall a, a = b \\/ a = b \\/ a = b).\n  { intros.\n    rewrite <- H.\n    apply Permutation_refl.\n    intros.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- HQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  intros.\n  destruct H0; subst; auto.\n  destruct H0; subst; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_r.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_r.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.\n  apply Nat2Z.inj_l.Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  destruct n.\n  + simpl.\n    repeat rewrite concat_comm, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, concat_assoc, <- concat_assoc, concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, concat_assoc, <- concat_assoc, concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, concat_assoc, concat_assoc, <- concat_assoc, concat_assoc, concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, <- concat_assoc, concat_assoc, concat_assoc, concat_assoc, concat_Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  assert (forall a, sub a a = sub a) by (destruct a; simpl; auto).\n  subst; rewrite PMap.gss.\n  destruct (zle a); auto.\n  rewrite PMap.gso by auto.\n  destruct (zlt a); auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.gso by auto.\n  rewrite PMap.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "   end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 650,
                "proof_start_offset": 29200,
                "proof_end_offset": 29478,
                "proof": "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\ninduction e2; simpl; intros.\nreplace n with n1 by omega.\nassumption.\neauto using length_insert, omega_hint_1 with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  induction e1; intros.\n  - inv H.\n  - inv H.\n    - inv H.\n    - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n      - inv H.\n        - inv H.\n      - inv H.\n      - inv H.\n        - inv H.\n        - inv H.\n      - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n        - inv H.\n          - inv H.\n          - inv H.\n        - inv H.\n        - invQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  induction e2; intros.\n  - simpl; intros.\n    rewrite IH.\n    destruct (eq_dec e2); auto.\n    rewrite IH.\n    rewrite IH.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    simpl.\n    simpl.\n    rewrite IH.\n    simpl.\n    rewrite IH.\n    simpl.Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct e1 as [e2 [??]].\n  generalize (IH (IH (IH (IH (IH (IH (IH (IH (IH (IH (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct e1; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  rewrite length_concat; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_length; repeat rewrite rev_Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  unfold concat.\n  destruct e1 as [x1 H2]; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  rewrite length_concat.\n  rewrite length_concat.\n  apply IHn.\n  intros.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  apply length_concat.\n  intros.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  apply length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.\n  rewrite length_concat.Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  rewrite length_concat; auto.\n  rewrite length_concat; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct e1; simpl; auto.\n  destruct e2; simpl; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct e1; simpl; auto.\n  simpl; auto.\n  destruct e1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\n",
                "context_tokens": 670,
                "proof_start_offset": 29680,
                "proof_end_offset": 29946,
                "proof": "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e; simpl; intros.\nreplace n with k by omega.\nassumption.\neauto using agree_insert with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  unfold agree, agree.\n  rewrite agree_concat.\n  split; [apply repr_inj_is_true | ].\n  do 2 rewrite agree_concat.\n  split; [apply repr_inj_is_true | ].\n  do 2 rewrite agree_concat.\n  split; [apply repr_inj_is_true | ].\n  do 2 rewrite agree_concat.\n  split; [apply repr_inj_is_false | ].\n  do 2 rewrite agree_concat.\n  split; [apply repr_inj_is_true | ].\n  do 2 rewrite agree_concat.\n  split; [apply repr_inj_is_true | ].\n  do 2 rewrite agree_concat. split; [apply repr_inj_is_false | ].\n  do 2 rewrite agree_concat. split; [apply repr_inj_is_false | ].\n  do 2 rewrite agree_concat. split; [apply repr_inj_is_false | ].\n  do 2 rewrite agree_concat. split; [apply repr_inj_is_false | ].\n  do 2 rewrite agree_concat. split; [apply repr_inj_is_false | ].\n  do 2Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  destruct e2; destruct e2; destruct e2; destruct e2; destruct e2; destruct e3; destruct e2; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e4; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e4; destruct e4; destruct e3; destruct e3; destruct e4; destruct e3; destruct e3; destruct e3; destruct e3; destruct e4; destruct e3; destruct e4; destruct e4; destruct e3; destruct e3; destruct e4; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e4; destruct e3; destruct e3; destruct e4; destruct e4; destruct e3; destruct e4; destruct e3; destruct e4; destruct e4; destruct e4; destruct e3; destruct e4; destruct e4; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destruct e3; destructQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  rewrite agree_concat.\n  auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  - simpl.\n    rewrite <- (map_map_map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map.\n    rewrite map_map.\n    rewrite map_map_map.\n    rewrite map_map_map.\n    rewrite map_map_Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  rewrite <- H.\n  apply agree_concat; auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_concat.\n  apply agree_Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  apply agree_concat; auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  unfold agree, agree, agree.\n  intros.\n  specialize (IHl _ _ _ e1); clear H; intros; subst.\n  destruct e1 as [? [? [? [??]].\n  assert (e1 = e2) by omega.\n  assert (e2 = e2) by omega.\n  assert (e2 = e2) by omega.\n  assert (e3 = e3) by omega.\n  assert (e2 = e3) by omega.\n  assert (e3 = e3) by omega.\n  assert (e4 = e3) by omega.\n  assert (e3 = e3) by omega.\n  assert (e3 = e3) by omega.\n  assert (e4 = e4) by omega.\n  assert (e3 = e4) by omega.\n  assert (e4 = e3) by omega.\n  assert (e3 = e4) by omega.\n  assert (e4 = e4) by omega.\n  assert (e3 = e3) by omega.\n  assert (e4 = e4) by omega.\n  assert (e4 = e3) by omega.\n  assert (e5 = e4Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  revert e1 e2 e2; induction e1; simpl; intros.\n  - apply agree_concat with (v1 := v2) (v2 := v2) (v3 := v3) (v4 := v4) (v4 := v5 := v5) (v4 := v5) (v5 := v5 := v5) (v5 := v5) (v5 := v5) (v5 := v5 := v6) (v6 := v6) (v5 := v6) (v6 := v6) (v6 := v6) (v6 := v6) (v6 := v6) (v6 := v6 := v6) (v6 := v6) (v7 := v7) (v8 := v8) (v8 := v7) (v8 := v8 := v8) (v8 := v9) (v9 := v10 := v10) (v9 := v9) (v10 := v10 := v10) (v10 := v10) (v10 := v11 := v10) (v10 := v12Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  rewrite agree_concat.\n  rewrite agree_concat.\n  split.\n  - rewrite agree_concat.\n    rewrite agree_concat.\n    split.\n    - rewrite agree_concat.\n      split.\n      - rewrite agree_concat.\n      split.\n      - rewrite agree_concat.\n      split.\n      - rewrite agree_concat.\n      split.\n      - rewrite agree_concat.\n      split.\n        - rewrite agree_concat.\n      split.\n        - rewrite agree_concat.\n      - split.\n        rewrite agree_concat.\n      - split.\n        rewrite agree_concat.\n        split.\n        + rewrite agree_concat.\n        split.\n        - rewrite agree_concat.\n        split.\n          rewrite agree_concat.\n        split.\n          rewrite agree_concat.\n        split.\n          rewrite agree_concat.\n        split.\n        - rewrite agree_concat.\n        split.\n        rewrite agree_concat.\n        split.\n          rewrite agree_concat.\n        split.\n        - rewrite agree_concat.\n        split.\n          rewrite agree_concat.\n        - split.\n          rewrite agree_concat.\n        split.\n        - rewrite agree_concat.\n        split.\n          rewrite agree_concat.\n        split.\n        - rewrite agree_concatQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\n",
                "context_tokens": 672,
                "proof_start_offset": 30028,
                "proof_end_offset": 30412,
                "proof": "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\ninduction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\nrewrite insert_insert by omega.\nerewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\neauto with f_equal omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e2; simpl; intros.\n  replace (nth 0 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 1 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 0 0 (nth 0 (nth 0 0 (nth 0 (nth 0 1 (nth 0 (nth 0 0 (nth 0 (nth 0 0 (nth 0 0 0 i))) (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 0 (nth 0 1 (nth 0 (nth 0 0 0 (nth 0 (nth 0 (nth 0 (nth 0 (nth 0 0 (nth 0 0 (nth 0 0 0 (nth 0 0 (nth 0 0 (nth 0 (nth 0 (nth 0 0 (nth 0 (nth 0 0 0 0 (nth 0 0 0 (nth 0 1 (nth 0 0 (nth 0 0Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  apply IHn; auto.\n  apply IHn; auto.\n  apply IHn; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e2; simpl; intros.\n  replace n with (n + 1) by omega.\n  replace (n + 1) by omega.\n  apply IHn; omega.\n  omega.\n  omega.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e; simpl; intros.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e2; simpl; intros.\n  replace n with (length (concat e1 e2 e2)) by omega.\n  rewrite rev_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_concat.\n  apply concat_Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  replace (e1 + 1) with (e1 + 1) by omega.\n  rewrite <- insert_concat; auto.\n  rewrite <- insert_concat; auto.\n  rewrite <- insert_concat; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e2; simpl; intros.\n  replace (rev e2) with (rev e1) by omega.\n  rewrite rev_concat; auto.\n  destruct (IH v1) eqn:E; auto.\n  rewrite rev_concat; auto.\n  rewrite rev_concat; auto.\n  rewrite rev_concat; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  unfold make, make_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insert_concat.\n  rewrite <- insertQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e; simpl; intros; auto.\n  replace n with (length e1); auto.\n  replace n with (length e1); auto.\n  replace n with (length e1); auto.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plusQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction e1; simpl; intros.\n  replace n with (fst e1) by omega.\n  replace n with (fst e2) by omega.\n  replace n with (fst e2) by omega.\n  replace n with (fst e2) by omega.\n  rewrite IHn.\n  replace n with (fst e2) by omega.\n  apply IHn.\n  apply IHn.\n  rewrite IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "flexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 30691,
                "proof_end_offset": 30815,
                "proof": "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite <- (IH (IH (S n) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (SQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction a; simpl; intros.\n  rewrite!map_length, H.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n  apply IHlength.\n Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  replace n with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))) (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (SQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_cons.\n  rewrite nth_consQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  replace n with n by omega.\n  replace n with (0 + 1) by omega.\n  rewrite <- (IHn (S n) by omega.\n  apply IHn; omega.\n  rewrite <- (IHn (S n) by omega.\n  rewrite (IHn (S n) by omega.\n  apply IHn; omega.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n  rewrite IH.\n Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros; auto.\n  rewrite map_length; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n  apply IH.\n Qed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros.\n  + destruct a; simpl in *; try discriminate.\n    rewrite <- beq_nat_S.\n    rewrite <- beq_nat_S.\n    rewrite <- beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beq_nat_S.\n    rewrite beqQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite <- insert_cons by omega.\n  apply rev_involutive.\n  rewrite insert_local by omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\n",
                "context_tokens": 701,
                "proof_start_offset": 30859,
                "proof_end_offset": 31110,
                "proof": "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  replace n with (length (filter (fun a => default n a) (filter (fun a => default n a) (filter (fun a => default n a) (filter (fun a => default n a)) (filter (fun a => default n a)) (filter (fun a => default n a)) (filter (fun a => default n a)) (filter (fun a => default n a)) (filter (fun a => default n) (filter (fun a => default n) (filter (fun a => default n a)) (filter (fun a => default n a)) (filter (fun a => default n)) (filter (fun a => default n a)) (filter (fun a => default n a)) (filter (fun a => default n) (filter (fun a => default n) (filter (fun a => default n a)) (filter (fun a => default) (fun a => default)) (filter (fun a => default)) (filter (fun a => default n a)) (filter (fun a => default n)) (filter (fun a => default)) (filter (fun a => default n))) (filter (fun a =>Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  destruct e; simpl; auto.\n  rewrite insert_concat_l by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_l by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_l by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_r by omega.\n  rewrite insert_concat_rQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl; intros.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_concat_inv in H.\n  rewrite insert_inv in H.\n  rewrite insert_concatQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  destruct a; simpl; auto.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_right by omega.\n  rewrite insert_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_right by omega.\n  rewrite insert_concat_right by omega.\n  rewrite insert_right by omega.\n  rewrite insert_right by omega.\n  rewrite insertQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  - reflexivity.\n  - simpl.\n    rewrite <- insert_concat_inv; reflexivity.\n  - simpl.\n    rewrite insert_concat_inv; reflexivity.\n  - simpl.\n    rewrite <- insert_concat_inv; reflexivity.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  + simpl; intros.\n    auto.\n    rewrite <- insert_concat_value by auto.\n  + simpl; intros.\n    destruct e1; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e1; auto.\n  + simpl.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e3; auto.\n    destruct e2; auto.\n    destruct e2; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3; auto.\n    destruct e3;Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  + simpl.\n    destruct (eq_dec n); auto.\n    + simpl.\n      destruct (eq_dec n (filter (elements n0)) (elements n0) (elements n0)); auto.\n    + simpl.\n      destruct (eq_dec n (filter (elements n0)) (elements n0) (elements n0))); auto.\n    + simpl.\n      destruct (eq_dec n (filter (elements n0)) (elements n0))) as (n0,n0)).\n      simpl.\n        destruct (eq_dec n (filter (elements n0))) (elements n0)) (elements n0)); auto.\n      + simpl.\n        destruct (eq_dec n (filter (elements n0)) (elements n0))) as (n0,n0).\n        simpl.\n        destruct (eq_dec n (filter (elements n0))) (elements n0)); auto.\n        simpl.\n        destruct (eq_dec n (filter (elements n0)) (elements n0)) as (n0,n1).\n        simpl.\n        destruct (eq_dec n (filter (elements n0)) (elements n0)) as (n0Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  replace (length (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev t))) b)))) (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev l)))) (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev l)))) (rev (rev (rev (rev (rev (rev l))) (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev (rev l)))) (rev (rev (rev (rev (rev l)))) (rev (rev (rev (rev (rev (rev (rev l)))) (rev (Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl; intros.\n  rewrite insert_insert_node by omega.\n  rewrite insert_insert by omega.\n  rewrite insert_insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omega.\n  rewrite insert_node by omegaQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  + simpl.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omega.\n    rewrite <- insert_concat_value by omegaQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\nLemma insert_concat_replicate:\n  forall (A : Type) n x nx (a : option A) (b : A) e1,\n  n + x = nx ->\n  raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  eauto using insert_concat, length_replicate.\nQed.\n\n(* [concat. (replicate. a)] is just an iterated version of [insert. a]. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 31191,
                "proof_end_offset": 31414,
                "proof": "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\nintros.\nsimpl.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  rewrite andb_true_iff; auto.\n  rewrite andb_false_iff; auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros; auto.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insert_app by omega.\n  rewrite insertQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  rewrite insert_concat_l; simpl; intros.\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; auto |].\n  destruct (ident_eq i a) eqn:E; [simpl; autoQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  + simpl.\n    rewrite <- insert_len by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.\n    rewrite map_app by omega.Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  rewrite <- insert_concat_l; try omega.\n  rewrite <- insert_concat_r; try omega.\n  rewrite <- insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.\n  rewrite insert_concat_r; try omega.Qed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  replace n with (map (fun i => rev (concat (map (fun i => rev (concat (map (fun i => rev (concat (concat (map (map (fun i => rev (concat (map (concat (map (concat (concat (concat (map (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concatconcat (concat (concatconcat (concat))))))) (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concatconcat (concat (concat (concat (concat (concatconcat (concat (concat (concat (concat (concat (concatconcat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concat (concatconcat vconcat (concatconcatconcat_concat (concat (concat (concat (concat (concat (concatconcat (concat (concatconcat (concatconcatconcat (concatconcat_concat (concat (concat_concat (concat (concatconcat (concatconcat (concatconcat (concat (concat (concat_concat (concat (concatconcat (concatconcat (concat (concatconcat (concatQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  induction n; simpl; intros.\n  rewrite <- insert_length.\n  destruct (map_iff _ _ _ _ H0) as [b1 [b2 [H1 H2]].\n  apply in_map_iff in H0.\n  destruct (map_iff _ _ _ H0) as [b2 [H3 [H4 H4]].\n  apply in_map_iff in H0.\n  destruct (map_iff _ _ H0) as [b2 [H4 H4]].\n  apply in_map_iff in H0.\n  destruct (map_iff _ _ _ _ H1) as [b2 [H5 H5]].\n  apply in_map_iff in H0.\n  destruct (map_iff _ _ _ H0) as [b2 [H5 H6]].\n  apply in_map_iff in H0.\n  destruct (map_iff _ _ _ _ H0) as [b2 [H4 H4]].\n  apply in_map_iff in H0.\n  destruct (map_iff _ _ _ H0) as [b3 [H4 H5]].\n  apply in_map_iffQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  + replace n with (length (concat (tail a)) (prev_involutive e (tail a) (tail a)) (tail a (tail a)) (tail a)) (tail a (tail a) (tail a)) (tail a (tail a) (tail a)) (tail a)) (tail (tail a a))) (tail a (tail a)) (tail a (tail a)) (tail a (tail a) (tail a)) (tail a (tail a)) (tail a (tail a) (tail a)) (tail a (tail a)) (tail a (tail a)) (tail a (tail a)) (tail a (tail a)) (tail a (tail a)) (tail a (tail a) (tail a)) (tail a (tail a))) (tail (tail a (tail a) (tail a) (tail a) (tail a)) (tail a (tail a)) (tail (tail a) (tail a)) (tail (tail a)) (tail a (tail a)) (tail a (tail a)) (tail a (tail a)) (tail (tail a (tail a)) (tail a (tailQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  + destruct (IH _ _ _ _ _ _ H0).\n    auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct a; simpl; auto.\n  rewrite insert_last_two_p by omega.\nQed."
                ]
            }
        ],
        "disel": [
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\n",
                "context_tokens": 571,
                "proof_start_offset": 1849,
                "proof_end_offset": 2122,
                "proof": "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  (* Filers the lemma. *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilerss *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* Dilers *)\n  (* DQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  apply: step_other; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply: step_same; auto.\n  apply step_same; auto.\n  apply: step_same; auto.\n  apply:Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  unfold getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, getS, get_S, get_S, get_S, get_S, get_S, get_S, get_S, getS, getS, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_S, get_Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nintros s1 s2 r n s2 r1 r2 r1 r2 r2 r2 r3 r3 r3 r4 r4 r5 r4 r5 r5 r6 r6 r6 r6 r6 r6 r6 r6 r6 r6 r6 r7 r6 r6 r6 r7 r7 r7 r8 r8 r8 r8 r9 r9 r9 r9 r8 r9 r9 r9 r9 r10 r10 r10 r10 r13 r10 r13 r13 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 rQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nhave s2_ok : forall s1 s2 r1 r2 r2,\n             (exists s2, s1 s2 s2 s2 ->\n             s1 s2 s2 ->\n             s1 s2 -> s2 s2 ->\n             s1 s2 -> s2 s2 -> s2 s2 ->\n             s2 -> s2 s2 ->\n             s1 s2 -> s2 s2 ->\n             s2 -> s2 s2 ->\n             s1 s2 -> s2 ->\n             s2 s2 -> s2 -> s2 s2 ->\n             s1 s2 -> s2 -> s2 ->\n             s2 s2 ->\n             s2 -> s2 s3 ->\n             s2 -> s2 -> s2 ->\n             s2 -> s2 s3 ->\n             s2 -> s2 s2 ->\n             s2 -> s2 s3 -> s2 ->\n             s2 -> s2 s3 ->\n             s2 -> s2 -> s2 ->\n             s3 s4 -> s3 -> s3 ->\n             s2 s3 -> s3 -> s3 -> s4 ->\n             s4 -> s4 -> s3 -> s4 ->\n             s4 -> s4Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\n\nLemma step_same_step : forall s1 s2 r,\n  s1 s2 -> s1 \\In s2 ->\n  step s1 s2 r ->\n  step s2 r1 r ->\n  step s1 s2 r ->\n  step s2 r ->\n  step s1 r2 r ->\n  step s2 r s2 r.\nProof.\n  intros s1 s2 r r1 r2 r2 r2 r2 r2 r3 r3 r4 r4 r4 r5 r6 r6 r6 r7 r7 r8 r8 r8 r8 r8 r9 r8 r9 r9 r9 r9 r8 r8 r9 r9 r9 r9 r9 r9 r9 r9 r9 r10 r14 r10 r11 r13 r14 r14 r13 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\napply: step_same; auto.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nhave s1 s2 r2 r r1 r2 r3 r3 r4 r4 r4 r5 r6 r6 r6 r6 r7 r6 r6 r6 r7 r8 r7 r8 r8 r8 r8 r8 r8 r8 r9 r9 r9 r9 r9 r10 r10 r13 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 ].\n(* FLE.1 *)\nDefinition r_pre (p1 p2 r2: list (ident * bool)) (s1 r2 r3: list (identQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r2 r1 r2 r2 r2 r3 r3 r4 r4 r4 r5 r5 r6 r5 r6 r6 r6 r6 r6 r6 r7 r8 r6 r7 r8 r8 r9 r9 r9 r9 r9 r9 r9 r10 r9 r9 r10 r9 r10 r10 r13 r13 r14 r14 r14 r14 r13 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 ].\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> s1 s2 r2 r2 r r3 r4 r4 r4 r4 r4 r5 r5 r6 r6 r6 r6 r7 r7 r6 r7 r7 r8 r8 r8 r8 r9 r9 r10 r10 r9 r10 r13 r14 r13 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 ].\nProof.\nmove=> r_r r_transQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "X Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2515,
                "proof_end_offset": 2608,
                "proof": "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nby rewrite -pf=>/(coh_s l).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> s1 s2; rewrite /get_last_nth in H.\nby rewrite!get_last_nth in H.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H; rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _ H); rewrite /get_local; apply: (H _Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H; rewrite eq_sym in H.\nmove=>H; rewrite eq_sym in H.\nby rewrite eq_sym in H.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>D; rewrite eq_sym.\nmove=>D1; rewrite eq_sym.\nmove=>D2; rewrite eq_sym.\nby move=>D2; rewrite eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_sym eq_symQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H; have H := (getS (getS (getS s l)) (getS (getS s l))) (getS (getS (get (S s l)) (getS (get (S s l))) (getS (get (S s l))) (getS (get (S s l)) (getS (get (S s l)) (get (S (get (S (get (S s l)))) (get (S (get s l))) (getS (get (S (get (S (S (get s l))) (get (S (get (S (get s l))) (S (get (S (get (S (get l)))) (S (get (S (get (S (get (S (get (S (get (S s (S (get s l))) (get (S (S (get (S (get (S s l))) (get (S (S (get (S (get l))) (S (get (S (get l (S (get l)) (S (get (S (get (S (S (get (S (get l))) (S (get (SQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>D s; apply: (getP s); auto.\nmove=>D s; apply: (getP s); auto.\nmove=>D s; apply: (getP s); auto.\nmove=>D s; apply: (getP s); auto.\nmove=>D s; apply: (getP s); auto.\nmove=>D s; apply: (getP s); auto.\nby apply: (getP s); auto.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>s l; apply: (getL s); rewrite (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply: (getS s); apply L.get; apply L.get; apply L.get. apply H; auto.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1; move=>H1; move=>H2; move=>H1; move=>H3; move=>H3; move=>H1 H3; move=>H3; move=>H3; move=>H3 H4 H5; move=>H3 H4; move=>H3; move=>H3 H4; move=>H3; move=>H4 H4 H4; move=>H5 H5; move=>H5 H5; move=>H6 H5; move=>H5; move/H4; move=>H5 H5; move: H5 H7 H5; move=>H5 H7 H6; move=>H5; move=>H6; move H7; move: H6 H7; move=>H7; move=>H6 H7; move=>H7; move/H7; move/H5; move=>H5; move=>H7; move/H5; move=>H5; move=>H7; move=>H7; move=>H7 H7; move/H8; move=>H7; move/H9; move=>H7; move=>Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [m [mm [m [m [m' [m m]]]]].\n  exists (m2 (m2 (m3 [m [m3 [m [m [m3 [m4 [m4 [m3 [m3 [m3 [m4 [m4 [m4 [m4]]]]]]]]]]]]]]]].\n  exists (m3 (m3 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m5 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m5 [m4 [m4 [m4]]]]]]]]]]]]]]]].\n  exists (m4 (m4 [m4 [m5 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m4 [m5 [m4 [m5 [m4 [mQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=> S1; case: s => //=; rewrite?find_step?mem_refl.\nby rewrite (mem_step _ _ (mem_step _ _ _ (mem_step _ _ (mem_step _ _ (mem_step _ _ _ (mem_step _ _ (mem_step _ _ _ (mem_step _ _ _ (mem_step _ _ _ (mem_step _ _ _ (mem_step _ _ (mem_step _ _ _ (mem_step _ _ _ (step_step _ _ _ (step _ _ _ _ (step_step _ _ _ _ (step_step _ _ _ _ _ _ (step_step _ _ _ _ (step_step _ _ _ _ _ _ (step _ _ _ _ _ (step_step _ _ _ _ _ _ (step_step _ _ _ _ (step _ _ _ _ _ _ _ (step _ (step _ _ _ _ _ _ _ (step_step _ _ _ _ _ _ _ (step _ _ _ _ _ _ _ _ (step_step _ _ _ _ (step _ _ _ _ _ (step _ _ _ _ _ _ _ (step _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "let in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2826,
                "proof_end_offset": 2945,
                "proof": "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby exists s, (f (safe_local S)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by rewrite -pf_step. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case: s. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>s1 s2 s2 s2 r2 r s3 r3 r4 r4 r4 r5 r5 r6 r6 r6 r6 r6 r7 r7 r6 r8 r6 r7 r7 r7 r8 r8 r8 r9 r9 r9 r9 r9 r9 r9 r9 r9 r9 r9 r9 r10 r9 r10 r9 r10 r10 r14 r14 r13 r13 r14 r14 r14 r14 r14 r14.\nProof.\nmove=>s2 s3; rewrite!pf_step1.\nby rewrite (IH _ _ s2); rewrite?pf_step1.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>N1 N2; rewrite /pf_step.\nby rewrite -pf_step.\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>H.\ncase: s1 s2 s2 r2 r3 r4 r4 r5 r5 r5 r6 r6 r6 r6 r6 r6 r7 r7 r7 r8 r8 r9 r9 r9 r9 r9 r9 r9 r9 r9 r9 r9 r9 r11 r13 r10 r9 r13 r9 r13 r9 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 r14 rQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by rewrite -pf_step_step_step_step. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\napply: (step_step_step_state s1 s2 r).\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case: s1 s2 r. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by move=>H1; rewrite -pf_step. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>H; rewrite (IH _ _ _ H0).\nby rewrite (IH _ _ _ _ H0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 2947,
                "proof_end_offset": 3016,
                "proof": "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by rewrite -pf_step_step. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1. Proof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by rewrite -pf_step_step_eq. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>x; apply (IH_step_refl s1); apply (IH_refl s); apply (IH_refl s1); apply (IH_refl s1); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s1); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s1); apply (IH_refl s2); apply (IH_refl s1); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2); apply (IH_refl s2Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by exists s'; split; auto. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>H; rewrite -pf_equal. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by exists s' => s' s' s' s' /\\ (match s' with | None => True end). Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by rewrite -pf_step_step_step. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by rewrite -pf_step_step_state1. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": ";\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3018,
                "proof_end_offset": 3160,
                "proof": "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nby move=>H; apply: Idle; case: H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by []. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by exists s2; split; auto. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by []. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>D; exists s1; split; auto.\n- exists s2; split; auto.\n- exists s2; split; auto.\n- exists s2; split; auto.\n  exists s2; split; auto.\n  exists s2; split; auto.\n- exists s3; split; auto.\n- exists s2; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s4; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n-Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by []. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>D; apply (step_step_step _ _ _ _ _ H).\nby apply (step_step_step _ _ _ _ H).\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; rewrite /pf_step_step; auto. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by split. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>n s1 s2 r. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\nLemma skip_step_sem s1 (S : skip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3842,
                "proof_end_offset": 3922,
                "proof": "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (IH); rewrite?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IH?IHIH?IH?IH?IH?IHIH?IH?IH?IH?IH?IH?IH?IHIH?IH?IH?IH?IH?IHIH?IH?IH?IH?IHQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=> t H; apply: (in_map s).\nmove=> t; apply: (in_map s) => i; apply: (in_map s).\nmove=> t; apply: (in_map s).\nby apply: (in_map s).\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (IH_in _ _ _ H). Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nsplit=> //= k t m IH.\nsplit=> //; rewrite?IH.\nby rewrite?IH.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (H0); rewrite?H0?H0?H0?H1?H1?H1?H2?H3?H3?H3?H3?H4?H4?H4?H4?H5?H4?H4?H6?H6?H6?H6?H6?H6?H6?H6?H6?H6?H7?H6?H6?H6?H6?H7?H7?H8?H6?H7?H7?H8?H7?H7?H8?H7?H7?H8?H7?H8?H8?H8?H8?H8?H8?H9?H8?H9 H8?H9?H10?H9?H10?H9?H9?H9?H10?H10?H9)\n||||||||||||||||||| || | | | | | | | | | | | | | | | | | |Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (findP k); apply: (Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: IHn; apply: IHn. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply/recv_in_bound. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (step_state_step _ _ _ _ _ _ H0). Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by case: H => //= H. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\nLemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by []. Qed.\n\n(* Can we make it decidable rather than classic? *)\nDefinition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=\n  exists (pf : s1 \\In Coh W),\n  (* No message to receive -- all relevant messages are marked *)\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5368,
                "proof_end_offset": 6467,
                "proof": "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)), let: d := getS s l in [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)), rt \\In (rcv_trans (getP l)), tag tms = (t_rcv rt), msg_wf rt (coh_s l C) this from tms & filter l from (t_rcv rt) (tms_cont tms)])); last first.\nmove=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\napply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\nby exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d := getS s l in let loc' := receive_step rt from tms (coh_s l C) T in let: f' := upd this loc' (dstate d) in let: s' := consume_msg (dsoup d) m in upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros.\ndestruct H as [s1 l] as [s2 s2].\ndestruct H as [s2 l2].\ndestruct H as [s2 [s2 l] s3].\ndestruct H as [s3 l3].\ndestruct H as [s3 l4].\ndestruct H as [s3 l4].\ndestruct H as [s3 l4].\ndestruct H as [s4 l4].\ndestruct H as [s4 l4].\ndestruct H as [s4 l4].\ndestruct H3 as [s4 l4].\ndestruct H4 as [s4 l4].\ndestruct H4 as [s4 l5].\ndestruct H4 as [s5 l5].\ndestruct H5 as [s5 l7].\ndestruct H5 as [s5 l6].\ndestruct H7 as [s5 l7].\ndestruct H7 as [s5 l7].\ndestruct H7 as [s6 l7].\ndestruct H7 as [s5 l6].\ndestruct H7 as [s5 l6].\ndestruct H7 as [s5 l7].\ndestruct H7 as [sQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\ninduction s'; simpl; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct a; auto.\ndestruct a, s'; auto.\ndestruct s'; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct s'; auto.\ndestruct a, s'; auto.\ndestruct s'; auto.\ndestruct a, s'; auto.\ndestruct s'; auto.\ndestruct a, s'; auto.\ndestruct s'; auto.\ndestruct a, s'; auto.\ndestruct s'; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct s'; auto.\ndestruct a, s'; auto.\ndestruct a, s'; auto.\ndestruct (s, s'); auto.\ndestruct s'; auto.\ndestruct s'; auto.\ndestruct s; auto.\ndestruct s'; auto.\ndestruct s'; auto.\ndestruct s'; auto.\ndestruct s'; auto.\ndestruct s'; auto.\ndestruct s';Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nintros s' H0.\ndestruct (is_act_step_bound s' s' H0 H0) as [H1 H2].\ndestruct (is_act_step_bound s' s' H1) as [H2].\ndestruct (is_act_step_bound s' s' H2) as [H2].\ndestruct (is_act_step s' H2) as [H3].\ndestruct (is_act_step s' s' H1) as [H2].\ndestruct (is_act_step s' s' H3) as [H4].\ndestruct (is_act_step s' s' H2) as [H4].\ndestruct (is_act_step s' s' H1) as [H4].\ndestruct (is_action s' H2) as [H4].\ndestruct (is_action s' H5) as [H4].\ndestruct (is_action s' H5) as [H4].\ndestruct (is_action s' H5) as [H4].\ndestruct (is_action s' H3) as [HQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nsplit.\n- (* no semantics *)\n  pose proof (H0 _ _ H0).\n  pose proof (H0 _ H1).\n  pose proof (H0 _ H1).\n  pose proof (H1 _ H).\n  pose proof (H1 _ H0).\n  pose proof (H0 _ H1).\n  pose proof (H1 _ H1).\n  pose proof (H0 _ H1).\n  pose proof (H0 _ _ H0).\n  pose proof (H0 _ H1).\n  pose proof (H1 _ H).\n  pose proof (H0 _ H1).\n  pose proof (H2 _ _ H0).\n  pose proof (H0 _ H0).\n  pose proof (H0 _ H1).\n  pose proof (H0 _ _ H1).\n  pose proof (H0 _ H0).\n  pose proof (H0 _ H0).\n  pose proof (H0 _ H0).\n  pose proof (H0 _ H).\n  pose proof (H0 _ H0).\n  pose proof (H0 _ _ H0).\n  pose proof (H0 _ _ H0).\n  pose proof (H0 _ _ H0).Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nsplit.\n- (* First, we can need to use the two order of [match_cont_cases] and [st_cases_bound] and [st_bound_bound_bound] *)\n  exists s', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists s'', exists sQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  apply H.\n  destruct H as [H1 H2].\n  destruct H as [H2].\n  destruct H as [H2].\n  exists (from_list_list_nil s' r).\n  rewrite (fun i => s) in H1.\n  exists (from_list_list_nil s' r' r').\n  rewrite (fun i => s) in H1.\n  exists (from_list_nil s' r').\n  rewrite (fun i => s) in H1.\n  exists (from_list_list_nil s' r').\n  rewrite (fun i => s) in H1.\n  exists (from_list_nil s').\n  rewrite (fun i => s) in H1.\n  destruct H as [H2].\n  exists (from_list_nil s').\n  rewrite (fun i => s) in H2.\n  exists (from_list_nil s' r').\n  rewrite (fun i => s) in H1.\n  exists (from_list_nil s').\n  rewrite (fun i => s) in H1.\n  exists (from_list_nil s').\n  rewrite (fun i => s)Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\npose proof (H0 _ _ _ _ H0).\npose proof (H0 _ _ _ H0).\npose proof (H0 _ H0).\npose proof (H0 _ _ _ H0).\npose proof (H1 _ _ H0).\npose proof (H0 _ _ H1).\npose proof (H0 _ _ H0).\npose proof (H0 _ _ H0).\npose proof (H0 _ H0).\npose proof (H0 _ H1).\npose proof (H0 _ H0).\npose proof (H0 _ H0).\npose proof (H0 _ H0).\npose proof (H0 _ H0).\npose proof (H0 _ H1).\npose proof (H0 _ H).\npose proof (H0 _ H0).\npose proof (H0 _ H1).\npose proof (H0 _ H0).\npose proof (H0 _ H0).\npose proof (H0 _ H0 _ H1).\npose proof (H0 _ _ H).\npose proof (H0 _ H1).\npose proof (H0 _ H1).Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\n  intros.\n  destruct H as [x [y [y [y [y [y [y [y [y [y [y [y [y [y [y [y [y [y [y [y [y [yz [y z y]]]].\n  exists (y,y,y), y,y,y,y))).\n  exists (y,y,y,y).\n  exists (y,y,y); split; auto.\n  exists (y,y,y); split; auto.\n  exists (x,y); split; auto.\n  exists (x,y); split; auto.\n  exists (y,y); split; auto.\n  exists (y,y); split; auto.\n  exists (y,y); split; auto.\n  exists (x,y); split; auto.\n  exists (y,y,y); split; auto.\n  exists (x,y); split; auto.\n  exists (y,y,y); split; auto.\n  exists (x,y); split; auto.\n  exists (x,y); split; auto.\n  exists (y,y); split; auto.\n  exists (x,xQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\napply try_recv_act_step_total; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 6469,
                "proof_end_offset": 6577,
                "proof": "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; rewrite /recv_act_step_safe.\nmove=>D; rewrite /recv_act_step_safe.\nby exists (m_step_s1 s2); exists (m_step_s2 s1 s2); exists (m_step_s2 s2); exists (m_step_s2 s2); exists (m_step_s2 s2); exists (m_step_s2 s2); exists (m_step_s2 s2); exists (m_step_s2 s2); exists (m_step_s2 s2); exists (m_step_s2 s2); exists (m_step_s2 s3); exists (m_step_s2 s3); exists (m_step_s2 s3); exists (m_step_step_s2 s3); exists (m_step_s2 s3); exists (m_step_s2 s3); exists (m_step_step_s2 s3); exists (m_step_s2 s3); exists (m_step2 s3); exists (m_step_Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; have: s' := (s' := (s' s').\nhave: s = s' /\\ s = s'.\n  have: s = s' by apply: (s' s').\n  move=>D; rewrite -recv_act_step.\n  have: s = s' by apply: (s' s'); apply: (s' (s' ++ s').\n  have: s = s'.\n    by apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s').\n  apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s').\n  apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: s'); apply: (s' ++ s'); apply: (s' ++ s'); apply: (s' ++ s');Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /recv_act_step_safe s2 s2 s2 s3 s3 s4.\nexists (t_cont_s1 s2 s3 s3).\nexists (t_cont s3 s3); split=> //; split; intros.\n- by exists s1, s2; split; constructor.\n- by exists s2; split; intros; split.\n- by exists s2; split; auto.\n- by exists s2; split; split.\n- by exists s2; split; auto.\n- exists (t_cont s2); split; intros.\n- exists s3; split; auto.\n- exists (t_cont_s2 s3); split; auto.\n- exists (t_cont_s1 s3); split; auto.\n- exists (t_cont s3); split; auto.\n- exists (t_cont s3); split; auto.\n- exists (t_cont_s2 s3); split; auto.\n- exists (t_cont_s1 s3); split; auto.\n- exists (t_cont_s3 sQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; rewrite /recv_act_step_star.\nby exists (T0, s1, s2) (Some (from_cont tms, s2) (s, s1, s2)) (Some (from_cont tms1, s2) (Some tms2, s2)).\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; exists (t_cont_step s1 s1 s2).\nby exists (t_cont_step s2 s1); split=> //; exists (t_cont_step2 s1 s2); split=> //.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /recv_act_step.\ncase: (classic (exists l, exists r, r = r /\\ r = r /\\ r = r).\nby exists r, r.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; have: s' \\In s' => d; first by rewrite?rec_safe_safe_safe; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'; exists s'. exists s'; exists s''; exists s; exists s; exists s'; exists s; exists s'. exists s'; exists s'; exists s''; exists s'. exists s'; exists s'; exists s'; exists s'; exists s''; exists s'; exists s; exists s'; exists s; exists s'; exists s; exists s'; exists s''; exists s; exists s; exists s; exists s; exists s'; exists s; exists s; exists s; exists s'; exists s'; exists s; exists s'; exists s''; exists s; exists s; exists s'; exists s; exists s; exists s'; exists s; exists s; exists s; exists s; exists s; exists s; exists s; exists s;Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /recv_act_step_step_total.\ncase: (exists l m, n = Some m -> \n  i = Some (s',s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s'') & (s', s') & (s', s') & (s', s'') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s'') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s') & (s', s')) & (s', s') & (s', s') & (s', s') & (s', s') & (sQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; rewrite /recv_act_step.\nmove=>D; exists s.\nby exists s; exists s; exists s; split=> //; exists s.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; exists s2; split=>// //.\nby exists s2; split=>//; exists s1; exists s2; split=>//; exists s2; exists s2; split=>//; exists s2; exists s2; split=>//; exists s2; exists s3.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 6579,
                "proof_end_offset": 6961,
                "proof": "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case:v_act_step. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>D; rewrite /recv_act_step.\ncase: (classic (exists r, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g,Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C D; rewrite /recv_act_step.\ncase: (classic (exists s, s = s /\\ exists m, s = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m = s /\\ m =Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D DQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case: (not_at_external_step s1 s2 s2); last first. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case:v_act_step_step. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case: v_ind. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case:v_act_step. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>D; rewrite /recv_act_step_safe.\nrewrite /recvact_step_step_safe s1 s2 s3 s4 s4.\nmove=>D; rewrite /recv_at_step_safe s1 s3 s4.\nmove=>D; rewrite /recv_step_safe s2 s3 s4.\nby exists s4; exists s4; exists s4; exists s5; exists s4; split=> //.\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /recv_act_step_safe s1 s2 s2 s3 H.\nby exists s3; exists s3; exists s4; split=>l m; exists m; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\n",
                "context_tokens": 743,
                "proof_start_offset": 8145,
                "proof_end_offset": 8221,
                "proof": "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nunfold s_function; intros.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irr.\napply proof_irrQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ninduction h; simpl; intros.\n- inv H; auto.\n- inv H; auto.\n  inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\n- inv H; auto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>D s n s l s.\ncase=>C s l s' H.\ncase=>D s1 s' s' H.\ncase=>D s' H.\ncase=>D s' H1 H2.\ncase=>D s' H1 H2.\ncase=>D s' H2.\ncase D' H1.\nby case D' H2.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ninduction l as [|r r r s IH]; intros.\nassert (IH : forall r, r = r) by (apply all_all_ok_ok; auto).\nexists r.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\napply all_all_ok; auto.\nexists r.\nsplit.\nsplit.\napply all_all_ok; auto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>s l; apply: (s_equal_trans_step _ _ _ _ _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ H); apply: (s_equal_trans _ _ _ _ H); apply: (s_equal_trans _ _ _ _ H); apply: (s_equal_trans _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ _ H); apply: (s_equal_trans _ _ _ _ _ H); apply: (s_equal_trans _ _ _ H); apply: (s_equal_trans _ _ _ _ H); apply: (s_equal_trans _ _ _ H); apply: (Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case: s => [k s1 s2]; rewrite /recv_goal; case: s1 => [k s1 s2]; rewrite /recv_goal; case: s1 => [k s2]; rewrite /recv_goal; case: s1 => [k s1 s2]; rewrite /recv_goal; case: s1 => [k s2] /=; rewrite /recv_goal; case: s2 => [k s1 s2]; rewrite /recv_goal; case: s1 s2; [k s1 s1]; rewrite /recv_goal; case: s2; [rewrite s2] //; rewrite /recv_goal; case: s1 s2]; rewrite /recv_goal; case: s2; rewrite /recv_goal; case: s2; rewrite /recv_goal; case: s1 s2; rewrite /recv_goal; case: s2; rewrite /recv_goal; rewrite /recv_goal; case: s2; rewrite /recv_goal; case: s1 s2; rewrite /recv_goal; case: s2 => //;Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ninduction l; simpl; intros.\n- (* case *)\n  + (* case *)\n    + (* case *)\n      + (* case *)\n      + (* case *)\n      + (* case *)\n      + (* case *)\n        + (* case *)\n        + (* case *)\n        + (* case *)\n        + (* case *)\n        + (* case *)\n        + (* case *)\n        + (* case *)\n          + (* case *)\n        + (* case *)\n        + (* case *)\n          (* case *)\n          + (* case *)\n          (* *)\n          + (* case *)\n          + (* case *)\n          + (* case *)\n          + (* case *)\n          + (* case *)\n          + (* case *)\n          (* case *)\n          + (* case *)\n          + (* case *)\n          + (* case *)\n          + (* case *)\n          + (* case *)\n            (* case *)\n          + (* case *)\n            (* case *)\n              (* case *)\n          + (* case *)\n            (* case *)\n          + (* case *)\n          + (* case *)\n          (* case *)\n          + (* case *)\n          + (* case *)\n            (* case *)\n            (* case *)\n            (* case *)\n            (* case *)\n          + (* case *)\n          (* case *)\n          + (* case *)\n          (* case *)\n          + (* case *)Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ninduction s; intros; simpl; auto.\napply all_ind_refl; auto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>s s1 s2 s2 s3 s4.\nmove=> s3 s4; rewrite /s3 /s3 /s4 /s4 /s4 /s4 /s5 /s6 /s6 /s6 /s6 /s6 / s6 /s6 /s6 /s6 /s6 / s6 /s6 / s6 /s6 /s6 / s6 /s6 / s6 / s6 / s6 /s6 / s6 / s6 /s6 /s6 / s6 / s6 / s6 / s6 / s6 / s6 / s6 /s6 /s6 / s6 / s6 / s6 / s6 / s6 / s6 / s6 / s6 /s6 / s6 / s6 / s6 / s6 / s6 / s6 /6 / s6 / s6 / s6 / s6 /6 / s6 /6 / s6 / s6 / s6 /6 /6 / s6 / s6 /6 / s6 /6 /6 /6 / s6 /6 / s6 /6Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>D s; rewrite /loop_safe_step_safe s.\nby rewrite /loop_step_step.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8223,
                "proof_end_offset": 8319,
                "proof": "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>s l s1 s2 s2 s2 s3; exists s2; exists s2; split; auto.\n- exists s2; split; auto.\n- exists s2; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s4; split; auto.\n- exists s3; split; auto.\n- exists s3; split; auto.\n- exists s4; split; auto.\n- exists s4; split; auto.\n- exists s4; split; auto.\n- exists s5; split; auto.\n- exists s4; split; auto.\n- exists s4; split; auto.\n- exists s3; split; auto.\n- exists s4; split; auto.\n- exists s4; split; auto.\n- exists s4; split; auto.\n- exists s3Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>C D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D DQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ninduction l; simpl; auto.\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nmove=>C; have [s [s1][s1][s2][s2][s2][s2][t1][t2][t2][t2][t3][t3][t3][t3][t3][t4][t3][t4][t4][t4][t4][t4][t4][t4][t5][t6][t5][t4][t5][t6][t6][t4][t5][t4][t5][t5][t4][t6][t5][t6][t6][t6][t4][t5][t6][t6][t5][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t6][t7][t6][t6][t6][t6][t6][t6][t7][t6][t6][t6][t6][t6][t6][tQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>C l H; case; try by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nunfold s_act_safe in *.\nunfold s_to_function in *.\napply (IHer _ _ _ _ _ H); rewrite (IHer _ _ _ H); rewrite (IHer _ _ H); rewrite (IHer _ _ _ H); rewrite (IHer _ _ H); rewrite (IHer _ _ H); rewrite (IHer _ H); rewrite (IHer _ _ H); rewrite (IHer _ H); rewrite (IHer _ _ _ H); rewrite (IHer _ H); rewrite (IHer _ _ _ _ H); rewrite (IHer _ H); rewrite (IHer _ H); rewrite (IHer _ _ _ H); rewrite (IHer _ H); rewrite (IHer _ H); rewrite (IHer _ H); rewrite (IHer _ _ H); rewrite (IHer _ H); rewrite (IHer _ H); rewrite (IHer _ _ H); rewrite (IHer _ _ H); rewrite (IHer _ _ H); rewrite (IHer _ _ _ H); rewrite (IHer _ _ _ H); rewrite (IHer _ H); rewrite (IHer _ _ _ _ H); rewrite (IHer _ H); rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\nLemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.\n\nDefinition send_act_step s1 (S: send_act_safe s1) s2 r :=\n   r = msg /\\\n   exists b,\n     Some b = send_step (safe_safe S) /\\\n     let: d :=  getS s1 l in\n     let: f' := upd this b (dstate d) in\n     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)\n                                         this to true)).1 in\n     s2 = upd l (DStatelet f' s') s1.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 8680,
                "proof_end_offset": 9239,
                "proof": "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nrewrite /send_act_step/send_act_safe.\ncase: S=>C S J K.\nmove/(s_safe_def): (S)=>[b][S']E.\nset s2 := let: d := getS s l in let: f' := upd this b (dstate d) in let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in upd l (DStatelet f' s') s.\nexists s2, msg; split=>//; exists b; split=>//.\nmove: (safe_safe (And4 C S J K))=> S''.\nby rewrite -E (pf_irr S'' S') .\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=> s1 s2 s2 s2 s3.\napply: (star_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof. by case: s => //= s'. Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof. by case. Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\napply: (step_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star_star.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof. by case=> //= a s' s' s' Hs. Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>s1 s2 s2 s3 s3 s4 s4.\ncase: (s1 ++ s2); first by exists s3; rewrite?s4; case: s3.\ncase: (s2 ++ s3); first by exists s3; rewrite?s4.\ncase: (s2 ++ s3); first by exists s4; rewrite?s5.\nby exists s4; rewrite?s5 //?s5?s5?s5?s5?s5?s5?s6?s6?s6?s6?s6?s6?s6?s6?s6?s6?s6?s6?s6?s6?s6?s6?s7?s7?s9?s9?s9?s9?s9?s10?s9?s9?s10?s9?s10?s10?s9?s10?s10?s9?s11?s12?s12?s10?s12?s12?s14?s13?s14?s14?s13?s15Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ninduction s; simpl; auto.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof. by case. Qed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>H; have:= (step_ind_inf s s' s); rewrite?IH.\ncase: s s' => //=; rewrite?IH.\nby case: s s' => //= ->.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>n H0; case: (s1 s1); case: (s2 s2); case: (s1 s2); case: (s1 s2); case: (s2 s2); case: (s2 s2); case: (s2 s3); case: (s2 s3); case: (s3 s4); case: (s3 s3); case: (s3 s3); case: (s4 s3); case: (s5 s3 s4); case: s4; case (s4 s5); case: (s4 s5); case: (s5 s5); case: (s5 s4); case (s5 s5; case (s5 s6); case: (s5 s4); case: (s5 s5); case: (s5; case (s6 s5); case: s4; case (s5 s5); case: (s5 s5); case: (s5 s5); case: (s6 s5); case (s5; case; case s6); case; case (s5 s5); case: (s5Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\n",
                "context_tokens": 479,
                "proof_start_offset": 1831,
                "proof_end_offset": 1898,
                "proof": "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> m n; apply: (iffP idP) => [m' | n'].\napply: (iffP idP) => [m' | n'].\nby apply: (iffP idP) => [m' | n'].\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d; have:= dub_coh d d_coh d_coh d_coh d d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh d_coh dQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by move=> d; apply/andP=> z. Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d; rewrite /all_perm_in_join d.\nhave: (dfree m d) by rewrite /all_perm_in_join d.\nhave: (dfree m d) by rewrite /all_perm_in_join d.\nhave: (dfree m d) by rewrite /all_perm_in_join d.\nhave: (dfree m d) by rewrite /all_perm d.\nhave: (dfree m d) by rewrite /all_perm d.\nhave dfree m d_free m d d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d_free m d.\n- move=> d_free m d_free m d_free m d_free m d_free m d.\n  move=> d_free m d_free_free m d_free m d_free m d_free m d_free m d_free m d_free m d.\n  move=>Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d h; rewrite /all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_allQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nhave{r} /all_in_data_at_at_at_at_at_external /=!un_data_at_at_external /=!un_data_at_at_external /=!un_data_at_at_external /=!un_data_at_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external_at_external /=!un_data_at_external /=!un_data_at_external.\nmove=> // [q | q] /all_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_at_external /=!un_data_atQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\ncase: (d_state d).\n  by case: (d_state d_R d).\n  by case: (d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R d_R dQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d d d d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d'' d' d' d' d' d' d'' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d' d'' d' d'' d' d'' d' d'' d' d' d' d' d' d' d' d' d' d'' d' d'' d' d'' d' d'' d'' d'' d'' d'' d' d''' d' d''' d''' d''' d' d''' d' d'' d'''' d''Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d; rewrite /all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> d d f; case: h => h f h; case: h => h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case: h; case h; case h; case: h; case: h; case h; case: h; case: h; case: h; case h; case: h; case: h; case h; case: h; case: h; case h; case h; case: h; case: h; case h;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\n",
                "context_tokens": 505,
                "proof_start_offset": 1900,
                "proof_end_offset": 1972,
                "proof": "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nby case; case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d;Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: d=> d d; rewrite /m_empty_in_join d. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: d1 d2 d3 d3 d3 d4 d4 d5 d6 d5 d6 d6 d7 d6 d6 d7 d6 d7 d7 d7 d8 d9 d9 d9 d10 d10 d10 d10 d10 d10 d10 d10 d10 d12 d10 d12 d13 d14 d14 d14 d15 d16 d19 d14 d15 d14 d15 d17 d16 d18 d19 d19 d19 d20 d17 d19 d20 d20 d20 d16 d17 d19 d19 d20 d19 d19 d20 d19 d19 d19 d20 d19 d20 d19 d20 d19 d19 d19 d20 d19 d20 d20 d20 d2019 d20 d20 d20 d20 d20 d20 d20 d2019 d19 d20 d20 d20 d20 d20 d20 d20 d20 d19 d20 d20 d20 d20 d2019 d20\nwith d19 d20 : Prop :=\n  let:t'0 < n' : Prop := d' in\n  let:nat := d'Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\napply/andP; rewrite /all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_all_Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case: d => //= d2. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\n",
                "context_tokens": 535,
                "proof_start_offset": 1974,
                "proof_end_offset": 2050,
                "proof": "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=> d; case: d=> d; case: d=> d; case: d=> d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d dQed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d; case: d=> // H1. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=> // d. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=> d d0 d0 d0 d1 d2 d2 d3 d3 d3 d4 d4 d5 d5 d6 d5 d6 d6 d5 d6 d6 d6 d6 d7 d6 d7 d7 d8 d8 d10 d11 d13 d12 d13 d14 d14 d13 d14 d14 d14 d14 d14 d14 d14 d14 d15 d14 d14 d14 d14 d15 d15 d15 d15 d16 d17 d16 d16 d16 d17 d16 d17 d18 d17\n          d2020 d20 d19 d19 d19\n          d19 d20 d20 d20 d20 d19 d20\n          d20 d20 d20 d20 d20 d20 d20 d20 d20 k0 k0 k0 k1 k1 k2.\nProof. by case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case; case; case: d; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=> d d d. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: (dle_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_ge_Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: h1=>H1 H2 H3; case: h1 H3. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: l2 => //; case: l3; case: l3 => _; case: l4; case: l4 => //; case: l4 => //; case: l5; case: l4; case: l5 => //; case: l5 => //; case: l5; case: l5 => // _; case: l5 => //; case: l5 => //; case: l5; case: l5 => // ->; case: l5; case: l5 => _; case: l5 => ->; case: l5; case: l5 => //. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "om fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\n",
                "context_tokens": 686,
                "proof_start_offset": 2529,
                "proof_end_offset": 2640,
                "proof": "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nby move=> H; case: C => _ _ _/(_ n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: (size d). Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: (nth_error (fun d => d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d dQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: d => //= d; case: d => // d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case; case: d; case: d; case; case: d;Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n => // n /andP[]. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: (size d); case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; caseQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: d => //= d' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h' h h' h' h' h' h' h' h h' h' h' h h' h' h h' h' h' h' h' h' h' h h' h' h h' h h' h' h' h h' h' h h' h' h' h h' h h' h h' h' h h' h' h' h h' h' h' h' h' h' h' h' h' h' h h' h h' h h' h' h' h' h h' h' h' h' h' h' h' h h h' h h' h' h h' h h' h' h' h' h' h h' h' h' h' h' h' h' h' h h' h' h' h' h h' h' h' h' h h h' h' h' hQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: (ltnP d d). Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: d => d; case: d=> d; case: d=> d; case: d; case: d; case: d=> d d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case:Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case: d; case d; case: d; case: d; case: d; case: d; case: d; case: d; case: d; case: d;Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: f. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 2642,
                "proof_end_offset": 2815,
                "proof": "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ _ _ _ _ _. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C=> _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case: C => _ _ _ _. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C D => _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> m d; case: C=> _ _ _ _ _ _. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3043,
                "proof_end_offset": 3233,
                "proof": "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (n.+1); rewrite findPtUn // sizePtUn. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: (lcoh (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m := m) (m :=Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> m n m n. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (perm_of d) => //. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (rcoh H)=>m; rewrite findPtUn in Hm. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\ncase: m => m n.\n  by case: m => m n.\n  by move=> H; case: m => m n.\n  by move=> m n.\ncase: m => m n.\n  by move=> n; case: m n => m.\n  by move=> m n; case: m => m n; move/IH=> m n; move: m => m n; move/IH; move/IH=> m n; move/IH; move/IH=> m n.\n  by move: m n; move=> m n=> m; move/IH=> m n; move/IH; move/IH m n m; move/IH; move/IH; move/IH=> m n; move/IH; move/IH=> m n m; move/IH; move/IH; move/IH=> m n.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: (i \\in size d) => m n m. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: (l_le_n _ _ H) => H; move: H; rewrite findPtUn in H; case H; case. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> m; rewrite memPtUn. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (rle_trans H); rewrite findPtUn. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": ".\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3250,
                "proof_end_offset": 3355,
                "proof": "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nLemma in_in_in_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list.\nProof.\nmove=> i j m m' H0 H0; move: H1; case: (lle_dec i j) => /H1; move: H2; move: H1; move: (H1,H2); move/H2; move: (H2,H2); move/H2; move/H2; move/H1; move/H2.\nby move: (H2,H1); move/H2; move/H1; move/H2; move/H3; move/H3; move/H3=> _; move/H3; move/H3.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=> H; case: (valid_block _ _ _ _ _ H)=>H; rewrite E.\nby move: (valid_block _ _ _ _ _ _ H)=>H.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>D; rewrite /perm-> // /perm-> // /perm-> /perm-> /perm-> // /perm-> /perm-> // /perm-> // /perm-> //.\nby move=> H1; rewrite!perm_unit?mem_cat.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=> H; rewrite /getN; move=>H n' H; rewrite /size_chunk_list. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\n\nLemma is_in_split : forall n d, m <= n -> exists m, n \\in (m < n)%nat.\nProof.\nmove=> n m; elim=> //= m; elim: m => [|m]; first by move/IHm=> m n; move: m; move/IHm=> m n; rewrite?IHn.\nby move=> m n m; rewrite!IHn?IHn //?IHn.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; rewrite /size_map_forall_forall_eq_bigr => i _; rewrite /size_map_forall_eq_bigr => i _; rewrite /size_map_forall_eq_bigr => i _; apply: eq_bigr => i _; rewrite -size_map_forall_eq_bigr => i _; apply: eq_bigr => i _; rewrite -size_map_forall_neq0.\nby move=> i ->; rewrite /size_map_forall_big_eq0_bigr => i _; apply: eq_bigr => i _; apply: eq_bigr => i _; apply: eq_bigr => i _; rewrite -size_map_forall_big_seq_seq_eq0_bigr => i _; apply: eq_bigr => i _; apply: eq_bigr => i _; apply: eq_bigr => i _; apply: eq_bigr => i _; rewrite -size_map_forall_eq0.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof.\nby move=> H; case: (eq_refl (perm_eq_refl _)) => // H; rewrite E in H; apply: eq_refl.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof.\nmove=> H; case: (valid_block_dec m d).\n  by move: (valid_block_dec m d).\nby move: (valid_block_dec m d).\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\nProof. by move=> H; case: (perm_size d); case: (perm_size d); case: (perm_size d); case: (perm_size d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d); case: (perm_size d d d); case: (perm_size d d d); case: (perm d); case: (perm_size d d d); case: (perm_size d d); case: (perm d d); case: (perm_size d d d); case: (perm d d); case: (perm_size d d d); case:Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes. *)\n\nLemma is_in_join_trans :\n  forall d, is_in_join d d -> is_in_join d d -> is_in_in_join d d.\nProof.\nmove=>H; rewrite /size_map.\ncase: (perm_in_join d d d) => [|m]; first by rewrite E.\nby move: (perm_in_join d d d) => ->; rewrite E.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\nLemma this_in_pf this to d msg :\n  greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by case. Qed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3357,
                "proof_end_offset": 3445,
                "proof": "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> m n m n. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> m n m; apply/andP=> m /andP[m HH]] /andP[m HH] /andP[m HH] /andP[m HH] /andP[m HH] -> HH -> ->\n  move=> m HH /andP[m HH] /andP[m HH] -> HH -> HH.\nmove=> m /andP[m HH] /andP[m HH] /andP[m HH] -> HH -> -> HH.\nby move=> m HH /andP[m HH] /andP[m HH] -> HH -> HH -> HH.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> m n; case: m => // m n IHn; case: m => m n m m n; case: m => //= m n m n; case: m => //= m n m n m n m n; case: m => //= m n m; case: m => //= m n m n m n; case: m => //= m n m; case: m n m m; case: m n m => // m n; case: m; case: m => // m n m; case: m n m => // m n m n m n; case: m n => // m n m n m n m; case: m n m; case: m => // m n m; case: m; case: m n m n; case: m n m => //= m n m; case: m n m => //= m n m n; case: m n m n; case: m => // m; case: m => // m n; case: m => // m n m m; case: m n m; case: m n m n m n m; case: m; case: m n m => // m n m n m; case:Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; rewrite /leq_trans=>H; rewrite /leq_trans. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: (n,n,n). Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> m n; case/andP=> m n /andP[->]; move/andP=> m n /andP[/andP[m1 /andP[m2 [m2 [m3 [m4 [m4 [m4 [m5 [m4 [m4 [m5 [m5 [m4 [m4 [m4 [m5 [m4 [m4 [m4 [m5 [m4 [m5 [m4 [m4 [m44 [m4 [m5 [m5 [m5 [m5 [m5 [m5 [m5 [m7 [m5 [m6 [m5 [m6 [m4m5 [m5 [m5 [m7 [m5 [m6 [m6 [m6 [m7 [m6 [m7 [m7 [m7 [m8 [m7 [m9 [m7 [m7 [m7 [m7 [m8 [m8 [m9 [m7 [m8 [m7 [m7 [m9 [m9 [m7 [m7 [m9 [m7 [m8 [m8 [m9Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=> H; case: H => /(_ n)=> _; rewrite EH. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; rewrite /size_list_trace_aux. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case. Qed."
                ]
            }
        ],
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H' H' H'0 H'0; elim H'0; clear H'0 H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\napply H'0; clear H'0; intros.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\ngeneralize (le_lt_gt_cases (S n) (S m)).\nintros.\ngeneralize (le_gt_cases (S m) (S m)).\nintros.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.\ngeneralize (le_gt_cases (S m) (S m)).\nintro.Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y H.\ngeneralize (H y H).\ngeneralize (H y H0).\ngeneralize (H y H).\nintro H0.\ngeneralize (H y H).\nintro H0.\ngeneralize (H y H0);intro H0.\ngeneralize (H y H1).\nintro H0.\ngeneralize (H y H0).\nintro H1.\ngeneralize (H y H1); intro H0.\ngeneralize (H y H0).\nintro H0.\ngeneralize (H y H0).\nintro H1.\ngeneralize (H y H1).\nintro H0.\ngeneralize (H y H0);intro H1.\nclear H0.\nintro H1.\ngeneralize (H y H1).\nintro H0.\ngeneralize (H y H0).\nintro H1.\ngeneralize (H y H0).\nintro H1.\ngeneralize (H y H0).\nintro H0.\ngeneralize (H y H0).\nintro H1.\ngeneralize (H y H0).\nintro H1.\ngeneralize (H y H1).\nintro H1.\ngeneralize (H y H0).\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H.\nelim H; intros.\napply H; auto with *.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y H; elim H; clear H; intros.\nsplit; intros; auto with *.\napply H; auto with *.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply (Build_group S); auto with arith.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H1 H2 H3.\nelim (H3 (S y) (S y) (S y) (S y) (S y)) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y)Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H' H' H'0; elim H'0; clear H'0.\nintros y z H' H'0; elim H'0; clear H'0.\nintros z' z' H'0 H'0; elim H'0; clear H'0.\nintros z' z' H'0; elim H'0; clear H'0; clear H'0.\nintros z' z' H'0 H'0; elim H'0; clear H'0.\nintros z'0 z' H'1 H'1; elim H'0; clear H'0.\nintros z'0 z' H'0; elim H'0; clear H'0.\nintros z' z' H'0; elim H'0; clear H'0.\nintros z' H'0 H'1; elim H'0; clear H'0.\nintros z' H'0 H'0 H'1; elim H'1; clear H'0.\nintros z'0 H'1 H'0; elim H'1; clear H'0.\nintros z'0 z'0 H'Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H.\nelim H; intros x y z H' H'0; elim H'0; intros x z H'0 H'0 H'1; elim H'0; intros y z H'0 H'0 H'1 H'1 H'2; elim H'0; intros x y z H'0 H'1 H'1; elim H'0; intros y z H'0 H'1 H'1; elim H'1; intros y z H'0 H'0 H'1 H'0 H'0 H'1; elim H'0; intros y z H'0 H'1 H'0 H'0 H'1 H'1; elim H'1; intros z0 H'0 H'1; elim H'0; intros x z H'0 H'0 H'0; elim H'1; intros z H'1 H'0 H'1; elim H'1; intros z' H'2; elim H'0; intros z H'1 H'0 H'1; elim H'0; intros z H'0 H'2;\n    elim H'0; intros z HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\napply (H7 x1 y1); intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\napply (H7 x); trivial.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros; elim H3; intros; elim H4; intros; elim H5; intros; elim H4; intros.\nelim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nelim H; intros; elim H6; intros; elim H6; intros.\nexists x; split; auto.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\ngeneralize (H2 y1); intro H4; elim H5; intros; elim H5; intros.\nclear H5 H5; elim H5; intros.\ngeneralize (H7 x1); intro H5; elim H5; intros.\ngeneralize (H7 x1); intro H5; elim H6; intros.\ngeneralize (H7 y1); intro H5; elim H6; intros.\nexists (Add x1 y2) (Add x1 y2)); intros.\nrewrite H5; elim H6; intros.\ngeneralize (H8 y1); intro H7; elim H7; intros.\ngeneralize (H8 y1); intro H5; elim H7; intros.\ngeneralize (H8 y1); intro H5; elim H7; intros.\ngeneralize (H7 y1); intro H5; elim H5; intros.\ngeneralize (H8 y1); intro H5; elim H6; intros.\ngeneralize (H8 y1); intro H5; elim H5; intros.\ngeneralize (H8 y1); intro H5; elim H6; intros.\ngeneralize (HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nsimple induction 1; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n clear H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H8Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nelim H; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nelim H2; intros; elim H4; intros.\nelim H4; intros; elim H5; intros.\nelim H3; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros.\nelim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nunfold Add in |- *.\napply (H1 x2); auto.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nelim H3; intros; elim H5; intros; elim H5; intros; elim H5; intros.\nsplit; intros; elim H5; intros.\nexists x0; split; intros; elim H5; intros.\nexists x0; split; intros; elim H5; intros; elim H5; intros.\nexists x0; split; intros; elim H5; intros.\nexists x0; split; intros.\nexists x1; split; intros; split; intros.\nexists x1; split; intros.\nexists x1; split; intros.\nexists x1; split; intros.\nexists x0; split; intros.\nexists x2; split; intros.\nexists x0; split; intros.\nexists x1; split; intros.\nexists x0; split; intros; split; intros.\nexists x1; split; intros.\nexists x2; split; intros.\nexists x1; split; intros.\nexists x1; split; intros.\nexists x0; split; intros.\nexists x1; split; intros.\nexists x1; split; intros.\nexists x0; split; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros comLE x1 y2.\nrewrite (ass (Add x1 y2) y1) in H0.\nrewrite (ass (Add x1 y2) y1); elim (ass (Add x1 y2) y1); auto with sets.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros com Hz; elim Hz; intros.\ngeneralize (conj_prop _ _ _ H0); intros; elim Hz.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros comLE x1 y2 y2 y3.\nrewrite (assoc (Add x1 y2) y1).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x2 y1) y1); rewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2) y2).\nrewrite (ass (Add x1 y2) y2).\nrewrite (ass (Add x1 y2) y2).Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros comimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimimQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros; elim (H1 x2); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H6; intros; elimQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros comI x1 y2 y2.\nrewrite (ass (Add x1 y2) y2); auto with arith.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros comIN x y1 y2 y2.\nrewrite (assoc (Add x1 y2) x2); elim (AddAdd y1 y2) (Add y1 x2) y2); auto with real.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (comm (Add x1 y1) (Add y2) (Add x2 y1) (Add x2 y2) (Add x2 y1) (Add x2 y1) (Add y2) (Add y1 y2) (Add x2 y2) (Add y1 y2) (Add y1 y2) (Add y2) (Add y1 y2) (Add y2) (Add x2 y2) (Add y1 y2) (Add y2) (Add y1 x2) (Add y2) (Add y2 y1) (Add y1 y2) (Add y1) (Add y1 x2) (Add y2) (Add y1) (Add y2 y2) (Add y1) (Add y2) (Add y1 y2) (Add y2) (Add y1 y2) (Add y1) (Add y2) (Add y1) y2) (Add y2) (Add y1) (Add y2) (Add y1) (Add y2) (Add y1) (Add y2)Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\napply (add_comm _ H); intro; elim H; intros; elim H; clear H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H;\n clear H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; clear H; intros; elim H; intros; elim H; intros; elim H; clear H; intros; elim H;\n intros; elim H; clear H; intros; elim H; intros; elim H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim (H0 y); intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H7; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H7; introsQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim (H0 x); intros; elim H0; intros; elim H; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H6; intros; elim H8; clear H7; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; clear H8; intros; elim H8;\n intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H9;\n intros; elim H7; intros; elim H7; clear H8Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y; elim H; intros; elim H; intros.\nunfold opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group,Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply opp_opp.\nassumption.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H8; intros; elim H9; clear H8 H7.\n(* [y] *)\nelim H9; intros; elim H8; clear H7; intros; elim H8; intros; elim H8; clear H8; intros; elim H8; clear H8; intros; elim H8; clear H8; intros; elim H8;\n intros; elim H8; clear H8 H8; intros; elim H8; clear H8 H8; intros; elim H8; clear H8; intros; elim H8; clear H8; intros; elim H8;\n clear H8; intros; elim H8; clear H8; intros; elim H8; clear H8; intros.\n(* [x] *)\nelim H9; intros; elim H8; clear H8; intros; elim H8; clear H8; intros; elim H8; clear H8; intros; elim H8; clear H8; intros; elim H8; clear H8; intros; elim H8; clear H8;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y; elim H; intros; elim H0; intros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H7; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H6; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7;\n intros; elim H8; clear H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; clear H7; intros; elim H7;\n intros; elim H7; intros; elim H7; clear H8; intros; elim H7;\n intros; elim H8; intros; elim H8; clear H8; intros; elim H7; intros; elim H8; clear H7;\n intros; elim H7; intros; elim H8; clear H8; intros; elim H8; clear H7; intros; elim H7; intros;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group,Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x y H0; elim H1; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H7;\n clear H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H6; clear H7; intros; elim H6; intros; elim H7;\n clear H6; intros; elim H7; intros; elim H7Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_prop _ (Opp x) x); intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; clear H8; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H8; intros; elim H8; clear H8; intros; elim H8; intros; elim H8; clear H8; intros; elim H8;\n intros; elim H8; intros; elim H8; clear H8; intros; elim H9;\n intros; elim H8; clear H9; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H8; clear H8; intros; elim H8;\n intros; elim H8; intros; elim H8; clear H8; intros; elim H8; intros; elim H8;\n intros; elim H8; clear H8; intros; elim H8;\n intros; elim H8; clear H8; intros; elim H8; intros; elim H9; clearQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_invQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H7; intros; elim H5; intros; elim H5; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H6; intros; elim H8; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; clear H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H7; clear H8; intros; elim H8; intros; elim H9;\n intros; elim H8; intros; elim H8; clear H8; intros; elim H8; intros; elim H8; intros; elim H8Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7;\n clear H6; intros; elim H7; intros; elim H6; intros; elim H7;\n clear H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\ncase (H1 (conj H2) (conj H1) (conj H2)) (conj H2) (conj H2)) (conj H2)) (conj H3) (conj H3)) (conj H2)) (conj H2)) (conj H3)) (conj H2) (conj H3) (conj H2)) (conj H3) (conj H2) (conj H3) (conj H3) H3) (conj H3) (conj H2)) (conj H4) (conj H2) (conj H2)) (conj H3) (conj H2)) (conj H3) (conj H3) (conj H3) (conj H3) H2)) (conj H4) (conj H2) (conj H3) (conj H3)) (conj H2)) (conj H3) (conj H3) (conj H3 H3) (conj H3) (conj H3) (conj H3) (conj H4) (conj H3) H3) (conj H4) (conj H3) (conj H4 H4) (conj H2) (conjQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H).\nelim H; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; clear H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; clear H7; intros; elim H8; clear H8;\n intros; elim H8;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napply (opp_injective H).\napplyQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_involutive (Fopp x) x y); auto with *.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group, opp_group,Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H8; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7; intros; elim H7; clearQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; generalize (opp_involutive (opp_comm (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (-Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_prop H).\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_zero_ext H).\nrewrite H; rewrite H0; rewrite H2; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H1; rewrite H0; rewrite H0; rewrite H0; rewrite H1; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0; rewrite H0;Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; clear H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6; clear H6; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7;\n intros; elim H7; clear H7; intros; elim H7; intros; elim H8; intros; elim H7; clear H7; intros; elim H7;\n clear H7; intros; elim H7; intros; elim H8; intros; elim H8; clear H7;\n intros; elim H7; introsQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H6; intros.\nrewrite H5; rewrite H6; rewrite H7; rewrite H5; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H8; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H8; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H8; rewrite H7; rewrite H7; rewrite H7; rewrite H8; rewrite H7; rewrite H7; rewrite H8; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewriteQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nunfold Opp in |- *; split.\nelim (H0 x); intros; elim H; intros; apply H0; elim H0; intros; clear H1; intros.\nrewrite H3; rewrite H3; apply H0.\n\nelim (H1 y); intros; elim H0; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7;\n intros; elim H7; clear H7; intros; elim H7;\n intros; elim HQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_unicity H (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add x) (Add (Add x) x (Add (Add x) x (Add (Add x) x) (Add (Add x) x (Add (Add x) (Add x) (Add x) (Add x) (Add (Add x) x (Add) x (Add) (Add x) (Add x) (Add (Add x) x (Add) (Add x) (Add (Add x) x (Add (Add x) (Add x) (Add (Add x) (Add x) (Add x) (Add (Add x) (Add x) (Add x) (Add (Add x) (Add (Add x) (Add x) (Add (Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim H; intros; elim H; intros; elim H4; intros; elim H4; intros.\nrewrite H4; rewrite H5; rewrite H5; rewrite H6; rewrite H5; rewrite H6; rewrite H5; rewrite H5; rewrite H5; rewrite H5; rewrite H5; rewrite H5; rewrite H6; rewrite H5; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H7; rewrite H6; rewrite H6; rewrite H7; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H6; rewrite H7; rewrite H7; rewrite <- H7; rewrite H7; rewrite H6; rewrite H7; rewrite H7; rewrite H7; rewrite H7; rewrite <- H7; rewrite H7; rewrite H7; rewrite H7; rewrite H6; rewrite H8; rewrite H7; rewrite H7; rewriteQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nrewrite (opp_comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (commQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_cancel_l_reverse (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (commQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition pi2_1_2 : forall (A : Set) (R : A -> Type), {x : A | P x} -> forall (x : A) (R : A -> Prop), {x : A | P x} -> P x.\nDefinition pi2_3_3_4_4 : forall (A : Set) (R : A -> Type), {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x :Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition pi2 : forall (A B : Set) (R : A -> Prop) (R : A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> A -> Prop) (R : A -> A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> R) (R : A -> A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> A -> Prop) (R : A -> A -> A -> Prop) (R : A -> A -> A -> Prop) (R : A -> A -> Prop) (R : A -> A -> R A -> R) (R : A -> A -> R) (R : A -> A -> A -> R) (R : A -> A -> A -> Prop) (R : A -> A -> A -> R) (R : A -> A ->Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nLemma pi2 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> forall y : A, R x y -> R y x y}.\nProof.\n  intros; split; intros;\n    [apply (H x); auto with arith | assumption ].\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\n(** * Facts about [prod] *)\n\nDefinition pi2 (A : Set) (P : A -> A -> Prop) :=\n  forall x y : A, R x y -> R x y -> R x y.\n\nDefinition pi2 (A : Set) (P : A -> A -> Prop) (x y : A) :=\n  forall x : A, R x y -> R x y.\n\n(** * Facts about [prod] *)\n\nDefinition pi2 (A : Set) (P : A -> Prop) (P : A -> Prop) :=\n  forall x : A, R x y -> R x -> R x.\n\n(** * Facts about [prod] *)\n\nDefinition pi2 (A : Set) (P : A -> Prop) (P : A -> Prop) :=\n  forall x y : A, R x y -> R x y.\n\n(** [prod] *)\n\nDefinition pi2 (A : Set) (P : A -> Prop) (P : A -> Prop) :=\n  forall x y : A, R x y -> R y -> R x y.\n\n(** * [prod] *)\nDefinition pi2 (A : SetDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 (A : Set) (P : A -> Prop) (P : A -> Prop), {x : A | P x} -> forall x y : A, R x y x -> R x y}.\n\nLemma pi2 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x}.\nProof.\nintros A x y; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; apply pi2; applyDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (P : A -> Prop) (x : A) (P : A -> Prop) : Prop :=\n  forall (P : A -> Prop), {x : A | P x} -> forall (P : A -> Prop), {x : A | P x} -> forall (P : A -> Prop), {x : A | P x} -> {x : A | P x} -> forall (P : A -> Prop), {x : A | P x} -> {x : A | P x} -> forall (P : A -> Prop), {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {x : A | P x} -> {Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 (A : Set) (R : A -> Prop) :=\n  forall x y : A, R x y -> R x y }.\n\nLemma pi2 : forall (A : Set) (P : A -> Prop),\n  forall x y : A, R x y -> R x y -> R x y.\nProof.\n  intros; unfold pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2, pi2 in pi2, pi2, pi2 pi2, pi2, pi2 pi2 pi2, pi2, pi2 pi2, pi2 pi2 pi3, pi2, pi2 pi2 pi3, pi2 pi2, pi2, pi2 pi2, pi2 pi2 pi3, pi3 pi1 pi2 pi3 -> pi2 pi3 pi3 pi3 pi3 pi3 pi3 pi pi3 pi3 pi3 pi3 pi3 pi3 pi3 pi3Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nLemma pi2 : forall (A B : Set) (P : A -> Prop) (P : A -> Prop),\n  forall x y : A, R x y -> R x y -> R x y.\nProof.\n  intros A x y H0 H1 H2.\n  induction H1.\n  simpl; auto with arith.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nLemma pi2 : forall (A B : Set) (P : A -> Prop),\n  forall x y : A, R x y -> R x y }.\n\nLemma pi2 : forall (A B : Set) (P : A -> Prop),\n  forall x y : A, R x y -> R x y.\nProof.\n  intros A B C x y H; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0. unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0; unfold pi2 in H0Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nDefinition pi1 (A B : Set) :=\n  forall x y : A, R x y -> R x y x :=\n  forall y : A, R x y -> R x y.\nDefinition pi1 (A : Set) (P : A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition pi2 (A B : Set) (P : A -> Prop) (P : A -> Prop) :=\n  forall x y : A, R x y -> R x y -> R x y.\n\nDefinition pi3 (A B : Set) :=\n  forall x y : A, R x y -> R x y -> R x y.\nDefinition pi2 (A B : Set) (P : A -> Prop) (P : A -> Prop) :=\n  forall x y : A, R x y -> R x y.\n\nDefinition pi2 (A B : Set) (P : A -> Prop) :=\n  forall x y : A, R x y -> R x y -> R y.\n\nDefinition pi3 (A B : Set) :=\n  forall x y : A, R x y -> R y x.\n\nDefinitionDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; intros; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\n\n\nLemma inv_com : forall (S : Set) (P : A -> Prop),\n  inv_equiv_equiv_equiv_equiv_equiv_equiv_equiv_equiv_equiv_equiv_equiv.\nProof.\nsimple induction 1; simpl; auto.\n constructor; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nintros; elim H; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *.\nintros.\napply le_trans with (S x); auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *.\nintros H0; elim H; intros H0; elim H0; intros H1; elim H1; intros H2; elim H1; intros H2; elim H2; intros H3; elim H3; intros H4; elim H5; intros H4; elim H5; intros H5; elim H6; intros H5; elim H5; intros H6; elim H6; intros H5; elim H6; intros H7; elim H5; intros H6; elim H6; intros H7; elim H7; intros; elim H6; intros H7; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros;Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nintros; apply inv_com; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\n\n\nLemma inv_com : forall (S : Set) (P : A -> Prop) (P : A -> Prop),\n  inv_equiv_equiv_equiv_equiv_equiv_equiv_equiv_equiv.\nProof.\nsimple induction 1; intros.\nelim (lt_dec (S x) (S x) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (S y) (SQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x H; unfold IdZ in |- *.\napply exp_plus_distr_r with (Z := Z).\napply Z_to_group_plus.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x; case x; trivial; try discriminate.\napply Zlt_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_ge.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_refl.\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_lt_weak.\napply Zle_le_weak.\napply Zle_trans with (1 := H).\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_trans with (2 := H).\napply Zle_le_weak.\napply Zle_le_weak.\napply Zle_refl.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0); trivial.\nintros x; case (Z_eq_dec x 0);Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold IdZ in |- *.\nintros.\napply False_ind; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold IdZ.\nauto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\napply Z_group_inverse.\napply Z_group_inverse.\napply Z_group_inverse.\napply Z_group_inverse.\napply Z_group_inverse.\napply Z_group_inverse.\napply Z_inverse.\napply Z_group_inverse.\napply Z_inverse.\napply Z_group_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverse.\napply Z_inverseQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x y Hx.\napply Z_group_inverse.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros.\napply Z_group_eq_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg with Z.\napply Z_group_le_reg_r with Z.\napply Z_group_le_reg_r with Z.\napply Z_group_le_reg_r with Z.\napply Z_Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_simplify.\napply Z_group_simplify.\napply Z_simplify.\napply Z_group_simplify.\napply Z_simplify.\napply Z_group_simplify.\napply Z_simplify.\napply Z_group_simplify.\napply Z_simplify.\napply Z_group_simplify.\napply Z_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_group_simplify.\napply Z_simplify_simplify.\napply Z_group_simplify.\napply Z_group_simplifyQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintros x.\napply Zle_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nintros x H.\napply Z_mult_reg_l with (Z := (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (- (-Qed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nintros.\ncut (x = x :>Z) by ring.\nauto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nintros x; elim (Z_mult_distr_l (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z, (Z)))))))))\n (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (Z.sgn (a, (a, (Z.sgn (sgn (a, (a, (a, (a, (a, (a, (a, (a, (c))), (a, (a, (a, (a, (a, d)), (a, (a, (b, (c, (a, (c, (a, (c, (c, (c))),Qed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nintros x; rewrite <- Z_Z_mult_distr_r_r_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r_l.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r_r.\nrewrite Z_mult_distr_r_reverse.\nrewrite Z_mult_distr_r_r.\nrewrite Z_multQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nintros z0; elim z0; auto with zarith.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0 z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elim z0; auto.\nintros z0; elimQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nintros.\napply Z_to_group.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napply is_ring_simplify.\napplyQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nintros.\napply Z_to_group; auto with zarith.\napply Zle_trans with (Z := 0%Z); auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit; auto with zarith.\nsimpl in |- *.\nunfold IdZ in |- *.\nsimpl in |- *.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_r.\napply inj_Z_mult_distr_r.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_r.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_r.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_l.\napply inj_Z_mult_distr_r.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; intros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto with zarith.\nintros; elim H; auto.\nintros; elim H; auto with zarith.Qed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\napply Z_unit_mult_left with Z; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\nsplit.\nexact Z_unit_commutative_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\napply Zlt_gt_le.\napply Zle_ge_trans with (Zabs (Z * Z)) (Zabs (Z * Z))) (Zabs (Z * (Z * Z))) (Zabs (Z * Z)) (Zabs (Z * Z))) (Zabs (Z * Z))) (Zabs (Z * Z)) * Zabs (Z * Zabs (Z * Z))) * Zabs (Z * Zabs (Z * Zabs (Z * Z))) * Zabs (Z * Zabs (Z * Zabs (Z * Z))) (Zabs (Z * Zabs (Z * Zabs (Z * Zabs (Z * Z)))%Z).\nProof.\nintros.\napply Zabs_eq.\nrewrite Zabs_eq.\nunfold Zabs_eq.\nrewrite Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.\napply Zabs_eq.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring_mult in |- *.\nsplit.\nred in |- *; auto with zarith.\napply Z_unit_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring_unit in |- *.\nsplit.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.\napply Zabs_mult.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nsimpl in |- *; auto with zarith.\nintros.\napply Z_unit_commutative_ring_unit_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans with (2 := Z2).\napply Zle_trans withQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring_mult in |- *.\nintros.\napply Z_unit_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nintros.\napply Z_unit_field.\napply sym_equal.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring_mult in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_ring_simplify.\nrewrite <- (Z_unitZ_unit_Z) in |- *.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nintros.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_ring_simplify in |- *; auto with zarith.\nsimpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_ring_simplify, IdZ Zplus_comm.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_r.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l_reverse.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite Zopp_mult_distr_l.\nrewrite Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l.\nrewrite <- Zopp_mult_distr_l_l.\nrewrite <- ZoppQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nintros.\ngeneralize (Z_unit_Z_unit_Z).\nintros.\ngeneralize (Z_unit_Z (unit_Z)).\nintros.\ngeneralize (Z_unit_Z (unit_Z (unit_Z (unit_Z (unit_Z (unit_Z (unit_Z))) (unit_Z (unit_Z)))).\nintros.\ngeneralize (Z_unit_Z (unit_Z (unit_Z (unit_Z (unit_Z (unit_Z)))).\nintros.\nrewrite Z_unit_Z_unit_Z.\nintros.\ngeneralize (Z_unit_Z (unit_Z (unit_Z (unit_Z (unit_Z (unit_Z))) (unit_Z (unit_Z (unit_Z (unit_Z))) (unit_Z (unit_Z (unit_Z (unit_Z (unit_Z))).\nintros.\ngeneralize (Z_unit_Z (unit_Z (unit_Z (unit_Z (unit_Z (unit_Z (unit_Z))) (unit_Z (unit_Z)))).\nintros.\ngeneralize (Z_unit_Z (unit_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nintros.\nunfold inj_Z in |- *; trivial.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nintros.\napply Z_unit_group_ring.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_unit, Zminus in |- *.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nintros; case (Z_eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq (Z.eq (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq_dec (Z.eq (Z.eq_dec (Z.eq_dec (ZQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_ring_simplify.\napply refl_equal.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_ring_simplify.\nsplit.\nred in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; right; trivial.\nrewrite <- H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right; trivial.\nrewrite <- H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; left; trivial.\n(* neg n = 0 *)\nintros; left; trivial.\n(* neg n = 0 *)\nintros; left; trivial.\n(* neg n = 0 *)\nintros; left; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\n(* neg n = 0 *)\nintros; right; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold is_ring_simplify.\nintros; left; reflexivity.\n(* pos n=0 *)\nintros; left; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; left; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.\n(* pos n=0 *)\nintros; right; reflexivity.Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; right; reflexivity.\n(* pos n = 0 *)\nintros; left; assumption.\n(* pos n = 0 *)\nintros; right; assumption.\nrewrite <- (plus_comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (comm (Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; left; trivial.\napply addibleZ.\napply addibleZ_ring.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; right.\nunfold inj, opp, opp_opp in |- *.\nsplit.\nred in |- *; auto with zarith.\nintros; left.\ngeneralize (H x); clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; right.\napply injible with (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inj_Z in |- *.\nsplit.\napply Z_is_opp_eq.\nred in |- *.\nintros; elim b.\nintros; right; right; assumption.\n(* neg n *)\nintros; right; assumption.\n(* neg n *)\nintros; right; assumption.\nintros; right; assumption.\n(* neg n *)\nintros; right; assumption.\n(* neg n *)\nintros; right; assumption.\nintros; right; assumption.\n(* neg n *)\nintros; right; assumption.\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; left; assumption.\n(* neg n = 0 *)\nintros; left; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n =Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold intExp at 1 in |- *.\nintros a b; elim b; intros; inversion H; trivial.\n(* neg n *)\nintros; right; assumption.\n(* neg n *)\nintros; right; assumption.\n(* neg n = 1 *)\nintros; right; assumption.\n(* neg n = 1 *)\nintros; right; assumption.\n(* neg n = 1 *)\nintros; left; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 1 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; left; assumption.\n(* pos n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; left; assumption.\n(* neg n = 1 *)\nintros; right; assumption.\n(* neg n = 1 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintrosQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inj, inj,ible.\nintros; right; trivial.\n(* neg n *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(* neg n = 0 *)\nintros; right; assumption.\n(*Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros; left; trivial.\nQed."
                ]
            }
        ],
        "zfc": [
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\n",
                "context_tokens": 334,
                "proof_start_offset": 1596,
                "proof_end_offset": 1761,
                "proof": "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof x; intro E; elim E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E; clear E;\n clear E; clear E; clear E; clear E; clear E; clear E; clear E;\n clear E; clear E; clear E; clear E;\n clear E; clear E; clear E; clear E;\n clear E; clear E; clear E; clear E;\n clear E; clear E; clear E;\n clear E; clear E; clear E; clear E;\n clear E; clear E;\n clear E; clear E; clear E;\n clear E; clear E; clear E;\n clear E; clear E; clear E;\n clear E; clear E; clear E; clear E;\n clear E; clear E;\n clear E; clear E; clear E E; clear E;\n clear E; clear E; clear E; clear E;\n clear E; clear E; clear E;\n clearQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intros H; elim H; clear H;\n intros H; elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H;\n intros H; elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H;\n intros H; elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H;\n intros H; elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H;\n intros; elim H; clear H; intros H; elim H; clear H; intros H; elim H; clear H;\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E; exists (fun f : F => match f with\n                                             | Some x => match f with\n                                  | Some x => match f with\n                                  | Some x => match f with\n                                    | Some x => match f with\n                                    | Some x => Some x\n                                    end\n                                    | Some x => match f with\n                                    | None => None\n                                    end\n                                  | None => match f with\n                                    | Some x => Some x\n                                      end\n                                    | Some x => Some x\n                                    end\n                                  end\n                                    | Some x => Some x\n                                    | Some x' => Some x\n                                    end\n                                    end\n                                    | None => Some x\n                                    | Some x => None\n                                    end\n                                    | Some x' => Some x\n                                    end\n                                    | None => None\n                                    end\n                                    | Some x' => Some x\n                                    end\n                                  | None => Some x\n                                    end\n                                    | Some x' => Some x\n                                    end\n                                    | Some x' => Some x\n                                    | Some x' => Some x\n                                    end\n                                    | None => Some x\n                                    end\n                                    end\n                                    | None => Some x\n                                    end\n                                    | Some x => None\n                                  end\n                                  end\n                                    | None => Some x\n                                    end\n                                    | Some x' => Some x\n                                    end\n                                    | Some x' => Some x'\n                                    | Some x' => Some xQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintro H.\napply H.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H;\n intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H;\n elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H;\n intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H; elim H; intros f H;\n elim H; intros f H; elim H; introsQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  split; [ assumption | idtac ].\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nintros E; unfold not in |- *; intros E F; elim F; clear F; clear F; clear F; intro F; intro F; clear F; intro F; intro F; clear F; clear F; intro F; intro F; clear F; intro F; clear F; intro F; elim F; clear F; intro F; clear F; intro F; clear F; intro F; clear F; intro F;\n  elim F; clear F; intro F; clear F; intro F; clear F; intro F;\n  elim F; clear F; intro F; clear F; intro F; clear F; intro F; clear F;\n  elim F; clear F; intro F; clear F; intro F; clear F; intro F; clear F; intro F;\n  elim F; clear F; intro F; clear F; intro F;\n  elim F; clear F; intro F; clear F; intro F;\n  elim F; clear F; intro F; clear F; intro F; clear F;\n  elim F; clear F; intro F; clear F; intro F;\n  elim F; clear F; intro F; clear F; intro F; clear F; introQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E H; elim H; clear H; clear H; intro H; intro H; elim H; clear H; intro H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; introQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof In E H.\nintro H; elim H; clear H; clear H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intros H; elim H; clear H; intro H;\n       elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H; intro H; elim H; clear H;\n       intros H; elim H;Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  simple induction 1; intros; [ | [ | [ | [ | [ | [ | [ | [ [ | [ | [ | [ | [ | [ | ] ] ] ] ] ] ] ] ] ] ] ] ].\n\n(* In the set of the set, but not used in the set, in set, but in the set, but the set. *)\n\nTheorem not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1764,
                "proof_end_offset": 2028,
                "proof": "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros E' H'0.\nelim H'0; intros H'0; elim x; intros x; elim x.\nelim H'0; intros x; elim x; intros y; elim x; intros; elim x; intros; elim x; intros; elim x; intros; elim x; intros; elim y; intros; elim x; intros; elim x; intros; elim x; intros; elim H;\n intros x; elim H'; intros; elim H'; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elimQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; cut False.\nintros E H; cut False.\napply not_rel_vide_vide.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E; cut False.\nsimple induction 1.\nelim H; intros x y; elim H; intros H; elim H; intros H; elim H; intros; elim H; intros H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E; cut (exists x : Ens, IN E' (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens => IN E (fun x : Ens =>Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E' H; elim x.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E' H'; cut False.\nauto with algebra.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; absurd (exists x : Ens, IN E' E').\nauto with algebra.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *.\nintros E H; elim H; intros x; elim H; intros; elim H; intros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros;Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold Vide in |- *; simpl in |- *; intros E' H'0; cut False.\nintro.\nelim H; intros x; elim H; intros x; elim H; intros x; elim H; intros.\nelim H; intros x; elim H; intros x; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elimQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nintros E E' H; generalize (H x); clear H; intros E H; elim H; clear H; intros E H; elim H; clear H; intros E; elim E; clear H; intros E H; elim H; clear H; intros E H; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim E; clear H;\n intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim E; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim E; clear H;\n intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; intros E; elim H; clear H; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2042,
                "proof_end_offset": 2158,
                "proof": "Definition Paire : forall E E' : Ens, Ens.\nProof.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; intros A H; cut (exists x : Ens, x = y).\nunfold Vide in |- *; simpl in |- *; intros A H; cut (exists x : Ens, x = y) by (exists y : Ens, x = y) by (exists y : Ens, x = y) by (exists x : Ens, y = y /\\ y = y) by (exists y : Ens, x = y /\\ y = y) by (exists x : Ens, y = y) by (exists y : Ens, y = y) by (exists y : Ens, x = y) by (exists y : Ens, y = y) by (exists y : Ens, x = y) by (exists y : Ens, x = y) by (exists y : Ens, x = y) by (exists y : Ens, y = y) by (exists y : Ens, x = y) by (exists y : Ens, x = y) by (exists y : Ens, y = y) by (exists y : Ens, x = y) by (exists y : Ens, y = y) by (exists y : Ens, x = y)Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; intros A x H; elim H.\n\nintros x y; elim H; intros x0; elim H; intros x0; elim H; intros x0; elim H; intros x1; elim H; intros H; elim H; intros; elim H;\n intros x0; elim H; intros x0; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elimDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; intros A H.\nelim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H ( H)))))))))))))))))))) \n   (cartesien (cartesien (couple (couple (couple ( (couple ( (S (S (S (S (S ()))); (H (H (H (H (H (H (H (H (H (H (H ()))) (H (H (H (H (H (H (H ( H)))) ()));\n auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E' H; cut (exists x : Ens, IN E' E -> IN E' E').\nintros E' H; cut (exists x : Ens, IN E' H).\nunfold not in |- *; simpl in |- *.\nintros E' H; cut (exists x : Ens, IN E' H);\n [ intro H' | elim H; clear H' ].\nelim H'0.\nintros x H'0; cut (exists x : Ens, IN E' H);\n [ intro H'0; elim H'0; clear H'0 ].\nexists x; auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintro E' : Ens, (forall x : Ens, IN E' E -> F) -> EQ E' H'.\n\nDefinition not (x : Ens) := exists y : Ens, IN (fun x : Ens => x = y) /\\ x = y.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\n\nDefinition not (x : Ens) := x.\nDefinition not (x : Ens) := xDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold not in |- *; simpl in |- *; intros A' H; generalize (H1 (H1 (H2 (H3 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H5 (H5 (H5 (H6 (H5 (H5 (H6 (H7 (H7 (H7 (H8 (H9 (H8 (H9 (H8 (H10 (H9 (H9 (H9 (H10 (H10 (H9 (H9 (H8 (H9 (H10 (H10 (H10 (H10 (H10 (H10 (H9 (H10 (H10 (H10 ( H9 (H10 (H9 (H11 (H10 (H10 ( H10 (H10 (H10 (H9 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 ( H10 (H10Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; intros A' H; elim H; intros x; elim H; clear H; intros x; elim H; clear H; intros x; elim H; clear H; intros x; elim H; clear H; intros x; elim H; clear H; intros x H; elim H; clear H; intros; elim H; clear H; intros x; elim H; clear H; intros x; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintro E; elim E; auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; intros A' H; generalize (H0 (H0 (H0 (H1 (H1 (H0 (H1 (H1 (H2 (H2 (H3 (H0 (H3 (H3 (H3 (H3 (H3 (H4 (H5 (H4 (H3 (H4 (H5 (H6 (H4 (H7 (H7 (H4 (H7 (H7 (H8 (H10 (H8 (H10 (H10 (H8 (H9 (H10 (H10 (H10 (H9 (H10 (H9 (H10 (H10 (H10 (H11 (H10 (H10 (H10 (H10 (H10 (H11 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H11 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H11 ( H11 (H11 (H10 (H10 (H11 (H10 (H10 (H11Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E' H' H'0 H'0.\nunfold not in |- *; intros A; generalize (H'0); intro H'; elim H'0; intros H'0; elim H'0; intros H'0; elim H'0; intros H'1; elim H'1; intros H'2; elim H'2; intros H'3; elim H'2; intros H'3; elim H'3;\n intros H'2 H'2; elim H'3; intros H'3 H'4; elim H'4; intros H'3 H'4; elim H'3;\n intros H'4 H'4 H'5; elim H'6; intros H'5; elim H'6; intros H'5; elim H'6;\n intros H'5; elim H'7; intros H'5; elim H'7; intros H'7; elim H'6;\n intros H'6 H'7; elim H'7; intros H'5; elim H'7; intros H'7; elim H'7; intros H'7 H'8; elim H'7;\n intros H'8Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\n",
                "context_tokens": 537,
                "proof_start_offset": 2204,
                "proof_end_offset": 2521,
                "proof": "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold EQ in |- *; simpl in |- *; intros A' H'; elim H; auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold not in |- *; simpl in |- *; intros A' B' H' H'0; elim H'0; intros H'0 H'0; elim H'0; intros H'1; elim H'1; intros H'2; elim H'2; intros H'1; elim H'2; intros H'2 H'3; elim H'3; intros H'4; elim H'3; intros H'3 H'4; elim H'4; intros H'4 H'5; elim H'3; intros H'5 H'5; elim H'6; intros H'7; elim H'4; intros H'5 H'6; elim H'7; intros H'6 H'7; elim H'6; intros H'7 H'7 H'8; elim H'7; intros H'9 H'8 H'8; elim H'9; intros H'9 H'8 H'8; elim H'9; intros H'9 H'8; elim H'8; intros H'9 H'9; elim H'9; intros H'8 H'8; elim H'10; intros HQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (Build_Predicate (fun f : Ens => f)).\nauto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Vide in |- *; simpl in |- *; intros A' B H0 H1; elim H1; clear H1 H2; elim H2; clear H1; intros x0; elim H1; clear H2; intros x0; elim H1; clear H1; intros x0; elim H1; clear H1; intros x0; elim H2; clear H2; intros x0; elim H2; clear H1; intros x1; elim H3; clear H2; intros x0; elim H2; clear H3; intros x0; elim H1; clear H1; intros x0; elim H3; clear H3; intros x1; elim H3; clear H3; intros x1; elim H3; clear H4; intros x0; elim H3; clear H3; intros; elim H4; clear H4; intros x1; elim H3; clear H4; intros x0; elim H4; clear H4; intros x2; elim H4; clear H4; intros x4; elim H4; clear H4; intros; elim H4; clear H4; intros x4; elim H4Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ EQ EQ,Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold EQ in |- *; simpl in |- *; intros A' B' H'; elim A.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (axs_comprehension\n    (fun x : X : Ens => In x X /\\ In X X x) (lem_sig x)\n    (lem_sig (lem_sig (lem_sig (lem_sig_sig (lem_sig_sig (lem_sig_sig_sig (lem_sig_sig_sig (lem_sig_sig_sig_sig (lem_sig_sig_sig_sig (lem_sig_sig_sig_sig H)))\n    (lem_sig_sig_sig (lem_sig_sig_sig (lem_sig_sig_sig_sig_sig H))).\nintros.\napply H.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Vide in |- *; simpl in |- *; intros A' B' H'0; generalize (H'0 (e x));\n auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold EQ in |- *; simpl in |- *; intros A' H; cut False.\nintros H'; elim H'; intros x0 H'0.\nexists x; auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold In, In, In, H.\nintros.\nelim H; clear H.\nintros.\nelim (H (H0 (H1 (H2 (H2 (H3 (H3 (H4 (H4 (H4 (H4 (H4 (H5 (H5 (H6 (H7 (H7 (H4 (H4 (H5 (H6 (H8 (H8 (H8 (H8 (H8 (H8 (H8 (H9 (H8 (H8 (H8 (H8 (H8 (H9 (H10 (H8 (H8 (H8 (H9 (H9 (H8 (H8 (H8 (H8 (H9 (H8 (H9 (H9 (H10 (H10 (H9 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H9 (H9 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H11 (H10 (H10 (H10 (H10 (H11 (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "er version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 603,
                "proof_start_offset": 2523,
                "proof_end_offset": 2823,
                "proof": "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Subset, inter in |- *.\nintros.\nelim (axs_comprehension\n    (fun x : E => exists y : E, In y E /\\ y = couple y y)\n    (parties (couple y (couple y (couple y (couple y (couple y (couple y (couple y y (couple y (couple y y))))\n    (cartesien (couple x y (couple (couple y (couple y (couple y y (couple y z))))\n    (cartesien (couple x (couple y (couple y (couple y z))))\n    (cartesien (couple x (couple y (couple y (couple y y (couple y z)))\n    (cartesien (couple x y (couple y (couple y (couple y z))))\n    (cartesien (couple x y (couple y (couple x y)))\n    (cartesien (couple y (couple y (couple y (couple y z))))\n    (cartesien (couple y (couple y z))) (couple y (couple y z)))\n    (cartesien (couple y (couple y z (couple (couple x y z)))\n    (cartesien (couple y z (couple x z)))) (couple x (couple (couple y z)))\n    (cartesien (couple x (couple y z (couple xQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold couple in |- *.\nintros.\ngeneralize (lem_cartesian_propertie a a b); intros.\nelim H; intros.\nsplit; auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold EQ, In in |- *.\nintros.\nsplit; [ auto with zfc | auto with zfc ].\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold equiv; simpl in |- *.\nintros; split.\napply (lem_cartesian_propertie a b); auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros.\nelim (lem_vide_propertie a (couple a (couple a (couple a (couple a (couple a (couple a (couple a (couple a (couple a b)))) (couple a (couple a (couple a (couple a (couple a a b)));\n auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Vide in |- *; simpl in |- *.\nintros; elim H; intros x H; elim x; clear x; intros x H; elim x; clear x; intros H; elim x; clear x; intros.\nexists x; exists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; unfold Vide in |- *; simpl in |- *; intros A B' H' H'0; elim H; clear H'; intros x0 H'0;\n elim H'0; clear H'0; intros x0 H' H'0; elim H'0; clear H'0; intros x0 H'0;\n elim H'0; clear H'0; intros x0 H'1 H'1;\n elim H'0; clear H'0; intros x0 H'0 H'1 H'2 H'2; elim H'1; clear H'0; intros x0 H'1 H'2;\n elim H'1; clear H'0; intros x0 H'1 H'0; elim H'1; clear H'0; intros H'1;\n elim H'0; clear H'1; intros x0 H'1 H'1; elim H'0; clear H'1; intros H'2 H'2 H'3;\n clear H'0; intros x0 H'2 H'1; elim H'1; clear H'0; intros x0 H'2Qed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold couple in |- *.\nintros.\napply (lem_inc_prop a).\napply (lem_inc_prop a).\nauto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold inter in |- *; simpl in |- *.\nintros; elim H; intros x0 H1.\nexists false; auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Eq in |- *.\nintros; elim (H0 (H (H (H0 (H2 (H4 (H4 (H4 (H4 (H4 (H4 (H5 (H6 (H5 (H4 (H5 (H5 (H6 (H6 (H7 (H5 (H7 (H7 (H8 (H7 (H8 (H8 (H10 (H9 (H9 (H8 (H9 (H10 (H8 (H10 (H10 (H10 (H9 (H9 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H9 (H10 (H10 (H10 (H10 (H10 (H10 (H9 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H11 (H10 ( H10 (H12 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 2910,
                "proof_end_offset": 3057,
                "proof": "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold inc in |- *.\nsimpl in |- *.\nintros; elim H; intros x0; elim x0; intros.\nexists false; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold In in |- *; simpl in |- *.\nintros; elim (H0 (lem_sig_fun f : F => ~ In (couple x x) a).\nunfold In in |- *; simpl in |- *.\nintros; elim (H0 (lem_sig_fun f : F => ~ In (couple x a)) a).\nunfold In in |- *; simpl in |- *.\nintros; elim (H0 (lem_sig_fun f : F => ~ In (couple x a) a)).\nunfold In in |- *; simpl in |- *.\nintros.\nelim (H0 (lem_sig_fun f : F => ~ In (couple x a)) a).\nunfold In in |- *.\nsimpl in |- *.\nintros; elim (H0 (lem_sig_fun f : F => ~ In (couple x a) a).\nunfold In in |- *.\nintros; elim (H0 (lem_sig_fun f : F => ~ In (couple x a)) a).\nunfold In in |- *; simpl in |- *.\nintros.\nelim (H1 (lem_sig_fun f : F => ~ In (couple x a) a).\nunfold In in |-Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold In in |- *; simpl in |- *; intros; split.\nsimple induction x.\nauto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nintros; elim (H0 (H1 (H2 (H2 (H2 (H2 (H3 (H4 (H4 (H5 (H5 (H4 (H5 (H4 (H5 (H4 (H5 (H4 (H6 (H5 (H6 (H6 (H6 (H7 (H7 (H8 (H7 (H8 (H8 (H8 (H10 (H10 (H8 (H10 (H9 (H10 (H9 (H10 (H9 (H10 (H10 (H10 (H9 (H10 (H10 (H10 (H10 (H9 (H10 (H10 (H10 (H10 (H11 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10 (H10Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold inter in |- *.\nintros.\nelim (axs_comprehension\n    (fun x : E =>\n      match x with\n      | x : E =>\n        match x with\n          | x : E, x = y\n        | E, x =>\n          match x with\n          | E, x =>\n          | E, x =>\n          match x with\n          | E, x =>\n          end\n          | E, x, x =>\n          match x with\n          | E, x =>\n          | E, x =>\n          end\n      end.\n\nTheorem not_inter_line :\n forall E E' : Ens, IN E E' A -> IN E' E'.\nunfold not in |- *; simpl in |- *; intros E H; generalize E'.\nunfold not in |- *; simpl in |- *; intros E'; elim E'.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold equiv in |- *.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nunfold equiv in |- *.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nunfold equiv in |- *.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nunfold equiv in |- *.\nintros.\nunfold equiv in H.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nintros.\nunfold equiv in H.\nunfold equiv in |- *.\nintros.\nunfold equiv in |- *.\nunfold equiv in H.\nintros.\nelim (axs_comprehension\n    (fun x : E =>\n     exists x : E, (exists y : E, In y E) (couple x x) (couple x x y))\n    (cartesien (couple x y) (couple x y))\n    (cartesien (couple x y) (couple y z)) (couple x y))\n    (cartesien (couple x y) (couple x y)))\n    (cartesien (Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold In in |- *.\nintros.\napply H.\nunfold In in |- *.\nintros.\nunfold In in |- *.\nunfold In in |- *.\nintro.\nunfold In in |- *.\nintro.\nelim (axs_comprehension\n    (fun x : E =>\n     exists x : E, In x E /\\ In x E /\\ In x E /\\ In x E /\\ In x E))\n    (cartesien a a) (couple x y))\n    (cartesien a (couple x y))\n    (cartesien a (couple x y)) (couple x y))\n    (cartesien a (couple x y)) (couple x y))\n    (cartesien a (couple x y)) (couple y) (couple y y))\n    (cartesien a (couple x y) (couple y) (couple y z) (couple y z))\n    (cartesien a (couple x y) (couple y z)) (couple y z))\n    (cartesien a (couple x y)) (couple y z) (couple y z))\n    (cartesien a (couple x y) (couple y z)))\n    (cartesien a (couple y z)) (couple x z)) (couple x y))\n    (cartesien a (couple x y) (coupleQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold inc in |- *.\nintros.\nunfold not in |- *.\nintros.\nsplit.\napply (H x); auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold union in |- *.\nintros; split.\napply (Equal_is_fun x y); auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold inter in |- *.\nintros.\nsplit; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "                 *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 3059,
                "proof_end_offset": 3209,
                "proof": "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Ex'.\nunfold inc in |- *.\nunfold inc in |- *.\nintros; elim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H ( H))))))))))\n              (fun x y => (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Same_in in |- *.\nunfold Same_in in |- *; simpl in |- *; intros A' H.\nelim H; intros x; elim x; clear x.\nintros y H'; elim H; clear x.\nexists y; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold inter in |- *; simpl in |- *; intros; split.\nauto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold In in |- *; simpl in |- *; intros A' H; elim A.\nintros; elim A; clear A'.\nexists true; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold inc in |- *.\nsimpl in |- *; intros A; elim A; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold In in |- *; simpl in |- *.\nintros; split.\nauto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Opp in |- *; simpl in |- *.\nintros; split.\nintros; split.\nunfold not in |- *; split; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Incident in |- *.\nunfold inc in |- *; simpl in |- *; intros.\nsplit.\nauto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold diff, ~ In in |- *; simpl in |- *; intros A' H; elim A; clear A.\nintros.\nexists y; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Opp in |- *; simpl in |- *; intros A; split.\nauto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 3211,
                "proof_end_offset": 3401,
                "proof": "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Same_a, In in |- *; simpl in |- *; intros A E H;\n elim H; intros x y; elim H; intros x y; elim H; intros y H; elim H; intros; elim H; clear H; intros x; elim H; intros; elim H; clear H; intros x y; elim H; clear H; intros x y H; elim H;\n intros x y H; elim H; clear H; intros; elim H; clear H; intros x y H; elim H;\n intros; elim H; clear H; intros; elim H; clear H; intros x y H; elim H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold In in |- *; simpl in |- *; intros E' H'0; elim H; clear H'; intro H'; elim H; clear H'; intro H';\n [ intro H'0; elim H'0; clear H'0 | clear H'0 | clear H'0 | clear H'0 | clear H' | clear H'0 | clear H' | clear H'0 | clear H'0 | clear H'0 | clear H'0 | clear H' | clear H' | clear H'0 | clear H'0 | clear H' | clear H'0 | clear H' | clear H' | clear H' | clear H'0 | clear H'0 | clear H' | clear H' | clear H'0 | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' | clear H' ];\nunfold In in |- *; simpl in |- *; intros E' H'0; elim H'0; clear H';\n intros H'0; elim H'0; clear HQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold EQ in |- *; simpl in |- *; intros E H'; elim H'; clear H'; intros.\nexists false; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold In, In in |- *; simpl in |- *; intros E' H'; elim H; clear H'; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold In in |- *; simpl in |- *; intros; split.\nauto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Opp in |- *; simpl in |- *; intros; split.\nintros; elim H; intros x; elim H; intros; elim H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim HQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold In in |- *; simpl in |- *; intros; split.\nsimple induction x.\nauto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold equiv in |- *; simpl in |- *; intros A E E H.\nunfold equiv in |- *; simpl in |- *; intros A e H0 H; elim H; intros x0 H1 H2; elim H0; intros H1; elim H1; intros H2; elim H3; intros H4; elim H5; intros H5; elim H5; intros H6; elim H5; intros H5; elim H6; intros H6; elim H7; intros H6; elim H6; intros H6; elim H6; intros H6; elim H7; intros; elim H7; clear H7; intros H7; elim H7;\n intros H7; elim H7; intros H8; elim H7; intros; elim H7; clear H8; intros H8; elim H7; intros; elim H7; clear H8;\n intros H7; elim H8; intros H7; elim H8; clear H7; intros; elim H7; intros; elim H7; clear H7; intros; elim H7; intros; elim H7; clear H7;\n intros H8; elim H7; clear H8Qed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold EQ in |- *.\nunfold In in |- *; simpl in |- *; intros; split; intros; elim H; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold EQ in |- *; simpl in |- *; intros A; elim H; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3620,
                "proof_end_offset": 3709,
                "proof": "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold In in |- *; simpl in |- *; intros A.\nelim (classic (exists x : Ens, X x /\\ X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, x = x) \\/ (exists x : Ens, x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, x = x) \\/ (exists x : Ens, X x = x) \\/ (exists x : Ens, x = x) \\/ (exists x : Ens, x = x) \\/ (exists xQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold not in |- *; simpl in |- *; intros A; elim a.\nintros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold union in |- *.\nunfold union in |- *.\nintros.\napply (classic (exists x : Ens, y : Ens, y : Ens, y : Ens, y : Ens, x : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, x : Ens, y : Ens, y : Ens, y : Ens, x : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, x : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : Ens, y : EnsQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold In in |- *; simpl in |- *; intros E; elim a; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *;\n intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *;\n intros b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b;\n simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *;\n intros b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *;\n intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b;\n simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b;\n intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b;Qed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold In in |- *; simpl in |- *.\nintros; elim b; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold sub; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold In in |- *; simpl in |- *; intros x; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *;\n auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold In in |- *.\nintros; split; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold In in |- *; simpl in |- *.\nintros; elim b; simpl in |- *.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold In in |- *; simpl in |- *; intros A.\nred in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ")   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3711,
                "proof_end_offset": 3859,
                "proof": "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *.\nunfold Disj in |- *; simpl in |- *.\nintros; split.\nintros.\napply H.\napply H.\napply H.\nassumption.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; simpl in |- *.\nintros E' E' H'0; elim H'; intros x0; elim H'; intros x0; elim H'; intros x1; elim H'; intros x1; elim H'2; intros x2; elim H'2; intros x1; elim H'2; intros x2; elim H'2; intros x3; elim H'4; intros x2; elim H'5; intros x3; elim H'6; intros x7; elim H'6; intros x7; elim H'8; intros; elim H'7; intros x7; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8;\n intros x8; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8;\n intros; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold cart in |- *.\nunfold union in |- *; intros; split.\nauto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj, Disj, Disj, Disj, Disj, Disj, Disj, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp opp, opp oppQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold union in |- *; simpl in |- *; intros E'; elim E'.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sep in |- *; simpl in |- *; intros A x H; elim b; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold covering in |- *.\nunfold covering in |- *; simpl in |- *; intros; elim b; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Canc in |- *; simpl in |- *; intros E' H; elim H; simpl in |- *; intros A H; elim H; simpl in |- *; intros A; elim H; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Disj in |- *; simpl in |- *; intros A; elim A; simpl in |- *; intros a H; elim A; simpl in |- *; intros a H; elim A; simpl in |- *; intros a H0; elim A; simpl in |- *; intros a0 H0; elim A; simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3902,
                "proof_end_offset": 4058,
                "proof": "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A'); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; simpl in |- *; intros A B; elim (gg_IN E' E'); auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; unfold Disj in |- *; simpl in |- *.\nintros a a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b; simpl in |- *; intros a b; elim b;\n auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj,,, \"A, \"A\", \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A) \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A) \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\"Qed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; simpl in |- *.\nintros A' H; elim (H x); auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; simpl in |- *; intros A a H; elim a; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold cart in |- *.\nintros A' A' B.\nunfold cart in |- *; simpl in |- *.\nintros A' B' H' H'0; elim (lem_cartesian_propertie a a a' b' b'); auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; simpl in |- *; intros A' H; elim (bsim_Singleton E' E');\n auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; simpl in |- *.\nintros A' A' H; elim (classic (exists x : Ens, x = y /\\ x = y).\nunfold Disj in |- *; simpl in |- *.\nintros A' H; elim (classic (exists x : Ens, x = y /\\ y = y).\nexists y; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Disj in |- *; simpl in |- *; intros A' H; elim (A' x); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4091,
                "proof_end_offset": 4278,
                "proof": "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros; apply EQ_inclus with ( funsig2 := fun x : Ens => exists x : Ens, In (couple x x) /\\ EQ (couple x x) /\\ EQ (couple x x)) /\\ EQ (couple x x x)).\nunfold Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj,, Disj,, Disj,, Disj,,, Disj,,, Disj,,, Disj,, Disj,,,, Disj,, Boston, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MAQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros; apply EQ_sym with (bf2 := x); auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *.\nunfold Disj in |- *; intros A' H; elim (EM A' x); auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; simpl in |- *.\nunfold Disj_lift in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Disj, Boston, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA,Qed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; intros; apply EQ_inclus with (cfg := fun x : Ens => In x (couple x (couple x (couple x (couple x (couple x (couple x (couple x (couple x (couple x (couple x (couple x (couple x))) (couple x (couple x (couple x (couple x y (couple x (couple x x))) (couple x (couple x (couple x y))) (couple x (couple x (couple x (couple x (couple x y)))) (couple x (couple x (couple x y))) (couple x (couple x (couple x (couple x (couple x y))) (couple x (couple x (couple x x (couple x y))))));\n auto with zfc.\n\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Disj in |- *; simpl in |- *.\nintros; split.\nauto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold cart in |- *; intros; apply EQ_symm with (rRel := fun x : Ens => x = y);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Canc in |- *; simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\n",
                "context_tokens": 754,
                "proof_start_offset": 4542,
                "proof_end_offset": 4719,
                "proof": "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* We define a set of a set of the set containing a set of set set of set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set set setDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\nDefinition Comp (A B : Type) (P : A -> Prop) :=\n  forall x : A, P x -> P x.\n\n(* Proof of a proof of a non-point-point, which is useful than the\n    set of set of [P] and [P] and [P] is the following\n    set of [P] and [P] is [P] is [P] is [P]\n    [P -> P] [P -> P] is a [P] is a [P]\n    [P -> P] is a [P -> P] is a [P]\n    [P -> P] is a\n    [P -> P] is a [P] is a\n    [P -> P] is a [P] is a\n    [P -> P] is a\n    [P -> P] is a [P] is the same predicate [P -> P] is a\n    [P -> P] is a\n    [P -> P] is a\n    [P -> P] is a [P] and [P -> P] is a\n    [P -> P] is a\n    [P -> P] is a-a] is a\n    [P -> P]Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* For example, the set of the same way of a set containing the set. *)\n\nDefinition In_empty_empty : Type :=\n  forall x : A, In x (couple x x) -> In x.\n\n(* For example, we use of a set element is a set of the set containing set of the set. *)\n\nInductive comp (A : Set) (P : A -> Prop) : Prop :=\n    exist : forall x : A, P x -> P x.\n\n(* For example, we define a set of the set element of set of set. *)\nDefinition comp (A : Type) (P : A -> Prop) : Prop :=\n    exist2 (fun x : A => P x)\n    (fun y : A => P x)\n    (fun x : A => P x)\n    (fun y : A => P y)\n    (fun y : A => P x) (fun y : A => P y)\n    (fun y : A => P y)\n    (fun y : A => P x)\n    (fun y : A => P x)\n    (fun y : A => P y)\n    (fun y : A => P y)\n   Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* A B : Prop := fun x : A => exists x : A, P x.\n\nDefinition comp (A : Type) (P : A -> Prop) : Prop :=\n  forall x : A, P x -> P x.\n\nDefinition comp (A : Type) (P : A -> Prop) : Prop :=\n  forall x : A, P x -> P x.\n\n(* A B : Prop := fun x : A, P x -> P x.\n\nDefinition comp (A : Type) (P : A -> Prop) : Prop :=\n  forall x : A, P x -> P x.\n\n(** A B : Prop := fun x : A => P x.\nDefinition comp (A : Type) (P : A -> Prop) :=\n  forall x : A, P x -> P x.\n\n(* A B : Prop := fun x : A, P x -> P x.\n\nDefinition comp (A B : Type) (P : A -> Prop) :=\n  forall x : A, P x -> P x.\n\n(* A B : Prop is a Prop is a Prop, a a Prop is a Prop. *)\n\nDefinition comp (A B :Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nDefinition Comp (A : Type) := exists a : A, P a.\n\n(* In the list of the list of list of list of list of list of list of list of list of list of list of list. *)\n\n(* In this list of list of list of list of list of list *)\n(* list of list of list of list of list of list of list of list *)\n(* In the list of list of list of list of list of list of list of list of list of list *)\n(*  list of list of list of list of list of list of list of list of list of list *)\n(*   The list of list of list of list of list of list of list of list of list of list of list of list of list of list of list *)\n(* of list of list of list of list of list of list of list of list of list of list of list of list of list of list list of list of list of list *)\n(* list of list of list of list of list of list of list of list of list of list of list. *)\n(* list of list of list of list of list of list of list of list of list of list of list of list list of list.Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* We do not depend on the set of the equality on the set of the set of the set of set of set in set. *)\n\nDefinition comp_spec := fun x : A => comp x (fun x : A => comp x).\n\n(* Definition is_rel : forall A : Ens, A -> A -> A -> Prop :=\n  fun x : A => fun x : A => comp x (fun x : A => comp x).\n\n\n(* Proof of the set of set. *)\n\nintros A x y z; elim y; simpl in |- *; intros; elim x; simpl in |- *; intros.\nelim x; simpl in |- *; intros.\nelim x; simpl in |- *; intros.\nexists (fun x : A => comp x (fun x : A => comp x (fun x : A => comp x (fun x : A => comp x y)) x).\nunfold comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, compDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\nLemma Comp_sub : forall A B : Ens, Comp A B -> Comp A B.\nunfold comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, compDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\nDefinition Comp (A : Set) (P : A -> Prop) :=\n  fun x : A -> Prop =>\n    forall x : A, P x -> P x.\n\n(* In the type of the set of the set of set_sigma and set_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma.\n\n(** A simple induction on non-founded [S] and [M]. *)\n\nDefinition comp_sigma : Type := comp (fun x : A => P) (fun x : A => P x) =>\n  forall x : A, P x -> P x.\n\n(* In the set of set_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma_sigma.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\nHint Resolve Comp_set: zfc.\n\n\nLemma Comp_set :\n forall A : Ens, Comp A (fun x : Ens => P x)\n    (rel1 x)\n    (rel2 x) (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel2 x)\n    (rel3 x)\n    (rel3 x)\n    (rel3 x)\n    (rel3 x)\n    (rel2 x)\n    (rel4 x)\n    (rel3 x)\n    (rel3 x)\n    (rel4 x)\n    (rel4 x)\n    (rel4 x)\n    (rel4 x)\n    (rel4 x)\n    (rel4 x)\n    (rel4 x)\n    (rel4 x)\n    (rel5 x0)\n    (rel4 x)\n    (rel4 x)\n    (rel4 x0)\n    (rel4 x0)\n    (rel4 x)\n    (rel4 x0)\n    (rel4 x)\n    (relDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\n\n(* A and a set of the set of (a : A) *)\n\nDefinition comp (A : Type) (P : A -> A -> Type) (P : A -> Prop) :=\n  exist : forall x : A, P x -> P x.\n\n(* A and B, a set of (a : A) *)\n\nDefinition comp (A : Type) (P : A -> Prop) (P : A -> Prop) :=\n  exist : forall x : A, P x -> P x.\n\n(* A, a set of the set (a : A) *)\nDefinition comp (A : Type) (P : A -> Prop) (P : A -> Prop) :=\n  exist : forall x : A, P x -> P x.\n\nDefinition comp (A : Type) (P : A -> Prop) (P : A -> Prop) :=\n  exist1 : forall x : A, P x -> P x.\n\n(* A, a set (a : A) *)\n\nLemma comp_comp : forall (A : Type) (P : A -> Prop) (P : A -> Prop) (P : A -> Prop) (P : A -> PropDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\nDefinition Comp : Ens -> (Ens -> Prop) -> Ens.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.\n\n(* The comprehension/separation axioms *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4764,
                "proof_end_offset": 4973,
                "proof": "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, INC in |- *; simple induction E; simpl in |- *; intros.\nelim H0; simple induction x; intros; exists x0; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp in |- *; intros; apply Comp_INC; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp in |- *; intros x; split.\nelim (axs_comprehension (fun x : A => P x) (fun x : A => P x) (fun x : A => P x) (fun x : A => P x))\n    (fun x : A => P x) (fun x : A => P x) (fun x : A => P x) (fun x : A => P x) (fun x : A => P x) (fun x : A => P x))\n    (fun x : A => P x) (fun x : A => P x))\n    (fun x : A => P x) (fun x : A => P x) (fun x : A => P x))\n    (fun x : A => P x) (fun x : A => P x))\n    (fun x : A => P x) (fun x : A => P x) (fun x => P x) (fun x : A => P x) (fun x : A => P x))\n    (fun x : A => P x) (fun x : A => P x))\n    (fun x : A => P x) (fun x : A => P x)Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp in |- *; intros A B f.\napply (P x).\nunfold comp in |- *.\nintros A f.\napply (P x); auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp in |- *.\nintros; elim (H (sig_dec A (fun x => P (f x)).\nintros; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (sig_dec A (fun x => P (f x)).\nintros; elim (H (sig_dec A (fun x => P (f x)).\nintro; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim (H (sig_dec A (fun x => P (f x))).\nintro; elim H; intros;Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp,Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp,Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E F H; elim (H (H (fun x => P (f x)) (g x))) (g x))).\nunfold comp in |- *; intros; elim (H (H (fun x => P (f x)) (g x))).\nunfold comp in |- *; intros; elim (H (H (fun x => P (f x))) (g x)).\nunfold comp in |- *; intros.\nelim (H (fun x => P (f x)) (g x)).\nunfold comp in |- *; intros; elim (H (fun x => P (f x)) (g x))).\nunfold comp in |- *; intros.\nelim H; auto with zfc.\n\nelim (H (fun x => P (f x))) (g x)).\nunfold comp in |- *; intros; elim (H (H (fun x => P (f x)) (g x))).\nunfold comp in |- *; intros; elim (H (f x)) (g x)).\nunfold comp in |- *; intros; elim (H (H (fun x => P (f x))) (g x)).\nunfold comp in |- *; intros; elim (H (H (fun x =>Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp in |- *; intros A f; apply comp_eq_sym_sym; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp, comp,Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; simpl in |- *; intros x; elim x; simpl in |- *; intros; split.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\n",
                "context_tokens": 319,
                "proof_start_offset": 1547,
                "proof_end_offset": 2774,
                "proof": "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A' B' B' H' H' H' H'0 H'1 H'1 H'2'2 H'3'3'4'4' H'4'4'5'6'5'5'6'6'7'6'7'7'7'7'7'10'10'10'10'11'13'10'11'13'11'13'13'13''14'13'13'14'13'14'13'14''13'14'14'13'14'13'14'14'13'14'13'14'13'14'14'14'14'14'14'14'13'13'14'14'13'14'14'15'14'14'14'13'14'14'14'14'14'14'14'13'14'14'14'14'14'15'14'14'14'14'14'14'14'14'14'14'14'14'14'15'15'14'13'14'14'14'13'14'14'14'14'14'Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A' B' B' H' H' H' H' H' H' H'' H''' H' H' H'' H'''' H''' H''''' H''''' H''''' H''''''' H''' H''''''' H'''''' H'''''' H'' H''''''''' H''''''''' H'''''''''' H''''''''' H'''' H'''''''''''''''''' H'''''''''''' H'''''' H'''''''''''''''''''''' H'''''''''''''''' H''''''''''''''''''''''''''''''''Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A B' B' B' C' H' H'0; try assumption.\nintros A' B' B' C' H'0; try assumption.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply H'0.\napply HQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof\n  intros A B' B' C' B' C' H' H'0.\n  apply (Couple_inj_left _ _ _ _ _ H'1); auto.\n  apply (Couple_inj_left _ _ _ _ H'1); auto.\n  apply (Couple_inj_left _ _ _ _ H'1); auto.\n  apply (Couple_inj_right _ _ _ _ H'1); auto.\n  apply (Couple_inj_right _ _ _ _ _ _ H'1); auto.\n  apply (Couple_inj_right _ _ _ _ H'1); auto.\n  apply (Couple_inj_left _ _ _ _ H'2); auto.\n  apply (Couple_inj_right _ _ _ _ _ H'1); auto.\n  apply (Couple_inj_left _ _ _ _ H'1); auto.\n  apply (Couple_inj_left _ _ _ _ H'1); auto.\n  apply (Couple_inj_right _ _ _ _ _ H'1); auto.\n  apply (Couple_inj_right _ _ _ _ _ _ H'1); auto.\n  apply (Couple_inj_right _ _ _ _Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A A' B' B' H'0.\nassert (H' : x <> y') by (intro; apply Singleton_inj_left; auto).\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple, Couple, Singleton, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, IncludedQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A' B C' C' H' H' H'0 H'0 H'0; try exact H'0 H'0 H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0; try exact H'0Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof\n  unfold Setminus, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included,Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof\n  intros A B' B' B' C' C' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D'' D' D'' D' D' D' D' D' D' D'' D' D' D' D' D' D' D' D' D' D' D'' D' D'' D' D' D' D' D' D' D' D''' D' D' D''' D' D' D'' D' D' D' D' D' D' D' D'' D' D' D' D' D' D' D' D'' D' D' D'' D'' D' D' D' D'' D' D' D'' D' D'' D' D' D' D'' D' D'' D'' D' DQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A B' B' H' H' H'0.\nunfold Lub in |- *.\nintros A B' H'0.\nunfold Compatible in |- *.\nintros A B' H' H'1.\nunfold Compatible in |- *.\nintros A' B' H' H'1.\nunfold Compatible in |- *.\nintros A' B' H'0.\nunfold Compatible in |- *.\nintros A' H'0.\nunfold Compatible in |- *.\nintros A' H'0.\nunfold Compatible in |- *.\nintros A' H'0.\nunfold Compatible in |- *.\nintros A' H'0.\nunfold Compatible in |- *.\nintros A'0.\napply (Le_inj_right _ _ _ H'1).\nunfold Compatible in |- *.\nintros A'0 H'1.\nunfold Compatible in |- *.\nintros A'0.\ncut (Le A'0 A'0).\nunfold Compatible in |- *.\nintros A'0 H'0.\nunfold Compatible in |- *.\nintros A'0.\ncut (Le A'0 A'0).\napply (Le_inj_right _ _ _ H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\nTheorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\n",
                "context_tokens": 647,
                "proof_start_offset": 2778,
                "proof_end_offset": 3718,
                "proof": "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *.\nsimple induction 1.\nintros.\nexists a.\nsplit.\nassumption.\napply (not_Out A'); auto with zfc.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Setminus in |- *; simpl in |- *; intros.\ncut (forall a : A' B, In a' -> In a' b -> In a' b -> In a' b -> In a' b \\/ In a' b /\\ In a' b').\nunfold Setminus in |- *; simpl in |- *; intros.\nelim (Rle_dec a' b); simpl in |- *.\nintro.\nelim (Req_dec a' b); simpl in |- *.\nintros H5; elim (H5 a'); simpl in |- *; intros.\napply (H4 a); simpl in |- *; intros.\napply (H5 a); simpl in |- *; auto with zfc.\napply (H4 a); simpl in |- *; intros.\nelim (H5 a); simpl in |- *.\nintros.\napply (H5 a); simpl in |- *.\napply (H5 a); simpl in |- *; auto with zfc.\n\n\napply (H6 a); simpl in |- *; auto with zfc.\n\napply (H5 a); simpl in |- *; auto with zfc.\napply (H5 a); simpl in |- *; auto with zfc.\n\n\napply (H6 a); simpl inQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A B B' B' H' H' H' H' H' H' H'0 H'0 H'0 H'1 H'0 H'1 H'1 H'2 H'2 H'3 H'1'1 H'3'3 H'3 H'4'4 H'5 H'4 H'6'6'6 H'5 H'6 H'6 H'6 H'5 H'7'8 H'6'9 H'8 H'10'9 H'10 H'11 H'11 H'11 H'11 H'11 H'12 H'13 H'12 H'14 H'14 H'14 H'14 H'15 H'13 H'14 H'15 H'14 H'15 H'14 H'14 H'14 H'14'15 H'15 H'14 H'14 H'14 H'15 H'14 H'15 H'16 H'14'14 H'14 H'14 H'14 H'15 H'15 H'15 H'16 H'16'15 H'15 H'15 H'15 H'15'15 H'Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Compatible in |- *.\nintros A A B' B' C' C' H' H' H' H'0 H'1'2 H'3 H'4 H'4 H'5 H'4'5 H'6 H'6'7'7 H'7 H'8'9 H'8 H'8 H'10 H'10 H'8 H'10'11 H'13 H'12 H'14 H'14 H'14'14 H'14 H'14 H'14 H'13 H'14'14 H'14'14 H'15 H'15 H'14'14 H'14'14 H'14 H'14'14 H'14'14 H'14'15'14 H'14 H'14 H'15'15 H'14'15 H'15 H'14 H'15 H'16 H'17'15 H'15 H'15 H'14'14 H'14 H'14'15 H'14'15 H'14 H'15 H'15'15 H'14 H'14'15 H'15 H'15'15'16 H'15 H'14 H'Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros A' B' B' B' B' C' C' C' D' C' D' C' C' D' C' D' C' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D' D'' D' D' D' D' D' D' D' D' D' D' D''' D' D' D' D' D' D'' D' D''' D' D'' D' D'' D' D'' D' D' D'' D' D'' D''' D' D'' D' D'' D' D'''' D'' D''' D''' D''' D''' D''' D''' D'' D' D'''' D' D''' D' D'''' D'''' D'' D'''' D'' D'''''' D'' D''' D'''''' D'''' D'Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros.\napply (not_eq (fun x => exists y : Ens, In (Couple A' B') (Couple A B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B' B') (Couple A' B') (Couple A' B') (Couple A' B' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B' BQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Compatible in |- *; simpl in |- *.\nintros.\nelim (classic (In (singleton A') B'); simpl in |- *.\nintros.\nabsurd (In (singleton A') B').\nsimpl in |- *.\nauto with zfc.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nintros.\ncut (Couple A B' B').\nintro.\ncut (Couple A B' B').\nintro.\ncut (Couple A B' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B).\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (Couple A' B').\nintro.\ncut (CoupleQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Included in |- *.\nsimple induction 1.\nintros.\nred in |- *.\nsimple induction 1.\nintros.\napply Trans with (a := a); auto with zfc.\napply IN_correct_left with (couple A x); auto with zfc.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros; elim H; simpl in |- *; intros.\nunfold Included in |- *.\nsimple induction 1.\nauto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4227,
                "proof_end_offset": 4370,
                "proof": "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Setminus, Setminus, Intersection, Intersection, Intersection, Intersection, Intersection, Union, Intersection, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, Union, UnionQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A A' B.\nunfold EQ in |- *.\nsimple induction 1; intros a b; elim (Seg a b); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPos A' B' H); simpl in |- *.\nintros b; elim (FcanonicLtPosQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Lub in |- *; simpl in |- *.\nsimple induction 1.\nintros; elim (classic (In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\ ~ In x s /\\Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros.\napply (H a); auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A' B' B' H' H'0 H'0; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'1; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintros; elim H'1; simpl in |- *.\nintros; elim H'1; simpl in |- *.\nintros; elim H'2; simpl in |- *.\nintros; elim H'1; simpl in |- *.\nintros; elim H'2; simpl in |- *.\nintros; elim H'0; simpl in |- *.\nintrosQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A' B B' B' H' H'0 H'1'1 H'2'3 H'3'4'4'4'4'5'5'5''6''6''6''6''7''7''6''6''7''7''7''7''7''7''7''7''6''7''7''7''7''7''7''7''7''7''7''7''7''7''7''7''7''7''7''''7''7''7''7''7''''8''''7''7''7''''7''7''7''''7''7''''7''7''7''7''''''''7''7''7''7''7''7''''7''''7''''''7''8''''7''''''''7''7''7''7''''7''7''''''7''7''7''''7''''''7''''''''7''''7''7''''''''''7''6''7''''''7''7''''''''7''7''''''7''''7''7Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold In in |- *.\nsimple induction 1.\nsimpl in |- *.\nintros.\ncase H0.\nintros; elim H0.\nintros a0 H1.\napply H1; auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Compatible in |- *.\nsimple induction 1.\nsimpl in |- *.\nsimpl in |- *.\nintros; elim H.\napply H.\nelim H.\nintros; elim H.\nintros.\napply H.\nelim H.\nintros.\napply H.\napply H.\napply H.\napply H.\nassumption.\nassumption.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A' B' B' C' B' H' H'0.\napply (is_is_finite_lemma_preserves_unicity_preserves_unicity_preserves_unicity_preserves_unicity_preserves_preserves_unicity_preserves_preserves_unicity_preserves_preserves_preserves_unicity_preserves_preserves_preserves_preserves_preserves_preserves_preserves_unicity with (bf' := bool); \n auto with zfc.\napply (is_finite_preserves_preserves_preserves_preserves_preserves_unicity with (bf' := bool); \n auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Setminus in |- *.\nintros A B A' B' B' H' H'0; elim H'0; clear H'0; elim H'0; clear H'0; intros.\nexists x0; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "simple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 4372,
                "proof_end_offset": 4516,
                "proof": "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Included in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nintros A B A' B' B' H' H'0 H'0.\nelim (H0 a).\nintros a' H'0.\nelim (H' a'0).\nintros a' H'0.\nelim (H' a'0).\nintros a' H' H'0.\nelim (H' a'0).\nintros a' H'0.\nelim (H' a'0).\nintros a'0 H'1.\nelim (H' a'1).\nintros a' H'0.\nelim (H' a'1).\nintros a'0 H'1.\nelim (H' a'0).\nintros a'1 H'1.\nelim (H' a'0).\nintros a'1 H'1.\nelim (H' a'0).\nintros a'1 H'2.\nelim (H' a'1).\nintros a' H'1.\nelim (H' a'0).\nintros a'1 H'1.\nelim (H' a'0).\nintros a'2 H'2.\nelim (H' aQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\napply not_intro.\nelim (H1 _ H1).\napply (H2 _ H1).\napply (H2 _ _ H2).\napply (H2 _ _ _ H2).\napply (H2 _ H2).\napply (H2 _ _ H2).\napply (H2 _ _ _ H3).\napply (H2 _ _ _ _ H2).\napply (H2 _ _ _ H1).\napply (H2 _ _ _ H3).\napply (H4 _ _ _ H4).\napply (H2 _ _ _ _ H3).\napply (H2 _ _ _ _ H4).\napply (H2 _ _ _ _ _ H3).\napply (H3 _ _ _ _ H4).\napply (H3 _ _ _ _ _ H4).\napply (H4 _ _ _ _ H3).\napply (H4 _ _ _ _ _ H3).\napply (H4 _ _ _ _ _ H3).\napply (H4 _ _ _ _ _ H3).\napply (H4 _ _ _Qed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nintros A B' B' B' H' H' H' H'0.\nelim (H0 _ H'0).\nintros a'0 H'1; elim (H0 a'0); intros.\nabsurd (In x (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' B') (Couple A' A' B') (Couple A' B') (Couple A' B' B') (Couple A' B') (Couple A' B' B') (Couple (Couple A' B' B) (Couple A' A' B') (Couple A' B' B') (Couple A' B' B') (Couple A' A' B') (Couple A' B' B') (Couple A' B' B') (Couple A' B' B) (Couple A' A' B')Qed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Included in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\napply not_intro.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": ".\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4519,
                "proof_end_offset": 5789,
                "proof": "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0)); auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\napply Couple_sound_left; auto with zfc.\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\nexists true; auto with zfc.\nsimple induction y; exists true; auto with zfc.\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\nsimple induction y.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nauto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Included in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Incident in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 5792,
                "proof_end_offset": 6539,
                "proof": "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1; auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2; auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Compatible in |- *; intros; auto with zfc.\n\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof\n  intros E1' E2' E2' E2' H'3'3; simpl in |- *.\nsplit.\nelim (diff_exists x1 x2); auto with zfc.\n\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E1' E2' E3' E2' E3' E4' E4'.\nsplit.\n\n\nintros x1 y1 E3; simpl in |- *.\nelim (IN_exists x1 y2); auto with zfc.\n\n\nunfold Subset in |- *.\nelim\n (IN_exists x1 y2); auto with zfc.\n\n\nsplit.\nunfold Subset in |- *.\nsplit.\nassumption.\n\nunfold Subset in |- *; intros.\nsplit.\nassumption.\n\n\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\n\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.\nassumption.\nunfold Subset in |- *.\nsplit.Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof\n  intros E1' E2'0 E2' E2'1' E2' E3' E3' E3' E3' E4' E'3' E4' E3' E' E'5' E' E'3' E'4' E' E'7' E'7' E'7' E'7 E' E'7' E'7' E'7 E'8' E' E'7' E'7' E' E'8' E'7 E' E'7' E'7' E'8 E' E'7' E' E'8' E'8' E' E'8' E' E'9' E' E'7 E' E'7' E' E'8' E'7' E'7 E' E'7' E' E'7'8 E' E' E'7' E'7' E'7' E'7' E' E'7' E'7' E' E'8' E' E'7' E' E'7' E'8' E' E'11' E' E'Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E1' E2' E2' x1 x2' y2' x3 x4 y4 y4 y4 y5 y7 y7.\nelim (IN_exists x y1); auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E1' E2' A2' A2' A3' A4' A5' B' A4' A5' A' A4' B' A' A5' A' B' B'6' A' A5' A' A' A' A' B' B'6' A' A' B' A' A' B' A' B' C' A' A' A' A' B' A' B' A' A' B' B' A' A' A' B' A' B' B' A' A' B' B' B' A' A' B' B' A' B' A' A' B' A' B' B' A' B' B' ->\n In E' B A' B' ->\n In E' B' B' B' A' ->\n In E' B' B' B' ->\n In E' B' B' B' ->\n In E' B' B' ->\n In E' B B' ->\n In E' B' B' B' ->\n In E' B' B' B' ->\n In E' B' BQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Couple in |- *; intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Compatible in |- *; intros; elim (is_Carrier_of_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_conv_Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Img in |- *; intros; auto with zfc.\n\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Setminus in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\nTheorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6543,
                "proof_end_offset": 6911,
                "proof": "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E' x y H'0.\nelim (IN_exists (fun x : Ens => In (Couple A x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) y))\n    (Couple x (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) y) (Couple x y) (Couple x y) (Couple x y) y) (Couple y) (Couple x y) (Couple y x y) (Couple x y) (Couple x y) (Couple x y) (Couple x y) y (Couple y) y) (Couple x y) (Couple y x y) (Couple x y) (Couple x y) (Couple y) y) (Couple y x y) (Couple x y) (Couple x y) (Couple y x y) (Couple y) x (Couple y x y) (Couple x y)Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E'' H'0; elim (is_finite _ _ _ x); intros A' H'0; elim A'0; intros A'0 A'0 H'1; elim A'0; intros A'0; elim A'0; intros A'0; elim A'0; intros A'0; elim A'1; intros A'1; elim A'0; intros A'0; elim A'1; intros A'0; elim A'1; intros A'1 A'0; elim A'1; intros A'1 A'1; elim A'1; intros A'1 A'0; elim A'0; intros A0; elim A'0; intros A'0; elim A'0; intros A'0 A'0; elim A'0; intros A'1 A'1; elim A'1; intros A'2 A0; elim A'1; intros A'1 A'0; elim A'1; intros A'2 A'1 A0; elim A'2; intros A0; elim A'0; intros A'1 A'2; elim A'1; intros A'2Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E'' E'' H' H'0.\nunfold Included in |- *.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E' H'0.\nsplit.\napply Lub_unique with (A := fun x : Ens => exists x : Ens, EQ (Couple x x) E).\nintro H'0; elim H'1; intros A x0; elim H'1; intros A0; elim A0; intros A1 x0; elim A1; intros A1 A2 A2; elim A2; intros A2 A3; elim A3; intros A3; elim A4; intros A3 A3 A4; elim A4; intros A4; elim A5; intros A4 A5 A6; elim A5; intros A6 A7; elim A7; intros A7; elim A7; intros A7; elim A7;\n intros A7 A7; elim A7; intros A7; elim A7; intros A8; elim A8; intros A7; elim A7; intros; elim A7;\n intros A9; elim A8; intros A9; elim A7;\n intros A7; elim A9; intros A7; elim A8; intros A8; elim A7; intros A9; elim A7;Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E'' H'0.\nelim (IN_fun A' (E' := fun x : Ens => ~ In (Couple A' E') (Couple E' x) (Couple E' x)) y).\nintros E'' H'0.\nelim (IN_fun A' (E : Ens => ~ In (Couple A' E') (Couple E' x) (Couple x y) (Couple E' x) (Couple E' x) (Couple E' x) (Couple x x) (Couple E' x) (Couple E' x) (Couple x y) (Couple x y) (Couple E' x) (Couple x y) (Couple x y) (Couple E' x) x y)).\nintros E'' H'1 H'2.\nelim (IN_fun A' (E' : Ens) (Couple x y) (Couple x y) (Couple x y) (Couple E' x) (Couple x y) (Couple x y) (Couple x y) x (Couple x y) y))).\nintros E'' H'1.\nelim (IN_fun A' (E : Ens) (Couple x y) (Couple x yQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E'' H; elim H; intros A' H'0.\napply Compatible_fun with (A := fun A : Ens => exists x : Ens, EQ (Couple x B) E'').\nintros E'' H'; elim H'; intros A'' H'0; clear H'0.\nelim H'; intros A'' H'0; elim H'; intros A'' H'0.\nexists x0; auto with zfc.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E'' H; elim (IN_exists A A B); auto with zfc.\nintros x y H' H' H'0.\nelim (IN_exists A B); auto with zfc.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E' H'; elim H'; intros A' H'0 H'0; simpl in |- *.\nsplit.\nauto with zfc.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E'' H'' H'0.\nelim (IN_exists x y); auto with zfc.\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nintros E'' x; elim x; intros A' x' H'0.\nexists x0; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n",
                "context_tokens": 399,
                "proof_start_offset": 1897,
                "proof_end_offset": 2155,
                "proof": "Definition EQC : Ens -> Ens -> Type.\nProof.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition EQC : Ens -> Ens -> Type.\n\nTheorem EQ : EQ C -> EQ C.\nProof.\nintros.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQ.\nrewrite EQDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition eq_dec (A B : Ens) : Prop :=\n  forall (A B : Ens) (P : A -> Prop),\n  forall (A B : Ens) (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> Prop), P P -> P -> P.\n\nDefinition EQC : Ens -> Prop :=\n  forall (A B : Ens) (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> Prop), forall (P : A -> Prop),\n  (P P) ->\n  forall (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> Prop), P -> forall (P : A -> Prop), P -> P.\n\nDefinition EQC : Ens -> Prop :=\n  forall (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (P : A -> Prop),\n  forall (PDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ (x : Ens) : EQ (x, y) :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ_EQ : Ens -> Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ_EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ_EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ_EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ_EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ_EQ : Ens :=\n  forall x : Ens, EQ (x, y) = y.\n\nDefinition EQ_EQ : Ens :=\n  forall xDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition eq_dec : forall (A : Type) (P : Prop) (Q : Prop), Q x -> Q x -> Q x.\n\nDefinition eq_dec (A : Type) (P : Prop) (Q : Prop) (Q : Prop) (Q : Prop), Q x -> Q x -> Q x.\n\nDefinition eq_dec : forall (A : Type) (P : Prop) (Q : Prop) (Q : Prop) (Q : Prop), P x -> Q x.\n\nDefinition eq_dec : forall (A : Type) (Q : Prop), Q x -> Q x -> Q x.\n\nDefinition eq_dec : forall (A : Type) (P : Prop) (Q : Prop), Q x -> Q x.\n\nDefinition eq_dec : forall (A : Type) (Q : Prop) (Q : Prop), Q x -> Q x.\n\nDefinition eq_dec : forall (A : Type) (P : Prop), P -> Q x -> Q x.\n\nDefinition eq_dec : forall (A : Type) (P Q : Prop) (Q : Prop), Q x -> Q x.\n\nDefinition eqDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\nDefinition EQ : Ens := EQ.\n\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nLemma eq_dec : forall (x : EQC) (a b : A), eq a b -> eq a b.\nProof.\nintros x y H.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nrewrite eq_dec.\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition eq_dec_dec : forall (A B : Ens) (b : A), eq_dec b -> eq_dec b.\n\nDefinition eq_dec_dec : forall (A B : Ens) (b : A), eq_dec a b -> eq_dec b.\n\nDefinition eq_dec_dec : forall (A B : Ens) (b : A) (b : A), eq_dec a b -> eq_dec b.\n\nDefinition eq_dec_dec : forall (A B : Ens) (a b : A), eq_dec b -> eq_dec b.\n\nDefinition eq_dec : forall (A B : Ens) (b : A), eq_dec a b -> eq_dec b.\n\nDefinition eq_dec_dec : forall (A B : Ens) (b : A), eq_dec b -> eq_dec a.\n\nDefinition eq_dec : forall (A B : Ens) (b : A), eq_dec a b -> eq_dec b.\n\nDefinition eq_dec : forall (A B : Ens) (a b : A), eq_dec b -> eq_dec b.\n\nDefinitionDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQ (x y : Ens) (x y : Ens) :=\n  let y := y in\n  let z := z in\n  let z := z in\n  let z := z in\n  let z := z in\n  let z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z := z in\n  let z := z := z in\n  let z := z in\n  let z := z := z in\n  let z := z := z in\n  let z := z in\n  let z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z in\n  let z := z := z in\n  let z := z in\n  let z := z in\n  let z := z in\n  let z := zDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition eq_dec : forall (P : Ens -> Prop) (f : A -> B) (g : A -> B) (g : A -> B) (g : A -> B) :=\n  forall (g : A -> B) (g : A -> B),\n  forall (g : A -> B), forall (g : A), P (g A g)) (g : B),\n  forall (g : A -> B) (g : A -> B),\n  forall (g : A -> B), forall (g : A -> B) (g : B),\n  forall (g : A -> B), (g A) (g : A -> B) (g : A),\n  forall (g : A -> B), (g A) (g : B),\n  forall (g : A -> B) (g : B),\n  forall (g : A -> B) (g : A),\n  forall (g : A -> B), forall (g : A -> B), (g A) (g : B),\n  forall (g : A -> B) (g : B),\n  forall (g : A -> B), forall (g : A -> B), forall (g :Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nDefinition EQ : Ens := forall x, EQ (eq x) (eq_dec x).\n\nDefinition EQ : Ens := forall x, EQ (eq_dec x) (eq_dec x).\n\nDefinition EQ : Ens := forall x, EQ (eq_dec x) (eq_dec x).\n\nDefinition EQ : Ens := forall x, EQ (eq_dec x).\n\nDefinition EQ : Ens := forall x, EQ (eq_dec x).\nDefinition EQ_dec : Ens := forall x, EQ (eq_dec x).\n\nDefinition EQ : Ens := forall x, EQ (eq_dec x).\n\nDefinition EQ : Ens := forall x, EQ (eq_dec x).\n\nDefinition EQ : Ens := forall x, EQ (eq_dec x).\n\nDefinition EQ : Ens := forall x : Ens, EQ (eq_dec x).\n\nDefinition EQ (x : Ens) := forall x : Ens, EQ (eq_dec x).\n\nDefinition EQ (x : Ens) := forall x : Ens, EQ (eq_dec x).\n\nDefinition EQ (x : Ens) := forall x : Ens, EQ (eq_dec x).\n\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\n",
                "context_tokens": 502,
                "proof_start_offset": 2179,
                "proof_end_offset": 2298,
                "proof": "Definition CIN : Ens -> Ens -> Type.\nProof.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1 eq2 eq2 eq3 eq3 eq4 eq5 eq5 eq7 eq7 eq7 eq7 eq8.\nintros A f eq3 eq7 eq8 eq8 eq10 eq8 eq8 eq9 eq101212 eq121212 eq131212 eq131212 eq13121212 eq12121212 eq13121212 eq1312121212 eq1312121212 eq1312121212 eq131212121212 eq13121212121212 eq12121212121212 eq1312121212121212121212121212121212121212121212121212121212121212121212122323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323Defined.",
                    "Definition CIN : Ens -> Ens -> Type.\n\nLemma BIN : Ens -> Prop.\nintros.\nexact (fun x y : A => eq1 x y (g y)).\nexact (fun x y : A => eq2 x (g y)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq0.\nauto.\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq0.\n\nchange (X x : Ens) with (x : Ens) in (x : Ens) (y : (x : (y : (y : (y : (y : (x y)))\n   : (x : (y : (y : (y : (y : (y : (y, y)))))\n   (x : (y : (y : (y : (y : (y : (y, y)))\n   (y : (y : (y : (y : (y : (y, y))\n   (y : (y : (y : (y, y : (y, y)))\n   (y : (y : (y : (y : (y, y)))\n   (y : (y : (y : (y : (y, y)), (y : (y, y))\n   (y : (y : (y : (x, y))\n   (y : (y : (y : (y, y) (y : (y : (y, y)))\n   (y : (y : (y : (y : (y, y)))\n   (y : (y : (yDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1 eq2; elim eq3; intros A f eq2; intros A f eq2 eq3 eq3; elim eq3; intros A f eq3 eq3; elim eq4; intros A f eq4 eq4 eq5; elim eq6; intros A f eq5; elim eq5; intros A f eq5 eq5; elim eq6; intros A f eq6; elim eq5; intros A f eq7 f eq5 eq6; elim eq5; intros A f eq5 eq7; elim eq7; intros A f eq5 eq7; elim eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7 eq7; elim eq6; intros A f eq5 eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7; elim eq7; intros A f eq7; elim eq7; intros A f eqDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\n\n(** ** A B C and C *)\n\nDefinition CIN : Ens -> Prop :=\n  fun x : A, A = B => B = B /\\ CIN A B /\\ B = B /\\ B = B /\\ C = B.\n\n(** ** B and C, C is a subset of a subset of the proof of the proof of a subset of the proof of the proof of the proof of the proof of the\n    proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the\n    proof of the proof of the proof of the proof of the proof of the proof of the proof of the\n    proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the\n    proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the\n    proof of the proof of the proof of the proof of the proof of the proof of the\n    proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the\n    proof of the proof of the proof of the proof of the proof of the proof of the proof of the proofDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\n\nDefinition CIN : Ens -> Type :=\n  forall x : A, P x -> P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x -> BIN (fun y : B => eq x y)) -> P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x -> B.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x -> P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x -> B.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x -> BIN x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, P x.\n\nDefinition BIN : Ens -> Type :=\n  forall x : A, PDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1 eq2 eq2 eq3 eq3 eq3 eq3 eq4 eq4 eq4 eq7.\nexact (fun x : A => eq2 x (g y)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq2 eq2.\nelim A; intros A f eq3 eq3 eq3 eq3.\nelim A1; intros A f eq3 eq3 eq3 eq3 eq4 eq5 eq7.\nelim A5; intros x3 eq3 eq4 eq6 eq7.\nelim A4; intros x5 eq7 eq7 eq8.\nelim A4; intros x7 eq7 eq7 eq7.\nelim A5; intros A7 eq7 eq7 eq8.\nelim A5; intros A7 eq7 eq7 eq7; eq8.\nelim A7; intros x8 eq7 eq7; apply eq7.\nelim A5; intros A7 eq7 eq8 eq8; apply eq8.\nelim A7; intros x8 eq8 eq10; apply eq9.\nelim A7; intros x8 eq9 eq9 eq9; apply eq9.\nelim A8; intros x10 eq10; apply eq10.\nelim A7; intros x8 eq9 eq10; apply eq9.\nelim A7; intros x10 eq9 eq11; apply eq12.\nelim ADefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq2 eq2 eq3 eq3 eq3 eq3 eq3 eq3 eq4 eq4 eq4 eq7.\nelim eq3; intros A f eq3 eq3 eq4 eq4 eq5 eq4 eq5.\nelim eq3; intros A f eq3 eq3 eq4 eq5 eq5.\nelim eq5; intros A f eq5 eq5 eq7 eq7.\nelim eq7; intros A f eq5 eq7 eq7; apply eq7_sym; auto.\nelim eq7; intros A f eq7 eq8 eq7 eq7.\nelim eq7; intros A f eq7 eq7 eq7; apply eq7_sym; auto.\nelim eq7; intros A f eq7 eq8 eq7 eq7; apply eq7; auto.\nelim eq7; intros A f eq8 eq7 eq7 eq9; apply eq7; auto.\nelim eq7; intros A f eq7 eq7 eq7; apply eq7; auto.\nelim eq8; intros A f eq7 eq8 eq7; apply eq7; auto.\nelim eq7; intros A f eq7 eq8 eqDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\n",
                "context_tokens": 551,
                "proof_start_offset": 2319,
                "proof_end_offset": 2425,
                "proof": "Definition CINC : Ens -> Ens -> Type.\nProof.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq0.\nexact (fun y : B => eq1 x (g y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq0 A; f eq0; simpl eq0.\nintros.\nexact (fun y : A => EQC (f x y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros.\nexact (fun x : A => EQC (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ (e y)) (fun y : A => EQ C (e y)) (fun y : A => EQ (e y)) (fun y : A => EQ (e y)) (fun y : A => EQ (e y)) (fun y :Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq0; auto.\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\napply (dep_fun x : A => EQB (f y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1 eq2 eq2 eq3 eq3 eq3 eq3 eq3 eq4 eq3 eq4 eq3 eq4 eq5 eq7 eq73 eq73 eq7 eq84 eq7.\nintros.\nexact (eq_dec _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (fun x : A => eq1 x (g y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\n\nintros.\nexact (proj1 (fun y : A => eq0 x y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nsimpl in |- *.\nauto with *.\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1 eq2 eq3 eq4 eq4 eq4 eq5 eq5 eq6).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "ms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\n",
                "context_tokens": 589,
                "proof_start_offset": 2470,
                "proof_end_offset": 2634,
                "proof": "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nexists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQ_F.\nintros E1 E2.\nelim (eq_dec E1 F); intros A B f eq_sig.\nelim (eq_dec E1 F); intros A B f eq_sig.\nelim (eq_dec E1 F); intros A B f eq_sig.\nelim (eq_dec E1 F); intros A B f eq_sig.\nelim (eq_dec E1 F); intros B f eq_sig.\nelim (eq_dec E1 F); intros A B f eq_sig.\nelim (eq_dec E1 F); intros A B f eq_sig.\nelim (eq_dec F1 F); intros A B f eq_sig.\nelim (eq_dec F1 F); intros A f eq_sig.\nelim (eq_dec F1 F); intros A f eq_sig.\nelim (eq_dec F1 F); intros B f eq_sig.\nelim (eq_dec F1 F1); intros A B f eq_sig.\nelim (eq_dec F1 F1); intros A B f eq_sig.\nelim (eq_dec F2 F2);Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nelim (eq_dec A B); intros A B; elim A; intros A B; elim A B; intros A B; elim B; intros A B; elim A B; intros A B; elim B; intros A B; elim B; intros A B; elim B; intros A B; elim A B; intros B; elim A B; intros A B; elim A B; intros B A B; elim A B; intros A B; elim B; intros A B; elim A B; intros A B; elim B; intros A B; elim A B; intros B; elim A B; intros A B; elim A B; intros A B B; elim A B; intros B; elim A B; intros; elim A B; intros; elim A B B; intros; elim A B; intros A B; elim A B; intros; elim A B; intros A B; elim A B; intros B; elim A B; intros; elim A B; intros A B; elim A B; intros A B; elim B; intros; elim A B B; intros A B B; elim B; intros; elim A B; intros; elim A B;Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nexact (fun x y : A, EQ C (e y)) (fun y : A, EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y)) (fun y : A => EQ C y (e y))Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nred in |- *.\nunfold not in |- *.\nintros E1 E2.\nelim (prod_t _ _ _ _ _ _ H0).\nexact (proj1 E2 E2).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nexact (fun x y : A, EQ C (fun y : A => eq_refl x y)) (fun y : A => eq_refl x y)) (fun y : A => eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A => eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y) (fun y : A, eq_refl x y)) (fun y : A, eq_refl x y)) (fun y : A, eq_refl y) (fun y : A => eq_refl x yQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E H; case E; intros A f eq1 eq2 eq2 eq3; case eq3; intros A f eq3 eq3; case eq4; intros A f eq3 eq3 eq4 eq4; case eq5; intros A f eq5 eq5; case eq5; intros A f eq5 eq6; case eq5; intros A f eq5 eq6; case eq5; intros A f eq5 eq6; case eq5; intros A f eq6; case eq6; intros A f eq5 eq5; case eq6; intros A f eq6 eq6; case eq6; intros A f eq6 eq6; case eq7; intros A f eq6 eq7; case eq6; intros A f eq7; case eq6; intros A f eq7 eq7; case eq7; intros A f eq7 eq7; case eq7; intros A f eq7; case eq6; intros A f eq7 eq7; case eq7; intros A f eq7 eq7; case eq7; intros A f eq7; case eq7; intros A f eq7 eq7; case eq7; intros A f eq7 eq7;Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\napply (fun y : Ens => eq1 x (g y)).\nexact (fun y : Ens => eq1 x (g y)).\nexact (fun y : Ens => eq2 x (g y)).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nexact (fun E : Ens => EQC (fun x : A => EQ C x) (g y)).\nexact (fun E : Ens => EQC (fun x : A => EQ C x)) (g y)).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\napply (fun x : A => eq1 x (g y)).\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in H.\nred in |- *.\nintros.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nintros.\nred in H.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nintro.\nred in |- *.Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E1 E2.\nexact (fun E : Ens => EQF X (F X)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                              *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\n",
                "context_tokens": 602,
                "proof_start_offset": 2636,
                "proof_end_offset": 3027,
                "proof": "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\napply (fun x : A => eq_refl A (g y)).\nexact (fun x : A => eq_refl A (g y)).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\nunfold EQC; case E1; intros B1; elim B2; intros B1 A2; elim A2; intros B2 B1 A3; elim B2; intros B1 A3; elim A3; intros B1 B2 B3; elim A4; intros B2 A4; elim A3; intros B1 A4; elim A5; intros B1 A4; elim B3; intros B1 B2 A4; elim B3; intros B1 B3; elim B2; intros B3 B4; elim B4; intros B4; elim A7; intros B4 A4 A4; elim B5; intros B4 A6; elim A7; intros B4 A5; elim B5; intros B5; elim B4; intros B5; elim A6; intros B5 A6; elim B6; intros B6; elim A6; intros B5; elim B5; intros B5 B5; elim A7; intros B5; elim A6; intros B5; elim A7; intros B6; elim A7; intros B5; elim B6; intros BQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof EQ.\nintros E1 E2.\nsimpl in |- *.\nsplit.\nexact (H0 E1 E2).\nexact (fun y : A, EQCIN E1 E2).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\ncut (forall y : Ens, EQ C (E1, C) -> EQ C x y) -> EQ C x y.\nintros E1 E2.\nelim (eq_dec x y); intros y0.\napply (H1 H); auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E2 E3.\nunfold EQ_F in |- *.\nsplit; intros.\napply (fun x : A => eq1 x (g y)).\napply (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq2 x (g y)).\nexact (fun x : A => eq3 x (g y)).\nexact (fun x y : A => eq3 x (g y)).\nexact (fun x y : A => eq3 x (g y)).\nexact (fun x : A => eqQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\nelim (eq_dec x x); intros x0.\napply (proj1 (fun y : A => eq1 x0 (g y))) in |- *.\nsplit; intros; auto with zfc.\nelim H; intros x0; exists y0; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E3.\napply (fun x : A, x : A, x : A, x : A, A = x : A, x : _, x : _, A = x : _, A = x : _, x : _, A = x : _, A : _, A = x : _, x : _, _, _, A : _, _, _, _, _, : _, _, : _, _, _, _, : _, _, : _, _, _, : _, _, _, : _, _, _, : _, _, _, : _, _, : _, _, _, _, : _, _, _, : _, _, _, _, : _, _, _, : _, _, _, : _, _, _, _, : _, _, _, _, : _, _, _, _, _, : _, _, _, _, : _, _, _, : _, _, _, _, : _, _, _, : _, _, _, : _, _, _, _, _, : _, _, _, _, : _, _, _, _, : _, _, _, _, : _, _, _, _, : _, _, _, _, : _, _, _, _, _, _, : _, _, _, _, _, _, : _, _, _, : _, _, _, _, _, : _, _, _, _, _, _, : _, _, _, _, _, _, : _, _, _, _, : _, _, _, _, : _, _, _, _, _, : _, _, _,Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\nsimpl in |- *.\nsplit; intros.\nsplit; [ left; auto with zfc | exists y; auto with zfc ].\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\nsimpl in |- *.\nsplit; intros.\napply (rel_trans _ (fun x : A => eq1 x (g y))) in |- *.\nsplit.\napply (rel_trans (fun x : A => eq1 x (g y)) in |- *.\nsplit; intros.\ninversion H.\nexists y; auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\napply (forall x : A, EQ C (F x)) (F x)) (F x)).\nexact (fun x : A, EQ C (F x) (F x)) (F x)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                  *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 3029,
                "proof_end_offset": 3283,
                "proof": "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1; intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nelim (a1 x); intros.\nelim (a1 x); intros.\nexists x1.\nexists x1.\nsplit; [ auto with zfc | right; right; right; reflexivity ].\nelim (a1 x); intros.\nelim (a1 x); intros.\nexists x1.\nsplit; [ auto with zfc | right; reflexivity ].\nelim (a1 x); intros.\nexists x2.\nsplit; [ auto with zfc | right; reflexivity ].\nelim (a2 x); intros.\nexists x1.\nsplit; [ auto with zfc | right; reflexivity ].\nelim (a1 x0); intros.\nexists x2.\nsplit; [ auto with zfc | right; reflexivity ].\nelim (a1 x); intros.\nexists x2.\nexists x1.\nsplit; [ auto with zfc | right; reflexivity ].\nelim (a1 x); intros.\nexists x2.\nexists x2.\nsplit; [ auto with zfc | right; reflexivity ].\nelim (a1 x); intros.\nexistsQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros E2 E2.\nred in |- *.\nsplit; intros.\napply (H x); auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1.\nintros.\nelim (H x); intros.\nelim (a0 x); intros.\napply (b x); auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1; intros.\napply (forall x y : A, x = y -> y = y).\nsimple induction 1; intros.\nexists x0.\nexists y.\nsplit.\nauto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1; intros.\napply (proj2C_trans _ _ _ _ _ H1); auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1.\nintros.\nexists x0.\nsplit; intros.\nexists x1.\nsplit; intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nexists x2.\nsplit; intros.\napply X with (e1 x); auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1; intros.\nsplit; [ idtac | assumption ].\nelim (a0 x); intros.\nelim (a1 x); intros.\nelim (a0 x); intros.\nelim (a1 x); intros.\nelim (a1 x); intros.\nexists y; auto with zfc.\nelim (a1 x); intros.\nexists x1.\nsplit; [ idtac | assumption ].\nelim (a1 x); intros.\nexists x1; auto with zfc.\nelim (a1 x); intros.\nexists x0.\nsplit; [ auto with zfc | assumption ].\nelim (a1 x0); intros.\nexists x1; auto with zfc.\n\nelim (a1 x); intros.\nexists x2; auto with zfc.\n\n\nsplit; [ auto with zfc | assumption ].\nelim (a1 x); intros.\nexists y; auto with zfc.\n\nexists y; auto with zfc.\nelim (a2 x); intros.\nexists y; auto with zfc.\n\n\nexists x1; auto with zfc.\n\n\nelim (a2 x); intros.\nexists y; auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1.\nintros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nexists x0.\nexists x1.\nexists x0.\nsplit.\nassumption.\nexists x1.\nexists x1.\nsplit.\nassumption.\napply H.\nexists x1.\nsplit.\nassumption.\nelim (a0 x); intros.\nexists x1.\nexists x1.\nsplit.\nassumption.\n\nassumption.\n\n\nexists x1.\nsplit.\nassumption.\n\nassumption.\nassumption.\nassumption.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nintros E1 E2.\napply (forall x : Ens, x <> x -> A = x /\\ A = x /\\ A = x /\\ A = x /\\ A = x /\\ B = x /\\ A = x /\\ A = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ C = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ C = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ C = x /\\ B = x /\\ C = x /\\ B = x /\\ B = x /\\ B = x /\\ B = x /\\ C = x /\\ B = x /\\ B = x /\\ B = x /\\ C = x /\\ C = x /\\ B = x /\\ C = x /\\ C = x /\\ B = x /\\ B = x /\\ C = x /\\ C = x /\\ B = x /\\ BQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction 1; intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nelim (a1 x); intros.\nexists x0.\nexists x0.\nsplit; [ auto with zfc | elim (a0 x); intros.\nexists x0.\nsplit; [ auto with zfc | elim (a0 x); intros.\nexists x0.\nexists x1.\nsplit; [ auto with zfc | exists x0.\nexists x1.\nsplit; [ auto with zfc | exists x1; auto with zfc ].\nelim (a0 x); intros.\nexists x1.\nsplit; [ auto with zfc | elim (a1 x1); intros.\nexists x2.\nexists x0.\nsplit; [ auto with zfc | exists x1.\nexists x0.\nsplit; [ auto with zfc | exists x1; auto with zfc ].\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "oor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3285,
                "proof_end_offset": 3557,
                "proof": "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nProof.\nsimple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; intros.\nelim (b x); intros.\nelim (a x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros E x y H0.\nelim (a x); intros.\nsplit; [auto with zfc | auto with zfc ].\nelim (b x); intros.\nsplit; [auto with zfc | auto with zfc ].\nelim (a0 x); intros.\nexists x0; auto with zfc.\nelim (b x); intros.\nsplit; [auto with zfc | auto with zfc ].\nelim (b x); intros.\nsplit; [ auto with zfc | auto with zfc ].\nelim (b x); intros.\nsplit; [auto with zfc | auto with zfc ].\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (b x); intros.\nsplit; [ auto with zfc | auto with zfc ].\nelim (b x); intros.\nsplit; [ auto with zfc | auto with zfc ].\n\nelim (a a); intros.\nsplit; [ auto with zfc | auto with zfc ].\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (b x); intros.\nsplit; [ auto with zfc | auto with zfc ].\n\nelim (a x0); intros.\nsplit; [ autoQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; intros.\nelim (a0 x); intros.\nelim (a0 x); intros.\nexists x1; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros E' H'0.\nelim (a0 x); intros.\nelim (a0 x); intros.\nexists x0.\nsplit; [ auto with zfc | auto with zfc ].\nelim (a x0); intros.\nexists x0.\nexists x1.\nsplit; [ auto with zfc | auto with zfc ].\nelim (a0 x0); intros.\nexists x1; exists x1.\nsplit; [ auto with zfc | auto with zfc ].\nelim (a0 x); intros.\nexists x1.\nsplit; [ auto with zfc | auto with zfc ].\nelim (a0 x); intros.\nexists x0.\nsplit; [ auto with zfc | auto with zfc ].\n\nelim (a0 x); intros.\nexists x0.\nsplit; [ auto with zfc | auto with zfc ].\nelim (a0 x); intros.\nexists x0; split; [ auto with zfc | auto with zfc ].\nelim (a0 x1 x); intros.\nexists x1; split; [ auto with zfc | auto with zfc ].\nelim (a0 x); intros.\nexists x0.\nsplit; [ auto withQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; intros.\nelim (a0 x); intros.\nexists x1; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; intros.\napply (H1 x); auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; intros; elim A; intros.\nelim (a0 x); intros.\nexists x0.\nsplit; [ auto with zfc | elim A0; intros; elim A0; intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; intros; elim A; intros; elim A; intros.\nelim (b x); intros.\nelim (b x0); intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; simpl in |- *; intros.\nelim X1; intros; elim X1; intros.\nexists x0; auto with zfc.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (b x); intros.\nelim (b x); intros.\nexists x0; auto with zfc.\n\nelim (a x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction 1; intros.\nsplit; intros.\nelim (a x); intros.\nexists x1.\nexists x1.\nsplit; auto with zfc.\napply X with (e1 x0); auto with zfc.\n\nelim (a x0); intros.\nexists x1.\nsplit; auto with zfc.\nelim (a x); intros.\nexists x0.\nsplit; auto with zfc.\nelim (a x0); intros.\nexists x1.\nsplit; auto with zfc.\n\nelim (a x1); intros.\nelim (a x0); intros.\nexists x1.\nsplit; auto with zfc.\nelim (a x0); intros.\nexists x1.\nsplit; auto with zfc.\n\nelim (a x0); intros.\nexists x2.\nsplit; auto with zfc.\nelim (a x0); intros.\nexists x2.\nsplit; auto with zfc.\nelim (a x0); intros.\nexists x1.\nsplit; auto with zfc.\nelim (a x); intros.\nexists x2.\nexists x1.\nsplit; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3604,
                "proof_end_offset": 3966,
                "proof": "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simpl in |- *.\nintros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\napply X2.\napply X2 with (e1 x); auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim (a x); intros.\nexists x0.\nexists x1; split; intros.\nexists x0.\nexists x1; split; auto with zfc.\nelim (a0 x); intros.\nexists x1; auto with zfc.\nelim (a0 x); intros.\nexists x1; split; auto with zfc.\nelim (a0 x); intros.\nexists x1; split; auto with zfc.\nelim (a0 x); intros.\nexists x1; split; auto with zfc.\n\nexists x0; auto with zfc.\nelim (a1 x); intros.\nexists x1; split; auto with zfc.\nelim (a1 x2); intros.\nexists x2; split; auto with zfc.\n\n\nexists x1; auto with zfc.\n\nexists x1; split; auto with zfc.\n\nelim (a0 x); intros.\nexists x2; split; auto with zfc.\n\nexists x2; split; auto with zfc.\n\nelim (a1 x2Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction 1.\nintros E F G L' H' H'0.\nelim (a0 x); intros.\nexists x0.\nelim (a x); intros.\nexists x0.\nexists x0.\nexists x1.\nsplit; auto with zfc.\n\nelim (a0 x); intros.\nexists x1.\nexists x1.\nsplit; auto with zfc.\n\nelim (a0 x); intros.\nexists x1.\nsplit; auto with zfc.\n\n\nelim (a0 x); intros.\nexists x0.\nexists x1.\nsplit; auto with zfc.\n\nelim (a0 x); intros.\nexists x1.\nexists x2.\nsplit; auto with zfc.\n\nexists x1.\nsplit; auto with zfc.\n\nelim (a0 x); intros.\nexists x2.\nsplit; auto with zfc.\n\nelim (a0 x); intros.\nexists x2.\nexists x2.\nsplit; auto with zfc.\nelim (a0 x); intros.\nexists x2.\nsplit; auto with zfc.\n\n\nelim (a0Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros.\nelim (a x0); intros.\nexists x0; auto with zfc.\nelim (a x); intros.\nexists x0; auto with zfc.\nelim (b x); intros.\nexists x0; auto with zfc.\n\nelim (b x); intros.\nexists x0; auto with zfc.\n\nelim (b x); intros.\nexists x1; auto with zfc.\n\nelim (b x); intros.\nexists x1; auto with zfc.\n\n\nelim (a x); intros.\nexists x1; auto with zfc.\n\n\nexists x0; auto with zfc.\n\nelim (a x0); intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E'; simpl in |- *; intros.\napply X with (e0 x); auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E'; simpl in |- *; intros.\nelim X; intros.\nelim (a x); intros.\nelim (a0 x); intros.\nelim (a1 x); intros.\nelim (a2 x); intros.\nexists x0; auto with zfc.\n\nelim (a2 x); intros.\nexists x0.\nexists x1; auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simpl in |- *; intros.\nelim X1; intros; elim X2; intros.\nelim X1; intros.\nelim X1; intros.\nexists x0; auto with zfc.\nelim (a0 y); intros.\nexists x0; auto with zfc.\nelim X1; intros.\nexists x0; auto with zfc.\n\nelim X2; intros.\nexists x1; auto with zfc.\nelim X2; intros.\nexists x0; auto with zfc.\n\nelim X2; intros.\nexists x0; auto with zfc.\n\nelim X3; intros.\nexists x0; auto with zfc.\n\n\nexists x1; auto with zfc.\n\nelim X3; intros.\nexists x0; auto with zfc.\nelim X2; intros.\nexists x0; auto with zfc.\nelim X1; intros.\nexists x0; auto with zfc.\nelim X2; intros.\nexists x1; auto with zfc.\nelim X3; intros.\nexists x0; auto with zfc.\n\n\nexists x0; auto with zfc.\n\nelim X2Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simpl in |- *; intros.\nelim X1; intros.\nelim (a x); intros.\nexists x0; auto with zfc.\nelim (a x); intros.\nexists x0.\nexists x1; auto with zfc.\n\nelim (a x); intros.\nexists x1; auto with zfc.\nelim (a x); intros.\nexists x1; auto with zfc.\nelim (a x); intros.\nexists x0; auto with zfc.\nelim (a x); intros.\nexists x1; auto with zfc.\n\nelim (a x); intros.\nexists x1; auto with zfc.\n\nelim (a x); intros.\nexists x2; auto with zfc.\nelim (a x); intros.\nexists x1; auto with zfc.\n\nelim (a x0); intros.\nexists x2; auto with zfc.\n\nelim (a x); intros.\nexists x2; auto with zfc.\n\nexists x2; auto with zfc.\n\nelim (a x); intros.\nexists x1; auto with zfc.\n\nelim (a x); intros.\nexists xQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction 1; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim (a0 x); intros.\nexists x1.\nexists x1.\nsplit; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim (a1 x); intros.\nexists x1.\nexists x2.\nexists x2.\nexists x2.\nsplit; intros.\nexists x1.\nsplit.\nexists x2.\nexists x1.\nsplit; intros.\nexists x1.\nexists x2.\nsplit; auto.\nelim X2; intros.\nexists x2.\nexists x2.\nsplit; auto.\nexists x2.\nsplit; intros.\nsplit; intros.\nexists x2.\nsplit.\nexists x1.\nsplit; intros.\nexists x2.\nexists x1.\nsplit; auto.\nexists x2.\nexists x2Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros E' E' H0.\nunfold EQC in |- *.\nelim X1; intros.\nexists x0; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4001,
                "proof_end_offset": 4205,
                "proof": "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''.\nintros.\nelim (a x); intros.\nexists x0; auto with zfc.\nelim (a x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E'; simpl in |- *; intros.\nelim X; intros; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E; simpl in |- *; intros.\nelim X; intros.\nelim X.\nelim X.\nelim X.\nelim X.\nintros.\nelim X.\nelim X.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\napply X.\nassumption.\nelim X.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E'; simpl in |- *; intros.\nelim X0; intros; elim X1; intros.\napply X2; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E; simpl in |- *.\nintro.\nsplit; intros.\nsplit; intros.\nelim (a0 x); intros.\nelim (a0 y); intros.\nexists x0; auto with zfc.\nelim (a0 x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E'' E'' H' H'0 H'1; elim (a x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim (a x); intros.\nexists x0; auto with zfc.\n\nelim (a x0); intros.\nexists x0; auto with zfc.\n\nelim (a x0); intros.\nexists x1; auto with zfc.\n\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E; simpl in |- *; intros; split; intros.\nelim X1; intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E; simpl in |- *; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim (a x); intros.\nelim (a x); intros.\nexists x0; auto with zfc.\n\nelim X.\napply X0; exists x1; auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim X.\nelim X; intros.\nelim X.\nelim X; intros.\nelim X.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4207,
                "proof_end_offset": 4489,
                "proof": "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nexists x1; auto with zfc.\n\nelim (a a); intros.\nexists x0; auto with zfc.\nelim (a x); intros.\nexists x0; auto with zfc.\n\nelim (a x0 x); intros.\nexists x0; auto with zfc.\n\n\nelim (a x0 x1); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros; elim p; intros.\nelim H1; intros.\nelim H1; intros.\nelim (a0 x); intros.\nexists x0; auto with zfc.\n\nelim (a1 x); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *.\nsplit; intros.\nelim X1; intros.\nelim X1; intros.\nexists y.\nsplit; auto with zfc.\nelim X1; intros.\nelim X1; intros.\nexists x0; auto with zfc.\n\nelim X1; intros.\nexists x0; auto with zfc.\nelim X1; intros.\nexists y0; auto with zfc.\nelim X1; intros.\nelim X2; intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *.\nintros.\nelim X1; intros.\nelim (a x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim (a x); intros.\nexists x0; auto with zfc.\n\n\nsplit; [ intros; elim H2; intros.\nexists x0; auto with zfc | auto with zfc ].\n\nelim X2; intros.\nexists x1; auto with zfc.\n\nelim X2; intros.\nexists x1; auto with zfc.\n\n\nelim X3; intros.\nelim X3; intros.\nexists x0; auto with zfc.\n\n\nsplit; [ intros; exists x1; auto with zfc | auto with zfc ].\n\n\nelim X2; intros.\nexists x1; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''.\nintros.\nelim X1; intros.\nelim (a x); intros.\nelim (a x); intros.\nexists x0; auto with zfc.\n\nelim (a x); intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X; intros.\nelim H; intros.\nelim X1; intros.\nexists x0; auto with zfc.\n\n\nelim X1; intros.\nelim H; intros.\nelim H; intros.\nexists x0; auto with zfc.\n\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''.\nintros.\napply X2; exists x; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 4491,
                "proof_end_offset": 4577,
                "proof": "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros.\napply X2.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E''; simpl in |- *.\nelim X1; intros.\nelim X1; intros.\nelim (a x); intros.\nexists x0; exists x0; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X2; intros.Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros; elim X1; intros; elim X1; intros.\nelim X2; intros; elim (H2 x); intros; elim H; intros; elim H; intros.\nelim (b x0 x); intros; elim H0; intros.\nexists x0; auto with zfc.\n\nelim (a0 x); intros; elim H1; intros.\nexists x1; auto with zfc.\nelim (a0 x); intros.\nexists x0; auto with zfc.\n\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nintros E' E'' E'' H'0.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nsplit; [ right | right; auto with zfc ].\napply T_trans with (e1 x); auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E'; simpl in |- *; intros; elim X0; intros.\nelim X1; intros; elim (a x); intros.\nexists x0; auto with zfc.\nelim (a x); intros; elim (a x0); intros; elim p0; intros.\nexists x0; auto with zfc.\n\nelim (a x); intros; elim p0; intros.\nexists x0; auto with zfc.\nelim (a x); intros; elim p0; intros.\nexists x0; auto with zfc.\n\nelim (a x0); intros.\nexists x0; auto with zfc.\n\nelim (a x0); intros.\nexists x1; auto with zfc.\n\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X0; intros.\napply X1; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X; intros; elim X1; intros.\nelim X; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3; intros.\nelim X3Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E'; simpl in |- *; intros.\nelim X0; intros.\nelim X1; intros.\nelim (a x0); intros.\nexists y; split; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4579,
                "proof_end_offset": 4703,
                "proof": "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros; elim X2; intros.\nelim X1; intros.\napply X1.\nexists x; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold D,INC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros; elim p0; intros.\nelim X1; intros.\nelim H1; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e := x0); auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros; elim H1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X3; intros.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros; elim X; intros; elim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim XQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros; elim (b x); intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros; elim (b x); intros.\nexists x1; auto with zfc.\n\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros;Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold D in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X2; intros.\nelim X3; intros.\nelim X2; intros.\nelim X4; intros.\nelim X4; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X5; intros.Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros; elim X1; intros.\nelim X1; intros; elim X1; intros; elim X2; intros; elim X1; intros; elim X2; intros; elim X1; intros; elim X2;\n intros; elim X2; intros; elim X2; intros; elim X3; intros; elim X4; intros; elim X3;\n intros; elim X4; intros; elim X4; intros; elim X4; intros; elim X4; intros; elim X4; intros; elim X4;\n intros; elim X4; intros; elim X4; intros; elim X4; intros; elim X4;\n intros; elim X5; intros; elim X6; intros; elim X5; intros; elim X5; intros; elim X5;\n intros; elim X4; intros; elim X5; intros; elim X5; intros; elim X5; intros; elim X5; intros; elim X4;\n intros; elim X6; intros; elim X5;\n intros; elim X5; intros; elim X4; intros; elim X5Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4706,
                "proof_end_offset": 4939,
                "proof": "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E'' E'' H''.\nunfold L; simpl in |- *; intros.\nelim X; intros; elim X0; intros.\napply X0.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim (a x); intros; elim X1; intros.\nelim (a x); intros; elim X1; intros.\napply X1.\nexists x1; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros; elim (H X); intros; elim (H X); intros; elim X; intros; elim H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelimQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold D'', EQ, D'', EQD', E'' E'' -> D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ D'' =INC' /\\ rr).\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.Qed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros; elim X; intros.\napply X.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X1; intros.\nelim X1; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X0; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E'' H'; unfold inc in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X0; intros.\nelim X0; intros.\napply X0; exists y0; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelim X.\nintros.\nelimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4941,
                "proof_end_offset": 5258,
                "proof": "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.Qed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros; elim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X; intros; clear X0; intros.\nelim X0; intros.\nelim X; intros.\nelim X0; intros; clear X0.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X1; intros.\nelim X0; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X1; intros.Qed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros; apply X2; intros; apply X2; intros; apply X3; intros; apply X4; intros; apply X4; intros; apply X4; intros; apply X4; intros; apply X5; intros; apply X5; intros; apply X5; intros; apply X4; intros; apply X5; intros; apply X5; intros; apply X5; intros; apply X4; intros; apply X6; intros; apply X6; intros; apply X4; intros; apply X5; intros; apply X6; intros; apply X4; intros; apply X5; intros; apply X5; intros; apply X5; intros; apply X6; apply X5; intros; apply X6; intros; apply X5; intros; apply X6; intros; apply X6; intros; apply X5; intros; apply X6; intros; apply X6; intros; apply X7; intros; apply X6; intros; apply X6; apply X6; intros; apply X6; intros; apply X6; intros; apply X6; intros; apply XQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros; elim (H x); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; elim H; intros; elim H; intros; elim H; clear H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; clear H; intros; elim H; intros; elim H; intros; elim H; clear H; intros; elim H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear HQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X1; intros.\nelim X1; intros; elim H1; intros.\nelim X1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros; elim H1; intros.\nelim X2; intros.\nelim X1; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X2; intros.\nelim X3; intros.\nelim X2; intros.\nelim X3; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X3; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim X4; intros.\nelim XQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X; intros; elim H; intros; elim H; intros.\nelim X; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; clear H; intros.\nelim X; intros; elim H; intros; elim H; intros; elim H; intros; elim H; clear H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n intros; elim H; clear H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros.\nelim X; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;Qed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; clear X; intros; elim X; clear X;\n intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X;\n intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X;\n intros; elim X; clear X; intros; elim X; clear X; intros.\nelim X; clear X; intros; elim X; clear X; intros; elim X; clear X; intros.\nelim X; clear X; intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X;\n intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X;\n intros; elim X; clear X; intros; elim X; clear X; intros; elim X; clear X;\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros; split; intros.\nelim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; elim X; intros; elim X; intros; elim X; intros; elim X; elim X; intros; elim X; intros; elim X; intros; elim X; intros; elim X; elim X; intros; elim X; clear X; intros; elim X; elim X; intros; elim X;\n intros; elim X; intros; elim X; elim X; intros; elim X; clear X; intros; elim X; clear X; intros; elim X; intros; elim X;\n intros; elim X; intros; elim X; clear X; intros; elim X; intros; elim X; clear X; intros; elim X; elim X; intros; elim X; clear X; intros; elim X;\n intros; elim X; clear X; intros; elim X; intros; elim X; intros; elim X; clear X; intros;Qed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros.\nelim X; intros; split; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5264,
                "proof_end_offset": 5529,
                "proof": "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros; elim (quadratic_prop _ _ _ _ H0); intros.\nelim X1; intros.\nelim (quadratic_prop _ _ _ _ H); intros; elim (quadratic_prop _ _ _ H); intros.\nexists x0; apply EQC_diln with (e x0); auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros; elim (Y1 E); intros.\nexists x0; apply EQC_mutind with (e x0); auto with zfc.\nelim X1; intros; elim (Y1 E); intros.\nexists x0; apply EQC_mutind with (e x0); auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros E' E' H'; elim (Ax A); intros.\nexists x0; exists x0; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros; elim (X2 X); intros; elim (X2 X); intros.\nexists x0; apply EQC_COMPL with (e x0); auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E'; simpl in |- *.\nelim X0; intros.\nelim X1; intros; elim (X2 E); intros.\nexists x0; apply EQC_mutind with (e x0); auto with zfc.\n\napply CIN_sound with (e x0); auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof\n  intros E' E' E' H' H'0; elim H'0; intros; elim H'0; intros; elim H'0; intros; elim H'0; intros; elim H'0; intros; elim H'0; intros; elim H'0; intros; elim H'1;\n intros; elim H'2; intros; elim H'2; intros; elim H'2; intros; elim H'2; intros; elim H'4; intros; elim H'3; intros; elim H'4;\n intros; elim H'3; intros; elim H'4; intros; elim H'4; intros; elim H'4; intros; elim H'5; intros; elim H'4; intros; elim H'6; intros; elim H'5;\n intros; elim H'6; intros; elim H'7; intros; elim H'5;\n intros; elim H'7; intros; elim H'6; intros; elim H'6; clear H'7; intros; elim H'7; intros; elim H'6; intros; elim H'7; intros; elim H'6;\n introsQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros.\nelim (X2); intros.\nelim (X2 E0); intros; elim (X2 E0); intros.\nexists x0; apply EQ1; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros E' H' H'0; elim H'; intros; elim H'; intros; clear H';\n intros; elim H'; intros; clear H';\n intros; elim H'; clear H'; intros; elim H';\n intros; clear H'; intros; elim H'; clear H';\n intros; elim H'; clear H'; intros; elim H'; clear H'; intros; elim H'; clear H';\n intros; elim H'0; intros; elim H'0; clear H';\n intros; elim H'; clear H'0; intros; elim H'1; clear H';\n intros; elim H'1; clear H'0; intros; elim H';\n intros; clear H'; intros; elim H'0; clear H';\n intros; elim H'1; clear H'1; intros; elim H'0; clear H'0; intros; elim H'1; clear H'0;\n intros; elim H'1; clear H'0; intros; elim H'2;\n intros; clear H'0; elim H';\n intros; clear H' H'0; intros; elim H'1; clear H'0; intros; elim H'0Qed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros x0 x1; elim p; intros.\nexists x0; split; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros.\nelim X1; intros.\nelim (X1 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X2 E); intros.\nelim (X3 E); intros.\nelim (X2 E); intros.\nelim (X3 E); intros.\nelim (X4 E); intros.\nelim (X3 E); intros.\nelim (X4 E); intros.\nelim (X4 E3 E); intros.\nelim (X4 E3); intros.\nelim (X4 E5 E); intros.\nelim (X4 E5 E6); intros.\nelim (X5 E6); intros.\nelim (X7 E5 E6); intros.\nelim (X4 E6 E6); intros.\nelim (X4 E6 E6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5532,
                "proof_end_offset": 5852,
                "proof": "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nsimple induction E; simpl in |- *; intros A' A' B'; elim (H (H x)); intros; elim (H x); intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; intros; elim H;\n clear H; intros; elim H; clear H; intros; elim H; intros; elim H; clear H; intros; elim H;\n clear H; intros; elim H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;\n clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; intros; clear H; elim H; intros; elim H; clear H;\n intros; elim H;Qed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Vide, Exrel, x in |- *; simpl in |- *; intros A' x' H' H'0; elim H'0; intros.\nelim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (Qed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A' B x; elim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (Qed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Vide in |- *; simple induction E'; simpl in |- *; intros.\nelim (X1 E); intros; elim (X2 E); intros.\nexists x0; exists y0; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A A B' B' H' H'0 H'1 H'1 H'1'2 H'2 H'3'3'3 H'4'4'5'5'7'7 H'7'8 H'9 H'9 H'10 H'9 H'10'11 H'14 H'13'14 H'14 H'14'14'15 H'15 H'13'13 H'14 H'14 H'13'15 H'15 H'14 H'14 H'15 H'15 H'15 H'15 H'15'15 H'14'15'17 H'18 H'17'15 H'16'15'14 H'13'17'15 H'15 H'16 H'16;\n [ apply T1 with (y := x); auto with zfc | idtac ].\nunfold Vide in |- *; intros.\nelim (H (H (lem_cartesian_propertie x x0 x1 x2); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold iff in |- *; unfold not in |- *; intros A' B' H'0; elim (H x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Vide in |- *; intros A' B x y H0 x y H0 H1; elim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (HQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Vide in |- *; simpl in |- *; intros A' B' A' H' H' H' H'0 H'1 H'0 H'1 H'2; clear H'1 H'1 H'2 H'2 H'3 H'3 H'4 H'4 H'4 H'4 H'5 H'5 H'4 H'6 H'5 H'6 H'6 H'7 H'8 H'8 H'8 H'9 H'8 H'9 H'8 H'9 H'9 H'9 H'8 H'11 H'12 H'14 H'15 H'15 H'14 H'16 H'16 H'14 H'15 H'16 H'17 H'16 H'16 H'17 H'17 H'16 H'17'17 H'19 H'20 H'18 H'17'16 H'16 H'18 H'16 H'16 H'17'17 H'17'19 H'17 H'18 H'20 H'16 H'17'19' H'16 H'17'17 H'17'17' H'18 H'Qed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Vide in |- *; simpl in |- *; intros A' B f X0 x0 x0 H0; elim (H x); intros; clear H0;\n intros; elim (H x0); intros; clear H1; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; clear H7;\n intros; elim H5; intros; elim H6; clear H6; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; clear H5;\n intros; elim H6; clear H7; intros; elim H6;\n intros; elim H5; clear H7; intros; elim H7; intros; elim H6; clear H6; intros; elim H6; intros; elim H7;\n intros; elim H5; clear H7; intros; elim H7;\n intros; elim HQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A A' B; elim A'; intros x y z; elim x; intros; elim H; intros; clear H;\n intros; elim H; clear H; intros.\nelim (H (e x)); intros; elim H; intros; clear H; elim H; intros; clear H; elim H; intros; clear H;\n intros; elim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5854,
                "proof_end_offset": 6157,
                "proof": "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; split.\nintro; elim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Same_intersection in |- *.\nsimpl in |- *.\nintros; split.\nunfold EQC, EQ_D, EQ_E'.\nunfold EQ in |- *.\nintros; split.\nelim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (HQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; split.\nunfold PC, HD,PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR PR, PR, PR, PR, PR, PR, PR; PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR, PR; PR, PR, PR, PR, PR, PR, PR, PR; PR, PR, PR, PR, PR, PR; PR, PR; PR, PR, PR, PR, PR, PR; PR, PR, PR, PR; PR, PR, PR; PR, PR, PR; PR; PR, PR; PR,Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; split.\nintro.\napply H.\nassumption.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Same, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In,Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; split.\nunfold Vide in |- *; unfold Vide in |- *.\nelim E; intros x0; elim x0; intros x0 x1 y2.\nexists x; auto with zfc.\n\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; split.\nintro.\nelim X; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H;\n intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H;Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold FSC in |- *; unfold Cong in |- *.\nintros.\nelim (X1 E' H); intros p; elim p; intros; exists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Incident in |- *.\nintros; elim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (HQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *.\nintros; split.\nintros; exists x0; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 6160,
                "proof_end_offset": 6309,
                "proof": "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold inc in |- *; simpl in |- *; intros A B x y H; elim H; intros; clear H; intros.\nelim (H (H (lem x)); auto with zfc.\n\nexists x; auto with zfc.\n\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold SP in |- *; simpl in |- *; intros; split.\nsimple induction x.\nelim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (Qed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold inc in |- *; intros; split.\nexists x.\nelim (H (H (e x) (lem_diff_fun x H)); intros.\nexists x.\nsplit.\napply H.\napply H.\nassumption.\nexists x.\nexists x.\nunfold inc in |- *; simpl in |- *; intros.\nelim (H (H (lem_diff_fun x H)); intros.\nexists x.\nexists y.\nsplit.\nassumption.\nexists x.\nexists y; auto with zfc.\n\n\nexists y; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Same, In in |- *; simpl in |- *.\nintros; split.\nauto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold inc in |- *.\nunfold inc in |- *.\nintros; split.\nauto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold In in |- *; intros; split.\nintros; elim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (HQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold inc in |- *.\nintros.\nelim (axs_comprehension (fun x : Ens => exists y : Ens, C = couple y y)\n    (cartesien (couple x y) (couple y) (couple y)) (couple y)) (couple y) (couple y))\n    (cartesien (couple y y) (couple y) (couple y))\n    (couple y (couple y) (couple y) (couple y)) (couple y z))\n    (couple y (couple y) (couple y) (couple y z))\n    (couple y z)) (couple y z))\n    (couple y z) (couple y z))\n    (couple (couple y z) (couple y z))\n    (couple z z) (couple z z)))\n    (couple z (couple z) (couple y z)) (couple z z))\n    (couple z z) (couple z z) (couple z) (couple z z) (couple z) (couple z z)); \n auto with zfc.\n\n\nLemma lem_couple_right :\n forall E' : Ens,\n In E' E' ->\n Equal (couple x y) (couple y) (couple z))\n    (couple z (Qed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold inter in |- *.\nintros; split.\nintros; unfold In, H; split.\nexists b; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Same_of in |- *; simpl in |- *.\nintros.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In in |- *.\nsplit.\nunfold In inQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Same in |- *; simpl in |- *; intros A B' H'0; elim A'; intros; clear H'0; intros.\nsplit; [ idtac | exists false; auto with zfc ].\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 6311,
                "proof_end_offset": 6463,
                "proof": "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold inc in |- *; simpl in |- *; intros A E' H'0 H'0; elim H'; intros.\nexists true; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold In in |- *; simpl in |- *; intros A B C H' H' H' H'0; elim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H ( H))) (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H ( H (H (H (H (H (H (H (H (H (H ( H)))) (H (Qed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold D, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold inc in |- *; simpl in |- *.\nintros; split.\nintros; elim H0; intros.\nexists y; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros A' H' H'0; elim (H' H'0); intros.\nexists y; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Same, MA_in in |- *; simpl in |- *; intros A' H' H'0; elim H'0; intros.\nexists x; auto with zfc.\nexists x; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Same, Included in |- *; simpl in |- *; intros A E' H'0; elim (H x); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Same, Diff, E' A' (cart E').\nunfold Same, Diff, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA, MA,Qed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Or in |- *; simpl in |- *; intros A' A' x' H'0; elim (H (H x)); intros.\nexists false; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Same_fun in |- *.\nunfold Same_fun in |- *; simpl in |- *; intros.\nelim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H ( H (H (H (H (H (H (H (HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6591,
                "proof_end_offset": 6793,
                "proof": "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Sum in |- *; simpl in |- *; intros A B E' H' H' H' H' H' H' H'' H'' H''' H'' H''' H''''' H''''''''' H'''''''''''''' H''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold sum_t; simpl in |- *; intros A f; elim H; intros.\nelim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H ( H)))); H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold diff, E', (diffC A E').\nunfold diff, E', (diffC A E').\nunfold diff, E', (diffC A E').\nunfold diff, E, (diffC A' E').\nunfold diff, E', (diffC A' E).\nunfold diff, (diffC A E').\nunfold diff, diff, (diffC A E').\nunfold diff, diff, (diffC A' E').\nunfold diff, diff, (diffC A' E').\nunfold diff, diff, (diffC A' E').\nunfold diff, diff, (diffC A' E').\nunfold diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff, diff,Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Sum in |- *; simpl in |- *; intros A' x y x y E' H' H'0; elim H'0; intros.\nelim (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H (H ( H (H (H (H (H (H (H (H (H (H (H (H (H (H (HQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold sum_t in |- *; simpl in |- *; intros A E f X H; elim X; intros.\nunfold sum_t in |- *; simpl in |- *; intros A f X.\nunfold sum_t in |- *; split.\napply sum_t_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sum_O_eq.\napply sumQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold sum_t in |- *; simpl in |- *; intros; elim A; clear A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro A; clear A; intro; clear A; intro A; clear A; intro A; clear A; intro A; clear A.\nelim A; clear A; intro A; clear A; intro; clear A; intro A; clear A; intro A; clear A; intro A; clear A; introQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold inc in |- *; simpl in |- *; intros A x0 y0 y0 y0 y0; elim y0; intros; elim y0; intros.\nexists (couple x0); auto with zfc.\n\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold sum_t in |- *; simpl in |- *; intros A E E' H' H' H'0 H'0.\nunfold sum_t in |- *; intros A H' H' H'1.\nunfold sum_t in |- *; simpl in |- *; intros A' H'0.\nunfold sum_t in |- *; simpl in |- *; intros A' H'0.\nunfold sum_t in |- *; simpl in |- *; intros A'0 H'1.\nunfold sum_t in |- *; simpl in |- *; intros A'0.\nunfold sum_t in |- *; simpl in |- *; intros A'0.\nunfold sum_t in |- *; simpl in |- *.\nintros A'0 H'1; elim (H'2 (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (H' (HQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Ps in |- *; simpl in |- *.\nintros; split; [ auto with zfc | auto with zfc ].\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold diff, diff, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar, Ar,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 6863,
                "proof_end_offset": 6954,
                "proof": "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold inc in |- *; unfold inc in |- *.\nunfold inc in |- *; unfold inc in |- *; simpl in |- *; intros.\nelim (X1 E); intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; clear b; intros; elim b;\n intros; elim b; clear b; intros; elim b; clear b; intros; elim b;\n intros; elim b; clear b; intros; elim b; clear b; intros; elim b; intros; elim b; clear b; intros; elim b; intros; elim b; clear b;\n intros; elim b; clear b; intros; elim b; clear b; intros; elim b; intros; elim b; clear b;\n intros; elim b; clear b; intros; elim b; clear b; intros; elim b; intros; elim b; clear b;\n intros; elim b; clear b; intros; elim b; clear b; intros; elim b;\n clear b; intros; elim b; clear b; intros; elim b; clear b; intros; elim b;\n clear b; intros;Qed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold diff, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In, In,Qed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same,Qed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold SP in |- *; simpl in |- *; intros A B C H0 H0 H0; elim H; intros; clear H0 H0;\n clear H0; intros A; elim H0; intros; clear H0;\n intros; elim H1; clear H0; intros; elim H1; intros; clear H1; elim H1; intros; elim H2; clear H1; intros; clear H1;\n intros; elim H2; clear H0; intros; elim H2; clear H1; intros; elim H2; clear H2; intros; elim H2; clear H1; intros; elim H2; clear H2; intros; elim H3; clear H1;\n intros; elim H3; clear H3; intros; elim H4; clear H2; intros; elim H3; clear H3; intros; elim H4; clear H3; intros; elim H4; clear H3; intros; elim H4; clear H4; intros; elim H4; clear H4;\n intros; elim H4; clear H5; intros.\nelim H3; clear H4; intros; elim H4; clear H3Qed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold alt, Equal in |- *; simpl in |- *; intros a b; elim b; intros; elim b; intros.\nsplit; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold inter in |- *; simpl in |- *; intros a b; elim b; intros b; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; elim b; intros; elim b; intros; elim b; intros; elim b; clear b; intros; elim b; intros; elim b; elim b; intros; elim b;\n intros; elim b; intros; elim b; clear b; intros; elim b; elim b; intros; elim b; intros; elim b; elim b; intros; elim b;\n intros; elim b; clear b; intros; elim b; intros; elim b;\n intros; elim b; clear b; intros; elim b; intros; elim b; elim b; intros; elim b; intros; elim b; clear b;\n intros; elim b; elim b; intros; elim b; intros; elim b; introsQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same, Same,Qed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold diff, Diff in |- *; simpl in |- *; intros a b; elim b; clear b; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold diff, inter, unlower in |- *; simpl in |- *; intros a b; elim b; intros;\n [ idtac | right; auto with zfc ].\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold comp in |- *; simpl in |- *; intros A E F H.\nunfold comp in |- *; intros A B f E F H; apply X; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\nTheorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 6956,
                "proof_end_offset": 7108,
                "proof": "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold covering in |- *; simpl in |- *; intros; elim b;\n simpl in |- *; intros a b; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b;\n simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold couple in |- *; simpl in |- *; intros A B' C; elim B; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C;\n [ intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C;\n intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C;\n intros; elim C; intros; elim C; intros; elim C; intros; elim C; elim C; intros; elim C; intros; elim C; intros; elim C;\n intros; elim C; intros; elim C; elim C; intros; elim C; intros; elim C;\n intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C; intros; elim C;\n intros; elim C; intros; elim C; intros; elim C;\n intros; elim C; intros; elim C; intros; elimQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Sep in |- *; simpl in |- *; intros A H H0; elim H0;\n intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H0;\n intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; elim H1; intros; elim H0; intros; elim H1; intros; elim H0;\n intros; elim H1; intros; elim H0; intros; elim H2; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H2; elim H3; intros; elim H2;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H3;\n intros; elim H5; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros;Qed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold ForAll in |- *; simpl in |- *; intros a b; elim b;\n auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold comp in |- *.\nintros E' H' H'0.\nunfold comp in |- *; intros a b; elim b; intros b; elim b; intros.\nexists b; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp, Opp,Qed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold alt in |- *; simpl in |- *; intros a H.\nelim (X x); auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Same_dom in |- *; simpl in |- *; intros A H'; elim A; intros; elim A; intros; elim A; intros; elim A; intros; elim A; intros; elim A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim A; clear A; intros; elim AQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold intersection_of in |- *; simpl in |- *; intros a; elim b; intros b;\n simpl in |- *; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b; intros; elim b;\n elim b; intros; elim b; intros; elim b; intros; elim b;\n intros; elim b; intros; elim b; elim b; intros; elim b; intros; elim b;\n intros; elim b; intros; elim b; intros; elim b; elim b; intros; elim b; elim b; intros; elim b; intros; elim b;\n intros; elim b; intros; elim b; elim b; intros; elim b; intros; elim b;\n intros; elim b; intros; elim b; intros; elim b; intros; elim b;Qed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold intersection, div in |- *; simpl in |- *; intros; elim b; intros a b; elim b; intros.\nexists b; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\n",
                "context_tokens": 351,
                "proof_start_offset": 1480,
                "proof_end_offset": 1579,
                "proof": "Definition Nat : nat -> Ens.\nProof.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Nat : nat -> Ens.\n\nLemma Nat_pred_succ : forall (E : Ens) (p : nat),\n Nat_pred_succ E p -> Nat_pred (pred_succ E) p.\nProof.\nintros E; split; auto with *.\nDefined.",
                    "Definition Nat : nat -> Ens.\n\nLemma Nat_pred : forall (E : Ens) (a : A) (a : A) (a : A),\n (a =' a in _) ->\n (forall a : A, a =' a in _) ->\n (forall a : A, in _ -> a =' a in _) ->\n (forall a : A, a =' a in _) ->\n (forall a : A, a =' a in _) ->\n (forall a : A, a =' a in _) ->\n (forall a : A, in _ -> in _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> _Defined.",
                    "Definition Nat : nat -> Ens.\n\nLemma Nat2Z : forall (P : Ens -> Prop) (x y : U),\n (forall y : U, In U (Eq A y) ->\n ~ In U (Eq A y) -> ~ In U (Eq A y) ->\n ~ In U (Eq A y) -> ~ In U (Eq A y) ->\n ~ In U (Eq A x) ->\n ~ In U (Eq A y) -> ~ In U (Eq A y) -> ~ In U (Eq A y) ->\n ~ In U (Eq A x) -> ~ In U A y.\n\n(* Proof of the proof of a non-fresh in a proof of the proof of a proof of the proof of the proof of a proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of theDefined.",
                    "Definition Nat : nat -> Ens.\n\nDefinition Nat : Ens :=\n  Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (fun x : Ens => Nat.eq (funDefined.",
                    "Definition Nat : nat -> Ens.\n\nDefinition Nat : Set := fun x : nat => x = y.\n\nLemma Nat_succ_succ_r : forall x : nat, Nat.succ_r x.\nProof.\n  intros x y H; simpl; auto with arith.\nDefined.",
                    "Definition Nat : nat -> Ens.\n\nDefinition Nat : Ens := Nat.succ_pred (nat -> nat).\n\nLemma Nat_pred : forall (F : Ens -> Ens) (x y : Z), Nat.pred (nat -> nat) -> forall x y : Z, Nat.pred (nat -> nat) -> forall x y : Z, Nat.pred (nat -> nat) -> forall x y : Z, Nat.pred (nat -> nat) -> forall x y : Z, Nat.pred (nat -> nat) -> forall x y : Z, Nat.pred (nat -> nat) x y.\nintros F x y; case x; intros H; rewrite H; rewrite H; auto.\nintros x y; rewrite H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nintros x H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nintros x y H; rewrite H; auto.\nDefined.",
                    "Definition Nat : nat -> Ens.\n\nDefinition Nat : Type := Nat.\n\nDefinition Nat : Type := Nat.\n\nDefinition Nat : Type := Nat.\n\nDefinition Nat : Type := Nat.\nDefinition Nat := Nat.\n\nDefinition Nat : Type := Nat.\n\nDefinition Nat : Type := Nat.\nDefinition Nat := Nat.\nDefinition Nat := Nat.Z.\nDefinition Nat := Nat.Z.\nDefinition Nat := Nat.Z.\nDefinition Nat := Nat.Z.\n\nDefinition Nat := Nat.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\n\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\n\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.Z.Z.\nDefinition Nat := Nat.ZDefined.",
                    "Definition Nat : nat -> Ens.\n\n(** ** The following definition of [fsetdec] *)\n\nDefinition Nat (A : Ens) := Union (A * B) (A * B) (B * B) (B * B)\n:= Union (A * B) (B * B) (B * B) (B * B) (B * B)\n:= Union (A * B) (B * B) (B * B) (C * B * B))\n:= Union (A * B) (B * B) (B * B) (B * B) (C * B) (B * B)\n:= Union (A * B) (B * B) (B * B) (C * B * B) (C * B)\n:= Union (A * B) (B * B) (C * B) (B * B) (B * B)\n:= Union (A * B) (B * B) (C * B) (C * B * B)\n:= Union (A * B) (B * B) (C * B) (C * B) (B * B)\n(B * B) (C * B) (C * B)Defined.",
                    "Definition Nat : nat -> Ens.\n\nDefinition Nat : Set := Nat.succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_nat_succ (nat_succ (nat_succ (nat_succ (nat_succ (nat_succ_nat_succ (nat_succ (nat_succ (nat_succ (nat_succ_nat_succ (nat_succ (nat_succ_succ (nat_nat_succ (nat_succ (nat_succ (nat_succ_nat_succ (nat_succ (nat_succ (S (nat_succ_nat_succ (nat_succ (nat_succ (nat_succ (nat_succ_nat_succ (nat_succ (nat_succ (nat_succ_pred (S (nat_succ_nat_succ (nat_succ (S (nat_succ_pred (nat_succ_pred (S (nat_succ_pred (nat_succ (nat_succ (nat_succ_nat_succ (S n))))\n | idtac ].\n\nDefinition Nat_pred (ADefined.",
                    "Definition Nat : nat -> Ens.\nDefinition Nat : Ens := Nat.le.\nDefinition Nat2 : Ens := Nat.le.\n\nDefinition Nat2 : Ens := Nat.le.\nDefinition Nat2 : Ens := Nat2Z.le.\nDefinition Nat2 : Ens := Nat2Z.le.\nDefinition Nat2 : Ens := Nat2Z.le.\n\nDefinition Nat2Z : Ens := Nat2Z.le.\nDefinition Nat2Z : Ens := Nat2Z.le.\nDefinition Nat2Z : Ens := Nat2Z.le.\nDefinition Nat2Z : Ens := Nat2Z.le.\n\nDefinition Nat2Z : Ens := Nat2Z.le.\nDefinition Nat2Z : Ens := Nat2Z.le.\nDefinition Nat2Z : Ens := Nat2Z.le.\n\nDefinition Nat2Z : Ens := Nat2Z.le.\nDefinition Nat3Z : Ens := Nat2Z.le.\nDefinition Nat2Z : Ens := Nat2Z.le.le.\nDefinition Nat2Z : Ens := Nat2Z.le.le.\nDefinition Nat2Z : Ens := Nat2Z.le.le.\nDefinition Nat2Z : EnsDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1709,
                "proof_end_offset": 1881,
                "proof": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintro E; elim E.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nred in |- *.\nauto.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; elim E; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nred (fun H => x H).\n\nDefinition IN_dec : forall (E : Ens) (x : IN X), IN E (Domain E) -> IN E.\nintros E H.\nexact (Pred_succ E).\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; elim E; intro E.\nexact (fun a : nat => In a nat); elim E; intro E.\nexact (fun a : nat => In nat a nat); elim E; intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => S a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => In nat a nat); intro E.\nexact (fun a : nat => exists a nat => a nat); intro E.\nexact (fun a : nat => a nat); intro E.\nexact (fun a : nat => exists a nat => nat); intro E.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof\n  unfold not, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN,, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN,, IN, IN, IN, EQ, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, EQ, EQ, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, EQ, IN, IN, IN, EQ, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, EQ, IN, IN, EQ, EQ, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, EQ, IN, EQ, IN, IN, EQ, IN, IN, IN, EQ, EQ, IN, IN, IN, IN, IN, IN, IN, IN, EQ, IN, EQ, IN, IN, IN,Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E H; elim H.\nexact (H0 a); auto with zfc.\nexact (H0 a); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\n  unfold not, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, var, varQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nred : forall E : Ens, IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> IN E (fun x : Ens => x = y) -> INQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; elim E; intros.\nexact (Pred_succ E).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 484,
                "proof_start_offset": 1884,
                "proof_end_offset": 2044,
                "proof": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nProof.\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *.\nintros E; unfold not in |- *; intros E; unfold not in |- *; apply IN_empty; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nred in |- *.\nintros.\nsimpl in |- *.\nred in |- *.\nintros.\nred in |- *.\nsimpl in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nsimpl in |- *.\nred in |- *.\nintros.\nred in |- *.\nsimpl in |- *.\nsimpl in |- *.\nintros.\nsimpl in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nred in |- *.\nintros.\nred in |- *.\nintros.\nred in |- *.\nred inQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold inc in |- *; apply IN_prop; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintro E_succ_r : forall E : Ens, X -> ~ In E (Add E E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add (Add E) E) (Add (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add E) (Add (Add E) (Add E) (Add (Add E) (Add E) (Add E) (Add E) (Add E) (Add (Add E) (Add E) (Add (Add E) E) (Add (Add E) (Add E) (Add E) (Add E) (Add (Add E) (Add E) (Add (Add EQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold not in |- *; apply IN_empty.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold not in |- *; apply IN_empty; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; unfold eq in |- *; unfold eq in |- *; intros H0; elim H1; intros.\nexact (H0 H).\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold not in |- *; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; intros E; elim E.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E H; unfold eq, eq, eq in |- *; unfold eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq, eq_, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_sym, eq_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\n",
                "context_tokens": 554,
                "proof_start_offset": 2096,
                "proof_end_offset": 2507,
                "proof": "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nHint Unfold IN_succ in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; intros.\napply IN_Union with E; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n\nTheorem IN_succ_r : forall E' : Ens, IN E' (empty E') -> ~ IN E' (empty E').\nintros E' H; unfold IN, IN in |- *; intros.\napply IN_empty_r in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros.\napply (Equal_succ_not_empty _ _ H).\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nHint Resolve IN_empty_l INC.\n\n(** The following proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof. *)\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n\n(** Title \"The proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof ofQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E; unfold EQ in |- *; unfold EQ in |- *; intro; elim (classic (In E); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n\nDefinition IN_succ_r : forall E' E' : Ens, IN E' E' (IN E) -> ~ In E' E'.\n\n(** The [exists x : Ens] is a [exists x : Ens]\n    [exists y : Ens, P y /\\ ~ In y E' -> ~ In y E'.\n\nTheorem IN_th_succ_r : forall E' : Ens, IN E' (E', T) -> ~ In y E'.\nProof\n  intros E' H'; unfold IN in |- *.\n  apply IN_th_succ_r; trivial.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n\nTheorem IN_th_succ_not : forall E : Ens, IN E' E' (fun x => E) -> EQ E'.\nintros E H; unfold IN in |- *; apply IN_th_succ_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_Qed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n\nTheorem EQ_rel_succ_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_inv_invQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E; unfold not in |- *; unfold not in |- *;\n apply IN_Union with E; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nDefinition IN_succ_l : forall E, IN E E' (fun x => IN E) E'.\n\nTheorem IN_succ_r : forall E : Ens, IN E' (fun x => IN E) E'.\nintros E; unfold IN', in |- *; unfold IN in |- *; simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\n",
                "context_tokens": 684,
                "proof_start_offset": 2510,
                "proof_end_offset": 2819,
                "proof": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E' H; unfold not in |- *; intros.\nelim (classic (exists x : Ens, IN (Range E) x)) (Domain (Singleton E)) x) (Domain x)) (Domain (Singleton E)) x)).\nintros E x H; unfold not in |- *; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E' F H; unfold IN in |- *; unfold not in |- *; unfold not in |- *; intros.\napply IN_sym with E0; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold not in |- *; unfold not in |- *; simpl in |- *; intros.\nelim (classic (In E (couple x x) (union E (couple x x) (union E (couple x x))) (union E (couple x x) (union E (couple x x))) (union E (couple x x E))) (union E (couple x x E)) (union E (couple x x E)) (couple x x E))).\nintros; exists (couple x x x (couple x x x E)) (union E (couple x x E)) (union E (couple x x E)) (couple x x E))).\nintros; exists (couple x x x (couple x x E)) (union E (couple x x E)) (couple x E))) (couple x E)) (couple x E)) (couple x E (couple x E))) (couple x E));\n auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold not in |- *; intro; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold not in |- *.\nunfold not in |- *; intros; unfold not in |- *; intros; unfold not in |- *; intros; unfold not in |- *; unfold not in |- *; intros; unfold not in |- *; unfold not in |- *; unfold not in |- *; intros; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in_in in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in_eq in |- *; unfold not in |- *; unfold not in_eq in |- *; unfold not in |- *; unfold not in |- *; unfold not in_eq, not in |- *; unfoldQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F H; unfold not in |- *; intro.\nelim (axs_comprehension\n    (fun x : E =>\n       In (couple x x) (couple x (couple x (couple x x (couple x x (couple x x)))\n    (cartesien (couple x (couple x (couple x x (couple x x (couple x x)));\n [ idtac | apply IN_prop_and_inv_r_r ].\nrewrite <- H; rewrite <- H; reflexivity.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E H; unfold IN in |- *.\nelim (Union_assoc (Singleton E) E); auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E' E' i; elim A; intros i2 i3; elim i3 i3; intros i4 i6 i5 i6 i7; elim i6 i6; intros i8; elim i6 i7 i7; intros; elim i6 i8; intros i8; elim i6 i7; intros; elim i7; intros; elim i9; intros; elim i8; intros; elim i7; intros; elim i9; intros; elim H9; intros; elim i9; intros; elim i13; intros; elim i13; intros; elim i13; intros; elim i14; intros; elim H14; intros; elim H14; intros; elim H14; intros; elim H14; intros; elim H13; intros; elim H14; intros; elim H14; intros; elim H14; intros; elim H14; intros; elim H15; intros; elim H14; intros; elim H14; intros; elim H15; intros; elim H14; intros; elim H14; clear H14; intros; elim H14; intros; elim H15; intros; elim H15; intros; elim H14; introsQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E H; unfold not in |- *; intros.\nelim (axs_reunion (couple x x)); intros; elim i; intros; clear i2 i2 i3 i3.\nelim (lem_ind_or_introl x); intros; elim i; intros; clear i2 i3 i3 i4 i4 i5 i5 i6 i7 i7 i7 i8 i9 i13 i13 i13 j13 i13 i13 i13 i13 i14 i13 i13 i14 i14 i13 j14 i14 i13 i14 i14 j14 i14 i14 j14 i13 j14 j14 j14 j15 j14 j15 j15 j15 j14 j15 j15 j14 j14 j15 j15 j15 j15 j15 j15 j14 j14 j14 j15 j14 j15 j15 j15 j15 j14 j15 j15 j14 j15 j15 j15 j14 j15 j15 j14 j14 j14 j15 j15 j15 j14 j15 j15 j15 j15 j15 j15 j15 j14 j15 j15 j15 j15 j15 j15 j14 j15Qed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E' H; unfold not in |- *; intros; elim H; intros i1 i2; elim i2; intros i2 i3 i4.\nunfold not in |- *; intros; elim i2; intros i3 i3 i5 i6 i6 i6 i6 i7 i7 i7 i7 i9 i9 i8 i9 i9 i10 i11 i14 i12 i13 i12 i13 i14 i14 i14 i13 i14 i13 i13 i13 i14 i14 i13 i14 i14 i14 i13 i14 i13 i13 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i13 i14 i13 i14 i14 i14 i14 i14 i14 i13 i13 i13 i14 i13 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i15 i13 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i14 i13 i14 i15 iQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "Y; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2822,
                "proof_end_offset": 2931,
                "proof": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\nunfold not in |- *.\nelim (O_P_intro (S x) i).\nintro a.\napply (Build_subtype_elt (P := fun x : nat => x = x) e.\nelim (O_intro a).\nelim (O_intro a); intros a.\napply (Build_subtype_elt (P := fun x : nat => x = y) e.\nelim (O_intro a).\nelim (O_intro a).\nintros a.\napply (Build_subtype_elt (P := fun x : nat => x = y) e.\nelim (O_intro a).\nintros a.\napply (Build_subtype_elt (P := fun x : nat => x = y) e.\nelim (O_intro a).\nelim (O_intro a).\nelim (O_intro a).\nexists (a a).\nelim (O_intro a).\napply (Build_subtype_elt (P := fun x : nat => x = y) e.\nelim (O_intro a).\nelim (O_intro a).\nintro.\nelim (O_intro a).\napply (Qed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n H; elim (H a); intros a.\nsimpl in |- *.\napply IN_sound_app with (P := fun x : nat => x) (h a) (h a) (h a) (h a)).\nauto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; red in |- *.\nelim (IN_prop _ x) (E (S n)) (S n)).\nintro; elim (IN_prop _ x) (E x) (E y)); intros a e.\ncut False.\nunfold not in |- *.\nintro a.\ncut False.\nelim (IN_prop _ x) (E x) (E y) (E y) (E y) (E y) (E y) (E y) y) (E y))\n    (E y (E y) (E y)) (E y) (E y) (E y)) (E y)\n    (E y (E y) (E y) (E y) (E y) (E y) (E y) (E y))\n    (E y (E y) (E y) (E y) (E y) (E y) (E y) (E y) (E y) y)\n    (E y (E y) (E y) (E y) (E y y) (E y) (E y) (E y) (E y) (E y) (E y))\n    (EQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n.\nelim (classic (forall x : Z, ~ In x (S x)) -> ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x.\nintros.\nelim (classic (exists x : Z, In x (S x)) -> ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x.\nintros.\nelim H0.\napply IN_sound_left with (P := fun x : Z => ~ In x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x)) \\/ ~ In x (S x) \\/ ~ In x (S x) \\/ ~ In x) \\/ ~ In x (S x) \\/ ~ In x).\nintros.\nelim H0.\nunfold In in |- *; auto withQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n H.\napply\n (Build_succ_l (nat_of_P n) (nat_of_P n) (nat_of_P n)).\napply\n (Build_succ_l (nat_of_P n) (nat_of_P n)); auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\nunfold not in |- *; intros.\nelim (H (H (H (S n)) a); intros; elim a; intros a b.\nexists (classic (exists b : nat, In b b a /\\ ~ In b b a /\\ ~ In b b a /\\ ~ In b a /\\ ~ In b b b).\nintros.\ngeneralize (H (H (S n)) a); intros; elim a; intros a b.\nunfold not in |- *; intros.\nelim (H (H (S n))) a b); intros; elim a; intros; elim a; intros;\n [ elim a; intros; elim a; intros; elim a; intros; auto with zfc | elim a; intros; auto with zfc ].\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *.\nintros E; elim (O_n_S _ (S _ _ (S _ (S _ (S _ _)) (sup A f)) i).\nintros a e.\napply IN_sound with (P := fun x : Ens => ~ IN x X Y).\nred in |- *; intros.\nelim (H0 x).\nintros x0 i2.\napply IN_sound with (P := fun x : Ens => ~ IN X Y (Singleton X (Singleton X))) i).\nintros x0 i.\nelim (X_n_S _ (S _ (S _ (S _ (S _ (S _ (S _ (S _ _)) (sup A f))).\nintros x0 i.\napply IN_sound with (P := fun x : Ens => ~ IN X (Singleton X (Singleton X)) i).\nintro i.\napply IN_sound with (P := fun x : Ens => ~ IN X (Singleton X (Singleton X))) i).\nintro i.\napply IN_sound with (P := fun x : Ens => ~ IN X (Singleton X (Singleton X)) i).\nintro i.\napply IN_sound withQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\nunfold not in |- *.\nintros.\napply Sym_sym.\napply Sym_trans with (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (Ap:=P) (ApQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros.\nunfold not in |- *; intros.\nelim (diff_exists x x); auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2966,
                "proof_end_offset": 3139,
                "proof": "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold IN in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in_nil in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in_cons in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in_nil in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in_cons in |- *; unfold In in |- *; unfold In in |- *; unfold In in in |- *; unfold In in |- *; unfold In in |- *; unfold In in_cons in in |- *; unfold In in |- *;Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; apply IN_sound with (Ap:=fun n : nat => EQ (Nat n) E) E; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; elim (X n); intros p.\napply IN_sound_intro with (P := fun n : nat => EQ (Nat n) E (Nat n) E (Nat n) E) (Nat n E) E) (Nat n E (Nat n E) E) (Nat n E)) E)\n  (Nat n E) E (Nat n E) E (Nat n E) E (Nat n E) E (Nat n E) E)\n  (Nat n E) E (Nat n E) E)\n  (Nat n E) E (Nat n E) E (Nat n E) E (Nat n E)\n  E (Nat n E) (Nat n E) E (Nat n E)\n  (Nat n E) E (Nat n E) E (Nat n E)\n  (Nat n E) E (Nat n E)\n  (Nat n E) (Nat n E) E (Nat n E) (Nat n E)\n  (Nat n E) (Nat n E) (Nat (Nat n E) E (Nat n) E (Nat n E))\n  (Nat n E (Nat n E) (Nat n E)\n  (NatQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; simpl in |- *.\nunfold not in |- *.\nintros.\nelim (axs_comprehension (fun n : nat => EQ (Nat n) E) (S n) (S n)) (S n)).\nintros.\nelim (axs_comprehension (fun n : nat => EQ (Nat n) E (Nat n) E))\n    (S n) (S n))\n    (S n) (S n) (S n) (S n))\n    (S n) (S n) (S n) (S n) (S n))).\nintros; simpl in |- *.\nintros.\nelim (axs_comprehension\n    (fun n : nat =>\n     (exists n : nat,\n       (exists n : nat,\n            (exists n : nat,\n            (exists n : nat,\n            (exists n : nat,\n            (exists n : nat,\n            (exists n : nat,\n              (exists n : nat,\n            (exists n : nat,\n            (exists n : nat,\n            (exists n : nat,\n                (exists n : nat,\n            (exists n : nat,\n                (exists n : nat, (exists n : nat,\n            (exists n : nat,\n           Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; red in |- *.\nelim (H (fun n : nat => EQ (Nat n)) (Nat n E)); intros n0; elim n; intros n0 H1 H2; clear H2; intro H2; elim n0; intros n1 H2; clear H2; intro H3; elim n0; intros n2 H3; clear H3; intros n2 H3 H3; elim n3; intros n2 H4 H4; clear H3 H3; intro H4; elim n4; intros n3 H4 H4 H5; clear H4 H4; intro H4; elim n3; intros n3 H4; clear H4 H5; intro H4; elim n4; clear n3 H4; intros n4 H5; elim n3; intros n4 H5; clear H5; intro H6; elim n4; intros n4 H5; clear H5; intro H5; elim n4; intros n5 H6; clear H6; intro H5; elim n3; intros n4 H6; elim n3; intros n4 H4 H6; clear n4 H5 H5Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; red in |- *; intros.\napply IN_sound with (P := fun n : nat => EQ (Nat n) (Nat n E) (Nat n E) (Nat n E)) (Nat n E) (Nat n E) (Nat n E)) (Nat n E) (Nat n E) (Nat n E) (Nat n E)) (Nat n E (id E)) (Nat n E (Nat n E)) (id E)) (Nat n E))\n    (Nat n E (id E)) (Nat n E (id E)) (Nat n E))\n    (Nat n E (id E)) (Nat n E)) (Nat (id E) E (id E))\n    (Nat (id E (id E)) (id E)) (Nat (id E)) (id E)) (id E)) (id E)) (id E)) (Nat (id E)) (id E))\n    (id E (Nat (id E)) (id E)) (id E)) (id E)) (id (id E)) (id E))\n    (id E (id E)) (id E)) (id E))\n    (id E (id E)) (idQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E x; red in |- *; intros a.\nelim (H x); intros a e1.\napply IN_sound with (A := A); auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold In in |- *; unfold In in |- *; intros; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in_in in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *; unfold In in_in in |- *; unfold In in_in in |- *; unfold In in |- *; unfold In in |- *; unfold In in |- *;Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros H; unfold not in |- *; intros x H; elim H; intros i; apply IN_correct_r.\napply IN_intro with (P:=A); auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; simpl in |- *; exists n.\nunfold ge in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3141,
                "proof_end_offset": 3491,
                "proof": "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\nintros.\nelim (H E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; unfold not in |- *; intros; elim E; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; intros n e.\nrewrite (E_S_n_S_S n_S_S_n_S_n_S_n_S_n_S_S_n_S n_S_S_n_S_n.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; simple induction 1; intros.\nexact H.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; split; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nred in |- *; intros.\nelim (eq_dec n e); intros.\ngeneralize (le_dec e); intros; apply EQ_symm with E.\nelim (eq_dec e); intros.\nelim (lt_dec e); intros.\ngeneralize (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e); intros.\nelim (le_dec e e); intros.\nelim (le_dec e); intros.\nelim (le_dec e e); intros.\nelim (le_dec e e); intros.\nelim (le_dec e e); intros.\nelim (le_dec e e); intros.\nelim (le_dec e e); intros.\nelim (le_dec e e); intros.\nelim (le_dec e e); intros.\nelim (Qed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; simple induction 1.\nintros n e.\napply IN_n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; intros.\nelim (IN_exists (Z n e) (nat_of_P n)).\nintros n e; elim (O_nat_of_P n).\nintros n e H.\nunfold EQ in |- *; split; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nred in |- *.\nintros.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.\napply IN_correct_r.Qed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; intros; unfold eq in |- *; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; intros; unfold eq_succ in |- *; simpl in |- *; intros; unfold eq_succ in |- *; simpl in |- *; intros; unfold eq_succ in |- *; simpl in |- *; intros; unfold eqQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros.\nunfold IN, In in |- *.\nelim (H (H (fun p : nat => EQ (Nat n)) (Nat n E)) (Nat n E)) (Nat n E) (Nat n E)) (Nat n E)).\nsimpl in |- *.\nelim (le_or_exists n (nat n E) (Nat n E)) (Nat n E)).\nsimpl in |- *.\nelim (le_or_exists n E (Nat n E)) (Nat n E) (Nat n E)) (Nat n E (Nat n E)) (Nat n E)) (Nat n E)) (Nat n E (Nat n E)) (Nat n E)) (Nat n E (Nat n E)) (Nat n E)) (Nat n E (Nat n E)) (Nat n E)) (Nat n E (Nat n E)) (Nat n E)) (Nat n E (Nat n E)) (Nat n E)) (Nat n E (Nat n E)) (Nat n E (Nat n E)) (Nat n E (Nat n) E (Nat n E))) (Nat n E (Nat n E)) (Nat n E (Nat n E)) (Nat (Nat nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\nTheorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 754,
                "proof_start_offset": 3494,
                "proof_end_offset": 4079,
                "proof": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nProof.\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\napply IN_sound_left with (Nat n).\nauto with zfc.\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\napply IN_sound_right with e; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; intro x.\nelim (IN_prop_or_prop _ x); auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nintros.\ngeneralize (Union_inv_prop_prop_prop_prop_prop_prop _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Singleton in |- *.\nintros.\nelim (H0 (O:=S n0)).\nintros.\napply (H0 (S n0)).\napply (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H1 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H1 (S n0))).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H0 (S n0)).\nrewrite (H1 (S n0)).\nrewrite (H0 (S n0 n0)).Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; intros.\napply (H x); auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, IN, EQ, IN, IN, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ EQ EQ, EQ, EQ, EQ, EQ, EQ, EQ EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ, EQ,Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nintro.\nunfold eq in |- *.\nunfold eq in |- *.\nsimple induction 1.\nauto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold incl in |- *.\nunfold incl in |- *.\nunfold incl in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold incl in |- *.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nintro.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nintro.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold In in |- *.\nintros; elim (Build_succ_pred (nat_of_P (nat_of_P (nat_of_P (nat_of_P (nat_of_P (nat_of_P (nat_of_P (nat_of_P (nat_of_P (nat_of_P (nat_of_P n)))) (P n0))).\nsimpl in |- *.\nauto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Singleton in |- *.\nintros; elim (H (fun x : nat => EQ (Nat n0) (S (Nat n0)) H1).\nsimpl in |- *.\nauto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nunfold x in |- *.\nsimple induction 1.\nintro; elim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\napply IN_prop_prop _ x.\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).\nintros.\nelim (IN_prop _ x).Qed."
                ]
            }
        ],
        "dep-map": [
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  ",
                "context_tokens": 255,
                "proof_start_offset": 944,
                "proof_end_offset": 1028,
                "proof": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\nProof.\nintros.\nnow symmetry.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros. destruct x; try reflexivity.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H.\n    destruct H as [x' [? [??]]].\n    exists y. split; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros x y; inversion H.\n    rewrite H. reflexivity.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros. rewrite eq_sym in H.\n    destruct H as [? | H].\n    exists x. split; auto.\n    intros x y. rewrite H in H.\n    destruct H as [? | H].\n    exists x. split; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros x y H; apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    apply eq_sym.\n    applyQed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n  intros; induction y; simpl; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n  intros x y H. rewrite eq_sym; auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros.\n    induction x; intros.\n    destruct y; simpl in *.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare y y); simpl in *; auto.\n    destruct (compare y x y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare y y y); simpl in *; auto.\n    destruct (compare y y y); simpl in *; auto.\n    destruct (compare y y y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare y y y); simpl in *; auto.\n    destruct (compare y y y); simpl in *; auto.\n    destruct (compare y y y); simpl in *; auto.\n    destruct (compare x y); simpl in *; auto.\n    destruct (compare y y); simpl in *; auto.\n    destructQed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros x y H.\n    destruct H; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    intros x y H.\n    unfold eq.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite eq_sym in H. rewrite <- eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite <- eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite eq_sym in H. rewrite <- eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite eq_sym in H.\n    rewrite eq_symQed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  ",
                "context_tokens": 285,
                "proof_start_offset": 1032,
                "proof_end_offset": 1144,
                "proof": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now apply eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. apply eq_trans with y. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now rewrite eq_sym. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  ",
                "context_tokens": 321,
                "proof_start_offset": 1148,
                "proof_end_offset": 1260,
                "proof": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros x y z; symmetry. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now apply lt_trans with y. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with y. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with y. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now apply lt_trans with y. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply eq_sym. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply eq_sym. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. rewrite eq_sym. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now rewrite eq_sym. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. exact O. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  ",
                "context_tokens": 357,
                "proof_start_offset": 1263,
                "proof_end_offset": 1413,
                "proof": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\nProof.\nintros ? ? Hlt Heq.\nrewrite Heq in Hlt.\nrevert Hlt.\napply StrictOrder_Irreflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq with x. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply eq_sym; assumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply le_trans with x. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. symmetry. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. symmetry. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply le_trans with x. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. destruct x. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros?? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n\n  ",
                "context_tokens": 404,
                "proof_start_offset": 1417,
                "proof_end_offset": 1681,
                "proof": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\nProof.\nintros x y.\nassert (H := (O.compare_spec x y)).\ndestruct (O.compare x y).\nconstructor 2.\nnow inversion H.\nconstructor 1.\nnow inversion H.\nconstructor 3.\nnow inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply lt_trans. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply lt_trans with y. apply lt_trans with y. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply lt_trans with (x := y). Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply eq_sym. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply Lt.lt_trans with x. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. destruct (lt_trans x y).\n  apply compare_lt.\n  Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. transitivity x; auto. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros x y H; apply compare. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros x y z H. apply lt_trans. Qed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n unfold multZ, Zplus, Zplus, Zplus, Zplus, Zplus, Zplus_0_r, Zplus_0_r, Zplus_r, Zplus_0_r, Zplus_assoc, Zplus_0_r, Zplus_0_r, Zplus_assoc, Zplus_comm, Zplus_0_r, Zplus_assoc, Zplus_comm, Zplus_comm, Zplus_comm, Zplus_comm, Zplus_assoc, Zplus_comm, Zplus_comm, Zplus_comm.\n unfold Zminus, Zplus_opp, Zplus_assoc, Zplus_comm.\n unfold Zminus in |- *; simpl in |- *.\n rewrite Zplus_0_r.\n unfold Zminus in |- *; simpl in |- *.\n rewrite Zplus_assoc_reverse, Zplus_comm, Zplus_comm.\n unfold Zminus in |- *.\n unfold Zminus in |- *.\n simpl in |- *.\n rewrite Zplus_assoc.\n unfold Zminus in |- *.\n simpl in |- *.\n rewrite Zplus_assoc_reverse, Zplus_comm.\n unfold Zminus in |- *.\n simpl in |- *.\n rewrite Zplus_assoc_reverse, Zplus_comm, Zplus_assoc, Zplus_comm.\n unfold Zminus in |- *.\n simpl in |- *.\n rewriteQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n; simpl in |- *; intro; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros; elim x; simpl in |- *; intros;Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n apply multZ_eq1_l.\n apply multZ_eq_0_l.\n apply multZ_eq_1_l.\n apply multZ_eq_1_l.\n apply multZ_eq_1_l.\n apply multZ_eq_1_l.\n apply multZ_eq_1_l.\n apply multZ_eq_1_l.\n apply multZ_eq_1_l.\n apply multZ_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1_r.\n apply mult_Z_eq_1_l.\n apply mult_Z_eq_1Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n; simpl in |- *; auto with arith.\nintros n0.\napply multZ_lt_1.\napply mult_0_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_lQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n apply multZ_eq1.\n applyQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (le_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (lt_gt_0 x1); intro.\n  case (Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n rewrite mult_1_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n applyQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  unfold multZ; simpl; intros.\n  replace (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S n)))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n apply plusZ_eq1.\n apply multZ_eq1.\n apply multZ_lt_1.\n apply multZ_le_0_compat.\n apply mult_Z_lt_1_compat.\n apply mult_Z_eq1_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\n apply mult_Z_le_compat.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_r.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.\n apply mult_le_compat_l.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto with arith.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros n1 n2.\n rewrite mult_comm.\n apply mult_pos_eq2.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 728,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n apply mult_le_compat_l with (n := 0).\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros x y.\n unfold multZ_eq in |- *.\n rewrite multZ_eq5 in |- *.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite mult_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\n rewrite plus_comm.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros; elim (mult_neg_Z _ _ _ _ y).\n intro; elim (mult_neg_Z _ _ _ y).\n intro; elim (mult_neg_Z _ _ y).\n intro; elim (mult_neg_Z _ _ y).\n intro; elim (mult_neg_Z _ _ y).\n intro; elim (mult_neg_Z _ _ y).\n intro; elim (mult_neg_Z _ _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_neg_Z _ x).\n intro; elim (mult_neg_Z _ y).\n intro; elim (mult_negQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n unfold multZ.\n rewrite mult_assoc.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros x y H; apply mult_reg_l with (Z := (-x)); auto with real.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n unfold multZ.le, multZ.\n unfold multZ.\n intros.\n rewrite multZ.\n rewrite <- multZ_eq5.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_commQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n unfold multZ.succ in |- *.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n unfold multZ.lt, multZ.\n intros x y y.\n apply mult_le_reg_l with (Z := (- x) (multZ_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_posQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n apply mult_le_compat.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim H0; intros; elim H0; intros; exact H1.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *;Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n unfold multZ.lt.\n replace (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.posQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim H0; intros; elim H0; intros.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* posn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *; reflexivity.\n(* negn *)\nsimpl in |- *;Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim H1; intros; elim H1; intros; apply H2; auto.\n(* neg n0 *)\nintros; elim H0; intros; elim H1; intros; auto.\n(* neg n0 *)\nintros; elim H2; intros; elim H1; intros; auto.\n(* neg n0 *)\nintros; elim H2; intros; elim H3; intros; auto.\n(* neg n0 *)\nintros; elim H3; intros; elim H3; intros; auto.\n(* neg n0 *)\nintros; elim H4; intros; elim H3; intros; auto.\n(* neg n0 *)\nintros; elim H3; intros; auto.\n(* neg n1 *)\nintros; elim H3; intros; auto.\n(* neg n1 *)\nintros; elim H4; intros; auto.\n(* neg n1 *)\nintros; elim H3; intros; auto.\n(* neg n1 *)\nintros; elim H4; intros; auto.\n(* neg n1 *)\nintros; elim H5; intros; auto.\n(* neg n1 *)\nintros; elim H4; intros;Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n unfold multZ.\nintros; rewrite <- mult_Z_eq_0_l; auto with zarith.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim H.\n(* neg *)\nsimpl in |- *; simpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n1 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *; reflexivity.\n(* neg n1 *)\nsimpl in |- *; reflexivity.\n(* neg n1 *)\nsimpl in |- *; reflexivity.\n(* neg n1 *)\nsimpl in |- *; reflexivity.\n(* neg n1 *)\nsimpl in |- *; reflexivity.\n(* neg n1 *)\nsimpl in |- *; reflexivity.\n(* neg n0 *)\nsimpl in |- *;Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nunfold multZ.\nintros; apply mult_le_compat_l.\nrewrite <- (tech_mult_neg (Z.neg (Z.neg (Z.neg (Z.neg (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.pos (Z.Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nauto with real.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n0 *)\nintros; elim n.\nsimpl in |- *; intro.\nelim H; intros; elim H2; intros; elim H3; intros.\nelim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros.\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim HQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n unfold multZ.\n intros; unfold multZ.\n rewrite mult_0_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ", multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim H0; intros.\n(* neg n0 *)\nintros; elim H0; intros; exact H0.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nintros; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* pos n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *; apply mult_positive_eq.\n(* neg n0 *)\nsimpl in |- *;Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim H1; intros; rewrite H2.\nunfold multZ.opp.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim H0; intros; assumption.\n(* pos n = 0 *)\nintros; elim H; intros; apply H0.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nintros; elim H1; intros; elim H2; intros; apply H0; exact H1.\n(* 0 = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nintros; elim H; intros; apply H0.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nsimpl in |- *; assumption.\n(* pos n = 0 *)\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; apply mult_IPR.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim (FcanonicLtPos_comm x y); intros; elim H0; intros; exact H0.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimpl in |- *; reflexivity.\n(* pos n1 *)\nsimplQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim H; intros; elim H0; intros; elim H0; intros; exact H1.\n(* neg n *)\nintros; elim H1; intros; exact H1.\n(* neg n = 0 *)\nsimpl in |- *; apply mult_IZR.\nexact (mult_l (Z_pos (pos n0) y)).\n(* neg n = 0 *)\nsimpl in |- *; apply mult_IZR.\nexact (mult_l (Z_pos (pos n0) y) (Z_pos (pos n0) y)).\n(* neg n = 0 *)\nsimpl in |- *; apply mult_IZR.\nexact (mult_l (Z_pos (pos n0) y)).\n(* neg n = 0 *)\nsimpl in |- *; apply mult_IZR.\nexact (mult_l (Z_pos (pos n0) y)).\n(* neg n = 0 *)\nsimpl in |- *; apply mult_IZR.\nexact (mult_l (Z_pos (pos n0) y)).\n(* neg n = 0 *)\nsimpl in |- *; apply mult_IZR.\nexact (mult_l (Z_pos (pos nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x; intros; apply H0.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim H; intros; apply H1.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* neg n = 0 *)\nsimpl in |- *; reflexivity.\n(* negQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim (FcanonicLtPos _ _ _ x); intros; elim H1; intros; exact H2; exact H2.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\n(* pos n = 0 *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim H; intros; exact H0.\n(* neg *)\nintros; elim H; intros; exact H0.\n(* neg n *)\nintros; elim H; intros; exact H1.\n(* neg n *)\nintros; elim H; intros; exact H0.\n(* neg n0 *)\nintros; elim H1; intros; exact H1.\n(* neg n0 *)\nintros; elim H1; intros; exact H1.\n(* neg n0 *)\nintros; elim H1; intros; exact H1.\n(* neg n0 *)\nintros; elim H2; intros; exact H1.\n(* neg n0 *)\nintros; elim H1; intros; exact H1.\n(* neg n0 *)\nintros; elim H1; intros; exact H1.\n(* neg n0 *)\nintros; apply neg n0; exact H1.\n(* neg n0 *)\nintros; elim H1; intros; exact H1.\n(* neg n0 *)\nintros; elim H1; intros; exact H1.\n(* neg n0 *)\nintros; elim H; intros; exact H1.\n(* negQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros x y; do 2 rewrite (tech_mult_Z (Z y) (Z.abs (pos x) y)).\nrewrite (mult_Z y) in |- *; elim (Rlt_irrefl (Z.abs x) (Z.abs y)).\nelim H; intros; rewrite (tech_mult_Z (Z.abs (nat y0) y)).\nrewrite (tech_mult_Z (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (abs (Z.abs (abs (Z.abs (Z.abs (Z.abs (Z.abs (abs (Z.abs (abs (Z.abs (Z.abs (abs (ZQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; unfold mult_Z; rewrite (mult_Z_mult x y0) (Z_mult (Z_mult (Z.neg y0) y)).\nelim (Req_dec x y); intros; exact (opp_Z y0).\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim (mult_lt_pos x y) (Z.abs y) (Z.abs y) (Z.abs x)).\nelim (Req_dec y (Z.abs y) (Z.abs y) (Z.abs y)) (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y) (Z.abs y)).\nelim (Z.abs y).\nelim (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y)).\nelim (Z.abs y) (Z.abs y).\nelim (Z.abs yQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y H; do 2 rewrite (tech_mult_Z (Z_pos y0) (Zabs_nat y0)).\nelim (Zle_or_neg (Z y0) (Zabs_nat y0) (Zabs_nat y0)).\nelim H; intros; rewrite (tech_mult_Z (Z_pos x0) (Zabs_nat y0) (Zabs_nat y0)) (Zabs_nat y0)).\nelim H; intros.\napply (tech_mult_Z (Z_pos (Zneg x0) (Zabs_nat y0) (Zabs_nat y0)) (Zabs_nat y0))).\nelim H; intros; elim H; intros; elim H0; intros; rewrite H5; assumption.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros; elim (le_ge_0 (Z y) (Zabs x) (Zabs x) (Zabs x) (Z y)).\nelim (Zcompare_trans (Z y0) (Zabs x) (Zabs x) (Z y)).\nelim (Zmax_le (Z y0) (Zabs x) (Zabs x) (Z y)).\nelim (Zmax_le (Z y0) (Zabs x) (Zabs x) (Z y)).\nelim (Zmax_le (Z y0) (Zabs x) (Zabs y)) (Zabs x)).\nelim (Zmax_lt (Z y) (Zabs x) (Zabs x) (Z y)).\nelim (Zmax_le (Z y0) (Zabs x) (Z y)).\nelim (Zmax_le (Z y0) (Zabs x) (Zabs y)); trivial.\nelim (Zmax_le (Z y) (Zabs x) (Z y)).\nelim (Zmax_le (Z_abs y) (Zabs x) (Zabs y)).\nelim (Zmax_le (Z y) (Zabs x) (Z y)).\nelim (Zmax_le (Z y) (Zabs y) (ZQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim (archimed_r x y); intros; rewrite (tech_mult_pos x y0) (Z x0) (pos y0)).\nelim (archimed_l y0); intros; rewrite (tech_mult_pos x y0) (Z y0) (pos y0)).\nelim (archimed_l y0) (pos y0) (pos y0) (pos y0)) (pos y0)).\nintros; rewrite (tech_mult_pos x y0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0)) (pos y0)) (pos y0)).\nelim (archimed_r y0) (pos y0) (pos y0)) (pos y0)).\nelim (archimed_l y0) (pos y0) (pos y0) (pos y0) (pos y0)) (pos y0)).\nelim (archimed_r y0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0) (posQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros.\nunfold multZ in |- *; rewrite (mult_comm (-Z y0) (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.opp (Z.oppQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y H; do 2 rewrite (tech_mult_pos y0 y0).\nrewrite (tech_mult_pos y0 y0) (pos y0) (pos y0) (pos y0)).\nrewrite (tech_mult_pos y0 z0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0)).\nrewrite (tech_mult_pos y0 z0) (pos y0) (pos y0)).\nrewrite (tech_mult_pos y0 y0) (pos y0) (pos y0) (pos y0) (pos y0)).\nrewrite (tech_mult_pos y0 y0) (pos y0) (pos y0) (pos y0)).\nrewrite (tech_mult_pos y0 y0) (pos y0) (pos y0)).\nrewrite (tech_mult_pos y0 y0) (pos y0) (pos y0) (pos y0)) (pos y0)).\nrewrite (tech_mult_pos y0 y0) (pos y0) (pos y0)).\nrewrite (techQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y H; do 2 rewrite (tech_mult_pos y (Z y0) (pos y0) (pos y0) (pos y0)).\nelim (mult_pos y x y0); auto.\nelim (RList_pos y0) (pos y0) (pos y0) (pos y0) (pos y0)).\nelim (RList_pos y x0) (pos y0) (pos y0)).\nelim (RList_pos y x0) (pos y0) (pos y0)) (pos y0)).\nelim (RList_pos y x0) (pos y0) (pos y0)).\nelim (RList_pos y x0) (pos y0) (pos y0) (pos y0) (pos y0)).\nelim (RList_pos y x0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0) (pos y0)) (pos y0)).\nelim (RList_pos y x0) (pos y0) (pos y0) (pos y0)).\nelim (RList_Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros x y; do 2 rewrite (tech_mult_pos y0); apply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_mult_pos.\napply Znat.inj_multQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple induction n.\nintro; elim (Req_dec (Z_pos x) (Z_pos x) (Z_pos x) (Z_pos x) (Z_pos x) (Z_pos y)) (Z_pos y)).\nelim (RList_P_pos (Z_pos x) (Z_pos y) (Z_pos y) (Z_pos y)).\nelim (RList_P_pos (Z_pos x) (Z_pos y)) (Z_pos y) (Z_pos y) (Z_pos y)) (Z_pos y)).\nelim (RList_P_pos (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y))) (Z_pos y)).\nelim (RList_P_pos (Z_pos y) (Z_pos y) (Z_pos y) (Z_pos y)) (Z_pos y)).\nelim (RList_P_pos (Z_pos y) (Z_pos y)) (Z_pos y (Z_pos y)) (Z_Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim (lt_irrefl (Z.abs n) (Z.abs n)).\nelim (Zabs_nat n) (Z.abs n).\nelim (Zabs_nat n) (Z.abs n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n) (Z.abs n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelim (Zabs_nat n).\nelimQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; apply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_l.\napply mult_integral_pos_l.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_l.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_l.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_l.\napply mult_integral_pos_l.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\napply mult_integral_pos_r.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros x; case (Rcase_abs x) (abs x) (abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs x) (abs y)).\nelim (Rcase_abs x) (abs x) (abs x) (abs y)).\nelim (Rcase_abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs x) (abs x) (abs x) (abs y)).\nelim (Rcase_abs x) (abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs x) (abs x) (abs y)).\nelim (Rcase_abs x) (abs x) (abs x)).\nelim (Rcase_abs x) (abs y) (abs (abs x) (abs y)).\nelim (Rcase_abs xQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; case (Rcase_abs x) (Rcase_abs x) (abs x) (abs x)).\nintros; case (Rcase_abs x) (Rcase_abs x) (abs y)).\nrewrite <- (abs_abs x).\nrewrite (abs_abs x).\napply (abs_abs x).\napply (abs_abs x).\nexact (abs_abs x).\napply (abs_abs x).\napply (abs_abs x).\nexact (abs_abs x).\napply (abs_abs x).\napply (abs_abs x).\napply (abs_abs x).\nrewrite <- (abs_abs x).\napply (abs_abs x).\napply (abs_abs x).\napply (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs x).\nexact (abs_abs_abs x).\nexact (abs_Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple induction n.\nsimple induction n.\nunfold multZ at 1 in |- *; rewrite (tech_mult_Z (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple induction n.\nintros; apply le_antisym; assumption.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim (Rge_opp (Z x) (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x y; rewrite (mult_comm x y) (mult_Z_mult x y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nintros n0 H; rewrite (mult_Z_mult_pos y y).\nelim (sg_involutive y).\nrewrite (mult_Z_mult_pos y y).\nelim (sg_involutive x y).\nelim (sg_involutive y).\nelim (sg_involutive x y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive x).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutive y).\nelim (sg_involutiveQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; apply mult_pos_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* pos (S y) *)\nintros x H; rewrite (tech_mult_neg y) in |- *; rewrite (tech_mult_Z y) in |- *; rewrite (tech_mult_Z y) in |- *;\n rewrite (tech_mult_Z (Z (pos y) y)) in |- *; \n rewrite (tech_mult_Z (Z (neg y) y) (succ (Z.abs (Z y)) (pos y)).\nauto.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* neg *)\nsimple induction n.\nauto.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\n(* neg *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple inductionQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\nintros x; rewrite (tech_mult_Z (Z_pos (nat_pos x) x) (pos x) (pos y)).\nrewrite (tech_mult_Z (Z_pos x) (Z_pos (nat_pos x) y)).\napply le_trans with (Z_pos (nat_pos x) y).\nrewrite (tech_mult_Z (Z_pos x) (Z_pos (nat_pos x) y)).\nrewrite <- (tech_mult_Z (Z_pos y) (Z_pos (nat_pos x) y)).\nrewrite (tech_mult_Z (Z_pos x) (Z_pos y) y)).\nrewrite (tech_mult_Z (Z_pos y) (Z_pos (nat_pos y) y)).\nrewrite (tech_mult_Z (Z_pos y) (Z_pos (nat_pos y) y)).\nrewrite (tech_mult_Z (Z_pos y) (Z_pos y) (Z_pos y)).\nrewrite (tech_mult_Z_posQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* 0 *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos *)\nsimple induction n.\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n *)\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n *)\nsimple induction n.\n(* pos *)simple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n.\n(* pos *)simple inductionQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* pos n = 0 *)\nintros x; rewrite (tech_mult_Z x) in |- *; reflexivity.\n(* pos n = 0 *)\nintros x; rewrite (tech_mult_Z (Z x) x).\nelim (pred_predn (Z x) (pos x) (pos x)).\nelim (EXPH_antisym x (Z y) (pos y))).\nelim (RList_pos_Z (Z x) (pos x) (pos y)).\nelim (RList_pos_Z x) (pos y)).\nelim (RList_pos_Z (Z x) (pos y)).\nelim (RList_pos_Z (Z x) (pos y)).\nelim (RList_pos_pos_Z (Z x) (pos y) (pos y))).\nelim (RList_pos_Z x (Z x) (pos y) (pos y))).\nelim (RList_pos_Z (Z x) (pos y))).\nelim (RList_pos_Z (Z x) (pos y)).\nelim (RList_pos_Z (Z x) (pos y) (pos y)).\nelim H.\nrewrite (RListQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* abs *)\nintros x; rewrite (tech_mult_Z (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z (Z_pos (Z_pos (Z_pos (Z (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_pos (Z_posQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* pos *)\nsimple induction n.\nreflexivity.\n(* pos(S y) *)\nsimple induction n.\nauto.\n(* pos(S x) *)\nsimple induction n.\napply (le_trans (Z_pos (pos n0) y) (pos y)).\nrewrite (tech_mult_Z (Z_pos (pos n0) y)).\napply (le_trans (Z_pos (pos n0) y)).\nrewrite (tech_mult_Z (Z_pos (Z_pos (S n0) y))).\nrewrite (tech_mult_Z (Z_pos (Z_pos (S n0) y)) (pos y)).\nrewrite (tech_mult_Z (Z_pos (Z_pos n0) y)).\nrewrite (tech_mult_Z (Z_pos (Z_pos (S n0) y)).\nrewrite (tech_mult_Z (Z_pos (Z_pos (S n0) y)) (pos y)).\nrewrite (tech_mult_Z (Z_pos (Z_pos (S n0) y)).\nrewrite (tech_mult_Z (Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* pos *)\nsimple induction n.\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n.\n(* pos *)\nsimple induction n.\n(* pos *)simple induction n.\nsimple induction n.\n(* pos *)\nsimple induction n.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction n.\n(* pos (S y) *)\nintros x; rewrite (tech_mult_pos y).\napply plus_reg_l with (Z.pos y).\napply le_O_l.\napply plus_reg_l with (Z.pos y).\napply le_O_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 744,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)simple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)simple induction n.\n(* pos (S y) *)simple induction n.\n(* pos (S y) *)simple induction n.\n(* pos (S y)Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\nsimple induction n.\n(* pos *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)\nsimple induction n.\n(* pos (S x) *)simple induction n.Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos *)\nsimple induction n.\nintros x y H; rewrite (tech_mult_neg (Z y) (pos x)); reflexivity.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_Z y); reflexivity.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S y) *)\nsimple induction n.\nauto.\n(* pos (S x) *)\nsimple induction n.\nauto.\n(* pos (S y)Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* neg *)\nsimple induction n.\nsimple induction n.\n(* neg *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple inductionQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos *)\nsimple induction n.\nintros x H0; rewrite (tech_mult_Z x (Z.pos y) (Z.pos y)); reflexivity.\n(* pos (S y) *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\nsimple induction n.\n(* pos (S y) *)simple induction n.\n(* pos (S yQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos *)\nsimple induction n.\nintros.\nrewrite (tech_mult_Z (Z.pos y)); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nrewrite (tech_mult_Z (Z.pos y) x); reflexivity.\n(* pos (S y) *)\nsimple induction n.\nrewrite (tech_mult_Z (Z.pos x) (Z.pos y)); reflexivity.\n(* pos n *)\nsimple induction n.\nrewrite (tech_mult_Z (Z.pos y) (Z.pos y)); reflexivity.\n(* pos n *)\nsimple induction n.\nauto.\nsimpl in |- *.\nrewrite (tech_mult_Z (Z.pos y) x); reflexivity.\n(* pos n *)\nsimple induction n.\nrewrite (tech_mult_Z_pos y 0); reflexivity.\nrewrite (tech_mult_Z (Z.pos y) (Z.pos y)); reflexivity.\n(* pos n *)simple induction n.\nrewrite (tech_mult_Z (Z.pos y) (Z.pos y) (Z.pos y)); reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* neg n *)\nintros x H; rewrite (tech_mult_Z x) in |- *; rewrite (tech_comm (pos y) (pos y)).\nrewrite <- (tech_opp_Z x) in |- *; auto.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nintros; rewrite (tech_mult_pos_Z y) in |- *; auto.\npattern 0 in |- *; rewrite (tech_mult_Z y) at 1 in |- *;\n rewrite (tech_mult_Z y (pos y) (pos y)); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* neg (S y) *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.\n(* pos n = 0 *)\nsimple induction n.\n(* neg n = 0 *)\nsimple induction n.Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)\nsimple induction n.\n(* pos (S y) *)simple induction n.\n(* pos (S y) *)\nsimple induction n.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros x y H; case H; case H; case H; case H; intros H; elim H; intros H; elim H; intros H; elim H; intros H; elim H; intros H; elim H; intros H; elim H; intros H; elim H; intros; elim H; intros; elim H;\n intros H; elim H; intros H; elim H; intros H; elim H; intros H; elim H; intros; elim H; intros H; elim H; intros H; elim H;\n intros H; elim H; intros; elim H; intros H; elim H; intros; elim H; intros; elim H; intros; elim H; intros H; elim H;\n intros H; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  simple induction 1; simpl; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nunfold neg in |- *.\nintro.\nintro.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros x y H0.\n  unfold sign_abs_Z; intros x y H.\n  unfold sign_abs_Z; intros x y H0.\n  unfold sign_abs_Z; intros x y H0.\n  unfold sign_abs; intros x y H1.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs; intros y H2.\n  unfold sign_abs_Z; intros x y H0.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros y H1.\n  unfold sign_abs_Z; intros x y H2.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros x y H1.\n  unfold sign_abs_Z; intros y H1.\n  unfoldQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  unfold sign_abs, neg_abs, neg_abs, neg_abs, neg_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs, neg_abs_abs, neg_abs_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs, neg_abs_abs, neg_abs_abs_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs_abs, neg_abs, neg_abs_abs, neg_abs_abs_abs_abs_abs, neg_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_absQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.\n  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.\n  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.\n  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.\n  unfold not in |- *.  unfold not in |- *.  unfold not in |- *.  unfold not in |- *. Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros x y H.\n  apply sign_abs_Z.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intros x y H.\nunfold zero.\ntauto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  unfold renf in |- *.\n  unfold OZ in |- *.\n  destruct x.\n  destruct y.\n  unfold neg in |- *.\n  destruct y.\n  unfold neg in |- *.\n  destruct y.\n  unfold neg in |- *.\n  destruct y.\n  unfold neg in |- *.\n  destruct y.\n  apply neg_abs_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_posQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n  unfold neg in |- *.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact IQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *; intro.\n exact I. intro; simpl in |- *.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\n apply (sg_pos x); auto with zarith.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact IQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *; auto with *.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\nauto with real.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x y; elim x; simpl in |- *.\nintros x y; elim H.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro x; elim x; simpl in |- *.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x; elim x; simpl in |- *.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x; elim x; simpl in |- *.\nauto with arith.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x y; elim x. \nunfold absZ in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H1.\n(* (pos n) *)\nintros; elim H1.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H1.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elimQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim y.\n(* (neg n) = (neg n). *)\nintros; elim H.\n(* (neg n) = (pos n) *)\nintros; elim H0.\n(* (neg n) = (neg n) *)\nintros; elim H.\n(* (neg n) = (neg n) *)\nintros; elim H0.\n(* (neg n) = (neg n) *)\nintros; elim H0.\n(* (neg n) = (neg n) *)\nintros; elim H0.\n(* (neg n) = (neg n) *)\nintros; elim H0.\n(* (neg n) = (neg n) *)\nintros; elim H1.\n(* (neg n) = (neg n) *)\nintros; elim H0.\n(* (neg n) = (neg n) *)\nintros; elim H1.\n(* (neg n) = (neg n) *)\nintros; elim H1.\n(* (neg n) = (neg n) *)\nintros; elim H1.\n(* (neg n) = (neg n) *)\nintros; elim H1.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros; elim x; simpl in |- *.\nintros; elim H.\n(* (pos n) *)\nintros; elim (pos n); intros; elim H.\n(* (pos n) (pos n0) *)\nintros; elim (pos n0); intros; elim H0.\n(* (pos n) *)\nintros; elim (pos n0); intros; elim H0; intros; elim H1.\n(* (pos n0) *)\nintros; elim (pos n0); intros; elim H0; intros; elim H1; intros.\n(* (pos n0) *)\nintros; elim (pos n0); intros; elim H1; intros; elim H1.\n(* (pos n0) *)\nintros; elim (pos n0); intros; elim H1; intros.\n(* (pos n0) *)\nintros; elim H1; intros; elim H1; intros; elim H1; intros; apply H1.\n(* (pos n0) *)\nintros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim x.\n(* (pos n) *)\nintros x; elim (pos_pos n0); intros; elim H1.\n(* (neg n) *)\nintros; elim (pos_pos n0); intros.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (pos_neg n0); intros.\n(* (neg n) *)\nsimpl in |- *; intros; elim H1.\n(* (neg n) *)\nsimpl in |- *; intros; elim (pos_pos n0); intros.\n(* (pos n) *)\nsimpl in |- *; intros; elim H1.\n(* (neg n) *)\nsimpl in |- *; intros; elim (pos_pos_neg n0); intros.\n(* (pos n) *)\nsimpl in |- *; intros; elim (pos_neg_neg n0); intros.\n(* (neg n) *)\nsimpl in |- *; intros; elim (pos_neg_neg n0); intros.\n(* (neg n) *)\nsimpl in |- *; intros; elim (pos_neg_neg n0); intros.\n(* (neg n) *)Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim H.\n(* (neg n) = 0 *)\nintros; elim H.\n(* (pos n) = 0 *)\nintros; elim H.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H2.\n(* (pos n) =Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros; elim H; intros; apply H.\n(* (pos n) = 0 *)\nintros; elim H0; intros; elim H1.\n(* (pos n) = 0 *)\nintros; elim H1.\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim (le_antisym n0 H1).\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim H0.\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim H0; intros; elim H1.\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim H1.\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim H1.\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim H1.\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim (lt_irrefl n0).\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim H1.\n(* (pos n) = 0 *)\nsimpl in |- *; intro; elim (le_irrefl n0).\n(* (posQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim x.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) = (pos n) *)\nintros; elim H0.\n(* (pos n) = (pos n) *)\nintros; elim H0.\n(* (pos n) = (pos n) *)\nintros; elim H0.\n(* (pos n) = (pos n) *)\nintros; elim H1.\n(* (pos n) = (pos n) *)\nsimpl in |- *; intros; elim H1.\n(* (pos n) = (pos n) *)\nsimpl in |- *; intros; elim H2.\n(* (pos n) = (pos n) *)\nsimpl in |- *; intros; elim H1.\n(* (pos n) = (pos n) *)\nsimpl in |- *; intros; elim H2.\n(* (pos n) = (pos n) *)\nsimpl in |- *; intros; elim H2.\n(* (pos n) = (pos n) *)\nsimpl in |- *; intros; elim H2.\n(* (pos n) = (pos n) *)\nsimpl in |- *; introsQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H1.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim HQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim y.\n(* (neg n) *)\nintros x y; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim x; intros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H; auto.\n(* (neg n) *)\nintros; elim H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 742,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\nauto.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x; intros; apply tech_pos_pos_pos.\n(* pos n *)\napply tech_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\n(* pos n = 1 *)\nintros; elim (le_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_O n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim (le_Sn_Sn_n n H).\n(* pos n = 0Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x; simpl in |- *; intros; elim H.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (pos n) *)\nintros; elim H1.\n(* (pos n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (pos n) *)\nintros; elim H1.\n(* (pos n) *)\nintros; elim H2.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction 1; intros; elim H.\n(* x *)\nintros; elim (le_Sn_Sn_Sn n H).\n(* neg n *)\nintros; elim H.\n(* x *)\nintros; elim H; intros; elim H.\n(* x *)\nintros; elim (le_Sn_Sn_Sn n H).\n(* abs n *)\nintros; elim H; intros; elim H.\n(* x *)\nintros; elim H; intros; elim H; intros.\n(* x *)\nintros; elim H0; intros; elim H0.\n(* x *)\nintros; elim H0.\n(* x *)\nintros; elim H1; intros.\n(* x0 *)\nintros; elim H1; intros.\n(* x0 *)\nintros; elim H0.\n(* x1 *)\nintros; elim H1; intros.\n(* x1 *)\nintros; elim H0.\n(* x1 *)\nintros; elim H2; intros; elim H1.\n(* x2 *)\nintros; elim H2; intros.\n(* x2 *)\nintros; elim H2; intros.\n(* x1 *)\nintrosQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\nunfold le_abs in |- *; intros; elim (le_Sn_Sn_n n H).\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n = 0 *)\nintros; elim H.\n(* pos n =Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x; simpl in |- *; intros; elim (le_irrefl n0); reflexivity.\n(* pos n0 *)\nsimpl in |- *; intro; elim (le_plus_minus_Sn_abs_pos_pos).\n(* 0 *)\nunfold lt_abs in |- *; intros; elim (le_minus_Sn_Sn_abs (S n0) H0); reflexivity.\n(* pos n0 *)\nsimpl in |- *; intro; elim (le_minus_Sn_abs (S n0) H0).\n(* pos n0 *)\nsimpl in |- *; intro; elim (le_minus_Sn_abs (S n0) H0); reflexivity.\n(* pos n0 *)\nsimpl in |- *; intro; elim (le_minus_Sn_abs (S n0) H0).\n(* pos n0 *)\nsimpl in |- *; intro; elim (le_minus_Sn_abs (S n0) H0); reflexivity.\n(* pos n0 *)\nsimpl in |- *; intro; elim (le_minus_Sn_abs (S n0) H0).\n(* pos n0 *)\nsimpl in |- *; intro; elimQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x; simpl in |- *; intros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nintros; elim H0.\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl in |- *; intros; elim (le_Sn_Sn_Sn_Sn n H).\n(* pos n = 0 *)\nsimpl inQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction x.\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = pos n *)\nsimpl in |- *; intro; elim (le_Sn_O n H).\n(* pos n = posQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim (pos n).\n(* 0) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H; intros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* 0) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H; intros.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0; intros.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H1; intros; elim H0.\n(* (pos n) *)\nintros; elim H1; intros; elim H1; intros.\n(* (pos n) *)\nintros; elim H1; intros.\n(* (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\n apply pred_ind1.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind3.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind3.\n apply pred_ind2.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind2.\n apply pred_ind2.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_ind2.\n apply pred_ind3.\n apply pred_ind2.\n apply pred_ind3.\n apply pred_ind3.\n apply pred_indQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold renfZ, absolute_Z, absolute_Z, absolute_Z, absolute_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_opp, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z, opp_Z,Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold bequiv; simpl; intros; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold setbit in |- *.\n  unfold Qmin; unfold unorm; unfold add_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg; unfold div_neg;Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n unfold renf0, opp0, opp0, opp0, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp2, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp2, opp2, opp1, opp1, opp2, opp1, opp1, opp1, opp2, opp1, opp1, opp2, opp2, opp1, opp1, opp1, opp1, opp1, opp1, opp2, opp1, opp1, opp1, opp2, opp1, opp1, opp1, opp1, opp2, opp1, opp1, opp1, opp1, opp1, opp1, opp1, opp2, opp1, opp1, opp1, opp1, opp2, opp1, opp1, opp1, opp2, opp1, opp2, opp1, opp1, opp2, opp1, opp1Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros x1 y2; elim y1; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n intros.\n rewrite <- (addneg_neg_neg _ _ _ H0).\n apply modneg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nunfold renamef, Zplus.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nunfold Rminus.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nrewrite Rplus_0_r.\nunfold Rminus.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nrewrite Rplus_0_r.\nunfold Rminus.\nrewrite Rplus_0_r.\nunfold Rminus.\nunfold Rminus.\nrewrite Rplus_0_r.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nrewrite Rplus_0_r.\nunfold Rminus.\nrewrite Rplus_0_l.\nunfold Rminus.\nrewrite Rplus_0_r.\nunfold Rminus.\nrewrite Rplus_0_rQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros x1 y2; case (le_dec x1 n0); auto with arith.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  apply Rplus_le_compat_l with (n := (m := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compat_l with (n := m).\n  apply Rplus_le_compatQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* neg n *)\nsimple induction n.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_involutive y).\n(* neg n0 *)\nsimple induction n.\nintros; elim x.\n(* neg n0 *)\nintros; elim x.\n(* neg n0 *)\nsimpl in |- *; apply (succ_involutive y).\napply H.\napply H.\napply H.\napply H.\napply H.\nassumption.\n(* neg n1 *)\nsimple induction n.\nintros; elim y.\n(* neg n1 *)\nsimpl in |- *; apply (succ_involutive y).\napply H.\nassumption.\n(* neg n1 *)\nsimpl in |- *; apply (succ_involutive y).\napply H.\nassumption.\n(* neg n1 *)\nsimple induction n.\nintros; elim y.\n(* neg n0 *)\nsimpl in |- *; apply (succ_involutive y).\napply H.\nassumption.\n(* neg n1 *)\nsimpl in |- *; apply (succ_involutive y).\napply H.\nassumption.\n(* neg n1 *)\nsimpleQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\nintros; elim x.\n(* neg n0 *)\nsimple destruct n.\nunfold succ in |- *; symmetry  in |- *; apply (succ_nonneg x). \n(* neg n1 *)\nsimple destruct n.\n(* neg n1 *)\nsimple destruct n.\nrewrite H.\nsimpl in |- *; apply (succ_nonneg x). \n(* neg n1 *)\nsimple destruct n.\nsimple destruct n.\n(* abs n1 *)\nsimple destruct n.\n(* abs n2 *)\nsimple destruct n.\n(* abs n1 *)\nsimple destruct n1.\n(* abs n2 *)\nsimple destruct n2.\n(* abs n2 *)\nsimple destruct n1.\n(* abs n2 *)\nsimple destruct n1.\n(* abs n2 *)\nsimple destruct n1.\n(* abs n2 *)\nsimple destruct n1.\n(* abs n2 *)\nsimple destruct n2.\n(* abs n1 *)\nsimple destruct n2.\n(* abs n2 *)\nsimple destruct n1.\n(* abs n2 *)\nsimple destruct n1.\n(* abs n2 *)\nsimple destruct n2.\n(* abs n2Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; apply pred_bigcupr.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; rewrite (pred_predn (pos x) y).\nrewrite (pred_predn (pos x) y).\nrewrite (pred_predn (pos x) y).\napply le_antisym.\napply le_trans with (pos x) (pos y).\napply le_trans with (pos x) (pos y).\napply le_trans with (pos x) (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).\napply le_trans with (pos y).Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 740,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq5.\nintro; rewrite pred_predZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Reserved Notation \"- x\" := (succ_predZ (pos x) (neg y) (neg y)).\n\n(*. *)\nintros; symmetry  in |- *; apply (succ_nonpos x); trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProofIrrelevance_eq5.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof\n                                                                                                    \n(* - 1 *)\nsimple induction x.\nintros; rewrite <- succ_predn.\nrewrite <- succ_predn.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof!.\nintros; elim x.\nrewrite /Z_lt_irrefl.\nrewrite <- H; auto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq5.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq5.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Mode.\n\tunfold succZ; intros; rewrite Rminus_0; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Declare Module Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type Type TypeQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq5.\n(*  *)\nintros; rewrite <- (succ_involutive x y) in |- *; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 741,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction n.\n(* pos *)\nsimple induction n.\nrewrite <- (tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction n.\n(* pos *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)simple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; intro.\nreflexivity.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\n(* neg n *)\nintros; elim x.\nauto.\n(* neg n0 *)\nintros; elim H.\nintros.\nrewrite H.\nauto.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nintros; rewrite (tech_add_neg_nonpos n).\nelim H; reflexivity.\n(* neg *)\nintros; rewrite (tech_add_neg_nonpos n).\nelim H; reflexivity.\n(* neg *)\nintros; rewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nunfold succ, pred, pred, pred, pred, pred, pred, pred, or.\nintros.\nrewrite pred_predn; apply pred_pred_pos.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nsimple induction n.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)simple induction 1.\n(* pos *)simple induction 1.\n(* pos *)\nsimple induction 1.\n(* pos *)simple induction 1.\n(* pos *)simple induction 1.\n(* pos *)simple induction 1.\n(* pos *)simple induction 1.\n(* pos *)simple induction 1.\n(* pos *)simple induction 1.\n(* pos *)Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; rewrite (tech_add_pos_neg_pos_pos_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 751,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\nauto.\nrewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction n.\nsimple induction n.\n(* neg n *)\nsimple induction n.\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0) n).\nintros; elim (le_or_lt (S y0)Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_double.\n(* pos n *)\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; rewrite (tech_add_pos_predZ n0).\nrewrite H; reflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n *)\n(* pos n *)simple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)simple induction nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\nsimpl in |- *; apply succ_pred_predn.\n(* (S y0) *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_nm.\n(* (S y0) *)\nsimple induction n.\nintros; rewrite (tech_add_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_posQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction n.\nauto with arith.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction n.\n(* (pos m) *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_predZ.\n(* pos *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nintros; simpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\napply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nintros; simpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_predn.\n(* pos n *)\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_predZ.\n(* pos n *)\nsimple induction n.\nintros; rewrite (tech_add_neg_sgn n0).\nelim H; reflexivity.\nintros.\nrewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_pos.\n(* neg n = 0 *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_bound.\n(* pos n = 0 *)\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_predZ.\n(* neg n = 0 *)\nsimple induction n.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_ version_pos_pos.\n(* neg n = 0 *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_pos_pos.\n(* pos n = 0 *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_pos_pos.\n(* pos n = 0 *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_pos.\n(* pos n = 0 *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_pos.\n(* pos n = 0 *)\nsimple induction n.\nsimpl in |- *; apply pred_pred_pos.\n(* pos n = 0 *)\nsimple induction n.\nsimpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 747,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nsimple induction n.\nunfold succZ in |- *; simpl in |- *; simpl in |- *; auto with arith.\nintros; rewrite tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nsimpl in |- *; apply succ_pred_predZ.\n(* pos n *)\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; simpl in |- *; apply add_0_l.\n\nreflexivity.\n(* pos n *)\nsimple induction n.\ntrivial.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\nreflexivity.\n(* pos n = 0 *)\nsimple induction n.\ntrivial.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction n.\n(* pos *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)simple induction n.\ntrivial.\n(* pos n *)simple induction n.\ntrivial.\n(* pos n *)\nsimple induction n.\ntrivial.\n(* pos n *)\nsimpleQed."
                ]
            }
        ],
        "UnifySL": [
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "port Logic.MinimunLogic.ProofTheory.Minimun.\nRequire Import Logic.MinimunLogic.ProofTheory.RewriteClass.\nRequire Import Logic.PropositionalLogic.ProofTheory.Intuitionistic.\nRequire Import Logic.PropositionalLogic.ProofTheory.DeMorgan.\nRequire Import Logic.PropositionalLogic.ProofTheory.GodelDummett.\nRequire Import Logic.PropositionalLogic.ProofTheory.Classical.\nRequire Import Logic.PropositionalLogic.ProofTheory.RewriteClass.\nRequire Import Logic.SeparationLogic.ProofTheory.SeparationLogic.\nRequire Import Logic.SeparationLogic.ProofTheory.DerivedRules.\nRequire Import Logic.SeparationLogic.ProofTheory.RewriteClass.\nRequire Import Logic.Extensions.ProofTheory.Stable.\n\nLocal Open Scope logic_base.\nLocal Open Scope syntax.\nImport PropositionalLanguageNotation.\nImport SeparationLogicNotation.\n\nClass Corable (L: Language) {minL: MinimunLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\n",
                "context_tokens": 639,
                "proof_start_offset": 2647,
                "proof_end_offset": 2756,
                "proof": "Lemma corable_truep: corable TT.\nProof.\napply (@truep_stable L _ _ Gamma corable corable_pstable); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_truep: corable TT.\nProof. apply (@prop_comm _ _ _ Gamma). Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@eq_comm _ _ _ A); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_prop L _ _ _ Gamma) in H. apply (@eq_true_l L _ _ _ Gamma) in H. apply (@eq_true_r L _ Gamma p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. intros. apply corable_truep_stable. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_prop L _ A) in H; auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_prop L _ Gammap); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@eq_true_r _ _ Gamma p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (p_stable L _ Gammap). Qed.",
                    "Lemma corable_truep: corable TT.\nProof. exact (@andp_prop L _ _ Gamma) corable_stable_stable_p. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. exact (@andp_prop L _ Gamma p). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "unLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 3431,
                "proof_end_offset": 3600,
                "proof": "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\nintros.\nrewrite andp_comm.\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_comm _ _ _ _ Gamma). Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_comm _ _ _ _ _ _ _ _ _ _ _ _ A corable_stable); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_prop L _ _ _ _ _ _ _ _ _ A B) in H. apply (@andp_prop L _ _ _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop L _ A B) in H. apply (@andp_prop LQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply corable_andp_prop. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply @prop_andp_prop_prop. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@orp_prop L _ _ A corable_gen _ corable_gen _ corable_gen _ _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen _ corable_gen_gen _ corable_gen _ corable_gen _ corable_gen _ corableQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (P_prop _ _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop _ Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) in H0. apply (P_prop Gamma) inQed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@exp_andp_sepcon L _ _ _ _ _ _ A corable_prop); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_prop L _ _ Gamma) corable_gen. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (exp_andp2 L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "ogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\nLemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 3602,
                "proof_end_offset": 3802,
                "proof": "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\nintros.\nrewrite sepcon_comm.\nrewrite (sepcon_comm x z).\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite (exp_andp2 _ _ _ _ _ ( corable_andp1 _ _ corable_sepcon1 _ ( corable_sepcon1 _ corable_andp2 _ ( corable_sepcon2 _ corable_sepcon1 _ corable_sepcon2 _ corable_andp2 _ corable_sepcon1 _ corable_sepcon2 corable_andp2 _ corable_sepcon2 corable_andp2 _ corable_sepcon1 _ corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon1 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_andp2 corable_sepcon2 corable_sepcon2 corable_andp2 corable_sepcon2 corable_sepcon1 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon1 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_sepcon2 corable_Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros. apply corable_andp_prop1.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply corable_andp_sepcon2; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros. apply corable_andp1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply (@andp_trans L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros. apply corable_andp_andp2.\n  apply corable_andp_andp_prop.\n  apply corable_andp_prop.\n  apply corable_sepcon_andp_prop.\n  apply corable_sepcon_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_sepcon_prop.\n  apply corable_andp_prop.\n  apply corable_sepcon_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_sepcon_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_andp_prop.\n  apply corable_prop.\n  apply corable_prop.\n  apply corable_andp_prop.\n  apply corable_prop.Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros. apply corable_sepcon_comm; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros. apply corable_andp_andp1; auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros. apply @derives_trans with x y; auto.\n  apply corable_andp_adjoint.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon_adjoint.\n  apply corable_sepcon1.\n  apply corable_sepcon_adjoint.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepcon1.\n  apply corable_sepconQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Env -> Env :=\n fun x => \n   match x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 737,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H.\n  apply Zis_gcd_minus; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n unfold gcd; intros.\n unfold gcd; intros.\n unfold gcd; intros.\n unfold gcd; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus_r; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_gcd_plus; intros.\n apply Zis_Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply Zis_gcd_minus; intros a b d H.\n apply Zis_gcd_minus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_minus; intros a b d H.\n apply Zis_gcd_minus; intros a b d H.\n apply Zis_gcd_minus; intros a b d H.\n apply Zis_gcd_minus; intros a b d H.\n apply Zis_gcd_minus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a b d H.\n apply Zis_gcd_plus; intros a d H.\n apply Zis_gcd_plus; introsQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n destruct (Pos.eq_dec a b d).\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus; auto.\n apply Zis_gcd_plus;Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewrite Zis_gcd_plus.\n  rewriteQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nunfold Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd, Zis_gcd,Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_mult_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_plus_distr.\n rewrite Zis_gcd_Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b); auto.\n  destruct (H a b);Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros.\n  assert (H := Zis_gcd a b d H).\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_mult_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_plus_distr_r.\n  rewrite Zis_gcd_mult_distr_r.\n  rewrite Zis_gcd_plus_distrQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (Neq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N].\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_dec a b d) as [N|N]; simpl.\n  destruct (N.eq_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 742,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b d H; case H; constructor; auto.\n  apply Zdivide_minus; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case H; constructor; intuition (auto with zarith).\n  replace b with (c-a)%Z.\n  rewrite Z.mul_comm.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a)%Z.\n  auto with zarith.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite Z.div_plus.\n  rewrite ZQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y z H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+b)%Z.\n  auto with zarith.\n  replace b with (b-a)%Z.\n  auto with zarith.\n  omega.\n  replace b with (b-b)%Z.\n  auto with zarith.\n  replace b with (b-a)%Z.\n  auto with zarith.\n  replace b with (b-a)%Z.\n  auto with zarith.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a)%Z.\n  auto with zarith.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a-a)%Z.\n  replace b with (b-a)%Z.\n  auto with zarith.\n  replace b with (b-a)%Z.\n  rewrite <- (Z_eq_false b b); auto with zarith.\n  replace b with (b-b)%Z.\n  auto with zarith.\n  apply Zis_gcd_minus.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b d H; case H; constructor; auto.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Zneq_bool_false.\n  apply Z.ge_bool_false.\n  apply Z.lt_bool_false.\n  apply Z.ge_bool_false.\n  apply Z.ge_false.\n  apply Z.ge_bool_false.\n  apply Z.lt_false.\n  apply Z.ge_bool_false.\n  apply Z.ge_false.\n  apply Z.ge_true.\n  apply Z.ge_false.\n  apply Z.ge_false.\n  apply Z.ge_false.\n  apply Z.ge_0.\n  apply Z.ge_0_0.\n  apply Z.ge_false.\n  apply Z.ge_0_r.\n  apply Z.ge_0_r.\n  apply Z.ge_0_r.\n  apply Z.ge_0_l.\n  apply Z.Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith); auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_true; auto with zarith.\n  apply Zneq_bool_true; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_true; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_false; auto with zarith.\n  apply Zneq_bool_true; auto with zarith.\n  apply Zneq_bool_false; autoQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H H; case H; constructor; intuition (auto with zarith); intros; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Z.eq_bool in H; rewrite Z.eq_bool_true in H; rewrite Z.eq_bool_false in H; rewrite Z.eq_bool_true in H; rewrite Z.eq_bool_false in H; rewrite Z.eq_false in H; rewrite Z.eq_bool_false in H; rewrite Z.eq_true in H; rewrite Z.eq_bool_true in H; rewrite Z.eq_bool_false in H; rewrite Z.eq_bool_false in H; rewrite Z.eq_false in H; rewrite Z.eq_bool_false in H; rewrite Z.eq_true in H; rewrite Z.eq_true in H; rewrite Z.eq_false in H; rewrite Z.eq_false in H; rewrite Z.eq_false in H; rewrite Z.eq_false in H; rewrite Z.eq_false in H; rewrite Z.eq_false in H; rewrite Z.eq_false in H; rewrite Z.eq_false in H; rewrite Z.eq_false inQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=z) ; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H; intro H0; apply Zcompare_Eq_eq; generalize H; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H1; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize H0; intro H0; apply Zcompare_Eq_eq; generalize HQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y); auto;\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);\ntry (intros; discriminate);Qed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Z.ge_bool in H0.\n case (x?=y); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Z.lt_bool in H0.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; auto; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Z.lt_bool.\n rewrite Z.eq_bool_false by auto; auto.  rewrite Z.eq_bool_true by auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros G q s H.\n  destruct (H H0) as [m [H0 H1 H2]; clear H0;\n    intros.\n    inversion H1; clear H2;\n    rewrite H1; intros;\n    simpl in H2; clear H3; clear H3;\n    rewrite H3; intros;\n    simpl in H2;\n    simpl in H2; clear H2;\n    destruct H1; clear H3;\n    intros e3 H4 H4;\n    simpl in H3; clear H3;\n    rewrite H4; intros;\n    simpl in H3; clear H3;\n    clear H3;\n    simpl in H3; clear H4;\n    simpl in H3; clear H3;\n    rewrite H3; intros;\n    simpl in H3;\n    simpl in H3; clear H3;\n    unfold subst; clear H3;\n    simpl in H3; clear H3;\n    simpl in H3; clear H4;\n    rewrite H4; intros;\n    simpl in H3;\n    rewrite H3;\n    simpl in H3; clear H4;\n    simpl in H3; clear H3;\n    rewrite H4; intros;\n    simplQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  assert (forall e m, e m = m -> e = m) -> m = m.\n  intros.\n  split.\n  + intros.\n    simpl.\n    rewrite e in H1; auto.\n    rewrite e in H1; auto.\n    simpl in H1; auto.\n    intros.\n    destruct H1 as [n0 H2]; simpl in H1; auto.\n    apply hoare_inversion H1; auto.\n  + intros.\n    rewrite e in H1; auto.\n    intros.\n    destruct H1 as [n0 H2]; simpl in H1; auto.\n    simpl in H1; auto.\n    rewrite e in H1; auto.\n    destruct H1 as [n0 H2]; simpl in H1; auto.\n    destruct H1 as [n0 H2]; simpl in H1; auto.\n    destruct H1 as [n0 H2]; simpl in H1; auto.\n    destruct H1 as [n0 H1 H2]; simpl in H1; auto.\n    destruct H1 as [n0 H2]; simpl in H1; auto.\n    destruct H1 as [n0 H2]; simpl in H1;Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros until post.\n  induction post.\n  intros p e' H0.\n  inv H.\n  destruct H0 as [p' [H1 H2].\n  inversion H2; clear H2; clear H2.\n  apply H2; intros e0 H1 H3;\n    destruct H2; clear H3;\n    unfold is_distributive; simpl; simpl; simpl; eauto.\n  intros r' H3 H4 H4.\n  clear H4 H5 H6.\n  simpl in H4.\n  destruct H5; clear H4.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H7.\n  rewrite <- H6.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H5.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewrite <- H6.\n  rewriteQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct H as [H|H].\n  destruct H as [H|H].\n  destruct H as [H|H].\n  destruct H as [H|H].\n  destruct H as [H].\n  exists (H0,H0); eauto with wp.\n  apply H0; auto.\n  auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct (I.eval cond p q r) as [r r].\n  constructor 1 with (x:=wp (Iwhile (P cond p)) post).\n  constructor 1 with (x:=wp (Iwhile (P cond p q)) post).\n  constructor 1 with (x:=wp (I.while (P cond p q) post).\n  constructor 1 with (x:=wp (I.while (P cond p q)) post).\n  constructor 1 with (x:=wp (I.while (P cond p q)) post).\n  constructor 1 with (x:=wp (I.while (P cond p q)) post).\n  constructor 1 with (x:=wp (I.while (P cond p q)) post).\n  constructor 1 with (x:=wp (I.while (P cond p q)) post).\n  constructor 1 with (x:=wp (I.while (P cond p q) post).\n  constructor 1 with (x:=wp (I.while (P cond p q) post).\n  constructor 1 with (x:=wp (I.while (P cond p q) post).\n  constructor 1 with (x:=wp (I.while (P cond p qQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros until p.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  assert (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q)) -> (forall q, q = q) -> (forall q, q = q)) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q = q) -> (forall q, q = q) -> (forall q, q = q) -> (forall q q q q, q = q)) -> (forall q, q = q = q) -> (forall q q, q = q) -> (forall q, q = q = q)) -> (forall q, q = q) -> (forall q, q = q) -> (forall q, q = q = q) -> (forall q, q = q)) -> (forallQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  unfold wp; intros.\n  destruct (P cond p0).\n  simpl; intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H1; auto.\n  (* return *)\n  intros.\n  destruct H1; auto.\n  (* return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H1; auto.\n  (* return *)\n  intros.\n  destruct H; auto.\n  (* return return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H1; auto.\n  (* return *)\n  intros.\n  destruct H0; auto.\n  (* return return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H1; auto.\n  (* return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H0; auto.\n  (* return *)\n  intros.\n  destruct H; auto.Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros until q.\n  intros until q.\n  generalize H; intro; case H; clear H.\n  apply H0; intros;\n    simpl; auto.\n  destruct H; clear H; intros H0;\n    unfold is_or; auto.\n  destruct H; clear H; intros H0;\n    generalize H0; intro; case H0; clear H0; intros;\n    generalize H0; intros; elim H0; clear H0; intros;\n    generalize H0; intros; case H0; clear H0; intros H1;\n    generalize H0; intro; case H0; clear H1; intros;\n      generalize H0; intro; case H0; clear H1; intros;\n      generalize H0; intros; case H1; clear H0; intros;\n      generalize (H0 (H1 (H2 (H2 (H3 (H3 (H3 (H3 (H3 (H4 (H4 (H4 (H4 (H5 (H4 (H5 (H6 (H4 (H7 (H5 (H6 (H5 (H7 (H6 (H7 (H7 (H8 (HQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold hoare; intros until post H; intros.\n  apply hoare_complete.\n  intros until post H0.\n  apply hoare_complete.\n  intros until post; intros.\n  destruct H0 as [l [r0 [r1 [r1 [r2 [r3 [r4 [r5 [r5 [r6 [r6 [r6 [r6 [r7 [r7 [r6 [r8 [r7 [r7 [r7 [r6 [r7 [r7 [r7 [r7 [r7 [r7 [r7 [r7 [r7 r7 [r8]]]]]].\n  econstructor; eauto with hoare_complete.\n  intros until post H0.\n  simpl in H0.\n  apply hoare_complete.\n  intros until post H1; intros.\n  destruct H0 as [l [r [r1 [r3 [r6 [r8 [r7 [r6 [r7 [r6 [r7 [r7 [r8 [r8 [r7 [r8 [r7 [r7 [r7 [r7 [r8 [r7 [r7 [r7 [r9 [Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "nd \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold post |= p.\n  intros [x y] ; simpl; intros;\n    destruct (H0 _ H).\n  (* [Iwhile] *)\n  intros H0;\n    destruct (H0 _ H1).\n  (* Nwhile *)\n    intros.\n    destruct (H0 _ _ H1).\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0.\n    apply H0Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold post |= p.\n intros.\n destruct r; simpl in *.\n- destruct r; destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n- destruct r; simpl in *.\n-Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct H as [n H].\nunfold prog in H.\nrevert p; case_eq (eval cond p q); intros.\ndestruct H as [n H].\ndestruct H as [n H].\nrewrite H in H0.\ncontradict H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\nrewrite H0 in H0.\ncontradict H0.\nrewrite H0 in H0.\ncontradict H0; clear H1;\n    rewrite H0 in H0.\nrewrite H0 in H0.\ncontradict H0.\nrewrite H0 in H0.\ncontradict H0.\nrewrite H0 in H0.\ncontradict H0.\nrewrite H1 in H0.\ncontradict H0; auto.\nrewrite <- H0 in H0.\nrewrite <- H0 in H0.\ncontradict H0.\nrewrite H1 in H0.\ncontradict H0.\nrewrite H0 in H0.\ncontradict H.\nrewrite <- H0 in H0.\ncontradict H0.\nrewrite <- H0 in H0.\ncontradict H0.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  unfold post |= q |= q |= q.\nProof.\n  intros until q.\n  intros q.\n  case H0; intros H0; inversion_clear H0.\n  destruct H0; inversion_clear H1; subst.\n  inversion_clear H0.\n  (* k is *)\n  simpl.\n  case_eq (m0 && pre)); simpl; tauto.\n  (* k = k *)\n  case_eq (m0 && pre) with (x:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (y:=e) (yQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  destruct p; simpl in *.\n  intros.\n  destruct p; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct H0; simpl in *.\n  destruct HQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintros.\nunfold pre |= punat; intros.\napply H; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n unfold post |= q |= q |= q |= q |= q |= q |= q |= q |= q |= q |= q |= q & m |= q |= q |= q ** q |= q ** q |= q |= q |= q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** q ** ** ** q ** q ** ** q ** ** q ** q ** ** q ** q ** q ** ** q ** q ** q ** ** ** q ** ** ** ** ** ** ** q ** ** ** ** ** q ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros s p post H.\n functional induction post.\n intros; simpl; split.\n  (* Sif [Iif] *)\n  simpl; split.\n  - (* Pif [Iif] *)\n  - (* Pif [Iif] *)\n    simpl; split.\n    - (* Pif [Iif] *)\n    simpl; split.\n      - (* Pif [Iif] *)\n      simpl; split.\n      - (* P is a [Iif] *)\n        simpl; split.\n      - (* P has an [Iif] *)\n        simpl; split.\n        - (* P has an inductive case *)\n        - (* P has an inductive case *)\n        - (* P has an inductive case *)\n        - (* P has a [Iif] *)\n        simpl; auto.\n - (* P has an inductive case *)\n        simpl; split.\n        - (* P has an inductive case *)\n        simpl; auto.\n        - (* P has a [Iif] *)\n        simpl; auto.\n - (* P has a [Iif] *)\n        simpl; split.\n        - (* P has an inductive case *)\n        simpl; auto.\n        - (* P has a [Iif] *)\n        simpl; split.Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold post |= p.\n intros.\n unfold post |= p.\n intros.\n apply box_intro.\n apply H.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n unfold hereditary; intros; case_eq (M.eval cond) in *.\n destruct (E.eval cond e) as (e,e) & H0;\n    intros H; inversion H0; subst.\n  (* no case *)\n  intros H0 H0; inversion H0; subst.\n  (* no case *)\n  intros H0; inversion H0; subst.\n  (* no case *)\n  intros H0; inversion H0; subst.\n  (* no case *)\n  intros H1; inversion H0; subst.\n  (* no case *)\n  intros H1; inversion H0; subst.\n  (* no case *)\n  intros H1; inversion H1; subst.\n  (* no case *)\n  intros H1; inversion H0; subst.\n  (* no case *)\n  intros; inversion H0; subst.\n  (* no case *)\n  intros; inversion H0; subst.\n  (* no case *)\n  intros; inversion H0; subst.\n  (* no case *)\n  intros H1; inversion H1; subst.\n  (* no case *)\n  intros; inversion H0; subst.\n  (* no case *)\n  intros; inversion H1; subst.\n  (* no caseQed."
                ]
            }
        ],
        "huffman": [
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \n",
                "context_tokens": 322,
                "proof_start_offset": 2063,
                "proof_end_offset": 2308,
                "proof": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; apply le_minus_O_O_n_S.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\napply lt_minus_O_Sn.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; elim n; clear n; clear n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; intro; clear n; intro; elim n; clear n; intro; elim n; intro; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n; clear n; intro; elim n;Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; induction m as [| m IH]; simpl.\nintros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H; clear H; intros m H; elim H;Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\n  Proof.\n    intros.\n    apply le_minus_O_O_Sn.\n    exact (le_Sn_Sn n).\n    exact (le_Sn_Sn n).\n  Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  unfold lt, lt, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, le, leQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m; induction m; simpl in |- *; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m p; case m; simpl; auto; intros; try easy.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m.\napply lt_minus_O_n.\napply lt_minus_O_n.\napply le_plus_O_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply lt_plus_O_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply lt_minus_O_n.\napply lt_minus_O_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply le_minus_n.\napply le_minus_O_n.\napply le_minus_n.\napply le_minus_O_n.\napply le_minus_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply le_minus_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply le_minus_O_n.\napply le_minus_Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H.\nunfold lt_n.\napply lt_minus_O_n.\napply le_minus_n_O_n.\napply lt_minus_O_n.\napply le_minus_n_O_O_n.\napply lt_minus_O_n.\napply le_minus_n_O_Sn.\napply lt_minus_n_O_n.\napply lt_minus_O_n_O_Sn.\napply lt_minus_O_n.\napply lt_O_O_n_Sn.\napply lt_minus_O_n.\napply lt_minus_O_Sn.\napply le_minus_O_n.\napply lt_minus_O_Sn.\napply lt_minus_O_n.\napply le_minus_n_O_Sn.\napply le_minus_O_n.\napply le_minus_O_n.\napply le_minus_n_O_Sn.\napply le_minus_n_O_Sn.\napply le_minus_O_n.\napply le_minus_O_nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 414,
                "proof_start_offset": 2311,
                "proof_end_offset": 2459,
                "proof": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_minus.\nintros a b H1; case (Rle_or_lt a b); auto.\nintros m1; Contradict H1; auto with arith.\nintros m2; Contradict H1; auto with arith.\nintros n1 H1; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1 H1; rewrite H1; auto with arith.\nintros m1 n2 H1; Contradict H1; auto with arith.\nintros m1; rewrite H1; rewrite H1; auto with arith.\nintros m1 H2; rewrite H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1; Contradict H1; auto with arith.\nintros m1 H1; rewrite H1; rewrite H1; auto with arith.\nintros m1 HQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_minus_O_Sn.\nintros; elim n; simpl in |- *; auto with arith.\nintros m1 H1; case m2; simpl in |- *; auto.\nintros m1 H2; absurd (m1 + m2) with (m2 + n1 + n1) by ring.\nintros m2; absurd (m1 + m2) by ring.\nintros m1 H2; absurd (m1 + m2) by ring.\nintros m1 H2; absurd (m1 + m2) by ring.\nintros m1 H3; absurd (m1 + m2) by ring.\nintros m2 H3; absurd (m1 + m2) by ring.\nintros m1 H3; absurd (m1 + m2) by ring.\nintros m2 H3; absurd (m2 + m1) by ring.\nintros m2 H4; absurd (m2 + m2) by ring.\nintros m1 H3; absurd (m1 + m2) by ring.\nintros m2; absurd (m1 + m2) by ring.\nintros m2 H4; absurd (Qed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using le_minus_O.\nintros n m H1; case n; simpl in |- *; auto.\nintros m1 H2; rewrite (mult_distr_l a b); auto with arith.\nintros m1 H2; elim n0; simpl in |- *; auto with arith.\nintros m1 H2; apply Rec; apply le_O_n; auto.\nintros m1 H3; apply Rec; apply lt_S_n; auto.\nintros m1 n2 H3; apply Rec; apply lt_S_n; auto.\nintros m1 H3; apply Rec; apply lt_S_n; auto.\nintros m2 H3; apply Rec; apply lt_S_n; auto.\nintros m1 H3; apply Rec; apply lt_S_n; auto.\nintros m1 H3; apply Rec; apply lt_S_n; auto.\nintros m2 H3; apply Rec; apply lt_S_n; auto.\nintros m1 H4; apply Rec; apply lt_S_n; auto.\nintros m1 H4; apply Rec; apply lt_S_n; autoQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_minus_O.\nintros n m H1; rewrite <- (le_minus_O _ H1); auto.\nintros m2; Contradict H1; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_n_O; simpl in |- *; auto.\nintros m1 n2; elim n; simpl in |- *; auto.\nintros m2 H1; elim n2; simpl in |- *; auto.\nintros m2; elim n2; simpl in |- *; auto.\nintros m2 H1; elim n3; simpl in |- *; auto.\nintros m2 H3; elim n3; simpl in |- *; auto.\nintros m2 H3; elim n3; simpl in |- *; auto.\nintros m2 H3; elim n3; simpl in |- *; auto.\nintros m2 H4; elim n3; simpl in |- *; auto.\nintros m2 H3; elim n3; simpl in |- *; auto.\nintros m2 H4; elim n3; simpl in |- *; auto.\nintros m2 H4; elim n4; simpl in |- *; auto.\nintros m2 H4; elim n3; simpl in |- *; auto.\nintros m2 H4; elim n3; simpl in |- *; auto.\nintros m2 H4; elim n4; simpl in |- *; auto.\nintros m2 H4Qed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_minus.\nintros a b; case b; simpl in |- *; auto.\nintros m1 n1 H2; elim H; simpl in |- *; auto.\nintros m1 H2; Contradict H1; auto with arith.\nintros m1 n1 n2 H3; elim H; simpl in |- *; auto.\nintros m2 H3; Contradict H1; auto with arith.\nintros m2 H3; Contradict H1; auto.\nintros m2 H3; Contradict H2; auto.\nintros m2 H4; rewrite H4; rewrite H4; auto.\nintros m1 n2 H4; rewrite H4; rewrite H4; auto.\nintros m1 H3; Contradict H1; auto with arith.\nintros m1 H3; rewrite H4; rewrite H4; auto.\nintros m2 H4; Contradict H1; auto.\nintros m1 H4; Contradict H3; auto.\nintros m2; Contradict H4; auto.\nintros m1 H4; Contradict H1; auto.\nintros m1; Contradict H1; auto with arith.\nintros m1 H3; Contradict H1Qed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_trans with (m := m).\nintros n m; elim n; simpl in |- *; auto.\nintros m n0 n0 H1; Contradict H1; auto with arith.\nintros m1 n0 H2; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1 n0 H1; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1 H2; Contradict H1; auto with arith.\nintros m1; Contradict H1; auto with arith.\nintros m2; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m2 H1; Contradict H1; auto with arith.\nintros m1 H1; Contradict H1; auto with arith.\nintros m2; Contradict H1; auto with arith.\nintros m2; Contradict H1; auto.\nintros m1 H1; Contradict H1; auto with arith.\nintros m1; Contradict H1; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using le_minus_O_n_O.\nintros a b; elim n; simpl in |- *; auto with arith.\nintros m2; apply Rec; auto.\nintros m1 Rec m2; elim n; simpl in |- *; auto with arith.\nintros m1 Rec m1 Rec m2; elim n0; simpl in |- *; auto with arith.\nintros m2 Rec m1 Rec m2 Rec m2 Rec m2 Rec m1 Rec m1 Rec m2 Rec m1 Rec m2 Rec m1 Rec m2 Rec m2.\nintros m n0 Rec m2 Rec m1 Rec m1 Rec m2 Rec m2 m2 Rec m2 Rec m2.\nintros m1 Rec m1 Rec m2 Rec m1 m2 Rec m2.\nintros m Rec m1 Rec m1' Rec m1 m2 Rec m2.\nintros m Rec m1 Rec m2 m2 Rec m1 Rec m2 m1 Rec m1' Rec m2.\nintros m Rec m1 Rec m1 m2 Rec m2' Rec m1 m2 Rec m2.\nintros m Rec m1 Rec m2 m2 Rec m2 m2Qed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_minus_O.\nintros n m; elim n; simpl in |- *; auto with arith.\nintros m1 n2; rewrite H1; auto with arith.\nintros m1 H1; elim n; simpl in |- *; auto with arith.\nintros m1 n2; apply Rec; apply lt_O_n; auto.\nintros m1 n2 n3 H1; apply Rec; apply lt_S_n; auto with arith.\nintros m1 n2; rewrite H2; auto with arith.\nintros m1 n2; elim n3; simpl in |- *; auto with arith.\nintros m2; apply Rec; apply lt_S_n; auto with arith.\nintros m1 m2; rewrite H1; auto with arith.\nintros m2 H2; apply Rec; apply lt_S_n; auto with arith.\nintros m1 n3 H3; rewrite H1; auto with arith.\nintros m1; elim n3; simpl in |- *; auto with arith.\nintros m1 n3 H3; elim n4; simpl in |- *; auto with arith.\nintros m2; apply Rec; apply leQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using lt_minus_O_n.\nintros n m H1 H2; elim H; simpl in |- *; auto with arith.\nintros m1 H2; Contradict H1; auto with arith.\nintros m1 H2; Contradict H1; auto with arith.\nintros m2 H3; Contradict H1; auto with arith.\nintros m2 H2; Contradict H2; auto with arith.\nintros m1 H2; rewrite H1; auto with arith.\nintros m2; rewrite H1; rewrite H1; auto with arith.\nintros m1 H3; rewrite H1; auto with arith.\nintros m1 H3; Contradict H1; auto with arith.\nintros m1 H3; Contradict H1; auto with arith.\nintros m1 H3; apply H2; auto with arith.\nintros m2 H3; Contradict H3; auto with arith.\nintros m1 H3; Contradict H3; auto with arith.\nintros m1 H3; Contradict H3; auto with arith.\nintros m1 H3; Contradict H3; auto with arith.\nintros m1 H3; Contradict H3; auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "e *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 439,
                "proof_start_offset": 2462,
                "proof_end_offset": 3023,
                "proof": "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using lt_minus_simpl_4; auto.\nintros a b c H; absurd (0 <= c - a + b + c) by auto.\nintros n H0; absurd (0 <= c - a + b + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + c + cQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using le_minus_simpl_r; auto.\nintros m1 H2; Contradict H1; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using lt_minus_simpl; auto.\nintros m; elim n; simpl in |- *; auto.\nintros m1 m2; case n; simpl in |- *; auto.\nintros m1 H2; elim n0; simpl in |- *; auto.\nintros m1 n1 H2; elim n0; simpl in |- *; auto.\nintros m1 n2; case n0; simpl in |- *; auto.\nintros m1 n2 H2; elim n0; simpl in |- *; auto.\nintros m1 m2; case n0; simpl in |- *; auto.\nintros m1 n2; case n0; simpl in |- *; auto.\nintros m1 n2; case n0; simpl in |- *; auto.\nintros m1 n2; case n0; simpl in |- *; auto.\nintros m1; case n0; simpl in |- *; auto.\nintros m1 n2; case n0; simpl in |- *; auto.\nintros m1 m2; case n0; simpl in |- *; auto.\nintros m1 n2 H1 H3; case n0; simpl in |- *; auto.\nintros m1 n2Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using lt_minus_simpl_4; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros m1 n0 H2; case b; simpl in |- *; auto.\nintros m1 H1; case b; simpl in |- *; auto.\nintros m1 m2 H2; case b; simpl in |- *; auto.\nintros m1 H2; case b; simpl in |- *; auto.\nintros m2 H3; case b; simpl in |- *; auto.\nintros m2 H3; case b; simpl in |- *; auto.\nintros m2 H3; case b; simpl in |- *; auto.\nintros m1 m2 H4; case b; simpl in |- *; auto.\nintros m2 H3; case b; simpl in |- *; auto.\nintros m1 H3; case b; simpl in |- *; auto.\nintros m2 H4; case b; simpl in |- *; auto.\nintros m2 H3; case b; simpl in |- *; auto.\nintros m2 H4; case b; simpl in |- *; auto.\nintros m2 H4; case b; simpl in |- *;Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using lt_minus_simpl_4.\nintros a b c H; case b; simpl in |- *; auto.\nintros m1 n2 n2 n2 H2; Contradict H1; auto.\nintros m1 n2; rewrite (mult_simpl_l n1 n2 H1); rewrite (mult_simpl_r n2 n1 n2); rewrite (mult_simpl_r n1 n2); rewrite (mult_simpl_l n1 n2); rewrite (mult_simpl_r n1 n2); rewrite (mult_simpl_r n1 n2); rewrite (mult_simpl_l n1 n1 n2); rewrite (mult_simpl_r n1 n2); rewrite (mult_simpl_l n2 n1); rewrite (mult_simpl_l n2 n1); rewrite (mult_simpl_r n1 n2); rewrite (mult_simpl_r n2); rewrite (mult_simpl_l n2 n2); rewrite (mult_simpl_l n2 n1); rewrite (mult_simpl_l n2); rewrite (mult_simpl_l n2 n2); rewrite (mult_simpl_r n2Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c; case b; simpl in |- *; auto.\nintros m1; case b; simpl in |- *; auto.\nintros n1 n2 H1; case b; simpl in |- *; auto.\nintros m2; case b; simpl in |- *; auto.\nintros m1 n2 H2; case b; simpl in |- *; auto.\nintros m1 H1; case b; simpl in |- *; auto.\nintros m1 m2 H2; case b; simpl in |- *; auto.\nintros m1 m2 H2; case b; simpl in |- *; auto.\nintros m1 H2; case b; simpl in |- *; auto.\nintros m1 n2 H2; case b; simpl in |- *; auto.\nintros m1 n1 H2; case b; simpl in |- *; auto.\nintros m1 m2; case b; simpl in |- *; auto.\nintros m2 H3; case b; simpl in |- *; auto.\nintros m1 m2; case b; simpl in |- *; auto.\nintros m1 n2 H3; case b; simpl in |- *; auto.\nintros m1 n2 HQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros; elim a; simpl in |- *; auto.\nintros n H0; Contradict H; auto.\nintros n H1; Contradict H1; auto.\nintros m1 H1; Contradict H1; auto.\nintros m1 H1 H2; Contradict H1; auto.\nintros n0 H1; Contradict H1; auto.\nintros n0 H1; Contradict H1; auto.\nintros m1 H1; Contradict H1; auto.\nintros m2; Contradict H1; auto.\nintros m1; Contradict H1; auto.\nintros m1 H1; Contradict H1; auto.\nintros m1 H1; Contradict H1; auto.\nintros m1 H1; Contradict H1; auto.\nintros m1 H1; Contradict H1; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using le_minus_simpl in |- *; auto.\nintros m1 n2; case n; simpl in |- *; auto.\nintros m2; case n; simpl in |- *; auto.\nintros m1 n2; case n2; simpl in |- *; auto.\nintros m1 n2; case n2; simpl in |- *; auto.\nintros m1 n2; case n2; simpl in |- *; auto.\nintros m2; case n2; simpl in |- *; auto.\nintros m1 n2; case n2; simpl in |- *; auto.\nintros m1; case m1; simpl in |- *; auto.\nintros m2; case n2; simpl in |- *; auto.\nintros m1; case n2; simpl in |- *; auto.\nintros m1 n2; case m2; simpl in |- *; auto.\nintros m1 n2; case n2; simpl in |- *; auto.\nintros m1 n2; case n2; simpl in |- *; auto.\nintros m2; case n2; simpl in |- *; auto.\nintros m2; case m1; simpl in |- *; auto.\nintros m2Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using lt_minus_simpl; auto.\nintros a b c H0; case b; simpl in |- *; auto.\nintros m1 n1 H2; case b; simpl in |- *; auto.\nintros m1 n2; case b; simpl in |- *; auto.\nintros m2 H1; case b; simpl in |- *; auto.\nintros m2; case b; simpl in |- *; auto.\nintros m1 n2 H1; case b; simpl in |- *; auto.\nintros m1 H2; case b; simpl in |- *; auto.\nintros m2 n2 H3; case b; simpl in |- *; auto.\nintros m1 n2; case b; simpl in |- *; auto.\nintros m1 n2 H3; case b; simpl in |- *; auto.\nintros m2 n1 H3; case b; simpl in |- *; auto.\nintros m1 n2 H3; case b; simpl in |- *; auto.\nintros m1 n2 H4; case b; simpl in |- *; auto.\nintros m2 H4; case b; simpl in |- *; auto.\nintros m2; case b;Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using lt_minus_simpl_l.\nintros a b c H; case b; simpl in |- *; auto.\nintros m1; elim H; simpl in |- *; auto.\nintros n1 n2; elim m1; simpl in |- *; auto.\nintros m1 H; elim m1; simpl in |- *; auto.\nintros m2 H1; elim m2; simpl in |- *; auto.\nintros m1 H1; elim m2; simpl in |- *; auto.\nintros m2; elim m1; simpl in |- *; auto.\nintros m1 n2 H1; elim m1; simpl in |- *; auto.\nintros m2; elim m2; simpl in |- *; auto.\nintros m1 H1; elim m2; simpl in |- *; auto.\nintros m1 H1; elim m2; simpl in |- *; auto.\nintros m1 n2; elim m2; simpl in |- *; auto.\nintros m1 m2 H1; elim m2; simpl in |- *; auto.\nintros m1 H2; elim m2; simpl in |- *; auto.\nintros m2 n2 H2 H3; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                      *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \n",
                "context_tokens": 524,
                "proof_start_offset": 3026,
                "proof_end_offset": 3298,
                "proof": "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H0 H0; case b; simpl in |- *; auto.\nintros m1 H2; elim n; simpl in |- *; auto.\nintros m1 H2; elim n0; simpl in |- *; auto.\nintros m1 H2; elim n0; simpl in |- *; auto.\nintros m1 H2; elim n0; simpl in |- *; auto.\nintros m2 H2; elim n0; simpl in |- *; auto.\nintros m1 H2; elim n0; simpl in |- *; auto.\nintros m1 H3; elim n0; simpl in |- *; auto.\nintros m1 H3; elim n0; simpl in |- *; auto.\nintros m1 H3; elim n0; simpl in |- *; auto.\nintros m1 H3; elim n0; simpl in |- *; auto.\nintros m1 H3; elim n0; simpl in |- *; auto.\nintros m2 H3; elim n0; simpl in |- *; auto.\nintros m2; elim n0; simpl in |- *; auto.\nintros m2 H3; elim n0; simpl in |- *;Qed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl_l; auto with arith.\napply plus_minus_simpl_l; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H1; elim H; simpl in |- *; auto.\nintros n H1; elim n; simpl in |- *; auto with arith.\nintros n H1 H1; elim n; simpl in |- *; auto with arith.\nintros n1 H2; elim n; simpl in |- *; auto with arith.\nintros n2 H2; elim n2; simpl in |- *; auto with arith.\nintros n1 H2; elim n2; simpl in |- *; auto with arith.\nintros n2; elim n2; simpl in |- *; auto with arith.\nintros n1 H2 H2; elim n2; simpl in |- *; auto with arith.\nintros n1 H2; elim n2; simpl in |- *; auto with arith.\nintros n1 H2 H2; elim n2; simpl in |- *; auto with arith.\nintros n2 H3; elim n3; simpl in |- *; auto with arith.\nintros n1 H3; elim n2; simpl in |- *; auto with arith.\nintros n1 H3; elim n3; simpl in |- *; auto with arith.\nintros n1 H3; elimQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H0.\napply plus_minus_simpl_r; auto with arith.\napply plus_minus_simpl_r; auto with arith.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc_reverse.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_Qed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H0.\napply plus_minus_simpl; auto.\napply plus_minus_simpl; auto.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using lt_minus_simpl_r; auto with arith.\nintros a b c H0 H1.\ncase b; simpl in |- *; auto with arith.\nintros n1 n2.\nrewrite plus_minus_simpl_l; auto with arith.\nintros n1 n2 H0 H1.\ncase b; simpl in |- *; auto with arith.\nintros n1 H0 H1 H1.\ncase b; simpl in |- *; auto with arith.\nintros n1 H1 H2.\ncase b; simpl in |- *; auto with arith.\nintros n1 H1 H2; case b; simpl in |- *; auto with arith.\nintros n1 H2.\ncase b; simpl in |- *; auto with arith.\nintros n1 H2 H1.\ncase b; simpl in |- *; auto with arith.\nintros n1 H1 H2.\ncase b; simpl in |- *; auto with arith.\nintros n1 H2; case b; simpl in |- *; auto with arith.\nintros n1 H2.\ncase b; simpl in |- *; auto with arith.\nintros n1 H2 H2 H3.\ncaseQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H.\napply plus_minus_simpl; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H0 H0.\napply plus_minus_simpl_l; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using le_minus_simpl.\nintros a b c H0; case b; simpl in |- *; auto.\nintros n H1; elim H; simpl in |- *; auto.\nintros n1 H2; elim H; simpl in |- *; auto.\nintros n1 H2; elim H; simpl in |- *; auto.\nintros n1 H2; elim H; simpl in |- *; auto.\nintros n1 H2; elim H1; simpl in |- *; auto.\nintros n1 H2; elim H1; simpl in |- *; auto.\nintros n1 H2; elim H1; simpl in |- *; auto.\nintros n1 H2; elim H1; simpl in |- *; auto.\nintros n1 H3; elim H1; simpl in |- *; auto.\nintros n1 H3; elim H1; simpl in |- *; auto.\nintros n2 H3; elim H; simpl in |- *; auto.\nintros n1 H3; elim H2; simpl in |- *; auto.\nintros n1 H4; elim H2; simpl in |- *; auto.\nintros n1 H3; elim H3; simpl in |- *;Qed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; case b; simpl in |- *; auto with arith.\nintros m1 n2; case b; simpl in |- *; auto.\nintros m1 n2; case b; simpl in |- *; auto.\nintros m1 n2; case b; simpl in |- *; auto.\nintros m1 n2 H1; case b; simpl in |- *; auto.\nintros m2 n2 H2; case b; simpl in |- *; auto.\nintros m1 n2 H3; case b; simpl in |- *; auto.\nintros m1 n3; case b; simpl in |- *; auto.\nintros m1 n3; case b; simpl in |- *; auto.\nintros m1 n2; case b; simpl in |- *; auto.\nintros m2 n3; case b; simpl in |- *; auto.\nintros m2 n3 H4; case b; simpl in |- *; auto.\nintros m2 n3 H4; case b; simpl in |- *; auto.\nintros m1 n3 H4; case b; simpl in |- *; auto.\nintros m2 n3; case b; simpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "****************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \n",
                "context_tokens": 593,
                "proof_start_offset": 3392,
                "proof_end_offset": 3555,
                "proof": "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof using eq_bool_dec.\n    induction a; simpl in |- *; auto.\n    intros n0 H1 H2; elim H1; simpl in |- *; auto.\n    intros n0 H1; elim H1; simpl in |- *; auto.\n    intros n1 H1; elim H1; simpl in |- *; auto.\n    intros n0 H1; elim H1; simpl in |- *; auto.\n    intros n0 H1; elim H2; simpl in |- *; auto.\n    intros n0 H1; elim H2; simpl in |- *; auto.\n    intros n1 H2; elim H2; simpl in |- *; auto.\n    intros n1 H2; elim H2; simpl in |- *; auto.\n    intros n1 H1 H2; elim H2; simpl in |- *; auto.\n    intros n1 H2; elim H2; simpl in |- *; auto.\n    intros n1 H2; elim H2; simpl in |- *; auto.\n    intros n1 H2; elim H3; simpl in |- *; auto.\n    intros n2 H2; elim H3; simpl in |- *; auto.\n    intros n1 H3; elim H3; simplDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof using eq_bool_dec.\n  intros a b.\n  destruct b.\n  rewrite eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof using eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_decDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof using eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_decDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof using eq_bool_dec.\n  exact eq_bool_dec.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof using eq_bool_dec.\nintros a b c H0.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_plus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simpl.\napply plus_minus_simplDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\nDefinition eq_bool : forall a b : bool, {a = b} + {a <> b} + {a <> b}.\n\nLemma eq_bool_eq : forall a b : bool, {a = b} + {a <> b} + {a <> b} + {a <> b}.\nProof using eq_bool_dec. Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  intros a b c H; elim b; simpl in |- *; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n\nLemma eq_bool_dec : forall a b : bool, {a <> b} + {a <> b} + {a <> b}.\nProof using eq_bool_dec. Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\n  Proof using eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_dec.\n  apply eq_bool_decDefined."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 3769,
                "proof_end_offset": 4044,
                "proof": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b H H H.\napply le_bool_correct1; auto with arith.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using le_bool_correct1. Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using le_bool_correct2. Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using le_bool_correct1. Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a bQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using le_bool_correct1. Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using le_bool_correct1. Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a bQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using le_bool_correct1. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4047,
                "proof_end_offset": 4291,
                "proof": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using le_bool_correct2.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintrosQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n1; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl inQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl inQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *;Qed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H H; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.Qed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros; elim n; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl inQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simplQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl inQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; elim H1; simpl in |- *; auto.\nintros n0 H1; elim n0; simpl in |- *; auto.\nintros n0 H1; elim n0; simpl in |- *; auto.\nintros n0 H2; elim n0; simpl in |- *; auto.\nintros n0 H2; elim n0; simpl in |- *; auto.\nintros n0 H1; elim n0; simpl in |- *; auto.\nintros n0 H2; elim n0; simpl in |- *; auto.\nintros n0 H2; elim n0; simpl in |- *; auto.\nintros n0 H3; elim n0; simpl in |- *; auto.\nintros n0 H3; elim n0; simpl in |- *; auto.\nintros n0 H3; elim n0; simpl in |- *; auto.\nintros n0 H3; elim n0; simpl in |- *; auto.\nintros n0 H3; elim n0; simpl in |- *; auto.\nintros nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \nTheorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4294,
                "proof_end_offset": 4558,
                "proof": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H0; elim n0; simpl in |- *; auto.\nintros n0 H1 H1; elim n0; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H1 H1; rewrite H1; auto.\nintros n0 H1 H2; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H2 H2; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H1; rewrite H1; auto.\nintros n0 H0; rewrite H1; auto.\nintros n0 H1; rewrite H0;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using le_bool.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n1 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 HQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0; case b; simpl in |- *; auto.\nintros n0 H1 H1; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl in |- *; auto.\nintros n1 H1; case b; simpl in |- *; auto.\nintros n0 H1 H2; case b; simpl in |- *; auto.\nintros n0 H2; case b; simpl inQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim b; simpl in |- *; auto.\nintros n0 H1; apply lt_irrefl with (n := a); auto.\nintros n0 H1; apply lt_S_n; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H0 H1; inversion H1.\nintros n0 H1 b; elim a; simpl in |- *; auto.\nintros n0 H1 b H1; elim a; simpl in |- *; auto.\nintros n0 H0; elim a; simpl in |- *; auto.\nintros n0 H1 b H1; apply lt_S_n; auto.\nintros n0 H2; elim a; simpl in |- *; auto.\nintros n0 H1 b; elim a; simpl in |- *; auto.\nintros n0 b H0; elim a; simpl in |- *; auto.\nintros n0 H1 b1; elim a; simpl in |- *; auto.\nintros n0 H1 b1 b1; elim a; simpl in |- *; auto.\nintros n0 H1 b1 b1 H2; elim a; simpl in |- *; auto.\nintros n0 b1 b1 H2; elim a; simpl in |- *; auto.\nintros n0 b1 b1 H1; elim a; simpl in |- *; auto.\nintros n0 b1 b1 H2; elim a; simpl in |- *;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1 H2; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H2; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H2; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H1; apply le_bool_correct2.\nintros n0 H2; apply le_bool_correct2.\nintros n0 H2; apply le_boolQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n0 H0; apply lt_S_n; auto.\nintros n0 H1; apply le_trans with (1 := H1); auto.\nintros n0 H1; apply lt_S_n; auto.\nintros n0 H1; apply le_trans with (1 := H1); auto.\nintros n0; apply le_trans with (1 := H1); auto.\nintros n0 H1; apply le_trans with (1 := H2); auto.\nintros n0 H1; apply le_trans with (1 := H1); auto.\nintros n0 H1; apply le_trans with (2 := H1); auto.\nintros n0 H1; apply le_trans with (1 := H2); auto.\nintros n1 H1; apply le_trans with (2 := H1); auto.\nintros n0 H2; apply le_trans with (2 := H); auto.\nintros n0 H1; apply le_trans with (1 := H1); auto.\nintros n0 H1 H2;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H1; elim a; simpl in |- *; auto.\nintros n0 H1; elim a; simpl in |- *; auto.\nintros n0 H1 H2; elim a; simpl in |- *; auto.\nintros n0 H1 H2; elim a; simpl in |- *; auto.\nintros n0 H1 H2; elim a; simpl in |- *; auto.\nintros n0 H1; elim a; simpl in |- *; auto.\nintros n0 H1; elim a; simpl in |- *; auto.\nintros n0 H1; elim a; simpl in |- *; auto.\nintros n0 H1; elim a; simpl in |- *; auto.\nintros n0 H2; elim a; simpl in |- *; auto.\nintros n0 H1; elim a; simpl in |- *; auto.\nintros n0 H2; elim a; simpl in |- *; auto.\nintros n0 H2; elim a; simpl in |- *; auto.\nintros n0 H2; elim a0; simpl in |- *; auto.\nintros n0 H2; elim a0; simpl in |- *; auto.\nintros n0Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H; case b; simpl in |- *; auto.\nintros n0; elim n0; simpl in |- *; auto.\nintros n0 H1; elim n0; simpl in |- *; auto.\nintros n0 H1 H1; rewrite H1; rewrite H1; rewrite H1; rewrite H2; rewrite H1; rewrite H1; rewrite H1; rewrite H2; rewrite H1; rewrite H1; rewrite H2; rewrite H1; rewrite H1; rewrite H2; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1; rewrite H1;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "Proof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\n",
                "context_tokens": 736,
                "proof_start_offset": 7607,
                "proof_end_offset": 7753,
                "proof": "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros a l1; case l1; simpl in |- *; auto.\nintros a l1 H2; case H.\nintros a1 H1; case H; auto.\nintros a2 H1; case H1; auto.\nintros a2 H2; case H1; auto.\nintros a2 H1; case H1; auto.\nintros a1 H2; case H1; auto.\nintros a2 H1; case H2; auto.\nintros a1 H2; case H1; auto.\nintros a2 H1; case H1; auto.\nintros a2; case H1; auto.\nintros a2 H3; case H2; auto.\nintros a1 H1; case H2; auto.\nintros a2 H2; case H3; auto.\nintros a3 H3; case H3; auto.\nintros a3 H3; case H3; auto.\nintros a1; case H3; auto.\nintros a3; case H4; auto.\nintros a3; case H3; auto.\nintros a4 H3; case H3; auto.Qed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l2; simpl in |- *; auto.\nintros a l1 l2 H; case H; auto.\nintros a l1 H1.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros a l1 l2 H; rewrite H; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros a l1 l2; elim l1; simpl in |- *; auto.\nintros a l1 l2; elim l2; simpl in |- *; auto.\nintros a1 l2; elim l2; simpl in |- *; auto.\nintros a1 l2; elim l2; simpl in |- *; auto.\nintros a1 l2; elim l2; simpl in |- *; auto.\nintros a1 l2 H2; elim l2; simpl in |- *; auto.\nintros a1 l2; elim l2; simpl in |- *; auto.\nintros a1 l2; elim l2; simpl in |- *; auto.\nintros a1 l2; elim l2; simpl in |- *; auto.\nintros a2; elim l3; simpl in |- *; auto.\nintros a2 l2; elim l3; simpl in |- *; auto.\nintros a2 a2 l3; elim l3; simpl in |- *; auto.\nintros a1 l3 H1; elim l3; simpl in |- *; auto.\nintros a2 l3; elim l3; simpl in |- *; auto.\nintros a1 l3; elimQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros.\napply length_app; auto.\napply length_app; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros; apply length_app.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; generalize a; clear a l1 l2; induction l1; simpl in |- *; auto.\nintros a1 l2 H2; case H; simpl in |- *; auto.\nintros a1 l2 H2; case H; simpl in |- *; auto.\nintros a1 l1 l2 H2 H3; case H; simpl in |- *; auto.\nintros a1 l2 H3; case H; simpl in |- *; auto.\nintros a1 l2 H3; case H; simpl in |- *; auto.\nintros a1 l2 H4; case H; simpl in |- *; auto.\nintros a1 l2 H3; case H; simpl in |- *; auto.\nintros a1 l2 H3; case H; simpl in |- *; auto.\nintros a1 l2; case H; simpl in |- *; auto.\nintros a1 l3; case H; simpl in |- *; auto.\nintros a1 l1 H4; case H; simpl in |- *; auto.\nintros a2 l3; case H; simpl in |- *; auto.\nintros a1 l3 H4; case HQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros a l1 l2; elim l1; simpl in |- *; auto.\nintros a1 l2 H; elim l1; simpl in |- *; auto.\nintros a1 l2; elim l1; simpl in |- *; auto.\nintros a2 l1; elim l1; simpl in |- *; auto.\nintros a2 l2; elim l1; simpl in |- *; auto.\nintros a2 l2; elim l2; simpl in |- *; auto.\nintros a2 l2; elim l1; simpl in |- *; auto.\nintros a2 a3; elim l1; simpl in |- *; auto.\nintros a2 l1 H0; elim l2; simpl in |- *; auto.\nintros a2 H0; elim l1; simpl in |- *; auto.\nintros a3 l2; elim l2; simpl in |- *; auto.\nintros a3 l1 H1 H2; elim l1; simpl in |- *; auto.\nintros a3 l2; elim l3; simpl in |- *; auto.\nintros a4; elim l1; simpl in |- *; auto.\nintros a3 l2; elimQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l2; simpl in |- *; auto.\nintros a l2 H; elim l1; simpl in |- *; auto.\nintros a l2 H; elim l1; simpl in |- *; auto.\nintros a l2 H; elim l1; simpl in |- *; auto.\nintros a l2 H; elim l1; simpl in |- *; auto.\nintros a l1; elim l2; simpl in |- *; auto.\nintros a l2 H; elim l1; simpl in |- *; auto.\nintros a l2 H; elim l1; simpl in |- *; auto.\nintros a l2; elim l2; simpl in |- *; auto.\nintros a l1 H; elim l2; simpl in |- *; auto.\nintros a l1 H; elim l2; simpl in |- *; auto.\nintros a l2 H; elim l2; simpl in |- *; auto.\nintros a l2 H; elim l2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\nTheorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 731,
                "proof_start_offset": 7756,
                "proof_end_offset": 7948,
                "proof": "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros l2; elim l1; simpl in |- *; auto.\nintros l1 H1; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1; elim l2; simpl in |- *; auto.\nintros l1; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1; elim l2; simpl in |- *; auto.\nintros l2; elim l2; simpl in |- *; auto.\nintros l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *;Qed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros l2 H0; elim l2; simpl in |- *; auto.\nintros l1 H1; elim l2; simpl in |- *; auto.\nintros l2; elim l2; simpl in |- *; auto.\nintros l2; elim l1; simpl in |- *; auto.\nintros l2 H0; elim l2; simpl in |- *; auto.\nintros l1 H1; elim l2; simpl in |- *; auto.\nintros l1 H1; elim l2; simpl in |- *; auto.\nintros l2 H1; elim l2; simpl in |- *; auto.\nintros l1 H2; elim l2; simpl in |- *; auto.\nintros l1 l2 H1 H2; elim l2; simpl in |- *; auto.\nintros l2 H1 H1; elim l2; simpl in |- *; auto.\nintros l2 H1 H2; elim l2; simpl in |- *; auto.\nintros l2; elim l2; simpl in |- *; auto.\nintros l1 H1 H2; elim l2; simplQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2 H1 H2; case H2; auto.\nintros l1 H2; case H3; auto.\nintros l1 l2 H1 H3; case H3; auto.\nintros l1 l2 H3 H3; case H3; auto.\nintros l1 l3 H3; case H3; auto.\nintros l1 H3; case H3; auto.\nintros l2; case H3; auto.\nintros l3; case H3; auto.\nintros l3 H3; case H3; auto.\nintros l3; case H4; auto.\nintros l3 H3; case H3; auto.\nintros l4 H4; case H4; auto.\nintros l3 H4 H4; case H4; auto.\nintros l4; case H4; auto.\nintros l4 H4 H4; case H4; auto.\nintros l4 H4; case H4; auto.\nintros l4; case H5; auto.\nintros l4; caseQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros; case H; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 H; elim l1; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "                                                   *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\n",
                "context_tokens": 488,
                "proof_start_offset": 2578,
                "proof_end_offset": 2793,
                "proof": "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros.\npose proof (IHn_gt _ _ _ _ _ _ H).\nassert (H : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat by omega.\nassert (H' : 0 <= n)%nat byQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros n; destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl; auto.\n  destruct n as [|n IHn]; simpl;Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  induction n; simpl; intros.\n  rewrite!IH, IH, IH, IH, IH, IH, IH, IH, IH, IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,?IH,Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t.\nassert (H : (n <= n)%nat) by (unfold height_pred; omega).\nassert (H : (n <= n)%nat).\n  {\n    unfold height; rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  induction n; simpl; intros.\n  - intros.\n    - intros.\n    - intros.\n      rewrite <- (IH (n + 1)) at 2; rewrite <-!minus_distr_r.\n      destruct (lt_dec n (S (S n))) eqn:E; simpl.\n        rewrite!minus_distr_r.\n        destruct (lt_dec n (S (S n)) eqn:E; simpl.\n        rewrite!minus_distr_r.\n        destruct (lt_dec n (S (S n)))) eqn:E; simpl.\n        rewrite!minus_distr_r.\n        destruct (lt_dec n (S n)) eqn:E; simpl.\n        rewrite!minus_distr_r.\n        destruct (lt_dec n (S (S n))) eqn:E; simpl.\n        rewrite!minus_distr_r.\n        destruct (lt_dec n (S n)) eqn:E; simpl.\n        rewrite!minus_distr_r.\n        destruct (le_dec n (S (S n))) eqn:E; simpl.\n        rewrite!minus_distr_r.\n        destruct (le_dec n (S (S n)))) eqn:E; simpl.Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t.\nrewrite -sumsumsumsumsumsumsumsumsumsumsumsumsumsumsumsum sumsumsumsumsumsumsumsumsumsumsumsumsumsumsumsumsumsumsum sumsumsum sumsum sumsumsumsum sumsum sumsumsumsumsumsumsumsum sum sumsumsum sum sumsum sumsumsumsumsumsum sumsum sum sumsumsum sum sum sumsumsum sum sum sum sumsum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sum sumQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros n; induction n; simpl in *; intros; try discriminate; intros; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH n); simpl in *; try discriminate.\n  destruct (IH nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n; apply height_pred_ordered_l; auto with arith.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  induction l; intros.\n  - intros.\n    - intros.\n      + intros.\n      + intros.\n      + destruct (eq_dec_dec_points (S n) (S (S n))) as [H | H].\n        + intros.\n          + intros.\n          + intros.\n            rewrite H.\n            + intros.\n            + intros.\n            rewrite H.\n            rewrite H.\n            + intros.\n            rewrite H.\n            + intros.\n              rewrite H.\n            + intros.\n            rewrite H.\n            rewrite H.\n            rewrite H.\n            + intros.\n            rewrite H.\n            rewrite H.\n            + intros.\n            rewrite H.\n            + intros.\n            rewrite H.\n            + intros.\n            rewrite H.\n            rewrite H.\n            + intros.\n            rewrite H.\n            + intros.\n            rewrite H.\n            rewrite H.\n            rewrite H.\n            intros.\n            rewrite H.\n            rewrite H.\n            intros.\n            rewrite H.\n            rewrite H.\n            assumption.\n            + intros.\n            rewrite H.\n            rewrite H.\n            intros.\n            rewrite H.\n            rewrite H.\n            rewrite H.\n            intros.\n            rewrite H.\n            rewrite H.\n            intros.\n            rewrite H.\n            rewrite H.\n            rewriteQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\ninduction n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [| n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\ndestruct n as [|n IHn]; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "CULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\n",
                "context_tokens": 533,
                "proof_start_offset": 2832,
                "proof_end_offset": 3143,
                "proof": "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using_pred_split.\nintros n t; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n; rewrite!IH; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n t H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n m H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using height_pred_lt_iff.\nintros n t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n t H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n m H; elim H; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "c., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\nTheorem height_pred_not_nil1 :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.\n\n(* The cover list is never empty *) \n",
                "context_tokens": 594,
                "proof_start_offset": 3182,
                "proof_end_offset": 3491,
                "proof": "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case l1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n t H; elim H; simpl in |- *; auto.\nintros n0 ln1 t2; case ln1 t2; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n t l H; elim H; simpl in |- *; auto.\nintros n0; discriminate.\nintros n0; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n; apply (iffP idP); simpl in |- *; auto.\nintros; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0 H1; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0 H1; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0 H1; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0 H1; discriminate.\nintros n0; discriminate.\nintros n0 H1; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0; discriminate.\nintros n0 H1; discriminate.\nintros n0; discriminate.\nintros n0;Qed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n m; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0; case ln.\nintros n0Qed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n H; elim H; simpl in |- *; auto.\nintros n0 H; discriminate.\nintros n0 ln1 H; discriminate.\nintros n0 ln1 ln2 t1 t2 t2; discriminate.\nintros n0 ln1 t2 t2.\ndestruct (lt_dec n0 t2 t3 t3 t3) as (t3,t3) as (t3,t4) (t4,t5) (t4,t5) (t6,t6) (t6,t7) (t8,t10,t10) (t11,t11) (t11,t11) (t11,t12) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (t22,t22) (tQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \n",
                "context_tokens": 244,
                "proof_start_offset": 1591,
                "proof_end_offset": 1678,
                "proof": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b.\nexists (a, b).\nintro.\nexists (a, b).\nsplit.\nsplit.\napply H.\napply H.\napply H.\napply H.\nassumption.\napply H.\nassumption.\napply H.\napply H.\nassumption.\napply H.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H'; elim H'; intros a b H'; elim H'; intros a b H'; elim H'; intros a b H'; elim H'; intros a b H'; elim H'; intros a b H'; elim H'; intros a b H'; elim H'; intros a b H' H'; elim H'; intros a b H' H' H' H' H' H';\n apply H'; auto with *.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\n intros a b H' H' H'0.\nunfold Contradict H'0.\napply inj_le_weak; auto with arith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b.\napply (H0 a).\napply (H1 a).\napply (H1 a).\napply (H2 a).\napply (H1 a).\napply (H2 a).\napply (H2 a).\napply (H1 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H3 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H2 a).\napply (H3 a).\napply (H2 a).\napply (H2 aQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b.\ncase b; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b H H; elim H; clear H; intros a b H0 H0 H1 H2; elim H; clear H; intros a b H0 H1 H2; elim H2; clear H2; intros a b H1 H2 H3; elim H3; clear H3; intros a b H3 H3; elim H4; clear H4; intros a b H4 H4; elim H4; clear H4; intros a b H4 H4; elim H4; clear H5; intros a b H4 H4; elim H4; clear H5; intros a b H4 H4 H5 H5; elim H5; clear H4; intros a b H5 H5; elim H4; clear H5; intros a b H5 H4; elim H4; clear H5; intros a b H5 H5; elim H5; clear H5; intros a b H4 H4 H5 H6; elim H5; clear H6; intros a b H5 H6; elim H5; clear H5; intros a b H5; elim H5; clear H5; intros a b HQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros.\napply elim H0; auto with arith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H H; case (a * b); intros H.\napply H; auto with zarith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintros a b.\napplyContradict H.\napply inv1.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply inv2.\napply invQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H;\n intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H; elim H; intros a b H0; elim H; intros a b H H; elim H; intros a b H0 H; elim H; intros a b H0 H0; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 277,
                "proof_start_offset": 1681,
                "proof_end_offset": 1759,
                "proof": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nintros a b H.\napply Contradict1; auto.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \nTheorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 305,
                "proof_start_offset": 1762,
                "proof_end_offset": 1830,
                "proof": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed."
                ]
            }
        ],
        "PolTac": [
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\nTheorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n\n",
                "context_tokens": 668,
                "proof_start_offset": 1675,
                "proof_end_offset": 2086,
                "proof": "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate); auto.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 < nat_of_P p1)%nat; auto with arith.\napply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1; auto.\nintros n1 H1; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n2 H1; inversion H2; auto.\nintros n2; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n2 H2; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n2 H2; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n2; inversion H1; auto.\nintros n2 H2; inversion H1; auto.\nintros n1 H2; inversion H1; auto.\nintros n1 H1; inversion H2; auto.\nintros n1 H1; inversion H1; auto.\nintros n2 HQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nle_le_n; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; intros n m; case m; auto with arith.\nintros m1 n1 H2; case m; auto with arith.\nintros m1 m2; case m1; auto with arith.\nintros m1 m2; case m1; auto with arith.\nintros m2; case m1; auto with arith.\nintros m2; case m2; auto with arith.\nintros m1 n2 H1; case m1; auto with arith.\nintros m2; case m2; auto with arith.\nintros m1 m2; case m2; auto with arith.\nintros m1; case m1; auto with arith.\nintros m2; case m2; auto with arith.\nintros m1 n1 H1; case m2; auto with arith.\nintros m2; case m1; auto with arith.\nintros m1; case m1; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2 H1; case m1; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2; case m2; autoQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; unfold N.compare; simpl; try (intros; discriminate); auto with arith.\nintros n m H1 H2; elim H1; intros; elim H2; intros; discriminate; discriminate; discriminate; discriminate; discriminate.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply lt_N_le_compat; auto with arith.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_lt_rev; auto with arith.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros m1; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m2; case m1; auto with arith.\nintros m1; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m2; case m3; auto with arith.\nintros m2; case m2; auto.\nintros m2; case m3; auto with arith.\nintros m2Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; simpl; try (intros; discriminate); auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto withQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_le; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).\nintros x y z H; rewrite H; auto.\nQed.\n\nTheorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).\nintros x y z H1 H2; red; apply Rge_trans with z; auto.\nQed.\n\n(* For RGroundTac *)\n\n\n",
                "context_tokens": 746,
                "proof_start_offset": 32895,
                "proof_end_offset": 33883,
                "proof": "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; case p; auto.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zpos (xI p2)) at 2; replace (Zpos (xI p2)) with (2 * (Zpos p2) +1)%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1);ring.\nintros p2 Rec; pattern (Zpos (xO p2)) at 2; replace (Zpos (xO p2)) with (2 * (Zpos p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zneg (xI p2)) at 2; replace (Zneg (xI p2)) with ((2 * (Zneg p2) + -1))%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p2 Rec; pattern (Zneg (xO p2)) at 2; replace (Zneg (xO p2)) with (2 * (Zneg p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; apply Z2R_correct; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; apply Rle_ge; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite H; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite H; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite H; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; red; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; red; intro; apply Rge_trans with z; auto with real.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite H; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; case p; intros p0 H1; simpl in H1; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\n",
                "context_tokens": 6,
                "proof_start_offset": 24,
                "proof_end_offset": 107,
                "proof": "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros.\n generalize (H x y); intro.\n generalize (H x y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.\n generalize (H y); intro.Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  unfold parity, parity.\n  intros; rewrite <- (pow2_l _ _ H).\n  apply pWF_pure_atom_cmp_eq; auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  unfold mult.\n  intros.\n  destruct (le_gt_cases x y); auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y z; elim (Rlt_irrefl 0).\nintros x y; apply Rlt_le_trans with (x + y).\napply Rlt_le_trans with (y + y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y + z + z).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (x + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (y + y).\napply Rlt_le_trans with (Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H.\nunfold Qminus; simpl; auto.\ndestruct (conj_sym x y).\nrewrite (conj_sym x y).\nrewrite (conj_sym x y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym x y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (conj_sym y).\nrewrite (Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H; rewrite <- H.\ndestruct x; simpl in *; auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  induction x; simpl; auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  intros x y H; apply (Rminus_eq x y); auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with y; auto.\n  apply Rlt_le_trans with x; auto.\n  apply Rlt_le_trans with yQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  intros x y H. elim H; intro H.\n  rewrite H in H.\n  rewrite <- (succ_double x y H).\n  apply (succ_double x y H).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y H).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_double x y).\n  apply (succ_doubleQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  intros x y H.\n  rewrite H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite H.\n  rewrite <- H.\n  rewrite <- H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 109,
                "proof_end_offset": 188,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros x y H.\ncut (y <= x + y).\nintro.\napply (Qle_trans _ _ (x + y)).\nrewrite <- (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qlt_trans _ (x + y)).\napply (Qle_trans _ (x + y)).\napply (Qlt_trans _ (x + y)).\napply (Qlt_trans _ (x + y)).\napply (Qle_trans _ (Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nreplace (x + y) with (y + x) by (apply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (2 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (2 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_test2 with (1 := H).\napply pols_testQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (pow2r x y).\nrewrite <- (pow2r x y).\napply pow_pow2r.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros x y H.\napply (H0 x).\napply (H0 x).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply pols_test2.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_2_test2_2_test2_test2_test2_2_test2_test2_2_test2_2_test2_2_test2_test2_test2_2_test2_2_test2_2_test2_test2_test2_2_test2_test2_2_test2_test2_test2_test2_2_test2_test2_2_test2_test2_test2_test2_test2_test2_test2_2_test2_test2_test2_2_test2_test2_2_test2_test2_test2_test2_test2_test2_test2_test2_testQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter_iter2_iter2_iter2_iter2_iter_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter2_iter_iter2_iter2_iter2_iter2_iter_iter2_iter2_iter.\n\nTheoremiter_iter_iter2_iter2_iter_iter_iter_iter2_iter2_iter2_iter_iter_iter2_iter_iter_iter_iter2_iter_iter2_iter2_iterQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test22_test2_test2_test2_test2_test2_2_test2_test2_2_test22_test2_test2_test2_test22_test2_test2_2_test2_2_test2_test2_2_test2_test2_2_test2_test2_2_test2_test2_test2_test2_2_test2_test2_test2_test2_test22_test2_2_test2_test2_test2_test2_test2_test2_test2_2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 84,
                "proof_start_offset": 191,
                "proof_end_offset": 311,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y) ; trivial.\nrewrite <- (pows_test2l x y)Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nunfold pols_test3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H4.\nrewrite H3 in H3.\nrewrite H3 in H2.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H4 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H3 in H3.\nrewrite H4 in H3.\nrewrite H3 in H3.\nrewrite H4 in H3.\nrewrite H3 in H3.\nrewrite H4 in H4.\nrewrite H3 in H3.\nrewriteQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pows_test3 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) at 1.\nrewrite <- (pows_test2 x y) atQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite (Qdiv_plus_distr_l x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_l x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qmult_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y) in H.\nrewrite (Qdiv_plus_distr_r x y)Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros x y.\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2l x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x y).\napply (pow2r x yQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (mult_plus_distr_l (x + y) * (y + x) * (y + y)).\nrewrite <- (mult_plus_distr_l (x + y) * (y + y) * (y + y)).\nrewrite <- (mult_distr_l (x + y) * (y + x) * (y + y)).\nrewrite <- (mult_distr_l (x + y) * (y + x) * (y + y)).\nrewrite <- (mult_distr_l (x + y) * (y + y) * (y + y)).\nrewrite <- (mult_distr_l (x + y) * (y + y) * (y + y)).\nrewrite <- (mult_distr_l (x + y) * (y + x) * (y + y)).\nrewrite <- (mult_distr_l (x + y) * (y + y) * (y + x * y)).\nrewrite <- (mult_distr_l (x + y) * (y + y)).\nrewrite <- (mult_distr_l (x + y) * (y + yQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pols_test3.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pows_test3 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y x y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y x y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y y).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 145,
                "proof_start_offset": 314,
                "proof_end_offset": 436,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (mult_comm (x * y) * (y + y) * (x + y) * (y + z) * (x + y) * (x + y) * (y + y) * (x + z) * (x + y) * (y + z) * (x + z) * (x + z) * (x + y) * (y + z) * (x + z) * (x + z) * (y + z) * (x + z) * (x + z) * (x + z) * (y + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) *Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s x y) at 1; try assumption.\nintros.\nrewrite <- (pows_test2s xQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintross.\nrewrite <- (pows_test4 (fun x y => x + y + x * y + z) + z.\nintross.\nrewrite <- (pows_test4 (fun x y => x + y + z) + z * (x + z) * (y + z) * (x + z) * (y + z)).\nintross.\nrewrite <- (pows_test4 (fun x y => x + y + z * (y + z) * (x + y) * (x + z) * (y + z) * (x + z) * (y + z)).\nintross.\nrewrite <- (pows_test4 (fun x y => x + z * (y + z) * (x + z) * (x + z) * (x + z) * (y + z) * (x + z) * (y + z) * (x + z) * (y + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + z) * (x + zQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pows_test3 x y).\nrewrite <- (pows_test3 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test3 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test3 x y).\nrewrite <- (pows_test3 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test5 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test6 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nrewrite <- (pows_test4 x y).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pows_test6 (fun x y => (x + y + y) * (y + y) * (y + y) * (y + z) * (y + z) * (y + y) * (y + y) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (x + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (y + z) * (x + z) * (y + z) * (x + z) * (y + z) * (y + z) * (y + z) * (y + z) * (z + z) * (y + z) * (y + z) * (y + z) * (y + z) * (z +Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (multQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nunfold pols'.\napply pols_test5; auto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite (pol_auxs3 _ x y) at 1.\napply (pol_auxs2 _ x y) at 1.\napply (pol_auxs2 _ x y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ x y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y) at 1.\napply (pol_auxs2 _ y)Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj xconj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conjconj (conj (conjconj (conj (conj (conj (conjconj (conj (conj (conj (conj (conj x (conj x)))) (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj xconj (conj (conj (conj (conj (conj (conj x (conj (conj (conj x))) (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conjconjconj (conj (conj (conj (conj (conjconj (conj (conj (conjconj (conjconj (conj (conj (conjconj (conj (conj (conjconj (conj (conjconj (conjconj (conjconj xconj (conj (conj (conjconj (conj (conj (conj (conj (conjconj (conj (conjconj (conj (conj (conj (conj xconj x)))Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 208,
                "proof_start_offset": 439,
                "proof_end_offset": 515,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite (pows_test3 x y).\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm y y).\napply (mult_comm x y).\napply (mult_comm y y).\napply (mult_comm y y).\napply (mult_comm y y).\napply (mult_comm x y).\napply (mult_comm y).\napply (mult_comm y y).\napply (mult_comm y y).\napply (mult_comm y z).\napply (mult_comm x y).\napply (mult_comm y y).\napply (mult_comm y).\napply (mult_comm y).\napply (mult_comm y).\napply (mult_comm x y).\napply (mult_comm y).\napply (mult_comm y).\napply (mult_comm y).\napply (mult_comm y y).\napply (mult_comm y).\napply (mult_comm y).\napply (mult_comm x y).\napply (mult_comm y).\napply (mult_comm y).\napply (mult_comm y).\napply (Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite (pows_test3 x y).\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <-Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nunfold pols.\nrewrite <- (pow2s_test5 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nrewrite <- (pow2s_test6 x y).\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pWF_sound1.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <-Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (pows_test2 (fun x y => x * y + y * y + y) * (y + z)).\nintros.\napply pols_test2; auto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply pols_test2 with (1 := x + y * y).\nintros.\nreplace (x + y + y) with (y + y * (y + y) * (y + y))).\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 244,
                "proof_start_offset": 517,
                "proof_end_offset": 613,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite (pow2_test2 x y).\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite <- (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\napply (mult_comm x y).\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply ( pol_test2_3_4_4_5_6_6_6_6_6_6_6_6_7_6.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite <- (iter1_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 y y).\nrewrite <- (iter2_test2 y).\nrewrite <- (iter2_test2 y y).\nrewrite <- (iter2_test2 y x).\nrewrite <- (iter2_test2 y).\nrewrite <- (iter2_test2 y).\nrewrite <- (iter2_test2 x y).\nrewrite <- (iter2_test2 y).\nrewrite <- (iter2_test2 y).\nrewrite <- (iter2_test2 y).\nrewrite <- (iter2_test2 y y).\nrewrite <- (iter2_test2 y y).\nrewrite <- (iter2_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (pow2r (l1 + y * y) (y * y)).\nintros.\nrewrite (pow2r (r1 + y) (y * y)).\nintros.\napply (pow2r (r1 + y * y)).\nintros.\napply (pow2r (r1 + y * y * y)).\nintros.\napply (pow2r (r1 + y * y * y * y)).\nintros.\napply (pow2r (r1 + y * y * y * y)).\nintros.\napply (pow2r (r1 + y * y * y * y * y)).\nintros.\napply (pow2r (r2 + y * y * y)).\nintros.\napply (pow2r (r1 + y * y * y)).\nintros.\napply (pow2r (r1 + y * y * y)).\nintros.\napply (pow2r (r1 + y * y * y)).\nintros.\napply (pow2r (r1 + y * y * y)).\nintros.\napply (pow2r (r1 + y * y * yQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite (pows_test2l x y); auto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nreplace (x * y) with (x * y * y).\napply pow_mult2r.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite <- (pow2_test2_test2_test2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nintros.\nsimpl.\ntrivial.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (pow2r_test2l x y).\nintros.\napply (pow2r_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).\nrewrite <- (pow2l_test2l x y).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 290,
                "proof_start_offset": 617,
                "proof_end_offset": 735,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H0.\napply pol_test2 with (2 := (2 := (2 := (2 := (2 := (2 := (2 := (2 := (2 := (2, (2, (2, (2))) in in *; clearbody H0.\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pol_test2.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (pow2s_test2s x y z).\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nrewrite <- (pow2f_test2 _ H0).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pol_test2.\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pol.\nrewrite pol_test2.\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nsimpl.\nrewrite <- (mult_comm x y).\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <-Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pol.\nring.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pol.\napply pol_test2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\n",
                "context_tokens": 33,
                "proof_start_offset": 123,
                "proof_end_offset": 285,
                "proof": "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros. rewrite <- mult_comm. apply plus_le_compat_l. apply plus_le_compat_r.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros.\n  assert (H: n <= p * m = p * m).\n  {\n    destruct p as [n p].\n    assert (H: n < m) by omega.\n    destruct p as [n].\n    destruct p as [n p].\n    exists (n, p).\n    exists (n, p).\n    exists (n, p).\n    exists (n, p).\n    exists (n, p).\n    exists (n, p).\n    exists (n, p).\n    split.\n    exists (n, p).\n    split.\n      exists (n, p).\n    exists (n, p).\n    exists (n, p).\n    split.\n      exists (n, p).\n    exists (n, p).\n    exists (n, p).\n    split.\n      exists (n, p).\n    split.\n      exists (n, p).\n    split.\n      exists (n, p).\n    exists (n, p).\n    split.\n      exists (n, p).\n    split.\n      exists (n, p).\n    split.\n      exists (n, p).\n    split.\n      exists (n, p).\n    split.\n      exists (n, p).\n      split.\n     Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros n m p H.\n  apply Nat2Z_le_compat.\n  now apply Nat2Z_le_compat.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros.\n  assert (forall n m p : nat, n < m -> p < p * m) by (intros; omega).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewriteQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros. unfold mult.\n  rewrite mult_0_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_lQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros.\n  unfold mult_le. intros.\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_l 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_r 2).\n  rewrite (mult_distr_l 2).\n  rewriteQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p; destruct p; simpl; auto with arith.\nintros n m p H; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m; rewrite H; auto with arith.\nintros n m; rewrite H; auto with arith.\nintros m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros n m p; rewrite H; auto with arith.\nintros m p; rewrite H; auto with arith.\nintros n m p H; rewrite H; auto with arith.\nintros n m p; rewriteQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros n m p H; case (le_lt_dec n m) as [H|H]; auto.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.\n  apply Nat2Z.inj_le_mono.Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n  intros.\n  generalize (mult_compat_l n m).\n  induction m.\n  - simpl.\n    - simpl.\n      - simpl.\n      - simpl.\n      - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - rewrite - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - rewrite - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simpl.\n        - simplQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\n",
                "context_tokens": 98,
                "proof_start_offset": 287,
                "proof_end_offset": 396,
                "proof": "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n m p H; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_l.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_r.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p; repeat rewrite (mult_comm p); apply mult_lt_compat_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\n",
                "context_tokens": 142,
                "proof_start_offset": 398,
                "proof_end_offset": 535,
                "proof": "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; induction m as [| p]; simpl; auto with arith.\nrewrite (mult_distr_r p); apply mult_lt_compat_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; induction m; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_l.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_l.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; induction p; simpl; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p; repeat rewrite (mult_comm p); apply mult_le_compat_l.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_l.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; induction m; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; induction m; intros m p; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 201,
                "proof_start_offset": 537,
                "proof_end_offset": 655,
                "proof": "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H; induction m as [| m p IH]; simpl; auto.\nintros n m p H; case m; auto.\nintros n m p H0; case m; auto.\nintros n m p H; case m; auto.\nintros n m p H0 H0; case m; auto.\nintros n m p H1; case m; auto.\nintros n m p H0; case m; auto.\nintros n m p H0; case m; auto.\nintros n m p H0 H1; case m; auto.\nintros n m p H0 H1; case m; auto.\nintros m p H0; case m; auto.\nintros m p H0; case m; auto.\nintros m p H0 H1; case m; auto.\nintros m p0; case m; auto.\nintros m p H0; case m; auto.\nintros m p H0; case m; auto.\nintros m p0 H1; case m; auto.\nintros m p H0 H1; case m; auto.\nintros m p H0; case m; auto.\nintros mQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; induction m; simpl in |- *; auto with arith.\nintros n m p; case m; simpl in |- *; auto with arith.\nintros n m p; rewrite (mult_comm p); apply mult_le_compat_l; auto.\nintros n m p H0; apply mult_gt_compat_l; auto with arith.\nintros n m p H1; rewrite (mult_comm p); apply mult_le_compat_l; auto with arith.\nintros n m p H1; case m; simpl in |- *; auto with arith.\nintros n m p H1; case m; simpl in |- *; auto with arith.\nintros n m p H1; case m; simpl in |- *; auto with arith.\nintros n m p H1; case m; simpl in |- *; auto with arith.\nintros n m p H1; case m; simpl in |- *; auto with arith.\nintros n m p H1; case m; simpl in |- *; auto with arith.\nintros n m p H1; case m; simpl in |- *; auto with arith.\nintros n m p H1 H1; case m; simpl inQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; red; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; apply mult_lt_compat_l; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; induction n; simpl; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; red; apply mult_lt_compat_l.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; induction m; simpl in |- *; intros; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; unfold mult_gt_compat; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 250,
                "proof_start_offset": 657,
                "proof_end_offset": 889,
                "proof": "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; induction m; simpl in |- *.\napply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; induction m; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; induction n; simpl; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nintros n m p H0; rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1; case p; auto with arith.\nintros n m p; case p; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\n",
                "context_tokens": 345,
                "proof_start_offset": 892,
                "proof_end_offset": 1010,
                "proof": "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n p); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m p); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m p); auto with arith.\nrewrite mult_gt_compat_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m p); auto with arith.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nrewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nrewrite <- mult_gt_compat_l; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 394,
                "proof_start_offset": 1012,
                "proof_end_offset": 1197,
                "proof": "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n m p); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\n",
                "context_tokens": 470,
                "proof_start_offset": 1199,
                "proof_end_offset": 1445,
                "proof": "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt m p); auto with arith.\nintros n m p H; case (le_or_lt_iff _ _ _ H0); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt m p); auto with arith.\nintros n m p H1; case (le_or_lt m p); auto with arith.\nintros n m p H1; case (le_or_lt m p); auto with arith.\nintros n m p H1 H1; case (le_or_lt m p); auto with arith.\nintros n m p H1 H1; case (le_or_lt m p); auto with arith.\nintros n m p H1 H1 H2; case (le_or_lt m p); auto with arith.\nintros n m p H1 H1; case (le_or_lt m p); auto with arith.\nintros n m p H1 H2; case (le_or_lt m p); auto with arith.\nintros n m p H1 H2; case (le_or_lt m p); auto with arith.\nintros n m p H1; case (le_or_lt m p); auto with arith.\nintros n m p H1 H2; case (le_or_lt m p); auto with arithQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1; case p; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt m n p); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 569,
                "proof_start_offset": 1447,
                "proof_end_offset": 1704,
                "proof": "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m p); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H1 H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H2; case (le_or_lt n m); auto with arith.\nintros n m p H1 H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nintros n m p H1; case (Qed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1; case (le_or_lt n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 1706,
                "proof_end_offset": 1872,
                "proof": "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p; case (le_or_lt_lt n m); auto with arith.\nintros n m p H1; elim (le_or_lt a b); auto with arith.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p H1 H1; case (le_or_lt a b); auto with arith.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p H2; case (le_or_lt a b); auto with arith.\nintros n m p H1; case (le_or_lt b n); auto with arith.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p1 H2; case (leQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1; case (le_or_lt a b); auto with arith.\nintros a b H1; case (le_or_lt a b); auto with arith.\nintros a b H1; case (le_or_lt b a b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b a b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintrosQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p1 H2; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1; case (le_or_lt a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 1874,
                "proof_end_offset": 1996,
                "proof": "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case b; simpl; auto with arith.\nintros n m H1 H2; absurd (0 < 0); auto with arith.\nintros n m H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1; case b; simpl; auto with arith.\nintros n m p H2; absurd (0 < 0); auto with arith.\nintros n m p H1; absurd (0 <= 0); auto with arith.\nintros n m p H1; absurd (0 < 0); auto with arith.\nintros n m p; absurd (0 < 0); auto with arith.\nintros n m p H1; absurd (0 < 0); auto with arith.\nintros n m p H1; absurd (0 <= 0); auto with arith.\nintros n m p H2; absurd (0 < 0); auto with arith.\nintros n m p H1; absurd (0 < 0); auto with arith.\nintros n m p H1 H1; absurd (0 < 0); auto with arith.\nintros n m p H1; absurd (0 < 0); auto with arith.\nintros n m p H1; absurd (0 < 0); auto with arith.\nintros m p0; absurd (0 < 0); auto with arith.\nintros n m p H1; absurd (0 <= 0); auto with arith.\nintros n m p0 H1Qed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case b; auto with arith.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case b; simpl; auto with arith.\nintros n m p H1; absurd (p * m); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case b; auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; case (le_or_lt a b); auto with arith.\nintros n m p H1 H2; absurd (0 < n); auto with arith.\nintros n m p H1; absurd (0 < n)%nat; auto with arith.\nintros n m p H1 H1; absurd (0 < n); auto with arith.\nintros n m p H1 H2; absurd (0 < n)%nat; auto with arith.\nintros n m p H1 H1 H2; absurd (0 < n)%nat; auto with arith.\nintros n m p H1; absurd (0 < m)%nat; auto with arith.\nintros n m p H1 H2; absurd (0 <= m)%nat; auto with arith.\nintros n m p1 H1; absurd (0 < m)%nat; auto with arith.\nintros m p1 H1; absurd (0 < n)%nat; auto with arith.\nintros n m p2Qed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case b; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 1999,
                "proof_end_offset": 2106,
                "proof": "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1; case b; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1; case b; auto with arith.\nintros a b H2; absurd (0 < b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; case (le_or_lt a b); auto with arith.\nintros a b H1; case (le_or_lt a b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b a b); auto with arith.\nintros a b H1; case (le_or_lt b a b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arith.\nintros a b0 H1; case (le_or_lt b b); auto with arith.\nintros a b H1; case (le_or_lt b b); auto with arithQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1; case b; auto with arith.\nintros a b H1 H2; case b; simpl; auto with arith.\nintros a b H1 H2; elim b; auto with arith.\nintros a b H2; case b; simpl; auto with arith.\nintros a b H2; case b; auto with arith.\nintros a b H1 H2; case b; simpl; auto with arith.\nintros a b H2; case b; simpl; auto with arith.\nintros a b H2 H2; case b; simpl; auto with arith.\nintros a b H2 H3; case b; simpl; auto with arith.\nintros a b H3; case b; simpl; auto with arith.\nintros a b H3; case b; simpl; auto with arith.\nintros a b H3; case b; simpl; auto with arith.\nintros a b H3 H4; case b; simpl; auto with arith.\nintros a b H3 H4; case b; simpl; auto with arith.\nintros a b H4; case b; simpl; auto with arith.\nintros a b H3; caseQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H; case b; auto with arith.\nintros n H1; absurd (0 < 0); auto with arith.\nintros n H1; absurd (0 < 0); auto with arith.\nintros n0 H2; absurd (0 < 0); auto with arith.\nintros n0 H2; absurd (0 < 0); auto with arith.\nintros n0 H2; absurd (0 < 0); auto with arith.\nintros n0 H1; absurd (0 < 0); auto with arith.\nintros n0 H1; absurd (0 < 0); auto with arith.\nintros n0 H1 H2; absurd (0 < 0); auto with arith.\nintros n0 H2; absurd (0 < 0); auto with arith.\nintros n0 H1; absurd (0 < 0); auto with arith.\nintros n0 H1 H2; absurd (0 < 0); auto with arith.\nintros n0 H2; absurd (0 < 0); auto with arith.\nintros n0 H2; absurd (0 < 0); auto with arith.\nintros n0 H3; absurd (0 < 0); auto with arith.\nintros nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1; case b; simpl; auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros H1; absurd (0 < 0); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H; case (le_or_lt a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2108,
                "proof_end_offset": 2250,
                "proof": "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case b; simpl; auto with arith.\nintros a b H1; case b; simpl; auto with arith.\nintros a b H1; case b; simpl; auto with arith.\nintros a b H1; case b; simpl; auto with arith.\nintros a b H1; case b; simpl; auto with arith.\nintros a b H1 H2; case b; simpl; auto with arith.\nintros a b H2 H1; case b; simpl; auto with arith.\nintros a b H1; case b; simpl; auto with arith.\nintros a b H1 H2; case b; simpl; auto with arith.\nintros a b H2; case b; simpl; auto with arith.\nintros a b H1 H1; case b; simpl; auto with arith.\nintros a b H1 H2; case b; simpl; auto with arith.\nintros a b H1 H2; case b; simpl; auto with arith.\nintros a b H1 H2; case b; simpl; auto with arith.\nintros a b H2; case b; simpl; auto with arith.\nintros a bQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H; case (lt_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case b; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H0; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case b; simpl; auto with arith.\nintros a b; case b; simpl; auto with arith.\nintros a b; case b; simpl; auto with arith.\nintros a b H1; case b; simpl; auto with arith.\nintros a b H1 H2; absurd (0 < 0); auto with arith.\nintros a b H2; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H2; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (0 < 0); auto with arith.\nintros a b H1; absurd (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2252,
                "proof_end_offset": 2358,
                "proof": "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2360,
                "proof_end_offset": 2503,
                "proof": "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "Qed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 2505,
                "proof_end_offset": 2590,
                "proof": "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n; case n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case (lt_or_lt n m); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case (le_or_lt n m); auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case (le_or_lt n m); auto with arith.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case (le_or_lt n m n); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros a b; case b; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_compat_l || apply mult_lt_compat_l ||\n              apply mult_ge_compat_l || apply mult_gt_compat_l ||\n              apply lt_mult_0 || apply gt_mult_0); auto with arith.\n\nLtac hyp_nsign_tac H :=\n  match type of H with\n   0 <= _ => clear H\n|?X1 <= 0 => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ <=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_le_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4783,
                "proof_end_offset": 5148,
                "proof": "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLet hyp_test : forall a b c d e, 0 <= b -> c < a * d + b * d + e.\n\nLet hyp_test : forall a b c d e f g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nLet hyp_test : forall a b c d e, 0 <= a * e -> a * b + d * e + e < e * e + e * e * e + e * e * e * e + e * e * e * e + e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e * e)%R * e * e * e * e * e * e * e * e * e * e * e * e * e * eQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLemma hyp_test_eq_0 : forall a b c d e, 0 <= a * b -> a * b = 0.\nProof.\nintros a b c d e e e e f g h e f g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLet hyp_test : forall a b c d e, 0 <= a * b * c -> a < b * c + c.\n\nLet hyp_test : forall a b c d e, 0 < a * b * b * d.\n\nLet hyp_test : forall a b c d e d e, 0 < a * b * d -> a * d < b * d.\nProof.\n\nLet hyp_test : forall a b c d e d e d e d e d e d e d e f e f e f e f e f e f e f e f e f g e f e f g e f e f g e f e f g e f g h e f g e f g e f g h e f g h h h e f h e f g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLet hyp_test_test_eq_eq_1 :=\n (Zlt_lt_lt_compat_l _ _ _ _ H)\n| _ => (lt_irrefl _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ _ _ H)\n| _ => (le_trans _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ _ _ H)\n| _ => (le_trans _ _ _ _ H)\n| _ => (le_trans _ _ _ H)\n| _Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLet hyp_test_eq : forall a b c d e, 0 < b -> 0 < a * b * d + b <= a * d.\nProof.\nintros a b c d e d e f g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLet hyp_test : forall a b c d e, 0 <= a * b * d -> d <= b * d -> d <= c * d <= c * d.\n\nLet hyp_test : forall a b c d e d e, 0 < b -> 0 < a * d * d -> e <= a * d * d <= c * d * d.\n\nLet hyp_test : forall a b c d e d e d e d e f g h e f h e f g h e h e f h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLet hyp_test : forall a b c d e, 0 <= a * b -> a * b = a * b * c + c * d.\n\nLemma hyp_test : forall a b c d e, 0 <= a * b * b * b * c * d <= a * d.\nProof.\n intros a b c d e d e f g h e f g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLemma hyp_test_test_eq_eq_1 : forall a b c d e d e, 0 <= a * d -> a * d <= b * d -> b = 0.\nProof.\ninduction a b; intros a b c d e d e d e d e d e d e d e f e f e f e f e f e f e f e f e f g e f e f g e f e f e f g e f e f g e f g e f e f g h e f g h e f g h e f g h h h e f g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\n\nLemma hyp_test_test_eq_refl : forall a b c d e, 0 < a -> 0 < b * b * b * c.\nProof.\nunfold hyp_test.\nintros a b c d e e e e e e e f e f e f e f e f e f e f e f e f e f e f e f e f e f e f e f e f e f e f f e f e f e f e f e f e f f e f e f e f e f e f e f e f e f e f f e f f e f e f e f e f f e f e f e f e f e f e f f e f e f e f f e f e f f e f f e f e f e f e f f e f e f e f e f e f f e f f e f e f f e f e f f f e f f e f e f e f e f f e f e f f f e f e f f e f f f e f e f e f e f e f f f f e f f f e f e f e f e f f e f fQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\nLet hyp_test : forall a b c d e, \n  0 <= a -> 0 < a -> a * b <= a * c  -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H should disappear *)\nhyp_nsign_tac H.\n(* a in H2 should disappear *)\nhyp_nsign_tac H2.\n(* H3 unchanged *)\ntry hyp_nsign_tac H3.\n(* d should disappear *)\nhyp_nsign_tac H4.\n(* Prove it *)\nhyp_nsign_tac H5.\nQed.\n\n\n",
                "context_tokens": 718,
                "proof_start_offset": 5151,
                "proof_end_offset": 5516,
                "proof": "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H0 H1 H2 H4.\n(* the case *)\nintros a b c d e H4.\nintros a b d e H4 H4 H5 H5.\n(* h1 is a b=0 *)\nintros a b c d e H5 H5 H5.\nintros a b d e H5 H5 H5.\n(* d=0 *)\nintros a b c d H4 H5 H5.\n(* d=0 *)\nintros a b c d e H5 H5 H5.\n(* e=0 *)\nintros a b c d H5 H5 H6 H5.\n(* d=0 *)\nintros a b c d H5 H5 H6.\nintros a b c d H5 H5 H5 H6 H6.\n(* d=0 *)\nintros a b d H6 H5 H6 H6 H6.\n(* d=0 *)\nintros a b d H6 H6.\nintros a d H6 H6 H7 H7.\n(* d=0 *)\nintros a b c d H6 H6 H7 H7.\nintros a b cQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H4 H5 H5 H5.\n(* H5 *)\n\nLemma hyp_test2 : forall a b c d e, b > 0 -> a * b * b * b * c + d + e <= c * d.\nintros a b c d e H5 H5 H5 H6 H7 H8 H7 H8 H10 H9 H10 H10 H10 H10 H11 H10 H12 H12 H13 H13 H13 H13 H13 H14 H14 H13 H13 H14 H15 H14 H15 H15 H14 H15 H16 H17 H14 H14 H14 H15 H17 H18 H14 H17 H15 H17 H16 H17 H15 H19 H17 H18 H18 H19 H19 H18 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H20 H19 H20 H19 H19 H19 H20 H19 H19 H19 H19 H19 H19 H19 H20 H19 H20 H19 H19 H19Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H_g H5 H4.\n\n(* Test the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof. *)\n\n(* Test of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof. *)\n\n(* Check that this proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof. *)\n\nRequire Import Coq.Logic.Logic.\n\nRequire Import Coq.Logic.FunctionalExtensionality.\nRequire Import Coq.Logic.FunctionalExtensionality.\n\n(* Check that the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof. *)\n\nRequire Import Coq.Logic.Logic.FunctionalExtensionality.\n\n(* Check the proof of the proof of the proof of the proof of the proof of the proof of the proof. *)\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H4 H5 H5 H5 H5 H6 H6 H6 H7 H7 H7 H8 H8 H8 H9 H9 H9 H9 H10 H10 H11 H11 H12 H11 H10 H12 H13 H11 H11 H13 H13 H15 H11 H15 H15 H17 H19 H17 H15 H17 H19 H17 H18 H17 H18 H19 H19 H19 H19 H19 H19 H19 H20 H19 H19 H19 H19 H19 H19 H19 H18 H19 H19 H19 H19 H19 H19 H19 H' H19 H'19 H19 H19 H20 H19 H20 H' H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H'19 H19 H19 H19 H20 H20 H19 H19 H20 H20 H19 H19 H' H19 H19 H19 H19 H20 H19 H19 H19 H19 H'Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H4.\nelim (le_mult_reg_l _ _ _ _ H2); clear H3;\n intros s1 t2;\n generalize (lt_mult_compat_l _ _ _ _ _ H2); clear H3;\n intros s2 t2; generalize (lt_mult_compat_l _ _ _ _ _ _ H2); clear H3; \n intros s2 t3; generalize (lt_mult_compat_l _ _ _ _ _ H2); clear H4; \n intros s3 t4; generalize (lt_mult_compat_l _ _ _ _ _ H2); clear H3 H4; \n intros s3 t4; generalize (lt_mult_compat_l _ _ _ _ _ H2); clear H3 H4; \n intros s4 t4; generalize (lt_mult_compat_l _ _ _ _ _ H3); clear H4;\n intros s3 t4; generalize (lt_lt_reg_l _ _ _ _ _ H3); clear H4 H4 H4 H5; \n intros s4 t4; generalize (lt_reg_l _ _ _Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H4 H5 H5 H5 H5 H5 H5 H5 H6 H6 H6 H6 H7 H7 H8 H8 H8 H8 H8 H8 H9 H9 H9 H10 H9 H10 H9 H11 H10 H11 H10 H9 H11 H11 H12 H11 H11 H13 H13 H13 H13 H13 H14 H15 H13 H14 H15 H15 H14 H18 H16 H17 H17 H17 H18 H19 H18 H18 H18 H17 H18 H18 H19 H19 H18 H19 H18 H19 H17 H19 H19 H19 H20 H20 H19 H19 H19 H19 H19 H19 H19 H19 H20 H19 H19 H19 H19 H19 H19 H19 H19 H20 H19 H19 H19 H19 H19 H19 H19 H20 H20 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H19 H20 H19 H19 H20 H20 H20 H19 H19 H20 H19 H19 HQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H4 H5 H5 H5 H6.\n(*  l1... *)\nintros a b c d e H4 H5 H5 H6 H6 H6 H6 H7.\n(* H6 *)\nintros a b c d H5 H6 H7 H8 H7 H8 H8 H9 H9 H9 H9 H10 H10 H10 H10 H10 H10 H10 H10 H10 H11 H11 H10 H11 H13 H11 H14 H13 H14 H13 H13 H14 H14 H14 H13 H15 H15 H15 H14 H15 H14 H17 H17 H17 H17 H15 H17 H17 H17 H18 H17 H18 H17 H17 H17 H17 H17 H18 H18 H18 H19 H19 H19 H20 H17 H19 H19 H17 H19 H19 H19 H17 H19 H17 H19 H19 H19 H17 H19 H19 H19 H19 H20 H19 H19 H19 H20 H19 H19 H19 H19 H19 H19 H19 H18 H20 H19 H19Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H2 H4.\n\n(* we can prove the test *)\n\nLemma hyp_test_eq_2 : forall a b c d e f e f e f e f e f g e f e f g e f g e f g e f g e f g e f g e f g h e f g h g h g h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h hQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H1 H2 H3.\napply hyp_n_ind_tac H5.\n(* d = a * b * b + b + c * c + c + d * a * b + c + d * c * b + d * a + d * d + d * a * d + d + d * d * b + d * a + d * d * b + d * d * d * d * d * d.\nintros a b c d e d e d e d e f g h H3 H4 H4 H5;\n clear H H4 H4 H4 H5 H5 H6 H6 H7 H7 H8;\n generalize (mult_eq_0_l _ _ _ _ _ H H); clear H; \n intros H H4; \n generalize (mult_eq_0_l _ _ _ _ _ H); clear H3 H4; \n intros H5; \n generalize (mult_eq_0_l _ _ _ _ H); clear H4 H5 H6 H7; intros H6 H7 H7; \n generalize (mult_gt_0_l _ _ _ _ H);Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H4 H5.\n(* Test *)\n\nLemma hyp_test2 : forall a b c d e, \n  0 <= a * b -> a * b <= b * c.\nintros a b c d e H1 H3 H3 H4.\n(* H5 H5 H5 *)\nhyp_nsign_tac H5.\n(* Check that a = b * b + b + c * b + c * b + c + c + c * c + c * d.\nintros a b c d e H4 H4.\n(* Check that the term *)\n(* Check that a = b + b + b + c * c + c + c * c + c + d + d + d * c + d * d.\nintros a b c d e H4 H5.\n(* Check that the term is a + b + c + c + c * c + c + c + d * d + d + d * d.\nintros a b c d e H4 H5 H5.\n(* Check a + c + d + d + d * d + d + d * d + d + d * d + d *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\n",
                "context_tokens": 329,
                "proof_start_offset": 839,
                "proof_end_offset": 971,
                "proof": "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros H1; case H1; auto.\nintros m1 H2; case (le_or_lt m1 m1); auto with arith.\nintros H2; case H1; auto.\nintros H2; absurd (nat_of_P p1 > nat_of_P p1)%nat; auto with arith.\nintros H2; case (le_or_lt n1 m1); auto with arith.\nintros H2; absurd (nat_of_P p2 < nat_of_P p2)%nat; auto with arith.\nintros H3; case H1; auto.\nintros H3; absurd (nat_of_P p1 > nat_of_P p2)%nat; auto with arith.\nintros H3; absurd (nat_of_P p1 > nat_of_P p2)%nat; auto with arith.\nintros H2; absurd (nat_of_P p1 > nat_of_P p2)%nat; auto with arith.\nintros H3; absurd (nat_of_P p2 > nat_of_PQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H2; case H1; auto.\nintros H2; case (le_or_lt n m1); auto with arith.\nintros H2; case (le_or_lt n m1); auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H1 H2; case (le_or_lt n m1); auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H1; case (le_or_lt n m1); auto with arith.\nintros H1Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; auto.\nintros n m; case m; auto.\nintros n1 m2 H2; case m; auto.\nintros m1 n2 H2; case m2; auto.\nintros m1 H2; case m2; auto.\nintros m1 n2 H3 H3; case m2; auto.\nintros m2 H3; case m2; auto.\nintros m2 n1 H3; case m2; auto.\nintros m1 H3 H4; case m2; auto.\nintros m1 n1 H4; case m1; auto.\nintros m2 n2 H4; case m2; auto.\nintros m2 H3; case m1; auto.\nintros m2 n2 H4 H5; case m2; auto.\nintros m2 n2 H4; case m2; auto.\nintros m2 n1 H4; case m2; auto.\nintros m2 H4; case m2; auto.\nintros m2 n2 H4 H4; case m2; auto.\nintros m2 H3; case m2; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros n1 H2; elim H1; auto with arith.\nintros m1 H2; case H1; auto with arith.\nintros n1 H2; elim H1; auto with arith.\nintros H2; case H1; auto with arith.\nintros m1 H1; elim H2; auto with arith.\nintros n2; case H2; auto with arith.\nintros n1 H2; elim H3; auto with arith.\nintros n2; rewrite nat_of_P_compare_morphism; auto with arith.\nintros m1 H2; case H1; auto with arith.\nintros m1 H2; elim H3; auto with arith.\nintros m1 H3; elim H2; auto with arith.\nintros m1 H3; rewrite nat_of_P_compare_morphism; auto with arith.\nintros m1 H3; elim H3; auto with arith.\nintros m1 H3; elim H3; auto with arith.\nintros m1 H3; elim H3; auto with arith.\nintros m1Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros n1 H2; case m; simpl; auto with arith.\nintros H2; elim (le_or_lt n m1); auto with arith.\nintros H2; case H1; auto.\nintros H2; case H1; auto.\nintros H2; case H1; auto.\nintros H3; case H3; auto.\nintros H3; case H3; auto.\nintros H3; case H3; auto.\nintros H3; case H3; auto.\nintros H4; case H4; auto.\nintros H4; case H3; auto.\nintros H5; case H4; auto.\nintros H4; case H4; auto.\nintros H4; case H5; auto.\nintros H5; case H3; auto.\nintros H4; case H5; auto.\nintros H4; case H5; auto.\nintros H5; case H6; auto.\nintros H5; case H5; auto.\nintros H5; case H5; auto.\nintros HQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; auto with arith.\nintros H1; case m; auto with arith.\nintros m1 n2 H2; case m; auto with arith.\nintros m1 H2; case m1; auto with arith.\nintros H2; case m1; auto.\nintros m1 H2; case m1; auto with arith.\nintros m1 H2; case m1; auto with arith.\nintros m1 H2; case m2; auto with arith.\nintros m1 H3; case m2; auto with arith.\nintros m1 H2; case m2; auto with arith.\nintros m1 H3; case m2; auto with arith.\nintros m1 H3; case m1; auto with arith.\nintros m2 H3; case m1; auto with arith.\nintros m1 H3; case m1; auto with arith.\nintros m1 H3; case m1; auto with arith.\nintros m1 H3; case m1; auto with arith.\nintros m1 H3; case m1; auto with arith.\nintros m1 H3; case m2Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros n m; case m; auto.\nintros n0 H1; case m; simpl; auto with arith.\nintros m1 H2; case m; auto with arith.\nintros H2; case m; auto with arith.\nintros m1 H2; case m1; simpl; auto with arith.\nintros m1 H2; case m2; simpl; auto with arith.\nintros m1 H2; case m1; simpl; auto with arith.\nintros m1 H1; case m2; simpl; auto with arith.\nintros m1 H3; case m1; simpl; auto with arith.\nintros m2 H3; case m1; simpl; auto with arith.\nintros m1 H3; case m1; simpl; auto with arith.\nintros m1 H3; case m1; simpl; auto with arith.\nintros m1 H3; case m2; simpl; auto with arith.\nintros m2; case m1; simpl; auto with arith.\nintros m1; case m2; simpl; auto with arith.\nintros m1 H3;Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros m1 H2; case (le_or_lt n m1); auto with arith.\nintros m1 H3; case (le_or_lt n m1); auto with arith.\nintros H4; case (le_or_lt n m1); auto with arith.\nintros H5; case (le_or_lt n m1); auto with arith.\nintros H4; case (le_or_lt n m1); auto with arith.\nintros H5; case (le_or_lt n m1); auto with arith.\nintros H6; case (le_or_lt n m1); auto with arith.\nintros H5; case (le_or_lt n m1); auto with arith.\nintros H6; case (le_or_lt n m1); auto with arith.\nintros H5; case (le_or_lt n m1); auto with arith.\nintros H5; case (le_or_lt n m1); auto with arith.\nintros H5; case (le_or_lt nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; auto.\nintros m; case m; auto.\nintros n1 H1; case n2; auto.\nintros H1; elim H2; auto.\nintros m1 H2; elim H2; auto.\nintros m1 H2; elim H2; auto.\nintros m1 H3; elim H3; auto.\nintros m1 H3; elim H3; auto.\nintros m1 H3; elim H3; auto.\nintros m1 H4; elim H3; auto.\nintros m1 H3; elim H4; auto.\nintros m1 H4; elim H3; auto.\nintros m1 H4; elim H4; auto.\nintros m1 H4; elim H5; auto.\nintros m1 H4; elim H3; auto.\nintros m2 H4; elim H5; auto.\nintros m1 H4; elim H5; auto.\nintros m1 H4; elim H5; auto.\nintros m2 H4; elim H4; auto.\nintros m1 H4; elim H4; auto.\nintros m2 HQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros m1 H2; case (le_or_lt n m1); auto with arith.\nintros m1; case m1; auto with arith.\nintros m1; case m1; auto with arith.\nintros m1; case (le_or_lt m1 m2); auto with arith.\nintros m1; case m1; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case (le_or_lt m1 m2); auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1 H2; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 386,
                "proof_start_offset": 973,
                "proof_end_offset": 1244,
                "proof": "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m H; case n; auto.\nintros m H; case m; auto.\nintros m; case m; auto.\nintros m0; case (le_or_lt m0 m0); auto with arith.\nintros m0; case m; auto.\nintros m0; case (le_or_lt m0 m0); auto.\nintros m0; case (le_or_lt n m0); auto.\nintros m0 H1; case (le_or_lt m0 m0); auto with arith.\nintros m0; case (le_or_lt m0 m0); auto with arith.\nintros m0; case (le_or_lt m0 m0); auto.\nintros m0 H1; case (le_or_lt m0 m0); auto with arith.\nintros m0; case (le_or_lt m0 m0); auto.\nintros m0; case (le_or_lt m0 m0); auto with arith.\nintros m0; case (le_or_lt m0 m0); auto.\nintros m0; case (le_or_lt mQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; case m; unfold N.le; simpl; auto with arith.\nintros n m; case m; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; auto with arith.\nintros n; case m; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; auto with arith.\nintros n m; case m; auto with arith.\nintros n m; case m; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; simpl; auto with arith.\nintros n mQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; auto with arith.\nintros n1; case m; simpl; auto with arith.\nintros n1 H1; case m; auto with arith.\nintros n1 H1; case m; auto with arith.\nintros n1 H2; case m; auto with arith.\nintros n1 H1; case m; auto with arith.\nintros n1 H2; case m; simpl; auto with arith.\nintros n1 H2; case m; auto with arith.\nintros n1 H1 H2; case m; auto with arith.\nintros n1 H2; case m; auto with arith.\nintros n1 H2; case m; auto with arith.\nintros n2 H1; case m1; auto with arith.\nintros n1 H2; case m1; auto with arith.\nintros n1 H2; case m1; auto with arith.\nintros n1 H1; case m1; auto with arith.\nintros n1 H2; case m1; auto with arith.\nintros n1 H2; case m1;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n0 H1; case n; auto.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H3; case n0; auto with arith.\nintros n0 H2; case n0; auto with arith.\nintros n0 H3; case n0;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; case n; auto with arith.\nintros n m; case n; auto with arith.\nintros m H1; case n; auto with arith.\nintros m; case m; auto with arith.\nintros m1; case m1; auto with arith.\nintros m2 H1 H2; elim H1; auto with arith.\nintros m2; case m1; auto with arith.\nintros m2 H3; case m2; auto with arith.\nintros m2 H1; case m2; auto with arith.\nintros m2 H1 H3; case m2; auto with arith.\nintros m2 H3; case m2; auto with arith.\nintros m3 H3 H4; case m3; auto with arith.\nintros m2 H4; case m3; auto with arith.\nintros m3 H4; case m3; auto with arith.\nintros m3 H4; case m3; auto with arith.\nintros m3 H4; case m3; auto with arith.\nintros m3 H4; case m3; auto with arith.\nintros m3 H4; case m4; auto withQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case m; simpl; auto with arith.\nintros n m; case m; auto with arith.\nintros n1 m; case m; auto with arith.\nintros m1; case m; auto with arith.\nintros m1; case m1; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m2; case m1; auto with arith.\nintros m2; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m2; case m2; auto with arith.\nintros m1; case m2; auto with arith.\nintros m1; case m2; autoQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case m; intros H1; absurd (nat_of_P p); auto with arith.\nintros n m; case m; auto with arith.\nintros n0 H1; absurd (nat_of_P p); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (nat_of_P p0); auto with arith.\nintros n0 H2; absurd (nat_of_P p0); auto with arith.\nintros n0 H1; absurd (natQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply Nle_compat; repeat rewrite N2Nat.id; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply lt_antisym; auto with arith.\nintros n1 H2; elim H; auto with arith.\nintros H2; elim H2; auto with arith.\nintros n1; elim H1; auto with arith.\nintros m1 H2; elim H2; auto with arith.\nintros m1 H3; elim H3; auto with arith.\nintros H3; elim H3; auto with arith.\nintros m2; elim H3; auto with arith.\nintros m2 H3; elim H3; auto with arith.\nintros m1 H3; elim H3; auto with arith.\nintros m2; elim H3; auto with arith.\nintros m2 H4; elim H3; auto with arith.\nintros m2 H3; elim H3; auto with arith.\nintros m1 H3; elim H4; auto with arith.\nintros m2 H4; elim H4; auto with arith.\nintros m2; elim H4; auto with arith.\nintros m2 H4; elim H4; auto with arith.\nintros m2 H4; elim H4; auto with arith.\nintrosQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 1246,
                "proof_end_offset": 1540,
                "proof": "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros; case m; unfold N.le; simpl; auto with arith.\nintros; elim H1; auto.\nintros n0 H1; apply nat_of_P_lt_Gt_compare_morphism; auto.\nintros H1; inversion H1.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversionQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; elim H1; auto.\nintros p1 H2; inversion H1.\nintros p2; inversion H1.\nintros p1 H2; inversion H1.\nintros p2 H2; inversion H1.\nintros p2; inversion H1.\nintros p2 H2; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p2 H2; inversion H1.\nintros p1 p2 H3; inversion H1.\nintros p2 H3; inversion H1.\nintros p2 H3; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p2 p2 H3; inversion H1.\nintros p2 H3 H3; inversion H1.\nintros p1; inversion H1.\nintros p2 H3; inversion H1.\nintros p2; inversion H1.\nintros p2 H3; inversion H1.\nintros pQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros; case n; auto.\nintros m; case m; auto.\nintros H2; inversion H1.\nintros n1 H2; inversion H1.\nintros n2 H2; inversion H1.\nintros n1 H2; inversion H1.\nintros n1 H1 H2; inversion H1.\nintros n1 H2; inversion H1.\nintros n2 H1 H2; inversion H1.\nintros n2 H2; inversion H1.\nintros n2 H2; inversion H1.\nintros n2 H2 H1 H2; inversion H1.\nintros n2 H2; inversion H1.\nintros n2 H3; inversion H1.\nintros n2 H3; inversion H1.\nintros n2 H2 H3; inversion H1.\nintros n2 H3; inversion H1.\nintros n2 H3; inversion H1.\nintros n2 H4; inversion H1.\nintros n2 H4; inversion H1.\nintros n2 H4 H4; inversion H2.\nintros n2 H4; inversion H1.\nintros n2 H4; inversion HQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros H1; inversion H1.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros;Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros; case m; unfold N.lt; simpl; auto with arith.\nintros; case m; unfold N.lt; simpl; auto with arith.\nintros; case m; unfold N.lt; simpl; auto with arith.\nintros; case m; unfold N.lt; simpl; auto with arith.\nintros; case m; unfold N.lt; simpl; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; unfold N.lt; simpl; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; case m; auto with arith.\nintros; caseQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros H1; inversion H1.\nintros H1; inversion H1.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H1; inversion H1.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H1Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.le; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case m; unfold N.le; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1; auto.\nintros H2; inversion H1.\nintros H2; inversion H1.\nintros H1; inversion H1; auto.\nintros H1; inversion H2.\nintros H2; inversion H1.\nintros H3; inversion H1.\nintros H3; inversion H3.\nintros H1; inversion H2.\nintros H3; inversion H1; auto.\nintros H4; inversion H1; auto.\nintros H4; inversion H5.\nintros H4; inversion H2.\nintros H4; inversion H2; auto.\nintros H4; inversion H3; auto.\nintros H4; inversion H4.\nintros H4; inversion H4; auto.\nintros H4; inversion H5; auto.\nintros H4; inversion H3.\nintros H4; inversion H4; auto.\nintros H4; inversion H4; auto.\nintros H4; inversion H4; auto.\nintros H5; inversion H5; auto.\nintrosQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros p H2; inversion H2.\nintros p1; inversion H1.\nintros p1; inversion H1.\nintros p1; inversion H2.\nintros p1 H2; inversion H1.\nintros p2; inversion H1.\nintros p1; inversion H1.\nintros p1 H1; inversion H1.\nintros p1; inversion H1.\nintros p1; inversion H1.\nintros p1; inversion H1.\nintros p1; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p1; inversion H1.\nintros p2; inversion H1.\nintros p1; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p1; inversion H1.\nintros p2; inversion H1.\nintros p1; inversion H1.\nintros pQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros H2; inversion H1.\nintros H2; inversion H2.\nintros H3; inversion H1.\nintros H3; inversion H1.\nintros H3; inversion H1.\nintros H3; inversion H3.\nintros; inversion H4.\nintros H4; inversion H4.\nintros; inversion H3.\nintros; inversion H4; inversion H4.\nintros H4; inversion H4.\nintros; inversion H5; inversion H5.\nintros; inversion H5.\nintros; inversion H5; inversion H5.\nintros; inversion H5.\nintros; inversion H5.\nintros; inversion H5; subst.\nintros; inversion H5; subst.\nintros; inversion H5.\nintros; inversion H5; subst.\nintros; inversion H5.\nintros; inversion H5; subst.\nintros; inversion H6.\nintros; inversion H5.\nintros; inversion H5.\nintros; inversion H5; subst.\nintros; inversion H5Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\n",
                "context_tokens": 610,
                "proof_start_offset": 1542,
                "proof_end_offset": 1672,
                "proof": "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m1 H1; case m; intros H2; auto with arith.\nintros m1 H2; case m1; auto with arith.\nintros m2 H2; case m2; simpl; auto with arith.\nintros m1 m2 H2; case m2; simpl; auto with arith.\nintros m2 H1 H2; case m2; simpl; auto with arith.\nintros m1 H2; case m2; simpl; auto with arith.\nintros m1 H2; case m2; auto with arith.\nintros m2 H2; case m2; auto with arith.\nintros m2 H3 H3; case m2; simpl; auto with arith.\nintros m1 H3; case m2; simpl; auto with arith.\nintros m2 H3; case m1; simpl; auto with arith.\nintros m2 H3; case m1; auto with arith.\nintros m2 H3; case m2; simpl; auto with arith.\nintros m1 H3; case m2; auto with arith.\nintros m2 H3;Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n; case n; simpl; try (intros; discriminate); auto with arith.\nintros n0 H2; inversion H1.\nintros n0; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H2; inversion H1.\nintros n1 H2; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H1 H2; inversion H2.\nintros n1 H2; inversion H2.\nintros n0 H2; inversion H1.\nintros n1 H2; inversion H2.\nintros n0 H1; inversion H2.\nintros n0 H2; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H1; inversion H1.\nintros n0; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H2; inversionQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; try (intros; discriminate); auto with arith.\nintros H1; elim H1; auto.\nintros H2; elim H1; auto.\nintros H2; elim H2; auto.\nintros H2; elim H2; auto.\nintros H2; elim H2; auto.\nintros H3; elim H3; auto.\nintros H3; elim H3; auto.\nintros H3; elim H3; auto.\nintros H4; elim H4; auto.\nintros H4; elim H4; auto.\nintros H5; elim H3; auto.\nintros H5; elim H6; auto.\nintros H6; elim H5; auto.\nintros H6; elim H5; auto.\nintros H6; elim H5; auto.\nintros H7; elim H7; auto.\nintros H7; elim H8; auto.\nintros H7; elim H6; auto.\nintros H7; elim H7; auto.\nintros H7 H7; elim H7; auto.\nintros H7; elim H8;Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; try (intros; discriminate); auto with arith.\nintros m1 H2; injection H1.\nintros H1 H2; injection H1.\nintros m1 m2; injection H1.\nintros m1; injection H1.\nintros m2; injection H1.\nintros m2; injection H1.\nintros m2; injection H1.\nintros m2; injection H1.\nintros m2; injection H1; intros m2; injection H1; intros m2; injection H1; intros m2; injection H1; intros m1; injection H1; intros m2; injection H1; intros m2; injection H1; intros m2; injection H2; intros m2; injection H1; intros m2; injection H2; intros m2; injection H1; intros m2; injection H2; intros m2; injection H1; intros m2; injection H1; intros m2; injection H1; intros m2; injection H1; intros m2; injection H1; intros m1; injection H2; intros m2; injection H1;Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 H1 H1; auto with arith.\nintros n1 H1; rewrite nat_of_P_lt_Lt_compare_morphism; auto.\nintros H1; apply nat_of_P_lt_Lt_compare_morphism; auto.\nintros H1; apply nat_of_P_gt_Lt_compare_morphism; auto.\nintros H1; apply nat_of_P_lt_Gt_compare_morphism; auto.\nintros H1; apply nat_of_P_lt_Lt_compare_morphism; auto.\nintros H1; apply nat_of_P_lt_Gt_compare_morphism; auto.\nintros H1; apply nat_of_P_lt_Lt_compare_morphism; auto.\nintros H1; apply nat_of_P_lt_Gt_compare_morphism; auto.\nintros H1; apply nat_of_P_lt_Lt_compare_morphism; auto.\nintros H1 H2; apply nat_of_P_lt_Lt_compare_Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case m; simpl; auto with arith.\nintros m1; case m2; intros H1; auto with arith.\nintros H1; elim H1; auto with arith.\nintros m1 H1; elim H1; auto with arith.\nintros H1; elim H1; auto with arith.\nintros m1; elim H1; auto with arith.\nintros m2 H1; elim H1; auto with arith.\nintros m1 H1; elim H1; auto with arith.\nintros m1 H2; elim H1; auto with arith.\nintros m1 m2 H1; elim H2; auto with arith.\nintros m2 H2 H2; elim H1; auto with arith.\nintros m1 H2; elim H1; auto with arith.\nintros m1 H2; elim H1; auto with arith.\nintros m2 H2; elim H1; auto with arith.\nintros m2 H3; elim H1; auto with arith.\nintros m1 H3; elim H2; auto with arith.\nintros m1 m2 H3; elim H1; auto with arith.Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros H; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; elim H2; auto with arith.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; elim H2; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; elim H1; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; auto.\nintros H1; rewrite nat_of_P_eq_compare_morphism; autoQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros H1; rewrite H1; auto with arith.\nintros H1; elim H1; auto with arith.\nintros n1 H1; elim H1; auto with arith.\nintros m1; elim H1; auto with arith.\nintros n1 H2; elim H1; auto with arith.\nintros H1; apply nat_of_P_lt_Lt_compare_morphism; auto.\nintros H1 H2; elim H1; auto with arith.\nintros m1 H2; elim H2; auto with arith.\nintros m1 H2; elim H2; auto with arith.\nintros m1 H1; elim H1; auto with arith.\nintros m2 H2; elim H1; auto with arith.\nintros m1 H2; elim H1; auto with arith.\nintros m1 H2; elim H2; auto with arith.\nintros m1 H3; elim H1; auto with arith.\nintros m1 H3; elim H1; auto with arith.\nintros m2 H3;Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros H; case m1; auto with arith.\nintros H1; case m1; simpl; try (intros; discriminate); auto with arith.\nintros H1; case m1; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m1; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m1; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1; case m2; auto with arith.\nintros H1 H2; case m2; auto with arith.\nintrosQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case m; unfold N.le; simpl; try (intros; discriminate); auto with arith.\nintros n m1 H2; apply nat_of_P_lt_Gt_compare_morphism; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\n",
                "context_tokens": 20,
                "proof_start_offset": 66,
                "proof_end_offset": 153,
                "proof": "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y H.\n  apply (pow2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_2_test2_test2_test2_22_test22_test2_test2_22_test22_test22_test22_test222_test22_test22_test22_3_test22_test2_test22_test2_22_test2_2_test2_test2_2_test22_test2_3_test2_2_test22_test2_2_test2_test2_2_test2_test22_test22_test22_test2_test2Qed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  induction x.\n  simpl.\n  induction x.\n  simpl.\n  destruct y.\n  simpl.\n  destruct y.\n  simpl.\n  destruct (le_gt_dec x y).\n  omega.\n  rewrite H0 in H.\n  destruct y.\n  simpl.\n  destruct y.\n  rewrite <- H0 in H.\n  destruct y.\n  simpl.\n  destruct y.\n  apply IHn.\n  simpl.\n  destruct (le_gt_dec x y).\n  omega.\n  destruct y.\n  simpl.\n  destruct y.\n  rewrite <- H0 in H.\n  destruct y.\n  simpl.\n  destruct y.\n  apply IHn.\n  simpl.\n  destruct (le_gt_dec x y); omega.\n  destruct (le_gt_dec y y); omega.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y H1.\ndestruct (le_gt_dec x y); auto.\nsimpl; ring.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  unfold Qminus.\n  induction y.\n  simpl.\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (Rplus_comm y).\n  rewrite <- (Rplus_comm x y).\n  rewrite <- (RplusQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y.\n  apply (well_founded_induction x).\n  simpl; intros.\n  destruct y.\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x); simpl; intros.\n  destruct y.\n  destruct y.\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x); simpl; intros.\n  destruct y.\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl; intros.\n  destruct y.\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destruct (well_founded_induction x).\n  simpl.\n  destructQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y H; apply le_trans with x y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. apply le_trans with y. applyQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y H.\ncase (Rle_or_lt (S x) y); intros H.\napply Rlt_le_trans with y.\napply Rle_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le_trans with y.\napply Rlt_le.\napply Rlt_le_trans with y.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napply Rlt_le.\napplyQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros. unfold xn.\n  apply pls_test1.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2.\n  apply pls_test2Qed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y H; induction x; simpl; trivial.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite <- IHl. rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite IHl. rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite IHl. rewrite <- IHl.\n  rewrite IHl. rewrite IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite IHlQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  rewrite (tech_test1 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x y).\n  rewrite <- (tech_test2 x yQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 63,
                "proof_start_offset": 155,
                "proof_end_offset": 234,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nunfold pols.\nrewrite <- (pow2_test2_test_test2 x y).\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow2s_test2s x y).\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nsimpl.\napply (Qle_trans _ _ _ _ (fun y => x + y + y).\napply (Qle_trans _ _ _ (fun y => x + y + y).\napply (Qle_trans _ _ (fun y => x + y + y + y).\napply (Qle_trans _ _ _ (fun y => x + y + y + y + y + y + y + x + y + y + y + y + x + y + y + x + y + x + y + y + x + y + y + x + y + y + y + x + y + y + y + y + y + y + y + x + y + y + y + y + x + y + y + y + x + y + x + y + x + y + y + y + x + y + y + y + y + y + y + y + x + y + y + x + y + y + y + y + x + y + y + y + y + y + y + x + y + x + y + y + x + y + y + y + y + y + x + y + y +Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite (pow2n_test2 n); auto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply (pow2s_test2s_test2s_test2s_test2s).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nunfold pols.\napply (pow2r (r + x + y) (l + x).\nintros.\nrewrite <- (pow2r (r + x) (l + y)).\nrewrite <- (pow2r (r + y) (l + y) (l + y).\nrewrite <- (pow2r (r + y) (l + y)).\nrewrite <- (pow2r (r + y) (l + y) (l + y)).\nrewrite <- (pow2l (r + y) (l + y)).\nrewrite <- (pow2r (r + y) (l + y)).\nrewrite <- (pow2r (r + y) (l + y)).\nrewrite <- (pow2r (r + y) (l + y)).\nrewrite <- (pow2r (r + y)).\nrewrite <- (pow2r (r + y) (l + y)).\nrewrite <- (pow2r (r + y)).\nrewrite <- (pow2r (r + y) (l + y)).\nrewrite <- (pow2r (r + y)).\nrewrite <- (pow2r (r + yQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nsimpl.\napply (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite map_c2.\nrewrite map_c2.\nrewrite map_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite <- (Rsum_c2 x y).\nrewrite map_c2 x y).\nrewrite map_c2.\nrewrite map_c2.\nrewrite map_c2.\nrewrite map_c2 x y).\nrewrite map_c2.\nrewrite map_c2.\nrewrite map_c2.\nrewrite map_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nunfold pol.\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (1 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (2 := x).\napply le_trans with (Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nrewrite <- (pow2_test2 x y).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nrewrite <- (pow2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_3_test2_test2_test2_test22_test2_2_test2_2_test2_2_test2_test2_2_test2_test2_2_test2_2_test22_test2_2_test2_test22_test2_2_test2_3_test2_test2_2_test2_test2_2_test2_2_test2_test2_test2_2_test2_test2_2_test2_test2_test2_test2_test2_test2_2_test2_test2_test2_test2_2_test2_test2_test2_test2_test2_test2_test2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 101,
                "proof_start_offset": 237,
                "proof_end_offset": 357,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros x y.\nreplace (x + y) with (x + y + y) by auto.\nreplace (y + x) with (y + x * y + y + (x + y) by auto.\nreplace (x + y) with (y + y + x * y + y + (x + y) by auto.\nreplace (y + y) with (y + y) by auto.\nreplace (y + x) with (y + y + y) by auto.\nreplace (y + x) with (y + x * y + y) by auto.\nreplace (y + x + x + y) with (y + x + y) by auto.\nreplace (y + y) with (y + x + y) by auto.\nreplace (y + y) with (y + y) by auto.\nreplace (y + y) with (y + x + y) by auto.\nreplace (y + x) with (y + x + y) by auto.\nreplace (y + x) with (y + x + y) by auto.\nreplace (y + y) with (y + y) by auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test3 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (pows_test2 x y H).\nrewrite <- (powsQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nchange (x + y * y) with (y * y * (y * x) * (y * y) * (y * y))).\nintros.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply xns_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply xns_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napply pols_test2.\napplyQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nreplace (x + y) with (x + y * y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test4 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 x y) by ring.\nrewrite <- (pows_test3 xQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply pols_test4.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (Rmult_comm (x + y) * (x + y) * (x + y)).\napply Rmult_le_compat_l.\nrewrite <- (Rmult_comm (x + y) * (x + y)).\nrewrite <- (Rmult_comm (x + y) * (x + y)).\napply Rmult_le_compat_l.\nrewrite <- (Rmult_comm (x + y)).\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\nrewrite <- (Rmult_comm (x + y) * (x + y)).\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rinv_0_lt_compat.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply RmultQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 x y).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y y).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y x).\nrewrite <- (pows_test2 y).\nrewrite <- (pows_test2 y x).\nrewrite <- (Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (pows_test4 x y).\nauto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (multQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros x y H.\nsimpl in |- *.\nrewrite (tech2s_test2 _ (fun x y => (y + y) * (y + y) * (y + y)).\nintros.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nsimpl.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nrewrite Rmult_assoc.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nrewrite <- Rmult_assoc.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\nrewrite Rinv_simpl.\nunfold Rdiv.\nunfold Rdiv.\nunfold Rdiv.\ndo 2 rewrite Rmult_assoc.\nunfold Rdiv.\nunfold Rdiv.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 162,
                "proof_start_offset": 360,
                "proof_end_offset": 482,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (mult_comm x y) at 2.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pows_test4_5 x y z) in H.\nrewrite <- (pows_test4 x y z) in H.\nrewrite <- (pows_test4 x y z) in H.\nrewrite <- (pows_test4 x y z) in H.\nrewrite <- (pows_test5 x y z) in H.\nrewrite <- (pows_test6 x y z) in H.\nrewrite <- (pows_test6 x y z) in H.\nrewrite <- (pows_test6 x y z) in H.\nrewrite <- (pows_test6 x y z) in H.\nrewrite <- (pows_test6 x y z) in H.\nrewrite <- (pows_test5 x y z) in H.\nrewrite <- (pows_test6 x z) in H.\nrewrite <- (pows_test6 x y z) in H.\nrewrite <- (pows_test6 x z) in H.\nrewrite <- (pows_test6 x z) in H.\nrewrite <- (pows_test6 x z) in HQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nreplace (x + y) with (x + y) by (now rewrite <- H0; auto).\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewriteQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (tech2s_test5 x y z).\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pols_test5 x y z) by (now rewrite <- (pols_test6 x z) by (now rewrite <- (pols_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by (now rewrite <- (pol_test6 x z) by ring).\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pol_c_test6 x y z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (pol_c_test6 x z) in H; clearbody H.\nrewrite <- (polQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x in |- *.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_commQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nrewrite <- (pows_test2 x y z).\nrewrite <- (pows_test2 x y z).\nrewrite <- (pows_test2 x y z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 x z).\nrewrite <- (pows_test2 xQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncut (forall y, x * y * y * (x + y) * (y + y) * (y + y) * (y + x) * (x + y) * (x + y) * (y + y) * (y + y) * (x + y) * (x + y) * (y + y) * (y + x) * (y + y) * (y + x) * (y + y) * (y + y) * (y + x) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + x) * (y + y) * (y + y) * (x + y) * (y + y) * (y + x * y) * (y + y) * (x + y) * (y + y) * (x + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y)Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nreplace (x + y + y) with (y + y) by (ring; ring; ring; ring;\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 225,
                "proof_start_offset": 485,
                "proof_end_offset": 561,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nsimpl in |- *.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nreplace (x + y) with (x + y * y).\napply Rle_trans with (x + y * y * (x + y)).\napply Rle_trans with (x + y * (y + y)).\napply Rle_trans with (x + y * (y + y)).\napply Rle_trans with (x + y * (x + y)).\napply Rle_trans with (x + y * (x + y))).\napply Rle_trans with (x + y * (y + y)).\napply Rle_trans with (x + y).\napply Rle_trans with (x + y * (y + y)).\napply Rle_trans with (x + y * (x + y)).\napply Rle_trans with (x + y * (y + y)).\napply Rle_trans with (x + y * (y + y)).\napply Rle_trans with (x + y * (x + y)).\napply Rle_trans with (x + y * (y + y))).\napply Rle_trans with (x + y).\napply Rle_trans with (x + y).\napply Rle_trans with (x + y +Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite pols_test2.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern (y * (y + x) at 2.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_comm x y).\nrewrite <- (mult_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncut (forall z, (1 <= z)%Z -> (x + y) = 2 * x * y).\nintros.\ncut (forall z, (1 <= z)%Z -> (x + y) = 2 * x * (y + y)).\nintros.\ncut (forall z, (x + y) = 2 * (x + y) * (x + y)).\nintros.\ncut (forall z, (x + y) = 2 * (x + y) * (y + y)).\nintros.\ncut (forall z, (x + y) = 2 * (x + y) * (y + y)).\nintros.\ncut (forall z, (x + y) = 2 * (y + y)).\nintro.\ncut (forall z, (x + z) = 2 * (x + y) * (y + y)).\nintro.\ncut (forall z, (x + y) = 2 * (y + z)).\nintro.\ncut (forall z, (x + y) = 2 * (y + z) * (y + z)).\nintro.\ncut (forall z, (x + zQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncut (forall x y, (x + y) * y = 2 * (x + y) * (x + y)).\nintros.\ncut (forall x y: N, x < y -> x < y -> y < y -> (x + y) * (y + y).\nintros.\ncut (forall x y:N, x <= y -> x <= y) by (apply Rlt_trans with (y + y + y) (y + x)).\n2: intros.\ncut (forall y:N, x <= y -> x <= y) by (apply Rlt_trans with (y + y)).\n2: intros.\nreplace (x + y) with (y + x + y).\n2: intros.\nreplace (x + y) with (y + y) by (apply Rlt_trans with (y + y) by (apply Rlt_trans with (y + y)).\n2: intros.\nreplace (x + y) with (y + y) by (apply Rlt_trans with (y + y).\n2: intros.\nreplace (x + y) with (y + y + y) by ring.\n2:Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nsimpl.\nrewrite <- (pow_poss x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_pow_r x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_pow_r x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_r x y).\nrewrite <- (pow_pow_r x y).\nrewrite <- (pow_pow_r x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_pow_r x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_pow_r x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_pow_r x y).\nrewrite <- (pow_poss x y).\nrewrite <- (pow_poss x y).\nrewriteQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nreplace (x * y + y) with (x * y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite <- (pows_test2 y) ; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 261,
                "proof_start_offset": 563,
                "proof_end_offset": 659,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (pow2_test2 _ x y) in H.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nring.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite <- (pow2_test2_test2 _ _ _ _ H).\nrewrite <- (pow2_test2_test2 _ _ _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ _ _ H).\nrewrite <- (pow2_test2 _ _ _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ _ _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ H).\nrewrite <- (pow2_test2 _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ H).\nrewrite <- (pow2_test2 _ _ H).\nrewrite <- (pow2_test2 _ H).\nrewrite <- (pow2_test2 _ H).\nrewrite <- (pow2_test2 _ H).Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nreplace (x * y) with (x * y + y + (x * y)).\napply (Qle_test2l x y).\nrewrite <- (Qle_test2l x y).\napply (Qle_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\napply (Qlt_test2l x y).\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\napply (pow2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_testQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite (pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow;pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow;pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_pow_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nreplace (x + y) with (x + y) * (y + y) * (x + y) * (y + y)).\nintros.\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_test2s x y).\nrewrite <- (pow2s_testQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncut (forall y, x < y -> (x + y) * (x + y) = (y + y)).\nintros.\nrewrite <- (mult_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_minus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_minus_plus_plus_plus_plus_minus_minus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_minus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_plus_minus_plus_plus_plus_minus.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nsimpl.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrewrite <- (pow2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 307,
                "proof_start_offset": 663,
                "proof_end_offset": 781,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (pow2_test2 x y z).\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pol.\nintros.\napply (pow2r_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2l_test2_test2l_test2l_test2_test2l_test2_test2l_test2l_test2_test2l_test2_test2l_test2_test2_test2_test2l_test2_test2_test2_test2l_test2_test2l_test2_test2_test2l_test2_test2_test2_test2l_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_testQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pol_test1.\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (pow2_test2_test2_test2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite (tech_test1 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_test2 x y) in H.\nrewrite (tech_testQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pol.\nrewrite <- (pow2_test2_test2_test_test2_test2_test_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_testQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pol_test1.\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply (pow_pos x y).\nauto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (conj_eq _ _ (conj_eq _ (conj_eq _ (conj_eq _ _ _ (conj_eq _ (conj_eq _ (conj_eq _ _ _ (conj_eq _ (conj_eq _ _ _ (conj_eq _ _ _ (conj_eq _ _ _ _ _ (conj_eq _ _ _ _ (conj_eq _ _ _ _ _ _ _ _ _ _ _ (conj_eq _ _ _ _ _ (conj_eq _ _ _ _ _ _ _ (conj_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply ( pol_test2_1 x y); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 223,
                "proof_start_offset": 611,
                "proof_end_offset": 812,
                "proof": "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_incl; repeat rewrite N2Nat.inj_mul.\napply le_trans; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans withQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_trans; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply le_trans with (1 := H2); repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H2; apply Nle_trans with (n := m); repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_compat_l; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_trans; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_trans with (n := m).\napply Nle_Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_antisym; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_mono_l; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_le_mono; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_mul.\napply le_mono_l; repeat rewrite N2Nat.inj_mul.\napply le_trans with p; repeat rewrite N2Nat.inj_Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_nlt; repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H2; apply Nle_trans; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 814,
                "proof_end_offset": 1025,
                "proof": "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nle_mono; repeat rewrite N2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.\napply Nat2Nat.inj_mul.Qed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nge_le; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply le_n_S; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply le_trans with (n := m); repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_gt; repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m); repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_ngt; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewriteQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.Qed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.Qed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_trans; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_antisym; repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m) by (apply Nle_refl; repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := m) by (apply Nle_trans with (m := m) by (apply Nle_trans with (m := m) by (apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by (apply Nle_trans with (m := m) by (apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans with (m := m) by apply Nle_trans withQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; apply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1027,
                "proof_end_offset": 1270,
                "proof": "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_compat; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mulQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_trans with n; repeat rewrite N2Nat.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.\napply Nat2Z.inj_mul.Qed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H; apply Nge_gt; repeat rewrite N2Nat.inj_mul.\napply le_nlt_l; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_transQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nle_ge; repeat rewrite N2Nat.inj_mul.\napply le_antisym; repeat rewrite N2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans with (2Nat.inj_mul.\napply le_trans withQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_gt; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_n_le; repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := n); repeat rewrite N2Nat.inj_mul.\napply le_le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (n := m); repeatQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Ngt_compat; repeat rewrite N2Nat.inj_mul.\napply Nat.inj_mul.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.\napply Nat.inj_add.Qed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H; apply Nle_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nle_trans with m; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply lt_n_0; repeat rewrite N2Nat.inj_mul.\napply le_mono_l; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_trans with m; repeat rewrite N2Nat.inj_mul.\napply le_transQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nge_le_compat; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_n_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_n_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_n_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_n_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_n_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_n_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.\napply le_trans with n; repeat rewrite N2Nat.inj_mul.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1272,
                "proof_end_offset": 1502,
                "proof": "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nle_le_compat; repeat rewrite N2Nat.inj_mul.\napply le_n_r; repeat rewrite N2Nat.inj_mul.\napply le_n_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_r; repeat rewrite N2Nat.inj_mul.\napply le_n_S; repeat rewrite N2Nat.inj_mul.\napply le_le_trans with (nat_of_N m) (nat_of_N m)).\nrepeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_S_n; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2NatQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_trans with (nat_of_N m); repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_mono; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_lt; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply lt_N_le; repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m) (nat_of_N m) (nat_of_N m) (nat_of_N m) (nat_of_N m)).\nrepeat rewrite N2Nat.inj_mul. apply le_n_Sn.\napply le_n_O_lt; repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m) (nat_of_N m) (nat_of_N m) (nat_of_N m)).\nrepeat rewrite N2Nat.inj_mul.\napply le_n_n_le; repeat rewrite N2Nat.inj_mul.\napply le_n_trans with (nat_of_N m) (nat_of_N mQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le_compat; repeat rewrite N2Nat.inj_mul.\napply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply Nle_compat; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_add.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_mul.\napply N2Nat.inj_Qed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le_compat; repeat rewrite N2Nat.inj_mul; apply N2Nat.inj_mul; repeat rewrite N2Nat.inj_mul.\napply Nlt_compat; repeat rewrite N2Nat.inj_mul; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nle_trans; repeat rewrite N2Nat.inj_mul.\napply le_lt_compat; apply le_n_n; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_n_O; repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_n_Sm; repeat rewrite N2Nat.inj_mul.\napply le_n_S; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_compat; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_lt_compat_l; repeat rewrite N2Nat.inj_mul.\napply lt_le_compat_l; repeat rewrite N2Nat.inj_mul.\napply le_le_compat; repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_refl; repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_le_compat; repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N n); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_N m); repeat rewrite N2Nat.inj_mul.\napply le_trans with (nat_of_NQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " p * n > p * m -> n > m.\nintros n m p H1; apply Ngt_gt; apply mult_gt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3553,
                "proof_end_offset": 3760,
                "proof": "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_lt; apply le_trans with (nat_of_N b). \napply Nlt_le_compat.  apply le_n_Sm; apply lt_le_n_S; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nge_mult_0_r with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_le_compat; repeat rewrite N2Nat.inj_mul; apply lt_n_0_r; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H0; apply Nlt_gt; repeat rewrite N2Nat.inj_mul; apply lt_Sn.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nlt_gt; repeat rewrite N2Nat.inj_mul; apply lt_nonneg.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; apply Ngt_lt_compat_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_n_l; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H0 H1; apply Nge_mult_compat; apply gt_n_l.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nle_gt; apply lt_O; repeat rewrite N2Nat.inj_mul; apply lt_n_gt; apply gt_n_Sn; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nlt_lt_rev. \napply lt_le_incl; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_gt; apply gt_l; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; apply Nlt_lt_compat; apply lt_le_compat; apply lt_n_0_l; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3762,
                "proof_end_offset": 3929,
                "proof": "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nlt_gt_0; apply gt_0_r. \nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nle_gt; apply lt_n_0; apply lt_n_0.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nle_gt; apply lt_0_l.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros a b H; apply Nle_gt_0; apply gt_0_l; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros a b H1; apply Nle_lt_compat; apply lt_0_r; repeat rewrite N2Nat.inj_mul; apply gt_le_0_r; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nle_gt_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_add_r; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros a b H0; apply Nlt_gt0_l; apply gt_Sn.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros a b H1; apply Nle_le_0_l with (nat_of_N b). \napply Nle_gt; apply lt_le_trans with (nat_of_N b). \napply Nle_gt; apply le_trans with (nat_of_N b).  apply lt_n_gt; apply lt_n_n_gt; assumption.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n. apply Nle_gt; apply lt_n_0_r with (nat_of_N a). \nnow apply gt_le_trans with (nat_of_N a). \nnow apply lt_N_le; repeat rewrite N2Nat.inj_mul; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nlt_gt; apply Ngt_0; repeat rewrite N2Nat.inj_mul; apply Nle_gt; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3931,
                "proof_end_offset": 4128,
                "proof": "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\nchange (0 >= nat_of_N n)%nat.\napply ge_Nge; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (Nat.id n), <- N2Nat.id, N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply Nge_0_eq; apply NQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0; apply Nge_0; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- N2Nat.inj_mul; apply Nge_0_eq0.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0; repeat rewrite N2Nat.inj_mul; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H; rewrite <- N2Nat.id; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0_eq; apply Nge_0; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " simplify x * y? x * z where? is < > <= >= *)\n\nTheorem Rmult_le_compat_l:\n  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.\nauto with real.\nQed.\n\nTheorem Rmult_le_neg_compat_l:\n  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30052,
                "proof_end_offset": 30304,
                "proof": "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1; replace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R withQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1; replace (p * n)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%RQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1; replace (p * n)%R with (- n)%R; auto with real; try ring.\nreplace (p * m)%R with (- n)%R; auto with real; try ring.\nreplace (p * m)%R with (- n)%R; auto with real; try ring; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- n)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring; try ring.\nreplace (p * m)%R with (- m)%R; auto with real.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring.\nreplace (p * m)%R with (- m)%R; auto with real; try ring; try ring.\nreplace (p * m)%R with (- m)%Qed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1; replace (p * n)%R with (p * n * m)%R; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * m)%R with (-(p * m)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1; replace (p * n)%R with (- p)%R; auto with real.\napply Rmult_le_compat_l.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring; tryQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1 H2; replace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring; try ring.\nreplace (p * m)%R with (p * mQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * m)%R with (- p * m)%R; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H0; replace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%RQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30306,
                "proof_end_offset": 30566,
                "proof": "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m p); auto.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto.\nreplace (p * n)%R with (p * m)%R; auto with real.\nreplace (p * n)%R with (p * n * m)%R; auto with real.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (p * m)%R; auto with real.\nreplace (p * m)%R with (p * m)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%RQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto; try ring.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real; try ring.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplaceQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; elim H1; simpl in |- *; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto.\nintro H1; absurd (p * m)%R; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto with real.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; try ring.\nintros n m p H2; case (Rle_or_lt n m); auto.\nintros m p H2; case (Rle_or_lt n m); auto.\nintros m p H2; case (Rle_or_lt n m p); auto with real.\nintros m p; case (Rle_or_lt n m p); auto.\nintros m p H2; case (Rle_or_lt n m p); auto.\nintros m p H2; case (Rle_or_lt n m p); auto.\nintros m p H1 H2; case (Rle_or_lt n m p); auto.\nintros m p H1; case (Rle_or_lt n m p); auto.\nintros m p H2; case (Rle_or_lt m p); auto.\nintros m p H1; case (Rle_or_lt m p); auto.\nintros m p H1; caseQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m p); auto with real.\nintros n m p H1; case (Rle_or_lt n m p); auto; intros H2;\n auto with real.\nreplace (p * m)%R with (p * m)%R; auto with real.\nrewrite Rmult_0_r; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; replace (p * m)%R with (p * m)%R; auto with real.\nrewrite Rmult_0_l.\nrewrite Rmult_0_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_1Qed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto with real.\nrewrite Rmult_assoc; apply Rmult_lt_compat_l; auto with real.\nrewrite Rmult_assoc; apply Rmult_le_compat_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": ", (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30568,
                "proof_end_offset": 30827,
                "proof": "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n m); auto.\nintros n m p H1 H2; case (Rle_or_lt m n m); auto.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\napply Rmult_lt_compat_l; auto with real.\nrewrite (Rmult_comm (p * m)%R); auto with real.\nrewrite (Rmult_comm (p *Qed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H; case (Rle_or_lt m p); auto; intros H1; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H H2; case (Rle_or_lt m n m p H2); auto.\nintros H1; case (Rle_or_lt m n m p); auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1; case (Rle_or_lt m n m p H1); auto with real.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n m p H1); auto.\ncase (Rle_or_lt m n m p H1); auto; try ring.\nintros n m p H1 H2; case (Rle_or_lt m n p H1); auto; try ring.\ncase (Rle_or_lt m n m p H1); auto; try ring.\nintros n m p H1 H2; case (Rle_or_lt m p H1); auto; try ring.\nrewrite (Rle_or_lt m p H1); auto.\ncase (Rle_or_lt m p); auto.\nintros n m p H1 H2; case (Rle_or_lt m p H1); auto.\nintros n m p H2; case (Rle_or_lt m p H1); auto.\nintros n m p H1 H2; case (Rle_or_lt m p H1); auto.\nintros m p H2; case (Rle_or_lt m p H1); auto.\nintros m p H2; case (Rle_or_lt m pQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n m); auto.\nintros n m p H1 H2; case (Rle_or_lt m n m); auto.\nintros m p H2; case (Rle_or_lt m n m); auto.\nintros m p H1; case (Rle_or_lt m n m); auto.\nintros m p H1; case (Rle_or_lt m n m); auto.\nintros m p H1; case (Rle_or_lt m p); auto.\nintros m p H1; case (Rle_or_lt m n m); auto.\nintros m p H1; case (Rle_or_lt m p m); auto.\nintros m p H1; case (Rle_or_lt m n m); auto.\nintros m p H1; case (Rle_or_lt m p m); auto.\nintros m p H2; case (Rle_or_lt m n m p); auto.\nintros m p H1 H2; case (Rle_or_lt m n m); auto.\nintros m p H2; caseQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n m p H1); auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l with (p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l with (p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l with (p * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l with (p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l with (p * m)%R; auto with real.\napply Rmult_lt_compat_l; autoQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2; elim H1; auto.\napply Rlt_not_le; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H0; case (Rle_or_lt m n m); auto; try ring.\napply Rmult_lt_compat_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30829,
                "proof_end_offset": 31096,
                "proof": "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1; case (Rle_or_lt m n m p); auto with real.\nintros n m p H1 H2; case (Rle_or_lt m n p); auto; intros H2.\nabsurd (p * n <= m)%R; auto with real.\nrewrite Rmult_assoc; auto with real.\nreplace (p * n)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R; auto with real.\nreplace (p * n)%R with (- p)%R; auto with real.\nreplace (p * n)%RQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m p); auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H1; apply Rle_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto; intros H1.\nabsurd (p * n <= p)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nrewrite Rmult_plus_distr_r; auto with real.\nrewrite Rmult_plus_distr_r; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%R with (- m)%R; auto with real.\nreplace (p * n)%Qed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H; case (Rle_or_lt m n); auto.\nintros n m p H1; case (Rle_or_lt m n m); auto.\nintros n m p H1; case (Rle_or_lt m n m); auto; intros H2; auto.\nabsurd (p * n <= n)%R; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * m < p)%R; auto with real.\napply Rle_not_le; apply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rle_not_lt; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt m n p); auto.\napply Rle_not_le; apply Rplus_lt_compat_l; auto with real.\napply Rplus_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m p); auto.\nintros n m p H2; case (Rle_or_lt m p); auto; intros H2.\nabsurd (p * n <= m)%R; auto with real.\napply Rle_not_lt; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m p); auto; intros H2; rewrite H2; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto.\nintros n m p H1; case (Rle_or_lt m n m); auto; intros H2; rewrite H2; auto.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31098,
                "proof_end_offset": 31286,
                "proof": "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rlt_not_le; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rle_not_lt; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rle_not_le; auto with real.\napply Rlt_not_le; auto.\napply Rlt_not_le;Qed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\napply Rlt_not_le; apply Rmult_lt_compat_l.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\napply Rle_not_lt; apply Rmult_lt_reg_r with (p * n)%R.\napply Rmult_lt_compat_l; auto with real.\napply Rlt_not_le; auto with real.\napply Rmult_lt_reg_r with (p * n)%R.\napply Rmult_le_reg_r with (p * n)%R.\napply Rmult_le_compat_l with (p * n)%R.\napply Rmult_le_reg_r with (p * n)%R.\napply Rmult_lt_reg_r with (p * n)%R.\napply Rmult_lt_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_lt_compat_l.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto.\nrewrite H1; case (Rle_or_lt n m p); auto.\nrewrite H1; case (Rle_or_lt n m p); auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt m n); auto with real.\nreplace (p * n)%R with (- p * m)%R; auto with real.\nreplace (p * n)%R with (- p * m)%R; auto with real.\nreplace (p * n)%R with (- p * m)%R; auto with real.\nreplace (p * m)%R with (- p * m)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p * m)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (p * m)%R with (- p)%R; auto with real.\nreplace (Qed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt m n); auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * m < n)%R); auto with real.\napply Rle_not_lt; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto; intros H2; try ring.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2.\ncut (p * n > 0)%R; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rlt_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rle_not_lt; auto with real.\napply Rlt_not_lt; auto with real.\napply Rlt_not_lt; auto with real.\napply Rle_not_lt; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31288,
                "proof_end_offset": 31484,
                "proof": "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2.\ncut (p * n <= p)%R; auto with real.\ncut (p * n < p)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_lt_Qed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H; case (Rle_or_lt n m); auto; intros H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H1; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H1; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H1; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H2; rewrite H1; rewrite H2; rewrite H2; rewrite H1; rewriteQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\nreplace (p * n)%R with (p * n)%R; auto with real.\napply Rmult_lt_compat_l with (p * n)%R; auto with real.\nreplace (p * n * m)%R with (p * m)%R; auto with real.\nreplace (p * n * m)%R with (p * n)%R; auto with real.\napply Rmult_le_compat_l with (p * n)%R; auto with real.\nreplace (p * n)%R with (p * m)%R; auto with real.\nreplace (p * m)%R with (p * p * m)%R; auto with real.\napply Rmult_lt_compat_l with (p * m)%R; auto with real.\nreplace (p * m)%R with (p * m)%R; auto with real.\nreplace (p * p * m)%R with (p * m)%R; auto with real.\nreplace (p * mQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= m)%R; auto with real.\napply Rmult_lt_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_le_compat_l; auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_ge; apply Rmult_lt_compat_l.\napply Rinv_0_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_le_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_le_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_le_compat_l.Qed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n m p); auto; intros H2.\nabsurd (p * m <= p)%R; auto with real.\nreplace (p * n)%R with (p * n)%R; auto with real.\nreplace (p * n)%R with (p * m)%R; auto with real.\napply Rle_ge; apply Rlt_not_le; auto with real.\napply Rle_not_lt; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\napply Rle_not_lt; apply Rle_not_lt; auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\napply Rmult_le_compat_l with (p * n * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_compat_l with (p * n + m)%R; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt m n m); auto.\napply Rlt_le_trans with (p * n)%R; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31486,
                "proof_end_offset": 31663,
                "proof": "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2;\nabsurd (p * n <= p)%R; auto with real.\nreplace (p * n)%R with (p * n)%R; auto with real.\napply Rmult_le_compat_l with p; auto with real.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H; case (Rle_or_lt n m p); auto; intros H1.\nabsurd (p * n <= p)%R; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\nintros n m p H1; case (Rle_or_lt n m); auto.\nintros n m p H1; case (Rle_or_lt n m); auto.\nintros n m p H1 H2; case (Rle_or_lt m n m); auto.\nintros n p H2; case (Rle_or_lt n m); auto.\nintros n m p H1; case (Rle_or_lt n m); auto.\nintros n m p H1; case (Rle_or_lt m n m); auto.\nintros n p H1 H2; case (Rle_or_lt m n m); auto.\nintros n m p H2; case (Rle_or_lt n m); auto.\nintros n m p H2; case (Rle_or_lt m n m); auto.\nintros n m p H1; case (Rle_or_lt m n m); auto.\nintros n m p H2; case (Rle_or_lt n m); auto.\nintros m p H2; case (Qed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\nintros n m p H1; case (Rle_or_lt m n m); auto.\nrewrite <- (Rmult_comm (p * n))%R; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\nabsurd (p * n > 0)%R; auto with real.\napply Rle_ge; apply Rplus_le_compat_l with p; auto with real.\ncut (p * n)%R; auto with real.\napply Rle_ge; apply Rmult_lt_compat_l; auto with real.\ncut (p * n < m)%R; auto with real.\napply Rle_ge; apply Rle_ge; apply Rplus_lt_compat_l; auto with real.\nreplace (p * n)%R with (p * n)%R; auto with real.\napply Rle_ge; apply Rplus_le_compat_l; auto with real.\napply Rplus_lt_reg_l with p; auto with real.\napply Rle_ge; auto with real.\napply Rlt_le; auto.\napply Rlt_le; auto with real.\napply Rle_ge; apply Rplus_lt_compat_l with p; auto with real.\napply Rlt_Qed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\napply Rle_ge; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto.\nintros n m p H2 H3; case (Rle_or_lt m n); auto.\nintros n m p H1 H3; case (Rle_or_lt m n m); auto.\nintros n m p H3; case (Rle_or_lt m n m); auto.\nintros n m p H3; case (Rle_or_lt n m); auto.\nintros n m p H4; case (Rle_or_lt m n m); auto.\nintros n p H4; case (Rle_or_lt m n m); auto.\nintros n m p H4; case (Rle_or_lt m n m); auto.\nintros n m p H4; case (Rle_or_lt m n m); auto.\nintros n m p H4; case (Rle_or_lt m n m); auto.\nintros n m p H4; case (Rle_or_lt m n m); auto.\nintros n m p H4; case (Rle_or_lt m n m); auto.\nintrosQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\napply Rmult_lt_compat_l with p; auto with real.\napply Rmult_lt_compat_l with p; auto with real.\napply Rmult_le_compat_r with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt m n m); auto.\napply Rplus_lt_compat_l with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Rle_or_lt n m p); auto.\nintros n m p H1 H2; case (Rle_or_lt n m p); auto.\nintros H1; case (Rle_or_lt n m p); auto.\nintros n m p H2; case (Rle_or_lt m p); auto.\nintros n m p H1; case (Rle_or_lt n m p); auto.\nintros n m p H1; case (Rle_or_lt m p); auto.\nintros n m p H1 H2; case (Rle_or_lt n m p); auto.\nintros n m p H1; case (Rle_or_lt m p); auto.\nintros n m p H2; case (Rle_or_lt n m p); auto.\nintros n m p H1 H2; case (Rle_or_lt m p n); auto.\nintros n m p H2; case (Rle_or_lt n m p); auto.\nintros n m p H2; case (Rle_or_lt m p); auto.\nintros n pQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31665,
                "proof_end_offset": 31850,
                "proof": "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt m n m p); auto.\nintros n m p H1; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt m p); auto.\nintros H2; case (Rle_or_lt m p); auto.\nintros H2; case (Rle_or_lt m p); auto.\nintros H2; case (Rle_or_lt m p); auto.\nintros H2; case (Rle_or_lt m p); auto.\nintros H2; case (Rle_or_lt m p); auto.\nintros H2; case (Rle_or_lt m p); auto.\nintros H3; case (Rle_or_lt m p); auto.\nintros H3; case (Rle_or_lt m p); auto.\nintros H3; case (Rle_or_lt m p); auto.\nintros H4; case (Rle_or_lt m p); auto.\nintros H3; case (Rle_or_lt m p); auto.\nintros H4; case (Rle_Qed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * n > 0)%R; auto with real.\napply Rmult_lt_compat_l with p; auto with real.\napply Rmult_le_compat_l with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt m n); auto.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\nintros n m p H2; case (Rle_or_lt n m); auto.\nintros n m p H2 H2; case (Rle_or_lt n m); auto.\nintros n m p H2; case (Rle_or_lt n m); auto.\nintros n m p H2; case (Rle_or_lt n m); auto.\nintros n m p H1; case (Rle_or_lt n m); auto.\nintros n m p H2 H3; case (Rle_or_lt n m); auto.\nintros n m p H2; case (Rle_or_lt n m p); auto.\nintros n p H3; case (Rle_or_lt m p); auto.\nintros n p H3; case (Rle_or_lt n m p); auto.\nintros n m p H4; case (Rle_or_lt n m p); auto.\nintros n m p H3; case (Rle_or_lt n m p); auto.\nintros n p H3; case (RleQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m p); auto.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite <- Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite <- Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite <- Rmult_Qed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p)%R; auto with real.\napply Rmult_lt_reg_l with (p * n)%R; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto.\nrewrite Rmult_comm.\napply Rmult_lt_compat_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 31871,
                "proof_end_offset": 31978,
                "proof": "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros n m p H1 H2; case (Rle_or_lt m n m); auto.\nintros n m p H1; case (Rle_or_lt m n m p); auto.\nintros n m p H1; case (Rle_or_lt m n m p); auto.\nintros m p H1; case (Rle_or_lt m n m p); auto.\nintros m p H2; case (Rle_or_lt m n m p); auto.\nintros m p H1; case (Rle_or_lt m n m p); auto.\nintros m p H1 H2; case (Rle_or_lt m n m p); auto.\nintros m p H2; case (Rle_or_lt m n m p); auto.\nintros m p H1; case (Rle_or_lt m n m p); auto.\nintros m p H1; case (Rle_or_lt m n m p); auto.\nintros m p H2; case (Rle_or_lt m n m p); auto.\nintros m p H1; case (Rle_or_lt m p m p);Qed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case (Rle_or_lt n m); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; case (Rle_or_lt y z); auto.\nintros H1 H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt 0 m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H1 H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H2; case (Rle_or_lt n m p); auto.\nintros H1; case (Rle_or_lt n m p); auto.\nintros H3; case (Rle_or_lt n m p);Qed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y H1; case (Rle_or_lt x y); auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; case (Rle_or_lt n m p); auto; intros H2;\n [ intros H1 | apply Rlt_not_le; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y H1; case (Rle_or_lt n m); auto.\napply Rplus_lt_compat_l with p; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros n m p H; case (Rle_or_lt n m p); auto; intros H1; apply Rlt_not_le; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; case (Rle_or_lt 0 m p); auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; case (Rle_or_lt x y); auto; intros H2;\n apply Rle_ge; apply Rlt_le_trans with y; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros n m p H1; red; intros H2; case (Rle_or_lt n m); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 31979,
                "proof_end_offset": 32086,
                "proof": "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; case (Rle_or_lt y z); auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; case (Rle_or_lt y z); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H1; case (Rle_or_lt x y); auto; intros H1 H2.\nabsurd (p * n > p)%R; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; apply Rle_ge; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; apply Rlt_not_lt; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; case (Rle_or_lt x z); auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; case (Rle_or_lt y z); auto; intros H1.\nabsurd (p * n > 0)%R; auto with real.\napply Rmult_lt_reg_l with p; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y H; case (Rle_or_lt y z); auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y H; red; intros H0 H2; red; intros H3;\n apply Rle_ge; apply Rplus_le_compat_l with p; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; case (Rle_or_lt x y); auto; intros H1 H2;\n try apply Rle_lt_trans with (y := z); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32087,
                "proof_end_offset": 32194,
                "proof": "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y H; rewrite H; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y H; case (Rle_or_lt x y z); auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y H; rewrite H; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; elim H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32195,
                "proof_end_offset": 32302,
                "proof": "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; case (Rle_or_lt x y); auto; intros H1 H2; apply Rle_lt; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y H; case (Rle_or_lt y z); auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y H; rewrite H; auto with real.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32303,
                "proof_end_offset": 32412,
                "proof": "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " a Z *)\nLtac RCst t :=\n  match t with\n   | R0 => constr:(Z0)\n   | R1 => constr:(Zpos xH)\n   | Rplus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4809,
                "proof_end_offset": 4938,
                "proof": "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_neg_compat_r; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_pos_compat_l with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_neg_compat_l.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_eq_compat; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_neg_compat_l.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_neg_compat_l.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_neg_compat; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_neg_compat_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4940,
                "proof_end_offset": 5073,
                "proof": "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_gt_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_gt_compat_l with n; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l with n; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l with a; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5075,
                "proof_end_offset": 5184,
                "proof": "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a b c H H1; case H; subst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_gt_compat_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_lt_reg_l with b; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_lt_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_reg_l; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_reg_r with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_reg_r with (f := plus_le_reg_l a b c).\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_reg_l with (f := plus_comm a b c); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros; apply plus_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5186,
                "proof_end_offset": 5320,
                "proof": "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_reg_r; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; apply plus_ge_reg_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_reg_l with (n := m); auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_reg_r with n; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_ge_reg_r with a; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_reg_l with (f := plus_pos p); auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_lt_reg_l with (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plus_le_reg_r (f := plusQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_compat_r; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\nTheorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.\n\n(* For replace *)\n",
                "context_tokens": 736,
                "proof_start_offset": 5340,
                "proof_end_offset": 5446,
                "proof": "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply plus_gt_reg_r with p; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y H; apply plus_le_reg_r with (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := r)) (f := plus_comm (f := plus_comm (f := (f := plus_comm (f := (f := plus_comm (f := plus_comm (f := plus_comm (f := (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_comm (f := plus_Qed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply plus_le_reg_r with p; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply le_lt_trans with (f := plus_gt_reg_r x y); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; unfold eq; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; apply plus_lt_reg_r with p; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; apply plus_le_reg_l with p; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H; induction z; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; case H.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply le_trans with z; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 485,
                "proof_start_offset": 1028,
                "proof_end_offset": 1154,
                "proof": "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl inQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nreplace (a + c) with (a + c + d).\n2:rewrite H.\nring.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2 in |- *.\npattern b at 2Qed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 552,
                "proof_start_offset": 1156,
                "proof_end_offset": 1273,
                "proof": "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nGoal forall a b c d, a + c > 0 -> a + c + c = a + c + c.\nintros.\nGoal forall a b c d H1 H2.\nsimpl.\nsimpl.\nring.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\napply (gcd0 r).\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nsimpl in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\napply (le_trans_trans_1 _ _ _ H1 H2).\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H1 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H1 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite H0 in |- *.\nintros.\nrewrite HQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nsimpl.\nring.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nelimtype False.\nintros.\nrewrite H.\nrewrite H1; auto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nelimtype False.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nexact H.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nsimpl in |- *; auto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nchange (a + c + c + d).\nintros.\nchange (a + c + d).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a + c).\nrewrite <- (a +Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 611,
                "proof_start_offset": 1275,
                "proof_end_offset": 1401,
                "proof": "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nrewrite <- H.\nring.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nrewrite H0; auto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nrings.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npattern (a + b + c) at 1 in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |-Qed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nring.\nring.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nintros.\nsimpl in |- *.\napply (lele_trans _ _ _ H0).\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nrewrite H0.\nring.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nsimpl.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nsimpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 1463,
                "proof_end_offset": 1579,
                "proof": "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl.\nreplace (a + c) with (a + c + d).\nrewrite (Zmult_assoc (a + c) (a + d)).\nrewrite (Zmult_assoc (a + c) (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_assoc (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_comm (a + d)).\nrewrite (Zmult_Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl in |- *.\nrewrite H.\nsimpl in |- *.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl in |- *.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl.\nsimpl.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nring_simplify.\nring_simplify.\nrewrite H0.\nring_simplify.\nring_simplify.\nrewrite H.\nring_simplify.\nrewrite H0.\nring_simplify.\nring_simplify.\nrewrite H0.\nring_simplify.\nrewrite H0.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl.\nrewrite <- (Zdiv0_r (a + c) P.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl.\nreplace (a + c + c) with (a + c + d).\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nsimpl.\nsimpl.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Open Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\nGoal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 1581,
                "proof_end_offset": 1693,
                "proof": "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\npolr (d = 0).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl in |- *.\nsimpl inQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nGoal forall a b c d, 0 <= a + b + c + c + d + d.\nintros.\nsimpl;auto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl.\nring.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl.\nring.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nrewrite (a + c) in *.\nrings.\nAbort.\n\n(* Test a tactic *)\n\nGoal forall a b c d d, a + b + c + d = d -> a + d + d + d.\nintros.\nsimpl.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl.\nring.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl in |- *.\nring.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nrewrite IHps.\nsimpl.\nsimpl.\nrewrite IHps.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.\nsimpl.Qed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl; auto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nsimpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 293,
                "proof_start_offset": 635,
                "proof_end_offset": 724,
                "proof": "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nreplace (x + y) with (2 * x * (y + y)).\nintros.\napply pols_test5; auto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros x y H.\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 x y H).\napply (Add_test2 xQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq x y).\nrewrite <- (pows_test2_eq y y).\nrewrite <- (pows_test2_eq x y).\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pols_test4.\napply pols_test5.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test5.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_test6.\napply pols_Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pols_test3.\napply pols_test4.\napply pols_test3.\napply pols_test3.\napply pols_test3.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply pols_test3.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nchange (0 <= x * y * y)%R with (1 * x * y + 1 * (x + y))%R.\nintros.\nreplace (0 <= x * y * (y + 1)) with (1 * x * y * (y * (y + 1)) * (y * y)).\nrewrite (mult_comm (x * y) * (y * (y + 1)) * (y * (x + y)) * (y * (y * y)))).\nrewrite (mult_comm (x * y) * (y * (y * y))).\nrewrite (mult_comm (x * y) * (y * (y * y))); auto with real.\nrewrite (mult_comm (x * y)) by auto with real.\nrewrite (mult_comm (x * y)) by auto with real.\nrewrite (mult_comm (x * y) by auto with real.\nrewrite (mult_comm (x * y) by auto with real.\nrewrite (mult_comm (x * y) by auto with real.\nrewrite (mult_comm (x * y)) by auto with real.\nrewrite (mult_comm (Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nreplace (x * y + 1) with (2 * x * y * y + 1 * (y + 1)) by ring.\nrewrite <- (mult2r_test4 x y).\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\napply (Qle_norm x y); auto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nunfold pols.\nrewrite <- (Rec_test2 x y).\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 336,
                "proof_start_offset": 726,
                "proof_end_offset": 820,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nrewrite <- (plus_plus_plus_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_one_oneQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\napply Qmult_zero.\napply Qinv_zero.\napply Qinv_zero.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncut (forall y, (x + y)%R -> 0 <= y)%R.\nintros.\ncut (forall y, (x + y)%R -> 0 <= x + y)%R.\nintros.\ncut (forall y, (y < y)%R -> (y <= x + 1)%R).\nintros.\ncut (forall y, (y < y)%R -> (y <= x + 1)%R).\nintros.\ncut (forall y, (y < x + 1)%R).\nintro.\ncut (forall y, (x + y)%R).\nintro.\ncut (forall y, (y <= y)%R).\nintro.\ncut (forall y, (y < x)%R).\nintro.\ncut (forall y, (y < x)%R).\nintro.\ncut (forall y : R, (y < x)%R).\nintro.\ncut (forall y : R, (y <= y)%R).\nintro.\ncut (forall y : R, (y < x)%R).\nintro.\ncut (forall y : R, (y <= y)%R).\nintro.\ncut (Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nrewrite <- (pow2_test3 x y).\napply pows_test3.\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test4 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test4 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (pow2_test3 x y).\nrewrite <- (powQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncase (leb x y); intros.\nrewrite <- (mult_comm x y); auto with real.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nunfold pol.\nrewrite (pow2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_test2_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncase (Zle_or_eq x y).\nintros.\nsimpl.\nrewrite <- (Rmult_comm (x * y)) at 1; rewrite <- Rplus_assoc; auto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncase H; intros.\nsimpl in |- *; intro.\nreplace (0 <= x * y)%R with (0 <= x * y)%R.\nrewrite (mult_comm x y x * y * (y * y * x)).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nrewrite <- (mult_comm x y).\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, (0 < x -> x  <= x  * y -> 1 <= y)%R.\nintros.\nhyp_polf H0.\nQed.\n\n",
                "context_tokens": 382,
                "proof_start_offset": 822,
                "proof_end_offset": 950,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply (pow2l_test2l (l_test2l (l_test2l (l_test2l (l_test2l (l_test2l_test2l (l_test2l (l_test2l (l_test2 l_test2l2 (l_test2l (l_test2l2 (l_test2l2)) (l_test2l (l_test2l (l_test2l_test2l2))) (l_test2l (l_test2 l1 (l_test2l (l_test2 l2)) (l_test2l (l_test2 (l_test2 l1 l2))) (l_test2l (l_test2 l1 (l_test2 (l_test2l2_test2 (l_test2l2))) (l_test2l (l_test2 (l_test2l2_test2l (l_test2 l2))) (l_test2l (l_test2l (l_test2 (l_test2l2 (l_Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pol_test2.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold pol, pol.\nunfold pol.\nintros.\nrewrite <- (pow2_test2 (fun x y => x + 1 + 1) * (x + y)).\nintros.\nrewrite <- (pow2_test2 (fun x y => x + 1 + 1) * (x + 1 + 1)) * (x + 1 + 1) * (x + 1 + 1) * (x + 1)) * (x + 1 + 1)) * (x + 1) * (x + 1) * (x + 1)).\nintros.\nrewrite <- (pow2_test2 (fun x y => x + 1) * (x + 1) * (x + 1) * (x + 1) * (x + 1)) * (x + 1)) * (x + 1) * (x + 1)) * (x + 1)) * (x + 1) * (x + 1) * (x + 1)) * (x + 1) * (x + 1)) * (x + 1) * (x + 1)) * (x + 1)) * (x + 1)) * (x + 1) * (x + 1)Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (z*z) ; auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply (pow_eq x y).\napply (pow_eq x y).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply ( pol_test2 _ x y z z).\nunfold polx, y in |- *.\napply ( pol_test2 _ x z).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (le_trans x y z).\ncase (le_trans y z).\nintros.\ngeneralize (le_trans y z).\nintro.\nrewrite (le_trans y z).\nrewrite (le_trans y z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (le_trans z z).\nrewrite (Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite (pows_test2_test2 _ _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ H0) in H.\napply (pows_test2 _ _ H0) in H.\napply (powsQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply pol_test2 with (1 := x * y * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\nintros.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\nrewrite <- (2 * z * 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napply pol_test2 with (2 := x * z + 1)%R.\napplyQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (Zle_lt_le_trans _ _ H0).\nintros.\napply Rle_trans with (1 * x * y)%R.\nintros.\ngeneralize (Zle_lt_trans _ _ H0).\nintros.\nrewrite (Zle_lt_trans _ _ H0).\nintros.\napply Rlt_trans with (1 * x * y)%R.\nintros.\nrewrite (Zle_lt_trans _ _ H).\nintros.\nrewrite (Zle_lt_trans _ _ H0).\nintros.\nrewrite (Zle_lt_trans _ _ _ H0).\nrewrite (Zle_lt_trans _ H).\napply Zlt_le_trans with (1 * x * y)%R.\nintros.\nrewrite (Zle_lt_trans _ _ H0).\nintros.\nrewrite (Zle_lt_trans _ _ H).\nrewrite (Zle_lt_trans _ _ H).\nrewrite (Zle_lt_trans _ _ H).\nintros.\nrewrite (Zle_lt_trans _ _ H0).\nrewrite (Zle_lt_trans _ H0).\napply Zlt_le_trans with (1 *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": " (-0)%R; auto with real.\nQed.\n\nTheorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.\nintros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring.\napply Rmult_lt_0_compat; auto with real.\nQed.\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3923,
                "proof_end_offset": 4160,
                "proof": "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; rewrite <- (Ropp_involutive x); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_sign_pos_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; apply Rlt_trans with (1 := x); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_sign_pos_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_sign_pos_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; apply Rle_ge; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_trans with (1 := H); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": ".\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4162,
                "proof_end_offset": 4401,
                "proof": "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H; case (Rle_or_lt 0 y); auto with real.\nintros H1 H2; absurd (0 <= x * y)%R; auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt 0 y); auto with real.\napply Rle_trans with (Rabs (x * y))%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt 0 y); auto.\nintros x y H1; elim H1; auto with real.\nintros H1; absurd (0 < x * y)%R; auto with real.\nrewrite <- (Ropp_involutive x); auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt 0 x y); auto with real.\nintros x y H1; case (Rle_or_lt 0 x y); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; auto with real.\napply Rle_ge; auto with real.\napply Rle_ge; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros; red; apply Rlt_le; auto with real.\nintros x y H1; elim H1; auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H; case (Rle_or_lt 0 x y); auto.\nintros H1; absurd (0 <= x * y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H2; absurd (0 <= x)%R; auto with real.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H; case (Rle_or_lt 0 y); auto.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_trans with (1 := H3); auto with real.\napply Rle_trans with (1 := H3); auto with real.\napply Rle_ge; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4403,
                "proof_end_offset": 4640,
                "proof": "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt 0 y 0); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H0; case (Rle_or_lt 0 y 0); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_ge; auto with real.\napply Rle_ge; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_le; auto.\napply Rlt_le; auto with real.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt 0 x y); auto with real.\nintros H1; absurd (0 < x * y)%R; auto with real.\napply Rle_ge; apply Rlt_le; auto with real.\napply Rle_ge; auto with real.\napply Rlt_trans with (1 < x)%R; auto with real.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H2; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt 0 x); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\nintros H4; absurd (0 <= x * y)%R; auto with real.\nintros H4; absurd (0 <= x * y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_le_trans with (1 := H); auto with real.\napply Rlt_le_trans with (1 := H3); auto with real.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H; case (Rle_or_lt 0 y); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\nrewrite <- (Ropp_involutive x); auto with real.\nrewrite <- (Ropp_involutive x); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H2; case (Rle_or_lt 0 y 0); auto.\nintros H2; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H0; case (Rle_or_lt y 0); auto with real.\nintros H1; absurd (0 < x * y)%R; auto with real.\napply Rle_trans with (1 := H1); auto with real.\napply Rlt_not_le; auto with real.\napply Rle_ge; apply Rle_ge; apply Rle_ge; auto with real.\napply Rle_ge; apply Rle_ge; auto.\napply Rle_ge; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\nTheorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4642,
                "proof_end_offset": 4880,
                "proof": "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H2; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_not_le; auto with real.\napply Rle_lt; apply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1; case (Rle_or_lt 0 x); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1; case (Rle_or_lt 0 y 0); auto.\nintros H1 H2; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_trans with (1 := H2); auto with real.\napply Rlt_not_le; auto with real.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1; case (Rle_or_lt y 0); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\napply Rlt_trans with (1 < x * y)%R.\napply Rlt_le; auto with real.\napply Rle_trans with (1 < x * y)%R.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1; case (Rle_or_lt 0 y); auto with real.\nintros H2; absurd (0 <= x)%R; auto with real.\napply Rlt_trans with (1 < x * y)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H; case (Rle_or_lt 0 y 0); auto with real.\nintros H3; absurd (0 <= x)%R; auto with real.\napply Rle_ge; apply Rlt_le; apply Rle_ge; apply Rlt_le; apply Rle_ge; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n    apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;\n  apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le;Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H1; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 x y); auto.\nintros H1 H2; absurd (0 <= x * y)%R; auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H2); auto.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H2); auto.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (1 := H2); auto.\napply RltQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Zex.v",
                "context": "Require Import ZArith.\nRequire Import PolTac.\n\nOpen Scope Z_scope.\n\nTheorem pols_test1: forall (x y : Z), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : Z), y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : Z), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with zarith.\nQed.\n \nTheorem pols_test4:\n forall (x y : Z),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <= x  * y)%Z.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 326,
                "proof_start_offset": 711,
                "proof_end_offset": 805,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (pol_smalls x y).\nrewrite (Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nrewrite <- (plus_eq (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (f_test2 x) (Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nrewrite (mult_comm x y) at 1; apply (mult_comm x y).\nrewrite (mult_comm y y) at 1; apply (mult_comm x y).\nrewrite (mult_comm y z) at 1; apply (mult_comm x y).\nrewrite (mult_comm x y) at 1; apply (mult_comm x y).\nrewrite (mult_comm y z) at 1; apply (mult_comm x y).\nrewrite (mult_comm y z) at 1; apply (mult_comm x y).\nrewrite (mult_comm z).\nrewrite (mult_comm x y) at 1; apply (mult_comm x y).\nrewrite (mult_comm y z).\nrewrite (mult_comm z) at 1; apply (mult_comm x z).\nrewrite (mult_comm z) at 1; apply (mult_comm x y).\nrewrite (mult_comm y z).\nrewrite (mult_comm z) at 1; apply (mult_comm x y).\nrewrite (mult_comm z).\nrewrite (mult_comm z) at 1; apply (mult_comm z).\nrewrite (multQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_test2 x y) in *.\nrewrite <- (f_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_comm x y) at 1.\nrewrite <- (mult_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros x y H.\nrewrite <- (conj_eq _ (conj_eq _ (conj_eq _ (conj_eq _ _ (conj_eq _ (conj_eq _ (conj_eq _ (conj_eq _ _ (conj_eq _ _ _ _ (conj_eq _ _ (conj_eq _ _ _ (conj_eq _ _ _ (conj_eq _ _ _ _ (conj_eq _ _ _ _ _ _ (conj_eq _ _ _ _ (conj _ _ _ _conj_eq _ _ _ _ _ _ _ _ (conj_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\ncase H.\nintros.\napply pols_test3 with (1 := x * (x * y)) * (y * y)).\nintros.\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <- (mult_comm x).\nrewrite <-Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nunfold pol.\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).\nrewrite <- (mul_comm x y).Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nrewrite (conj_eq x y).\nrewrite (conj_eq y).\nrewrite (conj_eq x y).\nrewrite (conj_eq y).\nrewrite (conj_eq x y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq x).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq x).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq x).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq y).\nrewrite (conj_eq x).\nrewrite (conj_eq x).\nrewriteQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nrewrite <- (f_test2 (fun x y => x * y * y * (x + y) * (x + y) * (y + y)) * (x + y) * (y + y))).\nintros.\nrewrite <- (f_test2 (fun x y => y * (x + y) * (y + y) * (x + y)) * (y + y)).\nintros.\nrewrite <- (f_test2 (fun x y => x * (y + y)) * (y + y) * (y + y) * (y + y)).\nintros.\nrewrite <- (f_test2 (fun x y => x * (y + y) * (y + y)) * (y + y) * (y + y) * (y + y) * (y + y)).\nintros.\nrewrite <- (f_test2 (fun x y => x * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + y) * (y + yQed."
                ]
            }
        ],
        "angles": [
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \n",
                "context_tokens": 447,
                "proof_start_offset": 1407,
                "proof_end_offset": 1868,
                "proof": "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v)))); auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold app, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nintros u v v v v' v' v' v' v' v' v' v' v' v' v' v' v' v' v' v' v'.\nintros u v v v' v' v' v' v' v' v' v' v' v' v'.\nintros v v v v' v' v' v' v' v' v' v'.\nintros v v v' v' v' v' v' v'' v' v' v' v'' v' v' v' v'' v'' v'' v' v'.\nintros v v' v' v' v' v' v' v'' v' v'' v' v'.\nintros v v' v' v' v' v' v' v' v' v'.\nintros v v' v' v' v' v'.\nintros v v' v' v' v' v' v' v' v'' v'.\nintros v v' v' v' v' v' v' v' v'' v' v' v''.\nintros v v' v' v' v' v'.Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold is_couple in |- *; intros.\napply not_all with (add one zero); auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \n",
                "context_tokens": 582,
                "proof_start_offset": 1900,
                "proof_end_offset": 2307,
                "proof": "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal; intros.\napply (add_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diffQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal, orthogonal; intros.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w); auto.\napply (map_swap v w w); auto.\napply (map_swap v w w); auto.\napply (mapQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply R_upper with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S i))))))))))\n  (fun a' : V =>\n         (plus (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S i))))))))\n    (fun a' : V =>\n         (plus (S (S (S (S (S (S (S (S (S (S i))) (S (S (S (S (S (S (S (S (S (S i))) (S (S (S (S (S (S i)))) (S (S (S (S (S (S (S (S (S (S (S i)))) (S (S (S (S (S (S i)))) (S (S (S (S (S (S (S (S (S (S (S (S i))) (S (S (S (S (S (S (S (S (SQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_not_Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply (in_map zero (cons u v)) (map (cons v w)); auto.\napply (in_map zero) with (map (cons v v)); auto.\napply (in_map zero); auto.\napply (in_map zero); auto.\napply (in_map zero); auto.\napply (in_map zero); auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero; auto.\napply in_map zero;Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \nLemma orthogonal_colineaire :\n forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 2310,
                "proof_end_offset": 2663,
                "proof": "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nunfold colineaire in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold is_ant, coherent, image, image, image, image, image,image, image, image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,image,Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold coherent, dans in |- *; intros.\napply transitive with (plus zero) (plus (S n)); auto.\napply le_trans with (plus one); auto.\napply le_trans with (plus one); auto.\napply le_trans with one); auto.\napply le_trans with (plus one); auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold open_a_pt in |- *; intros.\napply red in |- *; intros.\napply (H (inter_exists v w); auto.\napply (H (inter_exists v w); auto.\napply (H (diff_exists v w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napply (H (inter_exists w w); auto.\napplyQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nunfold is_upper, line_upper, extension in |- *; intros.\napply le_trans with (S (add u v)); auto.\napply le_trans with (plus one).\napply le_trans with (add (add u v) (add u v)); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add u v); auto.\napply le_trans with (add v v); auto.\napply le_trans with (add u vQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold is_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_rel, same_Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold suba, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, head, headQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold dans,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bdbd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd,bd2,bdbd,bd,bd,bdbd2bd,bd1,bd,bd,bd,bd2,bd,bd,bd,bd,bd,bd1,bd,bd,bd2,bd,bd,bd2bdbdbdbdbd,bd,bd2,bdbd2,bd1bd,bdbd1,bd2,bd2bd2,bd2bd2,bd,bd2bd,bd2bd1bd2,bdbd1bd2,bd2bd2bd1,bd2bd2bd2,bd2bd1bd2bdbd0bdbdQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold dans, egala, liftaireuirea_transitive.\nunfold egala, lifta, lifta_least_transitive.\nunfold is_is_least_transitive, lifta_transitive.\nunfold egala, lifta, liftairea_least_transitive.\nunfold egala, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lifta, lift a, lifta, lifta, lifta, lifta, lift a, lifta, lifta, lift a, lifta, lifta, lifta, lifta, lift a, lift a, lifta, lift a, lifta, lift a, lifta, lift a, lifta, liftlift, lifta, lift a, lift a, lift a, lift a, lifta, lifta, lifta, lifta, lifta, lifta, lift a, lift aQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold is_aire in |- *; intros.\napply H with (S (add a e)); auto.\napply le_trans with (plus one); auto.\napply le_trans with (plus one); auto.\napply le_trans with (mult one); auto.\napply le_trans with (mult one); auto.\napply le_trans with (mult one); auto.\napply le_trans with one; auto.\napply le_trans with (minus one); auto.\napply le_trans with one; auto.\napply le_trans with (plus one); auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one; auto.\napply le_trans with one;Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold coherent in |- *; intros.\napply le_trans with (plus (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))) (plus (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))); S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed."
                ]
            }
        ],
        "coq-procrastination": [
            {
                "filepath": "./coq_projects/coq-procrastination/src/Procrastination.v",
                "context": " match goal with |-?G =>\n    match type of G with\n    | Prop => mk_begin_defer_helper_Prop ids H\n    | _ => mk_begin_defer_helper_Type ids H\n    end;\n    cut H; subst H; [| now prove_begin_defer_helper]\n  end.\n\n(* Tests *)\nGoal True.\n  mk_begin_defer_helper tt.\n  intro H; eapply H; clear H.\nAbort.\n\nGoal True.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\nGoal nat.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\n(* [end defer] helpers.\n\n   [end defer] is called on the second subgoal produced by [begin defer], of the\n   form [exists a.. z, group a.. z], where [group a.. z] has been\n   instantiated by [defer] into something of the form [P1 /\\ P2 /\\... /\\ Pn /\\\n  ?P], where P1.. Pn are the propositions that have been deferred, and [?P] is\n   the \"accumulator\" evar.\n\n   The role of [end defer] is to close the goal, instantiating [?P] with [True],\n   and removing it from the goal.\n\n   This is done by first applying a lemma of the form:\n\n   ```\n   forall A.. Z (G1 G2 : A ->.. -> Z -> Prop),\n   (forall a.. z, G1 a.. z -> G2 a.. z) ->\n   (exists a.. z, G1 a.. z) ->\n   exists a.. z, G2 a.. z\n   ```\n\n   After applying this lemma, [G2] is unified with the current goal (to clean),\n   and [G1] is introduced as an evar. An auxiliary tactic\n   ([cleanup_conj_goal_core], defined below) is called on the first subgoal, and\n   will discharge it, instantiating [G1] with the cleaned-up goal (i.e [P1 /\\ P2\n   /\\... /\\ Pn]).\n\n   The helpers below help generating and proving this lemma, for any number of\n   variables [a].. [z].\n*)\n\n(* Tactic that proves the lemma above for any arity. *)\nLtac prove_end_defer_helper :=\n  introsType;\n  let P1 := fresh in\n  let P2 := fresh in\n  let H1 := fresh in\n  let H2 := fresh in\n  intros P1 P2 H1 H2;\n  unfold Marker.end_defer in *;\n  repeat (let x := fresh \"x\" in destruct H2 as (x & H2); exists x);\n  apply H1; auto.\n\n(* Tests. *)\nGoal forall A (P1 P2 : A -> Prop),\n  (forall a, P1 a -> P2 a) ->\n  (exists a, P1 a) ->\n  Marker.end_defer (exists a, P2 a).\nProof. prove_end_defer_helper. Qed.\n\n",
                "context_tokens": 707,
                "proof_start_offset": 14539,
                "proof_end_offset": 14719,
                "proof": "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nprove_end_defer_helper.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  prove_def_helper_nat.\n  intro H.\n  assert (H1 := H2).\n  intros P1 H2 H2.\n  apply H2; clear H2; clear H2; clear H2; clear H2;\n  clear H2; rename H2 into H2.\n  rename H into H2.\n  rename H into H1.\n  rename H into H2.\n  rename H into H2.\n  rename H into H2.\n  rename H into H1.\n  rename H into H2.\n  rename H into H2.\n  rename H into H3.\n  rename H into H3.\n  rename H into H2.\n  rename H into H3.\n  rename H into H2.\n  rename H into H3.\n  rename H into H3.\n  rename H into H2.\n  rename H into H3.\n  rename H into H3.\n  rename H into H4.\n  rename H into H4.\n  rename H into H2.\n  rename H into H3.\n  rename H into H3.\n  rename H into H3.\n  rename H into H2.\n  rename H into H2.\n  rename H3 into H3Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nintros.\nintros.\napply H1; clear H1 H2.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  intros.\n  let H2 := fresh in\n  let H2 := fresh in\n  pose proof H2;\n  clear H2;\n  assert (exists a, P1 a b).\n  apply (exists a, P1 a); exists b; exists b; exists b; split; auto.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. exact (fun x => True). Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  intros.\n  apply (fun a b => P1 a b); auto.\n  apply (fun a b => P1 a b); auto.\n  apply (fun a b => P2 a b); auto.\n  apply (fun a b => P1 a b); auto.\n  apply (fun a b => P2 a b); auto.\n  apply (fun a b => P2 a b); auto.\n  apply (fun a b => P2 a b); auto.\n  apply (fun a b => P2 a b); auto.\n  apply (fun a b => Q1 a b); auto.\n  apply (fun a b => Q1 a b); auto.\n  apply (fun a b => Q2 a b); auto.\n  apply (fun a b => Q1 a b); auto.\n  apply (fun a b => Q2 a b); auto.\n  apply (fun a b => Q2 a b); auto.\n  apply (fun a b => Q2 a); auto.\n  apply (fun a b => Q2 a); auto.\n  apply (fun a b => Q2 a); auto.\n  apply (fun a b => Q1 a); auto.\n  applyQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  intros.\n  (* test *)\n  unfold test_goal_def_helper_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal_eq_aux.\n  unfold test_goal_aux_aux.\n  unfold test_goal_eq_aux.\n  unfold test_goal_aux_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_aux_aux.\n  unfold test_goal.\n  unfold test_goal_aux.\n  unfold test_aux.\n  unfold test_goal_aux.\n  unfold test_aux.\n  unfold test_goal_aux.\n  unfold test_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_goal.\n  unfold test_goal_aux.\n  unfold test_goal_aux.\n  unfold test_aux.\n  unfold test_goal.\n  unfold test_goal_aux.\n  unfold test_aux.Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  intros A B P1 P2 H2.\n  unfold A, P2.\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (fun x => x).\n  apply (Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  simple induction on as [a b] tactic [a]\n    [a] tactic [b] tactic [b]\n    [a] tactic [b] tactic [b]\n    [b] tactic [b]\n    [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    [b] tactic [b] tactic [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    tactic [b] tactic [b] tactic [b]\n    [b] tactic [b] tactic [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    tactic [b] tactic [b]\n    tactic [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    [b] tactic [b] tactic [b]\n    [b] tacticQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n  intros; apply H1; clear H1 H1; intros P2 H2 H3; subst; clear H3; intros P1 H3; clear H3 H4; intros P1 H3 H4; clear H4; intros P1 H4 H4 H4; clear H4 H4 H4; intros P1 H4; clear H5; intros P1 H4 H4 H4 H5; clear H5 H5 H7; intros P1 H3; clear H7 H7 H7 H7 H8 H9 H8 H9 H9 H9 H9 H10 H10 H10 H10 H10 H11 H11 H12 H12 H12 H12 H13 H12 H13 H13 H13 H13 H13 H13 H14 H14 H14 H14 H13 H15 H14 H14 H15 H15 H15 H15 H15 H15 H15 H15 H15 H15 H17 H15 H15 H15 H14 H15 H15 H15 H15 H17 H15 H16 H17 H18 H17 H18 H17 H18 H18 H18 H18 H19 H17 H18 H19 HQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\n    intros A B P1 H2 H2 H2 H3.\n    apply (H2 (H3 (H3 (H3 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H4 (H5 (H6 (H4 (H5 (H5 (H5 (H5 (H6 (H5 (H6 (H7 (H8 (H6 (H6 (H6 (H7 (H7 (H8 (H8 (H8 (H8 (H8 (H8 (H8 (H8 (H8 (H9 (H8 (H10 (H9 (H8 (H9 (H10 (H9 (H9 (H8 (H9 (H8 (H9 (H8 (H9 (H10 (H10 (H8 (H9 (H9 (H9 (H10 (H9 (H10 (H10 (H9 (H10 (H10 (H10 (H10 (H9 (H10 (H9 (H10 (H9 (H10 (H9 (H9 (H9 (HQed."
                ]
            }
        ],
        "tree-automata": [
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nRequire Import EqNat.\nRequire Export Max.\n\nLemma nat_sum : forall n : nat, n = 0 \\/ (exists m : nat, n = S m).\nProof.\n\tsimple induction n. left. reflexivity. intros. right.\n\tsplit with n0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3102,
                "proof_end_offset": 3223,
                "proof": "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nelim (max_le_Sr_0 n m).\nintros.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim H. intros. elim H. intros. elim H. intros. simpl in |- *. apply (le_n_S (S n0)) (max (S n0) (S n0)) (max (S n0) (S n0)) (max n0))).\n\tintros. simpl in |- *. rewrite H0. trivial.\n\tsimpl in |- *. trivial.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. simpl in |- *. apply max_le_compat.\n\trewrite max_l; trivial.\n\tintros. simpl in |- *.\n\trewrite max_l; trivial.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\treplace n with (max (S n0) (max n0)) by trivial.\n\tsimpl in |- *. trivial.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (le_or_le_lt n m).\n\tintros.\n\tapply (le_n_S (S n0) (S n0)) (max n0)).\n\tintros.\n\tapply (le_trans (n_S (S n0) (S n0)) (max (S n0) (S n0)) (max n1)).\n\tintros.\n\trewrite (le_trans (n_S (S n0) (S n0)) (max n0)) (max n0))).\n\tintros.\n\tapply (le_trans (n_S (S n0) (S n0) (max n0)) (max n0)); trivial.\n\tintros.\n\tapply (le_trans (n_S (S n0) (S n0)) (max n0 (S n0)) (max n0 (S n0))).\n\tintros.\n\tapply (le_trans (n_S (S n0) (S n0) (max n0) (max n0 n0)) (max n0)).\n\tintros.\n\tapply (le_Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. apply max_le_trans with n0. rewrite <- (le_n_S n0) in H.\n\tintros.\n\trewrite max_r; auto.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n.\n\tintros. simpl in |- *. intros. elim (H0 (S n1)) (max n1) (max n1) (max n1) (max n1) (max n2)) (max n1)) (max n1 n1)).\n\tintros. elim (H0 (S n1)) (max n1) (max n1) (max n1) (max n1) (max n1) (max n1 n1)) (max n2)).\n\tintros. elim (H1 (S n1) (max n1) (max n1) (max n1 n1)) (max n1 n2)).\n\tintros. elim (H0 (S n1) (max n1) (max n1 n2) (max n1)) (max n1 (max n2) (max n1 n2)).\n\tintros. rewrite max_r; auto with arith.\n\tintros.\n\tapply (le_n_S (S n0) (max n1 n1) (max n1 n1)) (max n1 (max n1 n1) (maxQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. trivial.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tintros.\n\tapply (le_trans _ _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (le_trans _ (S m)).\n\tapply (Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. rewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\tsimpl in |- *. rewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\tapply (le_trans m n).\n\tsimpl in |- *.\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\trewrite (plus_comm n m).\n\tsimpl in |- *.\n\trewrite (plusQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3253,
                "proof_end_offset": 3397,
                "proof": "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *.\ntrivial.\nintros.\nsimpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (min_lt_lt_dec n m). intros.\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_trans _ _ H).\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (le_le_S n m). intros. elim (le_le_S n m). intros.\n\tapply (le_n_S m).\n\tintros.\n\tapply (le_trans_minus_lt_n m).\n\tintros.\n\tapply (le_n_S m).\n\tapply (le_le_S m).\n\tintros.\n\tapply (le_trans_minus_minus_minus_le_n m).\n\tintros.\n\tapply (le_trans_minus_minus_minus_le_n m).\n\tintros.\n\tapply (le_trans_minus_minus_le m).\n\tintros.\n\tapply (le_trans_minus_minus_le_n m).\n\tintros.\n\tapply (le_trans_minus_minus_minus_minus_minus_n m).\n\tintros.\n\tapply (le_minus_plus_minus_minus_minus_n m).\n\tintros.\n\tapply (le_minus_minus_plus_minus_minus_plus_minus_n m).\n\tintros.\n\tapply (Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (le_O _ H). intros.\n\tapply (le_O _ H).\n\tapply (le_n_S (S n0) (S n0)).\n\tapply (le_O _ H).\n\tapply (le_trans _ _ H).\n\tapply (le_O _ H).\n\tapply (le_O _ H).\n\tapply (le_O _ H).\n\tapply (le_O _ _ H).\n\tapply (le_O _ _ H).\n\tapply (le_O _ _ H).\n\tapply (le_n_S _ H).\n\tapply (le_O _ _ H).\n\tapply (le_n_S _ _ H).\n\tapply (le_O _ _ H).\n\tapply (le_O _ _ H).\n\tapply (le_O _ _ H).\n\tapply (le_O _ _ H).\n\tapply (le_O _ H).\n\tapply (le_O _ H).\n\tapply (le_O _ _ H).\n\tapply (le_O _ H).\n\tapply (leQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tapply le_n_O_Sn.\n\tintros.\n\tapply le_n_O_Sn.\n\tintros.\n\tapply le_n_Sn_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (le_or_lt n m). intros.\n\trewrite <- (le_or_lt_eq n m).\n\trewrite <- (le_or_lt_lt n m).\n\trewrite <- (le_or_lt_eq n m).\n\trewrite <- (le_or_lt m n).\n\trewrite <- (le_or_lt_lt n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_lt m n m).\n\trewrite <- (le_or_ltQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (le_lt_n _ _ H). intros.\n\texact (le_S_n _ _ _ H).\n\trewrite (le_O_Sn n m).\n\trewrite (le_S_S _ _ _ H).\n\tapply (le_S_n_Sn (S n0) (S n0) (S n0)).\n\trewrite (le_S_n_Sn (S n0) (S n0)) (S n0)) (S n0)).\n\tapply (le_S_n _ _ _ H).\n\tapply (le_n_Sn (S n0) (S n0))).\n\tintros.\n\telim H0. intros.\n\tapply (le_O_Sn (S n0) (S n0) (S n0)).\n\trewrite (le_S_n _ _ H0)).\n\trewrite (le_S_n _ _ H).\n\trewrite (le_S_n_Sn (S n0) (S n0)) (S n0)).\n\tapply (le_trans _ _ _ _ _ H).\n\tapplyQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\trewrite plus_n_Sm.\n\tintros.\nrewrite plus_n_Sm.\n\tintros.\nrewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\nrewrite plus_n_Sm.\n\trewrite plus_n_Sm.\nintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_n_Sm.\n\tintros.\n\trewrite plus_Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. elim (le_lt_n m). intros.\n\tapply (le_n_Sn n m).\n\tintros.\n\tapply (le_S (S (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\tintros.\n\tapply (le_n_S (S (S m))).\n\tintros.\n\tapply (le_S (S m)).\n\tintros.\n\tapply (le_trans (S (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\tintro.\n\tapply (le_S (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\trewrite (le_trans (S m)).\n\tintros.\n\tapply (le_trans (S m)).\n\trewrite <- (le_S m).\n\tQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros. apply le_n_Sn.\n\tintros.\n\telim (le_le_n n m). intros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\n\tintros.\n\tapply le_n_Sn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3399,
                "proof_end_offset": 3543,
                "proof": "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *; trivial.\nintros; simpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite plus_O_n_O_n_O_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn_Sn.\n\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite plus_n_O_O_Sn.\n\tapply plus_O_r.\n\tapply plus_O_O_Sn.\n\tapply plus_O_O_Sn.\n\tapply plus_O_Sn_Sn.\n\tapply plus_O_Sn_Sn.\n\tapply plus_O_Sn_Sn.\n\tapply plus_O_Sn_Sn.\n\tapply plus_O_Sn.\n\tapply plus_O_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_O_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn.\n\tapply plus_Sn_Sn_Sn.\n\tQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. simpl in |- *.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\tapply (le_n_O_Sn (S n0) (S n0)) (S n0)) (S (S n0)).\n\tsimpl in |- *.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewriteQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tapply plus_O_r_O_n.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n.\n simpl in |- *. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite (plus_O_r_r n).\n\tsimpl in |- *. rewrite (plus_O_l n).\n\tsimpl in |- *.\n\trewrite (plus_O_r n).\n\tsimpl in |- *.\n\tintros.\n\trewrite (plus_O_r n).\n\tsimpl in |- *.\n\tintros.\n\trewrite (plus_O_r n).\n\trewrite (plus_O_l n).\n\trewrite (plus_O_r n).\n\tsimpl in |- *.\n\tintros.\n\trewrite (plus_O_r n).\n\tsimpl in |- *.\n\trewrite (plus_O_l n).\n\tsimpl in |- *.\n\trewrite (plus_O_l n).\n\tsimpl in |- *.\n\trewrite (plus_O_r (S n0)) (plus_O_r n0)).\n\tsimpl in |- *.\n\tintros.\n\trewrite (plus_O_r n0).\n\tsimpl in |- *.\n\trewrite (plus_O_r n0).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\tintros.Qed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_comm n).\n\trewrite (plus_Qed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_O_Sn.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.\n\tapply le_n_S.\n\tintros.Qed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tapply plus_le_n_O_Sn.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\trewrite plus_comm.\n\treplace (S (S n0) with (S n0) by reflexivity.\n\tintros.\n\tapply le_trans with (S (S n0) by reflexivity.\n\tintros.\n\trewrite plus_comm.\n\tapply le_trans with (S (S n0) by reflexivity.\n\tintros.\n\tapply le_trans with (S (S n0) by reflexivity.\n\tapply le_trans with (S (S n0) by reflexivity.\n\tintros.\n\tapply le_trans with (S (S n0) by reflexivity.\n\tintros.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\tapply le_trans with (S (S (n0 - m0)) by reflexivity.\n\tintros.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\tQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3545,
                "proof_end_offset": 3788,
                "proof": "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n.\nsimpl in |- *.\nintro.\ncut (m + 0 = m).\nintros.\nrewrite H.\nexact (le_O_n m).\nexact (plus_O_r m).\nsimpl in |- *.\nintros.\nexact (le_plus_r m (m + n0 * m)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_l.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\trewrite <- plus_le_compat_l.\n\tintros.\n\trewrite <- plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\tapply plus_le_compat_r.\n\tintros.\n\trewrite <- plus_leQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\tunfold plus in |- *.\n\tsimpl in |- *.\n\tintros.\n\trewrite (mult_comm n m).\n\tintros.\n\tapply (le_n_Sn (S n0) (S n0) (S n0)).\n\tintros.\n\trewrite (mult_comm n m).\n\tintros.\n\trewrite (mult_comm (S n0) (S n0) (S n0) (S n0)) (S n0)).\n\tintros.\n\trewrite (mult_comm n0 (S n0) (S n0)) (S n0)).\n\tintros.\n\trewrite (mult_comm (S n0) (S n0) (S n1)) (S n0)).\n\tintros.\n\tapply (le_n_Sn (S n0) (S n0)) (S n0) (S n0))).\n\tintros.\n\trewrite (mult_comm n0 (S n0) (S n0)) (S n0)).\n\tintros.\n\trewrite (mult_comm n0 (S n0) (S n0)) (Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n m)).\n\trewrite (plus_comm (n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - m)%nat.\n\tapply le_trans with (n - mQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\tapply plus_n_O_l.\n\tintros.\n\tapply plus_n_O_Sn.\n\tintros.\n\tapply plus_n_O_Sn.\n\tintros.\n\tapply plus_O_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_O_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_Sn_Sn.\n\tintros.\n\tapply plus_O_Sn.\n\tintros.\n\tapply plus_n_Sn_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_O_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\n\tapply plus_n_Sn.\n\tintros.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\texact (le_mult_n m (S m)).\n\tintros.\n\telim (le_lt_trans _ (S m)).\n\tintros.\n\trewrite (plus_comm n m).\n\tintros.\n\trewrite (plus_comm n m).\n\tintros.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm (S n m)).\n\tintros.\n\trewrite (plus_comm (S m)).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\tintros.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\tapply (plus_comm m).\n\tintros.\n\trewrite (plus_comm n m).\n\tintros.\n\trewrite (plus_comm (S m)).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (S m)).\n\trewrite (plus_comm (S m)).\n\trewrite (plus_comm (S m)).\n\trewrite (plusQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n.\n\tintros. simpl in |- *.\n\tintros. simpl in |- *.\n\tintros. simpl in |- *.\n\tintros.\n\tcase (le_le_n m H).\n\tintros.\n\trewrite <- H.\n\trewrite (le_n_S (S (S n0)) (S (S n0) (S (S n0)) (S (S n0)) (S (S n0)) (S n0))).\n\tintros.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.\n\trewrite <- H.Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. rewrite (plus_comm n m). trivial.\n\tapply (le_trans_S n m). trivial.\n\tintros. simpl in |- *. rewrite (plus_comm n m). trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n mQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\telim (le_or_lt n m). intros.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tapply le_trans with m.\n\tQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3790,
                "proof_end_offset": 4019,
                "proof": "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\ncut (n * m = m * n).\ncut (n * S m = S m * n).\nintros.\nrewrite H.\nrewrite H0.\nexact (le_mult_lS m n).\nexact (mult_comm n (S m)).\nexact (mult_comm n m).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *.\n\tintros. simpl in |- *.\n\tintros.\n\tapply le_n_Sn_Sn.\n\tapply le_n_Sn.\n\tsimpl in |- *.\n\tintros.\n\trewrite H0.\n\trewrite H.\n\tauto.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n * m) (S (S n0)) (plus_comm n m)).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n * m)).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n * m)).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n * m)).\n\trewrite (plus_comm (Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\trewrite <- (le_S (S n) (S n0)).\n\trewrite <- (le_S (S n0)).\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S n0).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)).\n\tsimpl in |- *.\n\trewrite <- (le_S (S n0)) (S n0Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\trewrite (plus_comm m (S m)).\n\trewrite (plus_comm (n + m)).\n\trewrite (plus_comm m)).\n\trewrite (plus_comm (n + m)).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n + m)).\n\trewrite (plus_comm (n + m)).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n + m)).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm (n + m)).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewriteQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\trewrite H0. trivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *.\n\tintros. simpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |-Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\trewrite (plus_comm n m).\n\trewrite (plus_comm (m + n0)) (plus_comm n m)).\n\trewrite (plus_comm (m + n0) (S n0)).\n\trewrite (plus_comm (m + n0)) (plus_comm n m)).\n\trewrite (plus_comm (m + n0) (S n0)).\n\trewrite (plus_comm (m + n0)) (plus_comm (m + n0)) (plus_comm n m)).\n\trewrite (plus_comm (m + n0)) (plus_comm (m + n0)) (plus_comm n m)).\n\trewrite (plus_comm (m + n0)) (plus_comm (m + n0) m)).\n\trewrite (plus_comm (m + n0) (plus_comm n m)).\n\trewrite (plus_comm (m + n0)) (plus_comm (m + n0) m)).\n\trewrite (plus_comm (m + n0)) (plus_comm (m + n0) (n0 + n0)).\n\trewriteQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\n\tsimpl in |- *.\n\trewrite (plus_comm m).\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\trewrite (le_S_n m).\n\tapply (le_n_S m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans m).\n\tapply (le_trans (m + n0) (S m)).\n\tapply (le_trans (m + n0) (S m0) (S n0)).\n\trewrite (le_trans m).\n\tapply (le_transQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n.\n simpl in |- *. intros.\n\trewrite H.\n\ttrivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4021,
                "proof_end_offset": 4242,
                "proof": "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\ncut (m <= n \\/ n < m).\nintro.\nelim H0; intros.\nleft.\nexact (le_antisym n m H H1).\nright.\nexact (lt_le_S n m H1).\nexact (le_or_lt m n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite H.\n\trewrite (le_minus_r n m).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_minus_r n m).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_minus_r (S n) (S m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_minus_distr_l (S n) (S m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_minus_distr_l (S n) (S m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_minus_distr_l (S n) (S m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_minus_distr_l (S (S m)) (S m)).\n\tsimpl in |- *.\n\tintro.\n\trewrite (le_minus_minus_distr_r (S n) (S m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_minus_distr_Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite plus_comm.\n\tintros.\n\tapply le_plus_l.\n\tapply le_plus_lt_compat.\n\tintros.\n\tapply le_plus_minus_l.\n\tintros.\n\tapply le_plus_minus_lt_n_Sn.\n\tintros.\n\tapply le_plus_plus_le_n_Sn.\n\tintros.\n\tapply le_plus_minus_le_n_Sn.\n\tintros.\n\trewrite H0.\n\tapply le_plus_minus_n_Sn.\n\tintros.\n\tapply le_plus_minus_n_Sn.\n\tintros.\n\trewrite H0.\n\tapply le_plus_minus_n_Sn.\n\tintros.\n\tapply le_plus_minus_n_Sn.\n\tintros.\n\trewrite H0.\n\tapply le_plus_minus_n_Sn.\n\tintros.\n\trewrite H0.\n\tapply le_minus_plus_n_Sn.\n\tintros.\n\tapply le_minus_n_Sn.\n\tintros.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite H.\n\trewrite (mult_comm m).\n\tapply le_trans with (S m + S m + S m * S m + S m).\n\tapply le_trans with (S m + S m + S m + S m + S m + S m + S m).\n\trewrite H0.\n\trewrite <- (mult_comm m m).\n\tapply le_trans with (S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S m + S mQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\treplace (n * m) with (S m * n + S m)%nat by ring.\n\tintros.\n\trewrite H.\n\treplace (n * m) with (S m * n * S m + n) by ring.\n\trewrite H0.\n\trewrite (mult_comm (S n0) (S m)).\n\trewrite <- H0.\n\trewrite (mult_comm m (S n0)) (S m + S m)).\n\trewrite H0.\n\trewrite <- H0.\n\trewrite (mult_comm m (S m)) (S m).\n\tapply (le_plus_n m (S m0) (S m)).\n\tapply (le_plus_n_Sn (S m0) (S m0) (S m0)).\n\trewrite <- H0.\n\trewrite <- (mult_comm m (S m0) (S m0) (S m0)).\n\trewrite <- H0.\n\trewrite <- H0.\n\trewrite <- H0.\n\trewrite <- (mult_comm (S m0) (S m0) (SQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tunfold le in |- *.\n\tintros.\n\trewrite H.\n\trewrite H0.\n\trewrite <- H0.\n\tapply le_plus_n_Sn.\n\tsimpl in |- *.\n\trewrite <- H0.\n\trewrite <- H0.\n\tapply le_plus_n_Sn.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- (le_plus_O m).\n\trewrite <- (le_minus_O m).\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\tapply le_plus_minus_O_n.\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\trewrite <- (le_plus_plus_O m).\n\tsimpl in |- *.\n\tapply le_plus_minus_O_n.\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\trewrite <- (le_plus_O m).\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\trewrite <- (le_plus_O m).\n\trewrite <- (le_plus_O m).\n\tsimpl in |- *.\n\trewrite <- (le_plus_O mQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite (le_plus_comm m).\n\trewrite (le_plus_comm m).\n\tsimpl in |- *.\n\tintros.\n\trewrite H.\n\tapply le_plus_minus_l.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_plus_minus_l.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_plus_minus_l.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_plus_minus_l.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_plus_minus_r.\n\tintros.\n\tapply le_minus_minus_l.\n\tintros.\n\tapply le_plus_minus_l.\n\tintros.\n\tQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tapply le_plus_r.\n\tsimpl in |- *.\n\tintros.\n\treplace (n * m = S m * S m * S m) with (S m * S m * S m).\n\tintros.\n\trewrite <- (le_minus_minus_r m m) in H0.\n\trewrite <- (le_minus_minus_minus_l m m) in H0.\n\tsimpl in |- *.\n\tintros.\n\trewrite <- (le_minus_minus_minus_l m (S m) (S m))).\n\tapply le_plus_minus_minus_l.\n\tsimpl in |- *.\n\tintros.\n\treplace (n * m = S m * S m * S m).\n\trewrite <- (le_minus_minus_minus_minus_l m (S m)) in H0.\n\tsimpl in |- *.\n\trewrite <- (le_plus_minus_minus_minus_r m (S m) (S m)).\n\tapply le_plus_minus_minus_distr.\n\trewrite <- (le_minus_minus_minus_minus_distrQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite (le_minus_l m (S m)).\n\tintros.\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\tintros.\n\tapply le_trans with (n * m + n0 * m)%nat).\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_n m).\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_n m).\n\tsimpl in |- *.\n\tapply le_trans with (n * m + n0 + m)%nat).\n\tsimpl in |- *.\n\tintros.\n\trewrite (le_minus_n mQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_comm m).\n\trewrite <- (le_plus_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\nLemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros. cut (m <= n \\/ n < m). intro. elim H0; intros.\n\tleft. exact (le_antisym n m H H1).\n\tright. exact (lt_le_S n m H1).\n\texact (le_or_lt m n).\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4244,
                "proof_end_offset": 5286,
                "proof": "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintro.\nsimple induction m.\nintros.\ncut (n = 0).\nintro.\nrewrite H0; trivial.\nsymmetry in |- *.\nexact (le_n_O_eq n H).\ninduction n as [| n Hrecn].\nintros.\nsimpl in |- *.\nexact (le_O_n (p + n * p)).\nintros.\nsimpl in |- *.\ncut (n = n0 \\/ S n <= n0).\nintro.\ncut (n * p <= n0 * p).\nintro.\nelim H1; intros.\ncut (p <= p).\nintros.\nexact (plus_le_compat p p (n * p) (n0 * p) H4 H2).\nexact (le_n_n p).\ncut (n * p <= S n * p).\ncut (S n * p <= n0 * p).\nintros.\napply (le_trans (p + n * p) (p + S n * p) (p + n0 * p)).\nexact (plus_le_compat p p (n * p) (S n * p) (le_n_n p) H5).\nexact (plus_le_compat p p (S n * p) (n0 * p) (le_n_n p) H4).\nexact (H p H3).\nexact (le_mult_lS n p).\nelim H1; intros.\nrewrite H2.\nexact (le_n_n (n0 * p)).\ncut (n * p <= S n * p).\nintro.\ncut (S n * p <= n0 * p).\nintro.\nexact (le_trans (n * p) (S n * p) (n0 * p) H3 H4).\nexact (H p H2).\nexact (le_mult_lS n p).\ncut (n <= n0).\nintro.\nexact (le_disj n n0 H1).\nexact (le_S_n n n0 H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tsplit.\n\tapply le_lt_trans with (n * m + m)).\n\tapply le_mult_r.\n\tapply le_trans with (n * m)).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m)).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply le_trans with (n * m).\n\tapply leQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_le_trans (S m) (le_or_lt_lt n m) (le_or_lt n m) (le_or_lt_le n m) (le_or_lt n m) (le_or_lt_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt_lt n m) (lt_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (le_or_lt n m) (lt_or_lt_lt n m) (le_or_lt n m) (le_or_lt n m) (Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_le_trans with (n + m) (m * m).\n\tapply le_mult_r.\n\tapply le_trans with (n + m).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + m).\n\tapply le_trans with (n + m * n).\n\tapply le_trans with (n + m).\n\tapply le_trans with (n + m).\n\tapply le_trans with (n + m).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (n + p).\n\tapply le_trans with (n + m * p).\n\tapply le_trans with (nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite H. rewrite (le_plus_comm n m).\n\tapply (le_trans (S m) (lt_or_lt n m).\n\tapply (le_trans (S m) (le_or_lt n m)).\n\tapply (le_trans (S m) (lt_or_lt m n) (lt_or_lt n m)).\n\tapply (le_trans (S m) (lt_or_lt n m)).\n\tapply (le_or_lt m n m).\n\trewrite <- (le_le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n m).\n\tapply (le_or_lt m n mQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tunfold le in |- *.\n\trewrite (plus_comm m (S n)) (mult_comm (S n) (mult_comm (S n) (mult_comm (S n) (S n) (mult_comm (S n) (mult_comm n) (S n)) (mult_comm (S n) (mult_comm n) (S n) (mult_comm n) (mult_comm n) (S n) (mult_comm n) (mult_comm (S n) (S n) (mult_comm n) (mult_comm n) (mult_comm n) (mult_comm (S n) (mult_comm n) (mult_comm (S n) (mult_comm n) (mult_comm (S n) (mult_comm n) (mult_comm n) (mult_comm (S n) (mult_comm n) (mult_comm (S n) (mult_comm n) (mult_comm n) (mult_comm (S n) (mult_comm n) (mult_comm n) (mult_comm (S n) (mult_commQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite H.\n\trewrite (mult_comm n m).\n\tapply (le_trans_plus_l m (S m)).\n\tapply (le_lt_trans_plus_l m (S m)).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\tintros.\n\trewrite (mult_comm (S n0)).\n\tapply (le_trans_plus_l m (S m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite H0.\n\tapply (le_trans_plus_l m (S m)).\n\tsimpl in |- *.\n\trewrite (mult_comm (S n0) (S m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite (mult_comm (S n0) (S m)).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\trewrite (mult_comm (S m)).\n\tsimpl in |- *.\n\trewrite (mult_comm n m).\n\tsimpl in |- *.\n\tintros.\n\trewrite (mult_commQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\trewrite (le_minus_plus_l n m).\n\tsimpl in |- *.\n\tintros.\n\tapply le_trans with (m + n0 * p).\n\texact (le_plus_n m).\n\tintros.\n\tapply le_plus_le_l.\n\tapply le_plus_lt_l.\n\tapply le_plus_le_n_Sm.\n\tapply le_plus_plus_n.\n\trewrite <- (le_plus_comm m (S n0)) (le_minus_n m (S n0) (S n0)) (le_minus_n m)).\n\tapply le_plus_le_n_n.\n\tapply le_plus_n_Sm.\n\tapply le_plus_n_Sm.\n\trewrite <- (le_plus_minus_n m n0) (le_plus_n m) (plus_n m)).\n\tsimpl in |- *.\n\tintros.\n\trewrite H0.\n\trewrite <- (le_plus_comm m (S n0) (le_plus_n m0 n0)Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_trans with (m * m) (m * p).\n\tintros.\n\tapply le_trans with (m * p).\n\tauto with arith.\n\tapply le_trans with (m * p).\n\tauto with arith.\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\treplace (m + p) with (m + n)%nat by ring.\n\trewrite H1.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite (le_trans m (S (S m)) (S m)).\n\trewrite (le_S_n_Sn (S m)).\n\trewrite H1.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite (le_trans m (S (S m))).\n\tapply le_trans with m; trivial.\n\trewrite (le_plus_O m).\n\tapply le_le_trans with (S m + n0).\n\trewrite (le_plus_n_Sn (S m)).\n\trewrite <- (le_minus_O m)).\n\trewrite <- (le_plus_minus_minus_O m n).\n\trewrite <- (le_plus_plus_minus_minus_distr_l.\n\trewrite <- (le_minus_plus_minus_minus_minus_minus_distr_l).\n\trewrite <- (le_minus_minus_minus_distr_l m).\n\tapply le_minus_minusQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_lt_lt_n_S_S_n_S.\n\tintros.\n\trewrite <- H0.\n\tsimpl in |- *.\n\trewrite <- H0.\n\tapply le_trans with (n * m * m + p).\n\tapply le_trans with (n * m * p).\n\trewrite <- H1.\n\trewrite <- H1.\n\trewrite <- H0.\n\trewrite <- H1.\n\tsimpl in |- *.\n\trewrite <- H0.\n\trewrite <- H0.\n\trewrite <- H1.\n\trewrite <- H0.\n\tapply le_trans with (n * m + p * p).\n\tapply le_trans with (n * m + p * p).\n\trewrite <- H.\n\trewrite <- H0.\n\trewrite <- H0.\n\tapply le_trans with (n * m + p * p).\n\trewrite <- H1.\n\trewrite <- H0.\n\trewrite <- H1.\n\trewrite <- H0.\n\trewrite <- H0.\n\trewrite <- H0.\n\trewrite <-Qed."
                ]
            }
        ],
        "coquelicot": [
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "\n  exact Hl.\nQed.\n\nLemma linear_cont (l : U -> V) (x : U) :\n  is_linear l -> continuous l x.\nProof.\n  intros Hl.\n  apply filterlim_locally_ball_norm => eps.\n  apply locally_le_locally_norm.\n  case: (linear_norm _ Hl) => M Hn.\n  assert (0 < eps / M).\n    apply Rdiv_lt_0_compat.\n    apply cond_pos.\n    apply Hn.\n  exists (mkposreal _ H) => y Hy.\n  rewrite /ball_norm /minus -linear_opp // -linear_plus //.\n  eapply Rle_lt_trans.\n  by apply Hn.\n  evar_last.\n  apply Rmult_lt_compat_l with (2 := Hy).\n  apply Hn.\n  simpl.\n  field.\n  apply Rgt_not_eq, Hn.\nQed.\n\nLemma is_linear_ext (l1 l2 : U -> V) :\n  (forall x, l1 x = l2 x) -> is_linear l1 -> is_linear l2.\nProof.\n  intros Hl Hl1.\n  split.\n  intros ; rewrite -!Hl ; apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\n  case: Hl1 => _ _ [M Hl1].\n  exists M ; split.\n  by apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\nQed.\n\n(** zero in a linear function *)\nLemma is_linear_zero : is_linear (fun _ => zero).\nProof.\n  repeat split.\n  - move => _ _ ; by rewrite plus_zero_l.\n  - move => k _ ; by rewrite scal_zero_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\n",
                "context_tokens": 753,
                "proof_start_offset": 3935,
                "proof_end_offset": 4211,
                "proof": "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nrepeat split.\nmove => x y.\nnow apply opp_plus.\nmove => k x.\napply sym_eq.\napply: scal_opp_r.\nexists 1 ; split.\nexact Rlt_0_1.\nmove => x ; rewrite norm_opp Rmult_1_l.\nby apply Rle_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - exact Rlt_0_1.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n  - exact Rlt_0_1_r.\n  - exact Rlt_0_1.\n  - exact Rlt_0_1.\n  - exact Rlt_0_1_r.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x y.\n  replace x with (y + 1)%R.\n    rewrite mult_0_r.\n    apply le_trans with (1 := Hx).\n    apply Rle_trans with (2 := Hx).\n    apply Rle_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n    apply Rlt_le_trans with (2 := Hx).\n   Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  now apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros H; split.\n  - rewrite is_linear_opp.\n    apply Rle_trans with (1 := Hx).\n    apply Rlt_0_1.\n    rewrite (is_linear_opp (fun x => x) (1 := Hx).\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.\n    apply Rlt_0_1.Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x; apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x Hx.\n  - split.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n  - exact Rlt_0_1.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - destruct (linear_norm _ Hl) as [M1 Hn2].\n    destruct (linear_norm _ Hl1) as [M2 Hn2].\n    destruct (linear_norm _ Hl1) as [M2 Hn2].\n    apply is_linear_opp.\n    - apply is_linear_opp.\n    - now apply is_linear_opp.\n    - now apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  unfold is_linear; split.\n    exact Rlt_0_l.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  unfold is_linear.\n  unfold is_linear, is_linear, is_linear, is_linear, is_linear_linear, is_linear_linear, is_linear, is_linear_linear_linear, is_linear_linear_linear, is_linear_linear_linear_linear, is_linear_linear_linear.\nProof.\n  intros l1 l2.\n  apply is_linear_linear_linear_linear, is_linear_linear_linear, is_linear_linear_linear.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x y.\n  destruct (linear_norm _ _ _ Hl) as [M2].\n  - exists M2.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": " - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\n",
                "context_tokens": 740,
                "proof_start_offset": 5017,
                "proof_end_offset": 5487,
                "proof": "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_r.\nmove => u v /= ; apply sym_eq, @scal_assoc.\nexists (norm x + 1) ; split.\napply Rplus_le_lt_0_compat.\napply norm_ge_0.\nexact Rlt_0_1.\nmove => k /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\nnow rewrite Rmult_comm ; apply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k k x.\n  rewrite <- (Ropp_involutive (conj x) (conj x)).\n  apply Rle_trans with (2 := proj1_sig (conj x)).\n  apply Rle_trans with (2 := proj1_sig (conj x)).\n  apply Rle_trans with (2 := proj1_sig (conj x)).\n  apply Rle_trans with (2 := proj1_sig (conj x)).\n  apply Rle_trans with (2 := proj2_sig (conj x)).\n  apply Rle_trans with (2 := proj1_sig (conj x)).\n  apply Rle_trans with (2 := proj2_sig (conj x)).\n  apply Rle_trans with (2 := proj1_sig (conj x)).\n  apply Rle_trans with (2 := proj2_sig (conj x)).\n  apply Rle_trans with (2 := proj2_sig (conj x)).\n  apply Rle_trans with (2 := proj2_sig (conj x)).\n  apply Rle_trans with (2 := proj2_sig (conj x)).\n  apply Rle_trans with (2 := proj2_sig (conj x)).\n  apply Rle_trans with (2 := proj2Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k x.\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  apply f_equal.\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewrite (f_equal k).\n  rewriteQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k x.\n  apply is_linear_mult.\n  - move=> k x.\n    apply is_linear_linear_linear.\n  - move=> k x.\n    rewrite - now apply is_linear_linear_opp.\n  - move=> k x.\n    rewrite (opp_eq _ _ _ _ _ Hx).\n    rewrite (opp_eq _ _ Hx).\n    rewrite (opp_eq _ _ Hx).\n    rewrite (opp_eq _ _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).\n    rewrite (opp_eq _ Hx).Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  unfold is_linear, is_linear_linear, is_linear_linear_linear_linear.\nProof.\n  intros k x.\n  rewrite (linear_add_comm k x).\n  now apply is_linear_linear.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  apply (iffP idP) => [|k x] | k x].\n  - apply/is_linear.\n  - apply/is_linear.\n    rewrite -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphM -rmorphMQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  destruct k as [|k l]; [rewrite (linear_add k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k k kQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  unfold is_linear, is_linear_linear, is_linear_linear_linear_linear_linear.\nProof.\n  unfold is_linear_linear_linear_linear_linear_linear.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  repeat split.\n  - move=> x y; rewrite!linear_add_com.\n    rewrite!linear_opp_com.\n    by rewrite multK_com.\n    rewrite multK_com.\n    by apply f_equal.\n  - move=> x; rewrite!linear_add_com.\n    rewrite multK_com.\n    by apply f_equal.\n  - rewrite scal_com.\n    by apply f_equal.\n    rewrite!linear_add_com.\n    by apply f_equal.\n  - rewrite scal_com.\n    rewrite scal_com.\n    rewrite scal_com.\n    by apply f_equal.\n  - rewrite scal_com.\n    by apply f_equal.\n  - rewrite scal_com.\n    by apply f_equal.\n  - rewrite scal_com.\n    rewrite scal_com.\n    by apply f_equal.\n  - rewrite scal_com.\n  - rewrite scal_com.\n    by apply f_equal.\n  - rewrite scal_com.\n    by apply f_equal.\n  - rewrite scal_com.\n    by apply f_equal.\n  - rewrite scal_com.\n  - rewrite scal_com.\n    rewrite scal_com.\n    by apply f_Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite <- (sum_f_R (fun k : K => - k x) (f_R (fun k : K => k - x) (f_R (fun k : K => k - x) (f_R (fun k => k - k - x)) (f_R (fun k => k - x) (f_R (fun k => k - x) (f_R (fun k k - k - x)) (f_R (fun k => k - x) (f_R (fun k - k - k) - k)) (f_R (fun k => k - k)) (f_R (fun k => k - x)) (f_R (fun k - k - k)) (f_R (fun k => k - x) (f_R (fun k - k - x)) (f_R (fun k => k - k - x)) (f_R (fun k - k - k)) (f_R (fun k => k - x)) (f_R (fun k - k - x)) (f_R (fun kQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k k x.\n  destruct k as [|k l].\n  - rewrite!linear_add_comm.\n    rewrite <- (Rmult_comm k).\n    rewrite <- Rmult_assoc.\n    rewrite (Rmult_comm k).\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite <- Rmult_assoc.\n    rewrite RmultQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\nLemma is_linear_scal_l (x : V) :\n  is_linear (fun k : K => scal k x).\nProof.\n  split.\n  - move => u v ; by apply @scal_distr_r.\n  - move => u v /= ; apply sym_eq, @scal_assoc.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply norm_ge_0.\n    exact Rlt_0_1.\n    move => k /=.\n    rewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\n    apply Rplus_le_compat.\n    now rewrite Rmult_comm ; apply norm_scal.\n    apply norm_ge_0.\nQed.\n\n(** [fun x => scal k x] is a linear function if [mult] is commutative *)\n",
                "context_tokens": 724,
                "proof_start_offset": 5562,
                "proof_end_offset": 6076,
                "proof": "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_l.\nmove => u v /= ; apply sym_eq ; rewrite !@scal_assoc.\nby rewrite H.\nexists (abs k + 1) ; split.\napply Rplus_le_lt_0_compat.\napply abs_ge_0.\nexact Rlt_0_1.\nmove => x /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\napply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k.\n  rewrite <- minus_comm.\n  apply (is_linear_add k x).\n  - move=> u; apply conj_linear_add_r.\n    apply Rle_trans with (2 := proj1 (sqrt x)) by apply id_eq.\n    exact Rlt_0_1.\n  - apply Rle_trans with (2 := proj1 (sqrt x))).\n    exact Rle_trans with (2 := proj1 (sqrt x)).\n    exact Rlt_0_0_r.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n  - apply Rlt_0_1.\n  - rewrite <- minus_INR.\n    rewrite <- minus_INR.\n    exact Rlt_0_1.\n    exact Rlt_0_0_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x y.\n  rewrite (mult_comm k x) at 1.\n  apply mult_le_compat.\n  - move=> x y.\n    rewrite (mult_comm k x) at 1.\n    rewrite <- (mult_comm k x) at 1.\n    rewrite <- (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite <- (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite <- (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.\n    rewrite (mult_comm k x) at 1.Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x y.\n  rewrite (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj1 (proj1 (proj2 (proj2 (proj1 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj1 (proj1 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj1 (proj2 (proj1 (proj2 (proj2 (proj1 (proj1 (proj1 (proj1 (proj1 (proj1 (proj2 (proj1 (proj2 (proj1 (proj2 (proj1 (proj2 (proj1 (proj1 (proj2 (proj1 (proj1 (proj1 (proj1 (proj2 (proj2 (proj1 (proj2 (projQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  apply plus_le_compat_l.\n  - now rewrite plus_comm.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x.\n  assert (H : 0 <= 0 <= 0)%R).\n    apply (is_linear_add k x).\n    apply (is_linear_add k x).\n    apply (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    apply (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    apply (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    apply (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    apply (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    rewrite <- (is_linear_add k x).\n    apply (is_linear_add k x).\n    apply (is_linear_add k x).\n    apply (is_linear_add k x).\n    apply (is_linear_add k x).\n    apply (is_linear_add k x).\n    apply (is_linear_Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k x.\n  - move=> k x y.\n    rewrite (Rmult_0_r (R k)).\n    rewrite <- (Rmult_1_r (R k)).\n    apply Rmult_lt_compat_l.\n    apply Rinv_0_lt_compat.\n    now apply Rmult_le_compat_l.\n    now apply Rmult_lt_compat_l.\n    now apply Rlt_0_0_compat.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  split.\n  - move=> u; apply (is_linear_scal_l (fun x : V => scal k x) x).\n    rewrite (sum _ (sum _ _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ (sum _ _ (sum _ (sum (sum _ _ (sum _ _ _ sum (sum _ (sum _ (sum _ _ (sum _ (sum _ (sum _ _ _ (sum _ (sum _ (sum _ (sum _ _ (sum _ _ _ (sum _ _ (sum _ (sum _ (sum _ _ sum (sum _ (sum _ (sum _ ( sum _ _ (sum _ _ _ sum (sum _ _ _ sum (sum _ (sum _ _ (sum (S i (sum _ _ sum ( sum ( sum ( sum (S i i i sum (sum _ sum (S i (sum _ ( sum (sum _ sum (S i (sum (sumQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k m k x.\n  rewrite <- (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj (conj_com_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj_com (conj (conj_com (conj_com (conj_com (conj_com (conj_com (conj (conj_com (conj_com_com (conj_com (conj_com (conj_com (conj (conj_com (conj_com (conj_com (conj_com (conj (Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  split.\n  - move=> u; apply is_linear_add_r.\n    apply is_linear_add_opp_r.\n    exact is_linear_opp_r.\n  - move=> u; apply is_linear_linear_add_opp_l.\n    exact is_linear_add_opp_r.\n    exact is_linear_opp_opp_r.\n    exact is_linear_add_opp_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k x y.\n  rewrite (conj_scal_r k x).\n  apply eq_sym.\n  - now apply is_linear_opp_r.\n  - now apply is_linear_opp_r.\nQed."
                ]
            }
        ],
        "fermat4": [
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "\nLemma prop2 : forall m n : Z, rel_prime m n -> rel_prime (m * m) (n * n).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_mult;\n    apply rel_prime_sym; assumption.\nQed.\n\nLemma is_sqr_compat : forall k a : Z,\n  k <> 0 -> is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 20559,
                "proof_end_offset": 20779,
                "proof": "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); rewrite H in H0; clear H; rewrite Zmult_assoc in H0; apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H H H0; pattern (c - (c - (c - d)) at 1;\n    generalize (IH_sym (x1 * y1 * y2 * (x1 * y1 * x2 * y2 * (x2 * y1 * y2)) in H0;\n      clear H0; intro; rewrite H0 in H0; rewrite H in H0;\n          elim (lt_trans x1 * y2 * (x1 * y1 * (x2 * x2 * y2 * y1 * y2 * (x2 * y1 * y2 * y2 * y2 * y2 * x2 * y2 * y3 * y1 * y2 * y2 * y1 * y2 * y2 * y1 * y2 * y2 * y2 * y2 * y2 * y1 * y2 * y2 * y2 * y2 * y2 * x3 * y2 * y2 * y1 * y2 * y2 * y2 * y2 * y3 * y3 * y1 * y2 * y2 * y2 * y3 * y3 *Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; intros; elim H; clear H; introsQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with a; assumption.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c Ha Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb HbQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply (H a); clear H; intros; do 2 (elim H); intros; do 2 (elim H0; clear H0); intro;\n              rewrite H0 in H1; rewrite Zmult_1_l in H1; rewrite Zmult_1_l in H1; rewrite Zmult_1_l in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_l in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_l in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewriteQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply (proj1_r (x0 * x1 * x2 * y1 * y1) (x1 * x2 * y1 * y1 * y2 * y2 * y2 * y2 * y2 * y2 * y2 * y3 * y3) in H1; try ring.\n  generalize (prop2 _ _ H); clear H1; intro; rewrite H; clear H1; intros; elim (H2 _ _ H); clear H1; intros; elim H; clear H2; intros; elim H3; clear H3; intros; elim H4; clear H3; intros; elim H5; clear H4; intros; elim H5; clear H5; intros; elim H5; clear H5; intros; elim H5; clear H5; intros; elim H6; clear H6; intros; elim H5; clear H6; intros; elim H5; clear H7; intros; elim H6; clear H6; intros; elim H5; clear H7; intros; elim H6; clear H6; intros; elim H6; clear H6; intros; elim H5;Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with a;\n    [ apply divide_trans with a;\n    [ apply divide_trans with a;\n    [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      [ apply divide_trans with a;\n      | apply divide_trans with a;\n      [ apply divide_trans with a;\n        [ apply divide_trans with a;\n      [ apply divide_trans with a;\n        [ apply divide_trans with a;Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (b | b) (a | c) (b | c) (b | c) (b | c) (b | c) (b | c) (b | c) (b | c) (b | c) (b | c) (c | c) (b | c) (b c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c) (c | c (c | c) (c | c) (c | c (c | c) (c | c) (c | c) (c | c (c | c) (c | c) (c | c (c | c) (c | c) (c | c) (c | c (c | c) (c | c) (c | c (c | c) (c c) (c | c) (c | c) (c | c (c c) (c | c)Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a | b) (a | c | c) -> (a | c) -> (a | c).\nProof.\n  intros; apply divide_trans with (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c) (a | c)Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c Ha Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb HbQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 20781,
                "proof_end_offset": 21011,
                "proof": "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0; exists (q0 - q); rewrite H0; ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n    rewrite <- H0 in H0; rewrite <- H in H0; rewrite <- H0 in H0;\n      rewrite <- H1 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n      rewrite <- H1 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n      rewrite <- H in H0; rewrite <- H1 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H1 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 inQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite H0 in H1; rewrite Zmult_1_l in H1; rewrite Zmult_1_l in H1; rewrite Zmult_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_r in HQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite H in H; clear H H H0; rewrite Zmult_1_r in H; rewrite Zmult_1_r in H0;\n      rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0;\n      rewrite Zmult_1_r in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H;\n        rewrite Zmult_1_r in H; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0;\n        rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0;\n        rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c d (q,H0);\n    rewrite H in H0; clear H0; unfold is_square; intuition.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c d (q,H0);\n    rewrite <- H0 in H0;\n    rewrite <- H0 in H; clear H0; rewrite Zmult_1_l in H; rewrite Zmult_1_l in H0;\n    rewrite Zmult_1_r in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H0;\n      rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0;\n      rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0;\n        rewrite Zmult_1_l in H; rewrite Zmult_1_l in H0;\n        rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0;\n        rewrite Zmult_1_l in H0; rewrite Zmult_1_r in H; rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H0;\n        rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0;Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite H in H0; rewrite H0 in H0; rewrite Zmult_1_l in H; rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H; rewrite Zmult_1_l in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H; rewrite Zmult_1_r in H; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite H in H0; rewrite (phi_div a b c d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d dQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite <- H in H0; elim (le_or_eq _ _ _ _ H0); intro;\n        [ rewrite H0 in H0; rewrite <- H0 in H1; rewrite <- H0 in H0; rewrite <- H1 in H0; rewrite <- H1 in H0; rewrite <- H0 in H0; rewrite <- H0 in H1; rewrite <- H1 in H0; rewrite <- H0 in H1; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H1; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H1; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H1 in H0; rewrite <- H0 in H0; rewrite <- H0 in H; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H1 in H0; rewrite <- H1 in H0; rewrite <-Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite H in H0; clear H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0;\n      rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H; rewrite Zmult_1_r in H; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0;\n        rewrite Zmult_1_r in H; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0;\n        rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_r in H0; rewrite Zmult_1_r in H0;\n          rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_rQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0);\n    rewrite <- H0 in H0; rewrite Zmult_1_r in H0; rewrite Zmult_1_l in H0;\n      elim (gcd_mult_1 _ _ _ _ H1); intro;\n            [ apply Zle_antisym; apply Zlt_le_weak; apply Zlt_le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak; apply Z.le_weak;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 21013,
                "proof_end_offset": 21297,
                "proof": "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\nintros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a)) in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro; apply Zdivide_intro with (q := q); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    intros; rewrite H0 in H; elim (divide_l a b (q0 * q)); intro;\n    [ unfold is_mult; intuition; exists x; intuition | apply Zlt_le_trans;\n        [ apply Zle_trans; apply Zle_trans with (a + b)); assumption | apply Zlt_le_trans with (a + b); assumption ] ]\n      | elimtype False; rewrite H0 in H; rewrite H0 in H0; rewrite <- H0 in H0; rewrite H0 in H1;\n      apply (Zgt_lt_trans _ _ _ _ H0); assumption ]\n      | elimtype False; rewrite (Zabs_nat_dec x0); assumption ]\n      | elimtype False; rewrite H0 in H0; rewrite H0 in H0; rewrite <- H0 in H0;\n        apply (Zlt_le_trans _ _ _ H0); assumption ]\n      | elimtype False; rewrite H0 in H0; rewrite H0 in H0; rewrite H1 in H0; rewrite <- H0 in H0;\n        rewrite H in H0; rewrite <- H0 in H0; rewrite <- H0Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c d (q,H0);\n    unfold gcd in H; rewrite H; clear H0; intros;\n    rewrite H1 in H0; elim (gcd_mult_l _ _ _ _ H0); intro;\n        elim (gcd_mult_l _ _ _ H0); intro;\n            try (elim H0; clear H0; intros; elim (gcd_mult_l _ _ _ H1); intro;\n            try (elim (gcd_mult_l _ _ _ _ H0); intro;\n              try (elim H0; clear H0); intro;\n            try (elim H0; clear H0); intro;\n            try (elim H0; clear H1; intros; elim (gcd_mult_l _ _ H1); intro;\n            try (elim H0; clear H0); intro;\n            try (elim H0; clear H0); intro;\n            try (elim H1; clear H0); intro;\n            try (elim H0; clear H0); intro;\n            try (elim H0; clear H0); intro;\n            try (elim H0; clear H1); intro;\n            try (elim H0; clearQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    simpl; rewrite H0; apply (gcd_le_trans _ _ _ _ H0);\n    rewrite H0; rewrite H0; rewrite H0; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    [ generalize (gcd_mult_l a b c d (q0,H0);\n    [ generalize (gcd_mult_l a b c d (q0,H0));\n    [ generalize (gcd_mult_l a b c d (q0,H0));\n      [ generalize (gcd_mult_l a b c d (q0,H0);\n        generalize (gcd_mult_l a b d (q0,H0));\n        [ generalize (gcd_mult_l a b d (q0,H0);\n        generalize (gcd_mult_l a b d (q0,H0));\n        clear H0; intro; rewrite H0 in H0; elim (gcd_mult_r a b d (q0,H0));\n        clear H1; intros; elim (gcd_mult_l a b d (q0,H0));\n          intros; rewrite H0 in H0; elim (gcd_mult_l a b d (q0,H0));\n        intros; rewrite H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in HQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    cut (c = q); [ intro; apply H | apply H0].\n  elim (le_le_dec a b c d); intro; elim (Rle_lt_dec b c d); intro;\n          try (apply Rle_antisym; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_leQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    [ unfold is_mult; intro; unfold is_mult; intro; rewrite H0 in H0;\n    apply (gcd_intro a c (q0 * q)); assumption\n    | rewrite <- (gcd_mult_distr_l (x1 * q)); assumption\n    | rewrite <- (gcd_mult_distr_l (x1 * q)); assumption\n    | rewrite <- (gcd_mult_distr_l (x1 * q)); assumption\n    | rewrite <- (gcd_mult_distr_l (x1 * q)); assumption ].\n  intros; unfold is_mult; intro; rewrite H0 in H0; rewrite <- H0 in H0;\n    rewrite <- H0 in H1; rewrite <- H1 in H1; rewrite <- H0 in H1;\n    rewrite <- H1 in H1; rewrite <- H0 in H1; rewrite <- H1 in H1; rewrite <- H0 in H1;\n    rewrite <- H in H1; rewrite <- H1 in H1; rewrite <- H1 in H1;\n    rewrite <- H1 in H1; rewrite <- H1 in H1; rewrite <- HQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    [ rewrite H0 in H; rewrite H0 in H1; rewrite H0 in H1; rewrite H; clear H1;\n      elim (gcd_mult_1 _ _ _ _ H0); intro;\n          [ unfold is_mult; intuition; intuition; assumption | apply Zle_lt_trans; [ apply Zle_lt_trans; [ apply Zle_lt_trans; [ apply Zle_lt_trans; [ apply Zle_ge; apply Zle_lt_trans with (m | apply Zle_le_trans with (m | apply Zle_lt_trans with (m | apply Zle_lt_trans with (m | apply Zle_lt_trans with (m | apply Zle_ge_trans with (m | apply Zle_lt_trans with (m | apply Zle_lt_trans with (m | apply Zle_le_trans with (m | apply Zle_ge_trans with (m | apply Zle_trans with (m | apply Zle_trans with (m | apply Zle_lt_trans with (m | apply Zle_le_trans with (m | apply Zle_lt_trans with (m |Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    apply divide_mult_r; auto with zarith.\n  intros a b c (q,H0);\n    generalize (IH p); clear H0; intro; rewrite H0 in H;\n      rewrite H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H1 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H1 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H1 in H0;\n        rewrite <- H0 in H0; rewriteQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    rewrite H0 in H0; rewrite Zmult_0_l in H1; rewrite Zmult_r in H1; rewrite Zmult_r in H0;\n      rewrite Zmult_0_r in H1; rewrite Zmult_r in H1; rewrite Zmult_0_r in H1;\n        rewrite Zmult_1_r in H1; rewrite Zmult_r in H1; rewrite Zmult_1_l in H1; rewrite Zmult_r in H1; rewrite Zmult_r in H1;\n        rewrite Zmult_1_r in H1; rewrite Zmult_l in H1; rewrite Zmult_1_r in H1;\n        rewrite Zmult_1_r in H1; rewrite Zmult_r in H1; rewrite Zmult_1_r in H1; rewrite Zmult_r in H1;\n        rewrite Zmult_1_l in H1; rewrite Zmult_1_r in H1; rewrite Zmult_r in H1;\n        rewrite Zmult_1_r in H1; rewrite Zmult_r in H1; rewrite Zmult_1_r in H1;\n        rewrite Zmult_1_r in H1Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H0);\n    cut (c = 0); [ idtac | intro; elim (gcd_mult_strong a b c (q0,H0);\n      | intro; elim (gcd_mult_strong a b c (q0,H0));\n      | intro; generalize (gcd_mult_strong a b c (q0,H0);\n        intro; rewrite H0 in H0; rewrite H1; rewrite H0 in H0;\n        rewrite H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 21299,
                "proof_end_offset": 21412,
                "proof": "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\nintros; elim H; clear H; intros; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; replace (z * (z * (z * z)) with (z * (z * z)).\n rewrite <- H0; apply divide_0_r.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z.\n  unfold z.\n  unfold z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; rewrite (Zabs_eq_reg_l _ _ _ H0);\n    [ apply Zdivide_intro with (q := q); assumption | idtac ]\n    | apply Zdivide_intro with (q := q); assumption ].\n  apply divide_0_r; assumption.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H0 H1; unfold gcd in H0;\n    apply gcd_0_r; intros; apply gcd0_r; intros;\n    [ apply gcd0_r; intros; apply gcd_0_r; intros;\n    [ apply gcd_0_r; intros; rewrite H1 in H1; rewrite H1 in H1;\n    destruct (q0 * (q * a) * (q * (q * a) * (q * a) * (q * a) * (q * a) * (q * a) * (q * a) * (q * a) * (q * a) * (q * a) * (q * a) * (q * a) * (q * a * (q * a) * (q * a) * (q * a) * (q * a * (q * a) * (q * a) * (q * a) * (q * a) * (q * a * a) * (q * a * b) * (q * a * a) * (q * a) * (q * a * a) * (q * a) *Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; rewrite (Zmult_comm z).\n  apply divide_0_l.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z z; simpl; auto with zarith.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z.\n  destruct z.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0_r.\n  apply divide_0Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z z H H.\n  rewrite <- H in H0; rewrite <- H in H0; apply Zplus_0_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_0_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_0_r; apply Zplus_1_r; apply Zplus_0_r; apply Zplus_1_r; apply Zplus_1_r; apply Zplus_0_r; apply Zplus_0_r; apply Zplus_0_r; apply Zplus_r; apply Zplus_0_r.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H0; rewrite H; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; unfold divide; intros z H; rewrite H; simpl; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\nLemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 21414,
                "proof_end_offset": 21759,
                "proof": "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\nintros; cut (2 <> 0); auto with zarith; intro; generalize (Zdivide_bounds _ _ H2 H3); clear H2; simpl; generalize H; generalize H0; generalize H1; elim z; simpl; intros; progress (auto with zarith) || (elimtype False; auto with zarith).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z z H; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z z; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z z; elim H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z; elim H; clear H; intros; auto with zarith.\nQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ") \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nintros n; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nchange (n + n)%nat with (S n + n)%nat.\napply mult_n_O.\nauto.\nauto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\npattern n at 2; replace n with n by omega.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim m; intros m; elim m; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\npattern n at 1; replace n with (S n); auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nred in |- *.\napply refl_equal.\nred in |- *.\nintros n0.\nsimpl in |- *.\nintros n0 H1.\nred in |- *.\nintros n0 H2.\nsimpl in |- *.\nintros n0.\napply refl_equal.\nred in |- *.\nintros n0 H2.\nred in |- *.\nintros n0 H3.\nsimpl in |- *.\nintros n0 H1.\nred in |- *.\nintros n0 H3.\nsimpl in |- *.\nintros n0 H3.\nred in |- *.\nintros n0 H3.\nred in |- *.\nintros n0.\nsimpl in |- *.\nintros n0.\nsimpl in |- *.\nintros n0 H3.\nred in |- *.\nintros n0.\nred in |- *.\nintros n0 H3.\nsimpl in |- *.\nintros n0 H3.\nsimpl in |- *.\nintros n0.\nsimpl in |- *.\nintros n0 H3.\nsimpl in |- *.\nintros n0 H3.\nsimpl in |- *.\nintros n0 H3.\nsimpl in |- *.\nintrosSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nsimpl in |- *.\nintros n0 H.\nsimpl in |- *.\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n m H; elim m.\nintros n.\npattern n at 2 in |- *; apply case_eq with (S n); auto with arith.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction 1; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction 1; simpl in |- *; auto with core.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction m; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction m; simpl in |- *; auto with core.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction n; simpl in |- *; auto with core.\nSave size_assoc."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "R l3' b'))\n      end\n  | _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 763,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\n  exact (C # # # _ _ <| E).\nSave solution'_b.",
                    "Goal solvable b.\nProof.\npose proof (CIf _ _ #); pose proof (CIf _ #); pose proof (CIf _ #); pose proof (CIf _ #); pose proof (CIf _ #); pose proof (CIf _ #); pose proof (C # _ #); pose proof (C # _ #); pose proof (C # _ #); pose proof (C # _ #); pose proof (C # _ # _ _ _ #); pose proof (C # _ # _ _ # _); pose proof (C # _ # _ # _ _ _ # _ _); pose proof (C # _ # _ # _ _ _ # _ _ _ _ _ # _ _ _ # _ _ _ _ # _ _ _ _ _ # _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ # _ _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ _ _ # _ _ _ _ _ _ # _ _ _ _ _ _ _ # _ _ _ _ _ _ # _ _ _ _ _ _ # _ _ _ _ _ _ #Save solution'_b.",
                    "Goal solvable b.\nProof.\n  apply solvable_sol; auto.\nSave solution'_b.",
                    "Goal solvable b.\nintros.\neapply solvable_sol_proper; eauto.\nSave solution'_b.",
                    "Goal solvable b.\nexact I.\nexact I.\nSave solution'_b.",
                    "Goal solvable b.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n Save solution'_b.",
                    "Goal solvable b.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nSave solution'_b.",
                    "Goal solvable b.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nexact.\nSave solution'_b.",
                    "Goal solvable b.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold solvable.\nunfold.\nunfold solvable.\nSave solution'_b.",
                    "Goal solvable b.\nexact (C # # # # # /\nProof.\nexact (C # # # #).\nSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 758,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nProof.\nunfold Mptr.\npose proof (le_is_arg (arg := (arg := (arg := (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg * (arg *arg * (arg * (arg *arg)))))))\n  |> (( -- |> _ # _ ==  /  E  #  ::\nend)\n(<<\n>>\n*)\n\nLtac split_hyp :=\n  repeat match goal with |-?P?P?Q?P?P?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?Q?QSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold has_upper in *.\nunfold all_bound in *.\nunfold all_bound in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in *.\nunfold not in |- *.\nunfold not in *.\nunfold not in *.\nunfold not in |- *.\nunfold not in *.\nunfold not in |- *.\nunfold not in *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nunfold not in |- *.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold postic.\nmove=> mic.\nunfold postic.\nunfold postic.\nsimpl in *.\nunfold postic.\nunfold postic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold posticicic.\nsimpl in *.\nunfold postic.\nunfold posticic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold posticic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold posticic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold postic.\nunfold posticic.\nsimpl in *.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold posticic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold posticicic.\nsimpl in *.\nunfold postic.\nsimpl in *.\nunfold postic.\nunfold postic.\nsimpl in *.\nunfold posticicic.\nsimplSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold odd.\nunfold odd_of.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold even_of_nat.\nunfold even_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold even_of_nat.\nunfold even_of_nat.\nunfold odd_of_nat.\nunfold odd_of_nat.\nunfold even_of_Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_point.\nunfold mid_Save microban_1_solution.",
                    "Goal solvable microban_1.\n  exact (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=CSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold postic_1.\nunfold postic_2.\nunfold post_ic_1.\nunfold postic_2.\nunfold postic_2.\nunfold postic_2.\nunfold postic_2.\nunfold postic_3.\nsimpl in *.\nunfold postic_3.\nunfold postic_4.\nunfold postic_2.\nunfold postic_3.\nsimpl in *.\nunfold postic_4.\nunfold post_8.\nsimpl in *.\nunfold postic_3.\nunfold postic_3.\nunfold postic_4.\nunfold postic_4.\nunfold postic_2.\nunfold postic_4.\nunfold post_q.\nunfold postic_4.\nunfold postic_4.\nunfold postic_4.\nsimpl in *.\nunfold postic_4.\nunfold postic_4.\nsimpl in *.\nunfold postic_3.\nunfold postic_3.\nsimpl in *.\nunfold postic_4.\nunfold postic_4.\nunfold postic_3.\nsimpl in *.\nunfold postic_4.\nunfold postic_Save microban_1_solution.",
                    "Goal solvable microban_1.\nintros.\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nassert (H:=H).\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nintros.\nunfold ~=1.\nassert(n=n) by auto.\n(* A is a few cases of the same in the same point in the same type *)\nintros.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=n) by auto.\nassert(n=nSave microban_1_solution.",
                    "Goal solvable microban_1.\n  exact (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=C) (C:=CSave microban_1_solution."
                ]
            }
        ],
        "goedel": [
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": "\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 9996,
                "proof_end_offset": 10123,
                "proof": "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10202,
                "proof_end_offset": 10332,
                "proof": "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\nLemma codeAndCorrect :\n forall a b : Formula,\n codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.\n\nDefinition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10406,
                "proof_end_offset": 10536,
                "proof": "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "\napply cPairPi2IsPR.\napply pi2_2IsPR.\napply eqIsPR.\napply pi3_3IsPR.\napply pi1_3IsPR.\napply switchIsPR.\napply switchIsPR.\napply\n filter1100IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 12173,
                "proof_end_offset": 12326,
                "proof": "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply isPR.\napply isPR.\napply isPR.\napply isPR.\napply isPR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply is_PR.\napply isQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply comp1_2IsPR.\napply comp1_IsL.\napply comp1_IsL.\napply comp2_IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2IsL.\napply comp2L.\napply comp2IsL.\napply comp2L.\napply comp2IsL.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply comp2L.\napply compQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply exIsPR.\napply retIsIsPR.\napply noPR.\napply rIs.\napply rIsIs.\napply leIsIsEq.\napply noPR.\napply noPR.\napply H.\napply H.\nassumption.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\nassumption.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply comp2IsComp.\napply comp2_2IsComp.\napply comp2_3IsComp.\napply comp2_IsComp.\napply comp2_IsComp.\napply comp2_3IsComp.\napply comp2_2IsComp.\napply comp2_3IsComp.\napply comp2_3IsComp.\napply comp2_2IsComp.\napply comp2_3IsComp.\napply comp2_3IsComp.\napply comp3IsComp.\napply comp3_IsComp.\napply comp2_3IsComp.\napply comp3_IsComp.\napply comp2IsComp.\napply comp3IsComp.\napply comp2IsComp.\napply comp2_3IsComp.\napply comp2_3IsComp.\napply comp3IsComp.\napply comp2IsComp.\napply comp3IsComp.\napply comp3IsComp.\napply comp2IsComp.\napply comp3IsComp.\napply comp2_2IsComp.\napply comp3IsComp.\napply comp3IsComp.\napply comp2IsComp.\napply comp2_2Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply retIs.\napply retIsEq.\napply retIsEq.\napply retIsIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retEq.\napply retIsEq.\napply retIsEq.\napply retQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply clIsComp.\napply clIsIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.\napply clIsComp.Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply retIsIsFun.\napply retIsIsComp.\napply retIsComp.\napply retIsIsComp.\napply retIsIsComp.\napply retIsIsIsComp.\napply retIsIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsIsComp.\napply retIsComp.\napply retIsIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsIsComp.\napply retIsIsComp.\napply retIsIsComp.\napply retIsComp.\napply retIsIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsComp.\napply retIsIsComp.\napply retIsComp.\napply retIsComp.\napply retIsQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply\napply: is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Co.\napply is_Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply bindIsEq.\napply ret.\napply retIsIsIsExt.\napply T.\napply retIsIsEq.\napply T.\napply retIsIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retEq.\napply retIsEq.\napply retEq.\napply retIsEq.\napply retEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retEq.\napply retEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napply retIsEq.\napplyQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply comp1_2IsPR.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsCompQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\nLemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 12328,
                "proof_end_offset": 12484,
                "proof": "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi2IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply composeIsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply composeIsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply compose2IsComp.\napply composeQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub.\napply compose2IsEq.\napply fun _ _ => fun t recs.\napply sPair.\napply (fun t recs => t recs.\napply sPair.\napply (fun t recs => t recs.\napply (fun t recs => t recs.\napply (fun t recs => t recs.\napply tfun t recs.\napply t1IsLe.\napply (fun t recs => t recs.\napply t.\napply (fun t recs t recs.\napply t recs.\napply t.\napply t.\napply (fun t recs.\napply t recs.\napply t.\napply t.\napply t.\napply t.\napply (fun t recs t recs.\napply t recs.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\napply t.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\napply compose2IsEq.\napply rIsI.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold code of scs.\napply sigIsComp.\napply (fun t => t / (y,y,y,y,y,y,y,y,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,zz,z,zz,z,zzzzzz,zzzz,zzz,zzzzzzz,zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeIsIsComp.\napply comp2IsComp.\napply comp2_2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\n\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsComp.\napply comp2IsQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\napply compose3IsProd.\napply compose2IsEq.\napply compose3IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose3IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose3IsEq.\napply compose2IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose2IsEq.\napply compose3IsEq.\napply compose2IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\napply compose3IsEq.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeIsSub.\napply argsIsIs.\napply sigIsI.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub.\napply fun2IsIsLt.\napply cPair.\napply cPair.\napply sIsMP.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPairQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeIsIsL.\napply sig.\napply sigIsFun.\napply sigIsIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\napply sigIsEq.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold code ofM.\napply compose2IsEq.\napply cPairIsL.\napply cPair.\napply cPair.\napply cPair.\napply cB.\napply cPair.\napply cPair.\napply cB.\napply cPair.\napply cB.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cB.\napply cPair.\napply cPair.\napply cB.\napply cPair.\napply cPair.\napply cB.\napply cB.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cB.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cPair.\napply cQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\n",
                "context_tokens": 75,
                "proof_start_offset": 226,
                "proof_end_offset": 385,
                "proof": "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nLemma ext_eq_nat (n : nat) (a b : bool) :\n  (forall a b : bool, a = true) ->\n  (forall a : bool, a = true -> b = true) ->\n  (forall a : bool, a = true -> a = true) ->\n  (forall a : bool, a = true -> b = false) ->\n  (forall a : bool, a = true -> a = true) ->\n  (forall a : bool, a = true -> a = true) ->\n  (forall a : bool, a = true -> b = true) ->\n  (forall a : bool, a = true -> a = false) ->\n  (forall a : bool, a = true -> a = false) ->\n  (forall a : bool, a = true -> a = true) ->\n  (forall a : bool, a = true -> a = true) ->\n  (forall a : bool, a = true -> a = true) ->\n  (forall a : bool, a = true -> a = false) ->\n  (forall a : bool, a = true -> a = true) ->\n  (forall a : bool, a = true -> a = false)Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nLemma ext_axiom_axiom (n : nat) :\n    (forall n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n = n.\n\nLemma ext_axiom_axiom (n : nat) (n : nat) :\n  (exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n, exists n /\\ exists n, existsDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nFixpoint genPair (n : nat) (n : nat) : nat :=\n  match n with\n  | O => nat\n  | S n => nat\n  | S n' => nat\n  end.\n\nFixpoint genPair (n : nat) (n : nat) : nat :=\n  match n with\n  | O => nat\n  | S n' => nat\n  | S n' => nat\n  end.\n\nFixpoint genPair (n : nat) : nat :=\n  match n with\n  | O => 0\n  | S n' => nat\n  | S n' => nat\n  | S n' => nat\n  | S n' => nat\n  end.\n\nFixpoint genPair (n : nat) : nat :=\n  match n with\n  | O => nat\n  | S n' => nat\n  | S n' => nat\n  | S n' => nat\n  end.\n\nFixpoint genPair (n : nat) : nat :=\n  match n with\n  | O => n\n  | S n' => nat\n  | S n' => nat\n  end.\n\nFixpoint genPair (n : nat) (n : nat) : nat :=\n  match n with\n  | S n' => nat\n  |Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nLemma ext_eq_nat (n : nat) :\n  (forall b : nat, a = b) -> a = b.\nProof.\n  unfold ext_eq_nat_nat_eq_eq_nat_eq_eq_nat_eq_nat_eq_eq_nat_eq_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_nat_eq_eq_nat_nat_eq_nat_eq_nat_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_eq_nat_nat_eq_nat_eq_nat_eq_natDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nLemma extEqual_refl n : forall n : nat, n <> 0 -> a = a.\nProof.\n  induction n; simpl; intros; auto with arith.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nLemma ext_conj_eq : forall n (n : nat) (a b : A), forall (a b : A), a b -> a b.\nProof.\n  intros; apply ext_conj_eq; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nDefinition id (a b : bool) : Prop :=\n  match a with\n  | O => True\n  | S n => nat\n  | S n => nat\n  | S n => nat\n  end.\n\nDefinition id_eq (n : nat) (a b : bool) : Prop :=\n  match a with\n    | O => false\n    | S n => nat\n  end.\n\nDefinition id_eq (n : nat) : nat :=\n  match n with\n    | O => 1\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    end.\n\nDefinition id_eq (n : nat) (b : nat) : Prop :=\n  match a with\n    | O => true\n    | S n => nat\n    | S n => nat\n    | S n => nat\n    |Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nFixpoint dec_nat (a b : bool) : Prop :=\n  match n with\n  | O => fun b => b\n  | S n =>\n      match b with\n      | O => 0\n      | S n => fun b => fun b => a b\n  end.\n\nDefinition dec_nat (a b : bool) :=\n  match b with\n    | O => b\n    | S n => fun b => fun b => b\n  end.\n\nLemma dec_nat_rect (a b : bool) : b = b.\nProof.\n  intros.\n  destruct b.\n  - simpl in *.\n    apply dec_nat_rect_rect_eq.\n    - simpl in *.\n    apply dec_nat_rect_eq.\n    - simpl in *.\n      apply dec_nat_rect_eq.\n        simpl in *.\n        apply dec_nat_rect_eq.\n        simpl in *.\n        apply dec_nat_rect_eq.\n        simpl in *.\n        apply dec_nat_rect_eq.\n        simpl in *.\n        apply dec_nat_rect_eq.\n        simpl in *.\n        apply dec_nat_rect.\n        simpl in *.\n        apply dec_nat_rect_eq.\n        simpl in *.Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nDefinition id (b : bool) (b : bool) : Prop :=\n  match b with\n  | O => true\n  | S n => nat\n  | S n => nat\n  | S n => nat\n  end.\n\nLemma id_pair (n : nat) (a b : bool) : bool :=\n  match b with\n  | O => false\n  | S n => nat\n  | S n => nat\n  | S n => nat\n  | S n => nat\n  | S n => nat\n  end.\n\nDefinition id_pair (n : nat) : Prop :=\n  match n with\n  | O => nat\n  | S n => nat\n  | S n => nat\n  end.\n\nLemma id_pair (n : nat) : nat :=\n  match n with\n  | O => nat\n  | S n => nat\n  | S n => nat\n  end.\n\nLemma id_pair (n : nat) : nat :=\n  match n with\n  | O => nat\n  | S n => nat\n  | S n => nat\n  | S n => nat\n  | S n => nat\n  end.\nProof.\n  intros.\n  destruct (a b).\n  destruct b.\n  destruct b.\n Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n\nFixpoint dec (n : nat) (x : nat) : nat :=\n  match n with\n  | S n => n\n  | S n => nat\n  end.\n\nFixpoint inj_pair (n : nat) (x : nat) : nat :=\n  match n with\n  | S n => nat\n  | S n => fun x' => x\n  end.\n\nDefinition id (n : nat) (n : nat) : nat :=\n  match n with\n  | O => 0\n  | S n => fun x' => f (f x)\n  end.\n\nDefinition id_pair (n : nat) (n : nat) : nat :=\n  match n with\n  | O => 0\n  | S n => fun x' => f (f x')\n  end.\n\nDefinition id_pair (n : nat) (n : nat) : nat :=\n  match n with\n  | O => 0\n  | S n' => fun x => f (f x')\n  end.\n\nDefinition id_pair (n : nat) (x : nat) : nat :=\n  match n with\n  | O => fun x' => f (f x)\n  end.\n\nDefinition id_pairDefined."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\n",
                "context_tokens": 134,
                "proof_start_offset": 387,
                "proof_end_offset": 569,
                "proof": "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nsimpl.\nintro H.\nexact (H0).\nexact (fun c : nat => forall n : nat, m = n -> n = n.\nintros.\nelim (le_n _ _ H0).\nexact (fun c : nat => forall n : nat, m = m -> n = m.\nintros.\nelim (le_n _ H0).\nexact (fun c : nat => forall n : nat, m = n -> n = m.\nintros.\nelim (le_n _ _ H0).\nexact (fun c : nat => forall n : nat, m = m -> n = n.\nintros.\nelim (le_n _ _ H).\nexact (fun c : nat => forall n : nat, m = n -> n = m.\nintros.\nelim (le_n _ H).\nexact (fun c : nat => forall n : nat, m = m -> n = m.\nintros.\napply (le_n _ _ H0).\nexact (fun c : nat => forall n : nat, m = n -> n = m.\nintros.\nexactQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\nelim n as [| n Hrecn].\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat.\nintros.\nelim n as [| n Hrecn].\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nelim n as [| n Hrecn].\nexact (fun n : nat => nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nelim n as [| n Hrecn].\nelim n as [| n Hrecn].\nelim n as [| m Hrecn].\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nelim n as [| n Hrecn].\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nelim n as [| n Hrecn].\nelim n as [| n Hrecn].\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nelimQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\nexists (a, b).\nauto.\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\nsplit.\napply (pair_eq (fun n : nat => a = b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b + b +Qed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\napply (fun n : nat => let n := n in n = nat -> nat -> nat -> nat -> Prop.\nintros.\nexact (fun n : nat => n = nat -> nat -> nat -> nat -> nat -> Prop.\nintros.\nexact (fun n : nat => fun n : nat => n = nat -> nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat -> nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat -> nat.\nintros.\nexact (fun n : nat => nat ->Qed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\napply (well_founded_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind.\nexact (forall_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_ind_indQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nelim (eq_dec a n0); intros.\nelim (eq_dec a n); intros.\nexact (le_dec n0 a); intros.\nexact (le_dec n0 a); intros.\nexact (le_dec n0 a); intros.\nexact (le_trans n0 a0); intros.\nexact (le_trans n0 a0); intros.\nexact (le_trans n0 a0); intros.\nexact (le_trans n0 a0); intros.\nexact (le_trans n0 a1); intros.\nexact (le_trans n0 a1); intros.\nexact (le_trans n0 a1); intros.\nexact (le_trans n0 a1); intros.\nexact (le_trans n0 a1); intros.\nexact (le_trans n1 a1 a2); intros.\nexact (le_trans n0 a1 a2); intros.\nexact (le_trans n0 a1 a1); intros.\nexact (le_trans n1 a2); intros.\nexact (le_trans n1 a2 aQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\nexact (fun n => fun n => fun n => fun n => fun n => m n => m n end.\nintros.\nexact (fun n => fun n => fun n => fun n => m n => fun n => m end).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ndestruct a.\nexact (fun x => x).\nexact (fun x => x).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (prod_rect n a b).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\nLemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.\n\n",
                "context_tokens": 197,
                "proof_start_offset": 571,
                "proof_end_offset": 810,
                "proof": "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nsymmetry in |- *.\napply H.\nsimpl in |- *.\nintros.\napply Hrecn.\nsimpl in H.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\nassert (forall n : nat, (forall n : nat, (exists n : nat, (exists n : nat, (exists n : nat, (exists n : nat, n < n) -> n <= n) -> forall n : nat, (exists n : nat, (exists n : nat, (exists n : nat, n < n)) -> forall n : nat, (exists n : nat, (exists n : nat, (exists n : nat, n < n)) -> forall n : nat, (exists n : nat, (exists n : nat, n < n)) -> forall n : nat, (exists n : nat, (exists n : nat, n = n) -> forall n : nat, (exists n : nat, n = n) -> forall n : nat, (exists n : nat, n = n).\nintros.\nintro n.\nrewrite (le_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_S_Qed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nauto.\nintros.\ndestruct H.\nrewrite H.\napply (eq_dec a b); auto.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nrewrite H0.\nreflexivity.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\nsimpl in |- *.\napply (exists a : nat, fun a : nat => a = a) (a = b).\nintros.\napply (exists a : nat, fun a : nat => a = a) (a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b) (a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b) (a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b) (a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b).\nintros.\nrewrite (exists a : nat, fun a : nat => a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b) (a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b).\nintros.\napply (exists a : nat, fun a : nat => a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\napply ext_comp_equal with (B := fun c : nat => f a b).\nrewrite (eq_refl (fun c : nat => f a b)).\nauto.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\napply (fun x => x).\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (fun x => x).\nintros.\napply (Qed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nintro.\napply (H0 _ H0).\napply (fun a : nat => fun a : nat => fun a : nat => fun a : nat => fun a : nat => fun a : nat => a b) (b : a) => fun a : nat => fun a : nat => fun a : nat => a a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = a) (b : forall a : nat, a = b) (b : forall a : nat, b = a = a)Qed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nintros.\napply (eq_refl A).\napply (eq_refl A).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " unfold not in |- *; intros; elim b0.\ninversion H.\nreflexivity.\ninduction (b r r0).\nassert\n (forall (f g : Relations L) (p : f = g) (ts : Terms (arity L (inl _ f)))\n    (ss : Terms (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 8985,
                "proof_end_offset": 9141,
                "proof": "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction A; intros; simpl in |- *.\ninversion H.\ninversion H; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction n; simpl; intros.\ninversion H.\ninversion H.\neapply le_trans with (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (n:=n) (Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B H.\ninduction (H a); simpl; auto.\nleft; unfold not in |- *; intros.\ninversion H; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction A.\ninduction A.\nsimpl.\nauto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros.\napply le_trans with (P := fun x => forall x : nat, le_depth A B).\nintro x; apply le_trans with (P := fun x : nat => forall x : nat, le_depth A B x).\nintro x; apply le_trans with (P := fun x : nat => forall x : nat, le_depth A B x).\nintro x; apply le_trans with (P := fun x : nat => forall x : nat, le_depth A B x).\napply le_trans with (P := fun x : nat => forall x : nat, le_depth A B x).\nintro x; apply le_trans with (P := fun x : nat => forall x : nat, le_depth A x B x) -> le_depth B x.\nintros x; apply le_trans with (P := fun x : nat => forall x : nat, le_depth A x) x.\nintro x; apply le_trans with (P := fun x : nat => forall x : nat, le_depth A x) x.\nintro x; apply le_trans with (P := fun x : nat =>Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B C A B C.\ninduction (H0 f0).\nright.\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napply le_trans with (t := A).\napplyQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depthQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B; split; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth in |- *; intros.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H1.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion_clear H0.\ninversion H0.\ninversion_clear H0.\ninversion_clear H0.Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\ninduction (H _ a t) as [|a r]; auto.\napply le_trans with (n := n) (S n) (S n) (S n)).\napply le_trans with (n := n) (S n) (S n)).\napply le_trans with (n := n) (S n) (S n)).\napply le_trans with (n := n) (S n) (S n)).\napply le_trans with (n := n) (S n).\napply le_trans with (n := n) (S n).\napply le_trans with (n := n) (S n).\napply le_trans with (n := n) (S n).\napply le_trans with (n := n) (S n).\napply le_trans with (n := n).\napply le_trans with (n := n) (S n).\napply le_trans with (n := n).\napply le_trans with (n := n) (S n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": "s (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 9143,
                "proof_end_offset": 9299,
                "proof": "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_S_n.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_n.\napply le_n_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_n_Sn.\napply le_n_S.\napply le_n_S.\napply le_n_Qed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\ndestruct H.\nsimpl in |- *.\nrewrite H in H.\ninversion H.\ntauto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\ndestruct H.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\ninversion H0; auto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\ndestruct (H0 f).\nauto.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (n := 0) (n := n) (n := m) (n := m) (n := n) (n := m) (n := n) (n := m) (n := n) (n := m) (n := m) (n := m) (n := m) (n := m) (n := n) (n := m) (n := m) (n := n) (n := m) (n := n) (n := m) (n := m) (n := m) (n := m) (n := n) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := n) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (Qed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (n := n).\napply le_trans with (Qed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nsimpl in |- *.\nintros.\ninversion H.\napply le_le_n_Sm.\napply le_le_n_Sm.\napply le_le_n_Sm.\napply le_n_S.\napply le_n_Sm.\napply le_n_S.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_S.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_n_Sm.Qed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth, le_depth in |- *.\nsimpl in |- *.\nintros.\nrewrite H.\napply le_trans with (x := g) (n := f) (n := f) (n := g) (n := f) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n := g) (n :=Qed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (n := S (S (S n)) (n := S (S (S n)) (n := S (S (S n))) (S n)) (S n)) (S n)) (S n) (S n)) (S n) (S n)) (S n)).\nintros.\nrewrite (IHn (S n) (S n)) (S n) (S n) (S n)) (S n))).\nsimpl in |- *.\nsimpl in |- *.\nintros.\ninversion H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ".\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 9301,
                "proof_end_offset": 9401,
                "proof": "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_le_n_Sm.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply leQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (P := fun x : nat => exs x) t.\nsimpl in |- *.\nintros.\napply le_trans with (P := x).\napply le_trans with (P := x).\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_Qed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nintros.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napplyQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depth, le_depthQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_n_S.\napply le_n_Sm.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_max_l.\napply le_trans with (n := 0).\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply leQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\ninversion H.\napply le_trans with (l := l) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (t := t) (tQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_le_n_Sm.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply leQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_le_n_Sm.\napply le_le_S.\napply le_le_S.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply leQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nunfold lt_depth in |- *.\nunfold lt_depth in |- *.\nintros.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 9403,
                "proof_end_offset": 9523,
                "proof": "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_trans with (P := fun a : nat => f a) (depth a).\napply le_trans with (P := fun x : nat => f a) (depth a).\napply le_trans with (P := fun x : nat => f a) (depth a).\napply le_trans with (P := fun x : nat => f a) (depth a).\napply le_trans with (P := fun x : nat => f a) (depth a).\napply le_trans with (P := fun x : nat => f a).\napply le_trans with (P := fun x : nat => f a) (depth a).\napply le_trans with (P := fun x : nat => f a).\napply le_trans with (P := fun x : nat => f a).\napply le_trans with (P := fun x : nat => f a).\napply le_trans with (P := fun x : nat => f a) (depth a).\napply le_trans with (P := fun x : nat => f a).\napply le_trans with (P := funQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_le_n.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napplyQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_max_l.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).\napply le_trans with (P := H).Qed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_trans with (P := fun x => le_lt_n_Sm).\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_n_Sm.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_n_Sm.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napplyQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_le_n_Sm.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.Qed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nintros.\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 9525,
                "proof_end_offset": 9687,
                "proof": "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (P := fun x : nat => x) (S n).\nrewrite <- (lt_S_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_S_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_S_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm n).\nrewrite <- (lt_n_Sm_Sm n).\nrewrite <- (lt_Qed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nintros.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_O.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_O.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_Sm.\napply le_n_O.\napply le_n_Sm.\napply le_n_O.\napplyQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nunfold le_depth in |- *.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ") f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma eqDepth :\n forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 9689,
                "proof_end_offset": 10147,
                "proof": "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H n.\ninduction n as [| n Hrecn].\nintros.\napply H.\nintros.\nunfold lt_depth in H1.\nrewrite <- (le_n_O_eq _ H0) in H1.\nelim (lt_n_O _ H1).\nintros.\napply H.\nintros.\napply Hrecn.\napply lt_n_Sm_le.\napply lt_le_trans with (depth b).\napply H1.\napply H0.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold gt_depth, lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (1 := H0) (2 := H0) (2 := H0) (3 := H0) (2 := H0) (2 := H0) (2 := H0) (2 := H0) (2 := H0) (2 := H1) (2 := H0) (2 := H1) (2 := H0) (2 := H0) (2 := H1) (2 := H0) (2 := H0) (2 := H1) (2 := H0) (2 := H1) (2 := H0) (2 := H0) (2 := H1) (2 := H1) (2 := H1) (2 := H1) (2 := H0) (2 := H1) (2 := H0) (2 := H1) (2 := H0) (2 := H1) (2 := H1) (2 := H1) (2 := H1) (2 := H1) (2 := H2)Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectfulDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold Reflexive, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectfulDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold Sqrt, iff; intros; simpl; intros.\nunfold Fshift, meq; intros.\nrewrite <- H.\nrewrite H.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nunfold Fle, Proper, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful, respectful,Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation, relation,Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nrewrite <- H.\nassumption.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold iff in |- *.\nintros.\napply le_lt_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).\napply le_trans with (n := 0).Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold Sqrt in |- *.\nintros.\napply le_trans with (x := x) (x := y) (x := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := z) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := z) (y := y) (y := y) (y := y) (y := z) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := y) (y := z) (y := z) (y := z) (y := y) (y :=Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold Sqrt; intros.\nrewrite <- H.\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).\napply le_trans with (n := H).Defined."
                ]
            }
        ],
        "zorns-lemma": [
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " Import Eqdep.\napply inj_pair2 in H2.\ndestruct H2.\napply H3.\nQed.\n\nLemma ord_le_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta <= gamma -> alpha <= gamma.\nProof.\ninduction alpha.\ninduction beta.\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4386,
                "proof_end_offset": 4594,
                "proof": "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_anti.\napply ord_le_anti; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_anti.\napply ord_le_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.Qed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_upper_bound; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_full_uniq.\napply ord_le_full_uniq.\napply ord_le_full_full.\napply ord_le_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full.Qed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_anti; trivial.\napply ord_anti; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_upper_bound; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_full.\napply ord_le_full_r.\napply ord_le_full.\napply ord_le_full_full.\napply ord_le_full_full.\napply ord_full_full_full.\napply ord_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full_full.\napplyQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napplyQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_full.\napply ord_le_full_full.\napply ord_le_full_full.\napply ord_le_full_full_full.\napply ord_le_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full_full.\napply ord_full_full_full_full_Qed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\napply ord_le_anti.\napply ord_le_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": ".\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4596,
                "proof_end_offset": 4786,
                "proof": "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial; apply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_anti; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_respects_pred with (ord_incl_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha))) (le_chain (S alpha))) (le_chain (S alpha))) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha))) (le_chain (S alpha))) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha))) (le_chain (S alpha))) (le_chain (S alpha))) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha))) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha)) (le_chain (S alpha))) (le_chain (S alpha)) (le_chain (S alpha))) (le_chain (SQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_half_bound; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_anti with beta; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_respects_pred; trivial.\napply ord_eq_full_full; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_full_full_full_full.\napply ord_le_full_full.\napply ord_le_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full_full_full_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full_full_full_full_full_fullfull_full_fullfull.\napply ord_full_full_full_full_full_full_full_full_full_full_full_full_full_fullfull_full_full_full_full_fullfull_full_full_fullfull.\napply ord_full_full_full_full_full_full_fullfull_full_fullfull_fullQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_anti_n_anti_n.\nintro.\napply ord_anti_anti_n_anti.\napply ord_anti_anti_n_anti.\nintro.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti.\napply ord_anti_anti_n_anti.\nintro.\napply ord_anti_anti_n.\napply ord_anti_anti_n_anti.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_anti_n.\napply ord_anti_n.\napply ord_anti_anti_n.\napply ordQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_respects_pred; trivial.\napply ord_le_full_full; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4788,
                "proof_end_offset": 4941,
                "proof": "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_anti; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_anti; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_full.\napply ord_le_full_full.\napply ord_le_full_full.\napply ord_le_full_full_full.\napply ord_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full.\napply ord_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full.\napply ord_full_full_full_full_full_full_full_full_full_full.Qed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_anti; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_anti.\napply ord_le_anti.\napply ord_anti_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_anti.\napply ord_Qed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_upper_bound; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_upper; trivial.\napply ord_le_full; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_anti; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_full; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\nLemma ord_lt_respects_succ: forall alpha beta:Ordinal,\n  alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4943,
                "proof_end_offset": 7301,
                "proof": "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\ninduction alpha.\ninduction beta.\ndestruct (IHalpha beta) as [|[|]].\nleft; apply ord_lt_respects_succ; trivial.\nright; left.\nsplit.\napply ord_le_respects_succ; apply H.\napply ord_le_respects_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_anti_le_chain; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_respects_pred.\napply ord_total.\napply ord_trans with (ord_full beta); trivial.\napply ord_trans with beta; trivial.\napply ord_lt_respects_pred.\napply ord_trans with beta; trivial.\napply ord_lt_anti_anti_pred.\napply ord_anti_anti_trans with beta; trivial.\napply ord_anti_anti_transitivity with beta; trivial.\napply ord_anti_anti_anti_transitivity with beta; trivial.\napply ord_anti_anti_transitivity with beta; trivial.\napply ord_anti_anti_anti_transitivity with beta; trivial.\napply ord_anti_anti_transitivity with beta; trivial.\napply ord_anti_anti with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_lt_anti; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_anti_compat; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_eq; trivial.\napply ord_le_full.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_respects_pred.\napply ord_full_uniq; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_respects_pred; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_upper; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\n\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\n\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\n\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\n\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 752,
                "proof_start_offset": 7303,
                "proof_end_offset": 7689,
                "proof": "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nred; intro alpha.\ninduction alpha.\nconstructor.\nintros beta ?.\napply ord_le_respects_succ_converse in H.\nconstructor; intros gamma ?.\ndestruct IHalpha.\napply H1.\napply ord_lt_le_trans with beta; trivial.\nconstructor; intros alpha ?.\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [j].\ndestruct (H j).\napply H1; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\ndestruct (H i (ord_incl i j)); [apply ord_ord_monotonic | apply ord_le_incl ].\ndestruct (H i (ord_incl_incl i j)); [apply ord_le_incl | apply ord_le_incl ].\ndestruct (ord_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl].\ndestruct (ord_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_incl_Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply ord_trans with (o i < n)%nat; trivial.\napply ord_le_refl.\napply ord_le_trans with (o i < n)%nat; trivial.\napply ord_le_incl_n.\napply ord_le_trans with (o i < i)%nat; trivial.\napply ord_le_incl_incl_l.\napply ord_lt_incl_incl_incl.\napply ord_le_incl_incl_incl.\napply ord_le_incl_incl_incl.\napply ord_incl_incl_incl_incl.\napply ord_incl_incl_incl_incl.\napply ord_le_incl_incl_incl_incl.\napply ord_incl_incl_incl.\napply ord_incl_incl_incl_incl.\napply ord_incl_incl_incl_incl_incl.\napply ord_incl_incl_incl.\napply ord_incl_incl_incl_incl.\napply ord_incl_incl_incl_incl.\napply ord_incl_incl_incl_incl.\napply ord_incl_incl_incl_incl_incl.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ninduction: n x, x <= n -> n <= x -> n <= n.\nintros.\ndestruct (H i) as [[i [i | i] | i] | i] | i] | i] | i j] | i j] | i j] | i j] | i j] | i j] | i j] j i j].\nintros.\napply ord_le_upper_bound.\ninversion H0.\ndestruct (H i) as [[i | i] | i] | i j] | i j] | i j] | j] | i j] | j] j] | i j] | i j] | i j i j].\nassert (i < i < i)%N) by (apply ord_le_trans with (o i); trivial).\napply ord_le_trans with (o i); trivial.\napply ord_le_full_variant.\napply ord_le_full_upper_bound.\napply ord_le_max_full_full_full.\napply ord_le_full_full_full_full.\napply ord_max_full_full_full.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ndestruct (le_dec n n).\ndestruct H as [i | i j]; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros; destruct H as [i j | i j < i]; trivial.\nright; right.\ndestruct (classic (exists i:I, i < i < i)%N); trivial.\ndestruct (classic (exists i:I, j < j < j)%N); trivial.\ndestruct (classic (exists i:I, j < i < j)%N); trivial.\ndestruct (classic (exists j:I, j < j < j)%N); trivial.\ndestruct (classic (exists i:I, i < j < j)%N); trivial.\ndestruct (classic (exists i:I, j <= i < j)%N); trivial.\ndestruct H1 as [i [i j]; trivial.\ndestruct (classic (exists j:I, j <= j < j)%N); trivial.\ndestruct (classic (exists i:I, j < j < j)%N); trivial.\ndestruct (classic (exists j:I, j < j < j)%N); trivial.\ndestruct (classic (exists j:I, j <= j < j)%N); trivial.\ndestruct (classic (exists j:I, j < j)%N); trivial.Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintro x; destruct H as [i H].\nright; apply ord_incl_incl_incl.\napply ord_incl_incl_incl with (o i); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ninduction n; intro.\ndestruct H as [i [??]].\nright; exists i; trivial.\napply ord_le_trans with (o i) (o i); trivial.\napply ord_le_incl; trivial.\napply ord_le_incl.\napply ord_incl_incl_incl.\napply ord_le_incl.\napply ord_incl_incl_incl.\napply ord_lt_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_incl_incl.\napply ord_inclQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintros.\ndestruct (H i).\nleft; right.\ndestruct (H i).\nright; left.\ndestruct (H i) as [[i0 [??]].\nright; left.\nright; right; right; right.\nright; left.\nright; right; right.\napply ord_lt_trans with (o i); trivial.\nright; right; right.\nright; left; right; left; right; right; right; trivial.\nright; right; right; right; left; trivial.\nright; right; right; right; right; right; left; right; right; trivial.\nright; right; right; right; right; left; right; trivial.\nright; right; right; right; right; trivial.\nright; left; right; right; right; right; trivial.\nright; right; right; right; right; right; trivial.\nright; right; left; right; right; right; right; trivial.\nright; right; right; right; right; right; trivial.\nright; right; right; right; right; right; trivial.\nright; right; right; right; right;Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nintro.\ndestruct (le_dec n (exist _ _ _ _ (ord_of_P _ (ord_of_P _ (ord_of_P _ (ord_of_P _ (ord_of_P _ (ord_of_P _ (ord_of_P _ (ord_of_P _ (ord_of_P (ord_of_P _ (ord_of_P _ (ord_of_P (ord_of_P _ (ord_of_P n)))) as [|[|]].\ndestruct (le_dec n (exist _ _ _ (ord_of_P _ (ord_of_P _ (ord_of_P _ (ord_of_P (ord_of_P _ (ord_of_P _ (ord_of_P (ord_of_P (ord_of_P _ (ord_of_P (ord_of_P _ (ord_of_P (ord_of_P (ord_of_P _ (ord_of_P (ord_of_P _ (ord_of_P (ord_of_P _ (ord_of_P (ord_ofQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nintro.\ndestruct (H i) as [i|i].\nright; left; trivial.\ndestruct (H i) as [i|i].\nleft; right; trivial.\napply ord_lt_trans with (o i) (o i < i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_le_incl with (o i); trivial.\napply ord_le_incl with (o i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_le_incl with (o i); trivial.\napply ord_le_incl with (o i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_lt with (o i); trivial.\napply ord_lt_incl with (o i); trivial.\napply ord_le_incl with (o i);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\n",
                "context_tokens": 226,
                "proof_start_offset": 778,
                "proof_end_offset": 1010,
                "proof": "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Empty_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nsimpl.\nunfold Same_set.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\nintros.\ninversion H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Empty_set.\nunfold Empty_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\n",
                "context_tokens": 305,
                "proof_start_offset": 1059,
                "proof_end_offset": 1278,
                "proof": "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nintro.\nrewrite (Union_set (Ensemble U)) in H.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply ExtensionalityQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nunfold Included in |- *.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\nunfold Included, Included in |- *.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\nLemma subfamily_union: forall F G:Family T, Included F G ->\n  Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.\n\n",
                "context_tokens": 374,
                "proof_start_offset": 1280,
                "proof_end_offset": 1506,
                "proof": "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nconstructor.\ndestruct H0.\nintros.\napply H0.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included in |- *.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set.\nunfold Same_set.\nsimpl.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included in |- *.\nunfold Included in |- *.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\ndestruct H.\napply Extensionality_Ensembles.\ndestruct H.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\ndestruct H.\ndestruct H.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\ndestruct H.\napply Extensionality_Ensembles.\ndestruct H.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\ndestruct H.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\ndestruct H.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nunfold Included in |- *.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\nunfold Included in |- *.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included, Included.\nintros.\napply Extensionality_Ensembles.\nunfold Included in H.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set; intros.\ndestruct H.\napply H0.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Same_set.\nintros.\ndestruct H.\napply H0.\napply (finite_union_intro _ _ H0).\napply (finite_intro _ _ H0).\napply (finite_intro _ H0).\napply (finite_intro _ H0).\napply (finite_intro _ _ H0).\napply (finite_intro _ H0).\napply (finite_intro _ _ H0).\napply (finite_intro _ H0).\napply (finite_intro _ H0).\napply (finite_intro _ H0).\napply (finite_intro _ H1).\napply (finite_intro _ H1).\napply (finite_intro _ H1).\napply (finite_intro _ H1).\napply (finite_intro _ H1).\napply (finite_intro _ H1).\napply (finite_intro _ H1).\napply (finite_intro _ _ H1).\napply (finite_intro _ _ H0).\napply (finite_intro _ _ H2).\napply (finite_intro _ _ H0).\napply (finite_intro _ H1).\napply (finite_Qed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included in |- *.\nintros.\ndestruct H0.\napply H.\nQed."
                ]
            }
        ],
        "coqrel": [
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "inter_refl : typeclass_instances.\n\nLemma rel_inter_corefl_l {A} (R1 R2: rel A A):\n  Coreflexive R1 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6671,
                "proof_end_offset": 6793,
                "proof": "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros R1 x y Hxy2 y Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (rel_impl_leRat (fun R2 => R1 x y) x y); [ | apply rel_impl_r : typeclass_instances.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 6891,
                "proof_end_offset": 7009,
                "proof": "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 7147,
                "proof_end_offset": 7239,
                "proof": "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 7326,
                "proof_end_offset": 7416,
                "proof": "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 7595,
                "proof_end_offset": 7683,
                "proof": "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8747,
                "proof_end_offset": 8901,
                "proof": "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8903,
                "proof_end_offset": 9058,
                "proof": "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose; split; intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\nLemma rel_compose_id_right {A B} (R: rel A B):\n  eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 9060,
                "proof_end_offset": 9315,
                "proof": "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y z; firstorder; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder.\n  apply rel_refl_refl_left_left_r.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros y y; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; firstorder.\n  firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  intros x y; firstorder; firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  split; intros x y; firstorder.\n  firstorder.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " sum_rel R R (inl a) (inl b).\nProof.\n  intros.\n  rewrite H.\n  rewrite <- H.\n  reflexivity.\nQed.\n\n(** There is an issue with the following. *)\n\nGoal\n  forall A (a b: A) (R: rel A A) (f: A -> A) (p: A -> Prop),\n    Monotonic f (R ++> R) ->\n    Monotonic p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\n",
                "context_tokens": 685,
                "proof_start_offset": 2211,
                "proof_end_offset": 2462,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nAbort.\n\n(** The next a boolean function of [A] is an equivalence relation and [A] is used to [A]. *)\n\nGoal forall {A B} (RA: rel B) (f: A -> B) (x y: A),\n    (forall x y: A, R x y) -> (forall y:A, R x y) -> (forall y:A, R x y x) -> (forall y:A, R x y) -> (R x y) -> (R x y)) ->\n    (forall y:A, R x y) -> (forall y:A, R x y) -> (forall y:A, R x y) -> R y -> R y) ->\n    forall y:A, R y x y -> R y) ->\n    (forall y:A, R x y -> R y) -> R y ->\n    (forall y:A, R x y) -> R y) ->\n    (forall y:A, R y x y) -> R y -> R y) ->\n    (forall y:A, R y x y) -> R y -> R y) ->\n    forall y:A, R y -> RQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  destruct (eq_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_dec_decQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B C D H D H D H.\n  induction D; try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  destruct (H a0 a0).\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  repeat discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  repeat discriminate.\n  try discriminate.\n  repeat discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  repeat discriminate.\n  try discriminate.\n  try discriminate.\n  repeat discriminate.\n  try discriminate.\n  repeat discriminate.\n  simpl.\n  discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n  try discriminate.\n Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B C D E0 D0.\n  destruct (g x y) as (g, g, g), g), g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, gQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n  intros.\n  apply R.\n Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nAbort.\n\n(* The following two-typed case of the following tactics are done. *)\n\nGoal forall {A B} (RA: rel A) (a: A) (a: A),\n  a <> a ->\n  a <> a ->\n  a <> a ->\n  a <> a ->\n  a <> a ->\n  a <> a.\nProof.\n  intros A B RA.\n  destruct (eq_dec a a).\n  auto.\n  congruence.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nAbort.\n\n(* This is a class of a class to the class. *)\n\nGoal forall {A B} (RA: rel B) (x y: A),\n  (forall x y: A, D x y -> D x y) (R x y) ->\n  (forall x y:A, D x y -> D y x y) ->\n  (forall x, D x y -> D x y) ->\n  (forall x y:A, D x y -> D x y) ->\n  (forall x y:A, D x y -> D x y) ->\n  (forall y:A, D x y -> D x y) ->\n  (forall y:A, D x y -> D x y) ->\n  (forall y:A, D x y) -> D x y) ->\n  (forall y:A, D x y -> D y -> D x y) ->\n  (forall y:A, D x y -> D y) ->\n  (forall y:A, D x y -> D y) ->\n  (forall y:A, D x y -> D y) ->\n  (forall y:A, D x y -> D y) ->\n  (Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nAbort.\n\n(* Test a bug #15 a bug #15 #15 #17 #16 #18 #1716 #1625 #2021 #16 #192124a15 #232515 #2316 #2317a24a1421b2436a2224343427a23a3417a273514d27a442\" \"23f23a14d23a37f26f23a34a26a25f26f45a462121a3d23e7f6f8a9f8f7f8f9f8a8f8f9f9f9d8f8c9f9d9f8f9d9f9f9f9f9b9f9d9f9d9f9f8f9f9d9f9f9f9f9f9f9f9f9d9f9f9b9f9a9f8f8d8c9f9f9b9f9d9f9d9f9f9f9d9f9f9d9d9e9f9d10dQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B RA B D x y' y' y' H' H' H' H' H' H' H''' H''' H''' H''''' H''''' H''''' H'''''' H'''''''' H'''''''''' H''''''''' H'''''''''''''''''' H''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nAbort.\n\n(** The following tactic is defined as a tactic is a general form. *)\n\nGoal forall {A B} (RA: rel A B) (f: A -> A -> A) (f: A -> A -> B),\n    forall x y, f x y -> f x y -> f y = f y.\nProof.\n  intros A B D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D DQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 2464,
                "proof_end_offset": 2664,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  assert (H := H).\n  destruct H as (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b); destruct (a, b);Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  destruct (eq_dec _ _ _ _ _ H) as (a, b) as (a, b) as (a, b) as (a, b) (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) as (a, b) by (a,Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nGoal forall {A B} (RA: rel A B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) (RA: rel B) :=\n  forall x, RA_RA x (RA: A) (RA: rel B)Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  induction H; intros.\n  simpl; auto.\n  intros.\n  specialize (H (H0 (fun a b => a) (fun b => a) (fun b => b) (fun b => b) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a)) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a)) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a) (fun b => a)Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  assert (Hop: forall x y, RA x y -> RA x y -> RA x y -> RA x y -> RA x y -> RA y x y -> RA x y -> RA x y -> RA x y z -> is x y -> RA x y z -> RA x y z -> RA x y z.\nProof.\n  intros.\n  assert (Hop: forall x y z, RA x y -> RA x y z -> RA x y z -> RA x y z -> RA x y z -> RA y z -> RA x y z -> RA y z -> RA y z.\nProof.\n  intros.\n  assert (Hop: forall x y z, RA x y -> RA x y z -> RA x y z -> RA x z -> RA x y z -> RA x y z -> RA y z -> RA x z -> RA y z.\nProof.\n  intros.\n  assert (Hop: forall x y z, RA x y -> RA x y z -> RA x z -> RA x y z -> RA x z -> RA x z -> RA x y z -> RA y z -> RA x y z.\nProof.\n  intros.\n  assert (HopQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rewrite <- (RA :&: RA).\n  apply (RA :&: RA).\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  assert (Hop: forall x y z, RA x y -> RA (if b then a else a) = y) (fun x y z => (fun y => (a, b) (fun y => a) (fun y => (a, b) (a, b)) (fun y => a) (fun y => a) (a, b)) (fun y => (a, b)) (fun y => a)) (fun y => (a, b)) (fun y => a)) (fun y => (a, b) (fun y => a) (a, b)) (fun y => a)) (fun y => (a, b)) (fun y => (a, b)) (fun y => a) (a, b)) (fun y => a)) (fun y => (a, b)) (fun y => a) (a, b)) (fun y => (a, b)) (fun y => a) (a, b)) (fun y => a)) (fun y => (a, b)) (fun y => a) (a, b)) (fun y => (a, b)) (fun y => (Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  assert (Hop: forall (A B C : A) (x y:A), RA y x -> RA y x y -> RA y x y -> RA y x y.\nProof.\n  intros.\n  assert (Hop: forall (A B C : A) (x y:A) (y:A), RA x y -> RA x y -> RA y x y -> RA y x y.\nProof.\n  intros.\n  assert (Hop: forall (A B C : A -> C) (x y:A), RA x y -> RA y x y.\nProof.\n  intros.\n  assert (Hop: forall (A B C : A) (x y:A), RA x y -> RA x y -> RA x y -> RA y x y.\nProof.\n  intros.\n  assert (Hop: forall (A B C : A) (x y:A), RA x y -> RA y x y.\nProof.\n  intros.\n  assert (Hop: forall (A B C : A) (x y:A), RA x y -> RA x y.\nProof.\n  intros.\n  assert (Hop: forallQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rewrite r.\n  apply r.\n  apply r.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2666,
                "proof_end_offset": 2819,
                "proof": "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  induction R; auto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rewrite <- R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  induction 1.\n  simpl.\n  simpl.\n  rewrite <- H.\n  reflexivity.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  auto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  auto.\n  destruct x.\n  + apply R.\n  + apply R.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a).\n  apply le_trans with (a, a);\n  apply le_trans with (a, a);\n  apply le_trans with (aQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_impl.\n  apply R_Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  apply (prod_rel_fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rewrite <- (fun _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H := H).\n  assert (H :=Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 2821,
                "proof_end_offset": 2999,
                "proof": "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  assert (H := H).\n  rewrite H.\n  rewrite H0.\n  auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rewrite H.\n  auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  intros.\n  rewrite H in H.\n  simpl.\n  intros.\n  apply H.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  assert (forall a b: bool, a = b -> R a b) -> R x y -> R x y.\n  intros.\n  apply R_refl.\n  apply R_refl.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  apply r.\n  apply r.\n  auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  apply r.\n  auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  apply rel_rel.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rewrite r. auto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  simpl.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\n",
                "context_tokens": 715,
                "proof_start_offset": 3599,
                "proof_end_offset": 3825,
                "proof": "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\nintros A R f C x y Hf Hxy.\nFail rauto.\npose proof @f_equal_relim.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R R f x y H.\n  induction x; intros.\n  + simpl.\n    + simpl.\n      + simpl.\n      + simpl.\n      + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n          + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n        + simpl.\n          + simpl.\n        + simpl.\n        + simpl.\n        + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n          + simpl.\n         Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct x as [x y]; [left |right]; [right]; [left;right; split; auto |right; right; split; auto].\n  + intros x y. rewrite <- H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H. apply H.Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f g x y Hf.\n  apply (fun (f x y) (x1 y2 y2 y2)) with (y2:=R); auto.\n  apply (fun (f x y2 y1 y2) (x2 y2 y3) (y2 y3 y3)) with (y3:=R); auto.\n  apply (fun (f x y2 y3) (y3 y3 y3)) with (y3:=R); auto.\n  apply (fun (f x y2 y3) (y4 y3 y4) (y3 y4 y4) (y4 y4 y4))).\n  apply (fun (f x y3) (x4 y3 y4) (y4 y5 y7) (y4 y6 y7)) with (y3:=R); auto.\n  apply (fun (f x y3 y3) (y4 y7) (y4 y4 y5) (y7 y8) (y8 y8 y8) (y10 y8 y8) (y9 y9) (y8 y8 y9))\n    with (x2:=Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  apply (fun _ => True)).\n  apply (fun _ => True)).\n  apply (fun _ => True).\n  apply (fun _ => True)).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True)).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ _ _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ => True).\n  apply (fun _ _ => True).\n  apply (fun _ _ => True).\n  apply (fun _Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H.Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  apply H.\n  intros.\n  unfold compose, compose, compose, compose, compose, compose, compose, compose, compose, compose, compose, compose, f, compose, compose, compose, compose, compose, f, f_equal.\n  apply H.\n  intros.\n  unfold compose, compose, compose, compose, compose, compose, compose, compose, f_equal.\n  apply H.\n  intros.\n  unfold compose, compose, compose, compose, compose, compose, compose, compose, compose, f_equal.\n  destruct f_equal, f_equal.\n  apply H.\n  intros.\n  unfold compose, compose, compose, compose, compose, compose, compose_compose, f_equal.\n  destruct f_equal, f_equal.\n  apply H.\n  intros.\n  unfold compose, compose, compose, compose, compose, compose_ord, f_equal.\n  destruct f_equal.\n  apply H.\n  intros.\n  unfold compose, compose, compose, compose, compose, compose_compose, compose_compose, f_equal.\n  destruct f_equal.\n  apply H.\n  intros.\n  unfold compose, compose, compose, compose, compose, composeQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f g x y f y.\n  assert (f x = f y) by apply proof_irr.\n  intros x y f z f.\n  rewrite <- (f x y) in f.\n  rewrite <- (f x y) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f x) in f.\n  rewrite <- (f y) in f.\n  rewrite <- (f y)Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R S f x y f y f y f y f y f y f y f y f y f y f y.\n  intros.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y x y Hf.\n  rewrite <- (f x2 y Hf).\n  rewrite <- (f x2 y Hf).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y) by reflexivity.\n  rewrite <- (f2 y f2 y f2 y f2).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).\n  rewrite <- (f2 y).Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  exists (fun (b: bool) (a b': bool) (x' : A),\n    D x a' -> C x' -> C x' x' -> C x' x'.\n  intros.\n  assert (H1 : x' = x') by (apply H1; apply H1; apply H2; apply H2; apply H1; apply H2; apply H2; apply H1; apply H2; apply H2; apply H2; apply H2; apply H3; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H3; apply H2; apply H2; apply H2; apply H2; apply H1; apply H2; apply H2; apply H2; apply H3; apply H2; apply H2; apply H2; apply H2; apply H2; apply H3; apply H4; apply H2; apply H3; apply H2; apply H2;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ") (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3953,
                "proof_end_offset": 4077,
                "proof": "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\nintros A R x y Hxy Hyy.\nmonotonicity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros x y Hxy.\n  rewrite Hxy.\n  apply (f_equal_f_equal _ _ _ _ _ Hxy).\n  rewrite Hxy.\n  apply (f_equal_f_equal _ _ _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_f_equal _ _ _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_f_equal _ _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_f_equal_equal _ _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_equal _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_equal_f _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_equal_f_equal _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_equal_f_equal _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_equal_f_equal _ Hxy).\n  rewrite Hxy.\n  rewrite Hxy.\n  apply (f_equal_equal_f_equal _ Hxy).\n  rewriteQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f x y Hf.\n  destruct (f x) as (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n  exists (g,y).\n Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f C f x y Hf x y Hf.\n  apply (x,y,y).\n  auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R f y f' y f' x y f' y f' f' x' y'.\n  assert (f y = f y) by (apply (isisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisisQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f y f y Hf.\n  - rewrite <- (f_equal_equal_f _ _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_f _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ H) in Hf.\n    rewrite <- (f_equal_equal_f _ _ _ _ _ H) in Hf.Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y x y f Hfxy.\n  pose proof @f_equal_divlu.\n  rewrite <- (f_equal_equal_equal_impl_and_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_impl_implQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y f y Hf.\n  apply f_equal_equal_reflexivity.\n  transitivity (f x) (f y) (f y) (f y)).\n  apply f_equal_equal_reflexivity.\n  transitivity (f y) (f y)) (f y)).\n  apply f_equal_reflexivity.\n  transitivity (f y) (f y)).\n  apply f_equal_reflexivity.\n  transitivity (f x) (f y)).\n  apply f_equal_equal_reflexivity.\n  transitivity (f y) (f y) (f y)).\n  apply f_equal_reflexivity.\n  transitivity (f y) (f y)).\n  apply f_equal_reflexivity.\n  transitivity (f y) (f y)).\n  apply f_equal_reflexivity.\n  transitivity (f y) (f y) (f y)).\n  apply f_equal_reflexivity.\n  transitivity (f y) (f y)).\n  apply f_equal_equal_reflexivity.\n  transitivity (f y) (f y)).\n  apply f_equal_reflexivity.\n  transitivity (f y) (f y).\n  apply f_equal_reflexivity.\n  transitivity (f y) (f yQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f y x y Hf.\n  unfold eq in H.\n  apply eq_sym; auto.\n  apply eq_sym; auto.\n  apply eq_sym; auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R f x y Hf Hxy.\n  cbn.\n  match goal with |- context [x] =>\n      apply (H x y)\n    | [H x y H y H y H y H H y H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H H HQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R f x y f y H.\n  apply (f_equal_equal_f _ _ _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ H).\n  apply (f_equal_equal_f _ _ _ _ _ _ H).\n  apply (f_equal_f _ _ _ _ _ _ _ H).\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\n",
                "context_tokens": 730,
                "proof_start_offset": 4556,
                "proof_end_offset": 4698,
                "proof": "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\nintros A R f Hf.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R R x y x y H.\n  apply (f x y H) in H.\n  apply (f x y H).\n  apply (f x y H).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f y).\n  apply (f yQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R x y Hxy.\n  apply (H x y Hxy).\n  apply (H x y Hxy).\n  apply (H x y Hxy).\n  apply (H x y Hxy).\n  apply (H y Hxy).\n  apply (H y x Hxy).\n  apply (H x y Hxy).\n  apply (H x y Hxy).\n  apply (H x y Hxy).\n  apply (H x y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H x y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply Hxy.\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).\n  apply (H y Hxy).Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R x y Hy.\n  apply R x y Hy.\n  apply R x y Hy.\n  apply R x y Hy.\n  apply R y z.\n  apply R y z.\n  apply R z.\n  apply R z.\n  apply R y z.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  apply R x y Hxy.\n  apply R x y Hxy.\n  apply R x y Hxy.\n  apply R x y Hxy.\n  apply R x y Hxy.\n  apply R y Hxy.\n  apply R x y Hxy.\n  apply R x y Hxy.\n  apply R x y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R x y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R x y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply R y Hxy.\n  apply Hxy.\n  apply R y Hxy.\n  apply Hxy.\n  apply R y Hxy.\n  apply Hxy.\n  apply R y Hxy.\n  apply Hxy.\n  apply Hxy.\n  apply Hxy.\n  apply R Hxy.\n  apply Hxy.\n  apply Hxy.\n  apply R y Hxy.\n  apply Hxy.\n  apply Hxy.\n  apply Hxy.\n  apply Hxy.\n  apply Hxy.\n  apply Hxy.Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy.\n  intros A R x y Hxy.\n  apply R; auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hx Hxy.\n  apply le_trans with (f := x); auto.\n  - apply le_trans with (f := x); auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R R x y Hy Hxy.\n  rewrite (f x y Hxy).\n  rewrite (f x y Hxy).\n  rewrite (f x y Hxy).\n  rewrite (f y Hxy).\n  rewrite (f x y Hxy).\n  rewrite (f x y Hxy).\n  rewrite (f x y).\n  rewrite (f y Hxy).\n  rewrite Hxy.\n  rewrite (f x y).\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite (f x y) Hxy.\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite (f y).\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewrite Hxy.\n  rewriteQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R R f x y Hx.\n  apply R; auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R x y Hxy.\n  constructor; auto.\n  intros A R x y Hxy.\n  constructor; auto.\n  intros A R x y Hxy.\n  constructor; auto.\n  intros A R x y Hxy.\n  constructor; auto.\n  intros A R x y Hxy.\n  constructor; auto.\n  intros A R y Hxy.\n  constructor; auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y H.\n  rewrite <- H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4997,
                "proof_end_offset": 5177,
                "proof": "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\nintros A R R' f Hf HR.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f g g Hf Hf g Hf g Hf g Hf Hf g Hf Hf Hg g Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg HgQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  apply (R ==> flip R) with (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R) (R ==> flip R') (R ==> flip R') (R ==> flip R) (R ==> flip R') (R ==> flip R') (R ==> flip R) (R ==> flip R') (R ==> flip R') (R ==> flip R') (R ==> flip R) (R ==> flip R) (R ==> flip R') (R ==> flip R') (R ==> flip R) (R ==> flip R') (R ==> flip R) (R ==> flip R) (R ==> flip R') (R ==> flip R) (R ==> flip R) (R ==> flip R) (R ==> flip R) (R ==> flip R) (R ==> flip R') (R ==> flip R) (R ==> flip R) (R ==> flip R') (R ==> flip R) (R ==> flip R) (R ==>Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  firstorder.\n  firstorder.\n  firstorder.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf x Hf.\n  specialize (A R x Hf).\n  specialize (A R).\n  specialize (A R x Hf).\n  specialize (A R).\n  specialize (A R).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).\n  specialize (A R x).Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f g.\n  apply (f a) with (R ++> flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R) by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R') by auto.\n  apply (f a) with (R := flip R) by auto.\n  apply (f a)Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  firstorder.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n  rewrite <- (R ==> R') in Hf.\n Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf x y Hxy.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply HfQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f g x y Hxy.\n  specialize (A R f x y Hxy).\n  destruct (A R x y) as [x [y [y [y [y [y [y [y [y [y [y [y z]]]]; [y [y [y [y [y [y [y [y [y [y [y [y z]]]]; [y [y [y [y [y z]]]]; [y [y [y [y [y [y [yz [y [yz z]]]]; [y [y z]]]]; [y [y [y [y [y [y [z [y [y y]]]]; [y [y [y [z [z [yz [z z]]]]; [z [z [z [z [z z]]]]; [z [z [z [z z]]]]; [z [y z]]]]; [z [z [z [z z]]]]; [z [z z [z [z [z [z [zzz z]]]]; [z [z [z z [z z]]]]; [z z z z z [z z]]]]; [z z [z z [z z z z z [z z]]]]; [Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rewrite Hf.\n  auto.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f f Hf Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.\n  apply Hf.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 5968,
                "proof_end_offset": 6181,
                "proof": "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\nintros A B C R f a1 a2 b c Hf Ha.\nmonotonicity; rauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D f Hf.\n  intros A B C D f Hf.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply g.\n  apply gQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D f Hf Hf Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg Hg HgQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D f Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf HfQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D E.\n  split; auto.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D f Hf.\n  destruct (H x).\n  apply (H x) in H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversion H; inversionQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D f Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf HfQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D f Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf HfQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D a1 b c d H1.\n  destruct (eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_dec eq_Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D f Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf Hf HfQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 6183,
                "proof_end_offset": 6385,
                "proof": "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 R1 R2 R HR12 x y.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B1 B2 R1 R2 R2 R1 R2 R2 R2 R2 R2 R3 R3 R3 R3 R4 R3 R4 R4 R4 R5 R4 R5 R4 R5 R5 R5 R6 R6 R6 R6 R6 R6 R7 R6 R7 R6 R6 R7 R6 R6 R6 R6 R7 R8 R10 R11 R7 R12 R12 R13 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R15 R14 R14 R14 R14 R15 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R15 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R15 R14 R14 R15 R14 R14 R14 R14 R15 R14 RQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B1 R2 R1 R2 R2 R2 R3 R3 R3 R4 R5 R5 R6 R5 R6 R5 R6 R6 R7 R6 R6 R6 R6 R6 R6 R7 R7 R7 R7 R8 R10 R10 R10 R12 R11 R12 R12 R12 R13 R12 R13 R12 R14 R14 R13 R14 R14 R13 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R15 R14 R15 R14 R14 R14 R14 R14 R14 R15 R14 R15 R15 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R15 R14 R14 R15 R14 R15 R14 R14 R15 RQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 R1 x y Hxy.\n  split; auto.\n  intros A1 R2 x y Hxy.\n  split; auto.\n  intros A1 R2 y Hxy.\n  split; auto.\n  intros A2 R1 y Hxy.\n  split; auto.\n  intros A1 R2 y Hxy.\n  split; auto.\n  intros A1 R2 y Hy Hxy.\n  split; auto.\n  intros A1 R2 y Hxy.\n  split; auto.\n  intros A2 R3 y Hxy.\n  split; auto.\n  intros A1 R2 y Hxy.\n  split; auto.\n  intros A1 R1 y Hxy.\n  split; auto.\n  intros A2 R3 R3 y Hxy.\n  split; auto.\n  intros A R1 R2 y1 y3.\n  split; auto.\n  intros A1 R1 y1 y2 y3.\n  split; auto.\n  intros A1 R3 x y3 y3 y4 Hxy.\n  split; auto.\n  intros A2 R2 R3 y4 y4.\n  split; auto.\n  intros A2 R3 y3 y4 y4.\n  split; auto.\n  intros AQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B1 A2 B2 B2 C3.\n  split; auto.\n  intros a b Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb Hb HbQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 R2 R2 R3 R3 R3 R3 R4 R4 R5 R4 R5 R5 R5 R5 R5 R6 R6 R7 R6 R7 R7 R6 R8 R10 R10 R10 R10 R11 R12 R12 R13 R14 R14 R12 R14.\n  intros A2 R3 R R3 R3 R6 R12 R12 R14 R12 R13 R13 R14 R14 R14 R14 R14 R14.\n  intros A3 R12 R12 R13 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14.\n  intros A1 R12 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R15 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R15 RQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 R1 R2 R2 R2 R2 R3 R3 R3 R3 R3 R4 R4 R4 R4 R4 R5 R5 R5 R6 R6 R6 R7 R6 R6 R6 R6 R6 R7 R7 R7 R7 R7 R7 R9 R6 R7 R8 R10 R7 R6 R7 R7 R7 R7 R8 R8 R10 R10 R10 R10 R10 R10 R10 R11 R12 R12 R12 R14 R13 R14 R12 R13 R12 R14 R12 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 RQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A B1 B2 R1 R2 R2 R1 R2 R2 R3 R3 R3 R3 R4 R5 R5 R5 R5 R5 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R7 R6 R7 R6 R7 R8 R7 R7 R7 R7 R7 R7 R8 R10 R10 R10 R10 R10 R12 R12 R12 R13 R12 R12 R14 R13 R12 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R15 R15 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R15 R15 R14 R14Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B1 B2 B2 C2 D1 D2 D2.\n  apply R1; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 C2 D1 R2.\n  apply (R1 x); auto.\n  apply (R2 x); auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 R2 R2.\n  apply R1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6615,
                "proof_end_offset": 6735,
                "proof": "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A x1 y2 y1 y2 H3.\n  assert (y1 = x2) by (apply proof_irrelevance).\n  assert (x1 = x2) by (apply proof_irrelevance).\n  assert (x1 = x2) by (apply proof_irrelevance).\n  assert (x1 = x2) by (apply proof_irrelevance).\n  assert (x1 = x2) by (apply proof_irrelevance).\n  assert (x1 = x2) by (apply proof_irrelevance).\n  assert (x2 = x1) by (apply proof_irrelevance).\n  assert (x2 = x2) by (apply proof_irrelevance).\n  assert (x2 = x2) by (apply proof_irrelevance).\n  assert (x2 = x2) by (apply proof_irrelevance).\n  assert (x1 = x2) by (apply proof_irrelevance).\n  assert (x2 = x2) by (apply proof_irrelevance).\n  assert (x2 = x1) by (apply proof_irrelevance).\n  assert (x2 = x2) by (apply proof_irrelevance).\n  assert (x1 = x2) by (apply proof_irrelevanceQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 B2 R1 R2 R1 R2 R1 R1 R2 R2 R2 R2 R1 R2 R2 R2 R3 R3 R3 R2 R3 R3 R3 R4 R4 R3 R4 R0 R4 R5 R6 R4 R5 R4 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 RQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 B2 R2 R3 R3 R4 R4 R4 R5 R5 R5 R5 R5 R5 R5 R5 R6 R5 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R7 R8 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R7 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 RQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y2 y1 y2.\n  rewrite (R1, y2) in H2.\n  rewrite (R1, y2) in H2.\n  rewrite (R2, y2) in H2.\n  rewrite (R1, y2) in H2.\n  rewrite (R2, y2) in H3.\n  rewrite (R2, y2) in H3.\n  rewrite (R2, y3) in H3.\n  rewrite (R2, y3) in H3.\n  rewrite (R2, y3) in H4.\n  rewrite (R2, y3) in H4.\n  rewrite (R2, y2) in H3.\n  rewrite (R2, y3) in H3.\n  rewrite (R2, y3) in H4.\n  rewrite (R2, y3) in H4.\n  rewrite (R2, y3) in H3.\n  rewrite (R2, y3) in H4.\n  rewrite (R2, y3) in H4.\n  rewrite (R2, y3) in H4.\n  rewrite (R2,Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y2 y2 H3.\n  apply (R1 x2 x1 y1 y2 H4).\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A x1 y2 y2 y1 y2.\n  firstorder.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y2 R1 R1 R2 R2 R2.\n  split; auto.\n  apply R2 with R2; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B C x1 R1 R2 R1 R2.\n  rewrite <- (R1, R2), <- (R2, R2), <- (R2, R2), <- (R2, R2), <- (R2, R2), <- (R2), <- (R2, R2), <- (R2, R2, R2), <- (R2, R2), <- (R2, R2), <- (R2, R2, R2), <- R2, R2, <- R2, R2, R2, <- R2, <- (R2, R2, R2), <- (R2, R2), <- R2, R2, <- R3, R2, R2, R2, R2, <- R2, <- R2, <- R2, R2, R2, <- R2, R2, <- (R2, R2), <- (R2, R2, R2, R2), <- (R2, R2, R2, R2, R2, R2, R2, R2, <- R3, R2, RQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x y1 y2 y2.\n  case (x1,y2) as [y1 [y2 [y3 [y3 [y4 [y4 [y5 [y5 [y4 [z5 [z6 [z7 [z7 [z7z8 [z7z7 [z7z7 [z7z7z7 z7 z7z8z8 z9 z9 z9 z9 z10 z11 z11 z11 z12 z13 z12 z14 z14 z14 z14 z14 z14 z14 z14 z15 z14 z15 z15 z14 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z16 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z16 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z15 z16 z15 z15 z15 z15 z15 z15 z16 z16 z15 z15 z15 z15 z15 z15 z15Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 y2 R2 R1 R1 R2 R2 R2 R2 R1 R2 R3 R3 R3 R3 R3 R3 R3 R4 R4 R4 R4 R5 R5 R5 R5 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 RQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 6885,
                "proof_end_offset": 7143,
                "proof": "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\nrewrite HR12.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B1 R2 R2 R1 R2 R2 R3 R1 R2 R2 R3 R3 R3 R3 R4 R4 R4 R5 R5 R4 R5 R6 R5 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R7 R7 R6 R6 R6 R6 R7 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B2 C1 D1 C2 D2.\n  induction A1; auto.\n  rewrite <- (R1 ==> R2) in H0.\n  intuition auto.\n  rewrite <- (R2 ==> R2) in H0.\n  intuition.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B2 C1 C2 D2 R2 R1 R2 R2 R2 R3 R3 R3 R4 R3 R4 R4 R5 R5 R5 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R7 R6 R6 R7 R6 R7 R6 R7 R7 R7 R6 R7 R6 R7 R7 R6 R7 R7 R7 R8 R10 R10 R11 R10 R12 R12 R12 R12 R12 R14 R12 R12 R13 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R14 R12 R14 R12 R14.\nProof.\n  intros A1 B2 C3 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R14 R12 R12 R14 R12 R12 R12 R12 R12 R12 R14 R12 R14 R12 R12 R12 R12 R12 R12 R14 R12 R12 R12 R12 R12 RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B2 B2 R1 R2 R2 R3 R3 R3 R3 R4 R4 R4 R4 R5 R5 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R7 R6 R7 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R7 R6 R7 R7 R7 R6 R7 R6 R6 R6 R6 R7 R6 R6 R6 R7 R7 R6 R7 R6 R6 R7 R7 R7 R7 R7 R10 R6 R6 R6 R6 R6 R7 R6 R7 R6 R6 R7 R7 R8 R6 R6 R6 R6 R7 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R7 R7 R6 R6 R6 R7 R6 R6 R8 R6 R7 R7 R10 R9 RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B1 C2 R2 R1 R2 R2 R2 R2 R2 R2 R2 R3 R3 R3 R4 R4 R3 R4 R4 R5 R5 R6 R5 R6 R6 R6 R6 R6 R7 R7 R7 R8 R6 R7 R7 R9 R6 R8 R10 R12 R12 R12 R12 R13 R12 R12 R13 R12 R12 R12 R13 R13 R13 R14.\nProof.\n  intros A1 B2 R3 R3 R4 R1 R2 R3 R4 R4 R5 R5 R6 R7 R12 R12 R12 R12 R13 R14 R12 R14 R12 R14 R14 R14 R14 R14 R14 R14 R14 R13 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B2 R1 R1 R2 R2 R2 R2 R2 R2 R2 R2 R2 R3 R3 R3 R3 R3 R4 R5 R4 R5 R5 R6 R5 R5 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R7 R6 R6 R6 R6 R6 RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A B1 B2 C2 C1 R2 R3.\n  assert (R2==>R1) by (intro; apply R2; apply R1; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R1; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R1; apply R2; apply R2; apply R2; apply R2; apply R1; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2; apply R2;Qed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B2 C1 C2 R1 R2 R2 R2 R3 R3 R3 R3 R4 R4 R4 R5 R5 R4 R5 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R7 R6 R6 R6 R7 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 B2 B2 R2 R1 R2 R2 R1 R2 R2 R2 R3 R3 R4 R3 R3 R4 R5 R4 R4 R5 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R7 R7 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 RQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A B1 B2 R1 R2 R2 R2 R3 R1 R2 R3 R3 R3 R3 R4 R4 R4 R4 R5 R5 R6 R6 R6 R5 R6 R6 R6 R6 R7 R6 R6 R7 R6 R6 R7 R7 R7 R6 R7 R6 R6 R7 R6 R6 R7 R7 R7 R7 R9 R6 R6 R6 R6 R7 R7 R9 R6 R8 R6 R7 R8 R6 R10 R10 R6 R11 R R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 R12 RQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8058,
                "proof_end_offset": 8174,
                "proof": "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\nintros.\nrstep.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  apply (R1 x y z t).\n  apply (R2 x z t).\n  apply (R2 x z t).\n  apply (R2 x z t).\n  apply (R2 x z t).\n  apply R2 x z.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R2R1.\n  apply R2R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R2R1.\n  apply R2R2R1.\n  apply R2R2R1.\n  apply R2R1.\n  apply R2R1R1.\n  apply R2R2R1.\n  apply R2R1.\n  apply R2R1.\n  apply R2R2R1.\n  apply R2R2Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  unfold crelation.\n  intros.\n  rewrite R.\n  apply R.\n  apply R.\n  apply R.\n  apply R.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  destruct x as [x y z] [y z] [z z] [z z] [z z] [z z] [z z] [z z] [z z] [z z] [z z] [z z] z [z] z] [z z] [z z] [z z] z] z [z z] [z z] [z z] z] [z z z] [z z] [z z] [z z] z] [z z] [z z] z [z z] z] [z z] z [z z] z z] [z z] [z z] z] z [z z] [z z] z] z [z z] [z z] [z z z] z] [z z z] [z z] z z z] [z z z] [z z] z [z z] z z] [z z] [z z z] z z [z z] [z z z z z] z z z z] [z z z z z z z] z z [z z] [z z z z z zQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros;\n  split.\n  - intros;\n    split.\n    - intros;\n    - intros;\n    - intros;\n    - intros;\n      - intros;\n      - intros;\n      - intros;\n      - intros;\n      - intros;\n      - intros;\n        - intros;\n        - intros;\n        specialize (H0 (H1 (H0 (H0 (H0 (H0 (H1 (H0 (H0 (H0 (H1 (H0 (H0 (H0 (H0 (H0 (H0 (H1 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H1 (H0 (H0 (H0 (H1 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (H0 (Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  assert (R1==>iff R1) by (inv1;inv1;inv2;inv2;inv2;inv2;inv2;inv3;inv3;inv3;inv3;inv3;inv3;inv3;inv3;inv4;inv4;inv3;inv3;inv5;inv5;inv5;inv5;inv3;inv5;inv5;inv3;inv5;inv5;inv5;inv5;inv5;inv5;inv5;inv5;inv5;inv5;inv6;inv5;inv6;inv6;inv5;inv5;inv5;inv5;inv5;inv6;inv5;inv6;inv6;inv6;inv5;inv6;inv5;inv5;inv5;inv5;inv6;inv6;inv5;inv6;inv6;inv6;inv6;inv5;inv5;inv6;inv5;inv6;inv5;inv5;inv6;inv5;inv6;inv6;inv6;inv6;inv6;inv6;invQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  unfold flip.\n  destruct R as [x y z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [y z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [y z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [y z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [x z].\n  destruct R as [Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros x y z t H.\n  apply R_le_trans with x y z; auto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  apply (R1 x y z t); auto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  assert (Hop : forall x y z : A, R x y -> R y z -> R z t y z -> R z t z -> R z t z t.\nProof.\n  intros.\n  assert (Hop : forall x y z : A, R x y z -> R z z -> R z t z -> R z z z t.\n  induction 1; intros.\n  - auto.\n  - auto.\n  - auto.\n  - auto.\n  - auto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  destruct x; try solve [left; auto].\n  rewrite <- HR12.\n  apply R2R1.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ": rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 8703,
                "proof_end_offset": 8872,
                "proof": "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  destruct (eq_dec _ _ _ _ _ _ H0 H1) as [B B1 C2].\n  rewrite <- (R1_equiv R_equiv R_equiv R_equiv_equiv R_equiv_equiv R_equiv R_equiv_equiv_equiv_equiv R_equiv_equiv_equiv_equiv_equiv.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  destruct (eq_dec x x y y).\n  - apply (prod_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_relQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  exists R0; auto.\n  exists (fun x => R x x /\\ R x /\\ R y x /\\ R y x).\n  intros.\n  apply (prod_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  unfold rel_rel, R in *.\n  destruct R as (R & R & R & R & R).\n  assert (R1' & R').\n  { intros R2' x y' H1' H2' H2' H3'3' H3'4'5'5'5''5'6'7''6''6''6''6'7''7''7''7''7''7''7''6''7''7''7''7''7''7''7''7''9''7''7''7''7''7''7''7''7''7''7''7''7''7''7''9''7''7''7''7''''7''7''7''7''7''7''7''7''7''7''7''''7''7''''7''7''''7''7''''7''7''''7''7''7''''''7''7''7''''7''''''7''7''''''7''''''7''7''''7''''''7''''''7''7''''''''''''7''Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros A B C R S P R' R' x y H H.\n  induction l1 as [x y0 y0 y0 [y0 y1 [y0 y1 y2]]]].\n  exists y0.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.\n  split; auto.Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  pose proof (H0 _ _ _ H0).\n  unfold Basics.compose.compose.\n  pose proof (H0 _ H0 _ H0).\n  unfold Basics.compose.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).\n  unfold Basics.compose.\n  pose proof (H0 _ H0).Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  unfold compose.\n  intros.\n  unfold compose.\n  destruct (f x); auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  assert (forall w, R' x y -> R' y' -> R x y) by (intro; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; apply R; applyQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros A B R' R H.\n  exists x; split; auto.\n  intros.\n  destruct x.\n  destruct x.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H.\n Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  exists (fun x => R x).\n  split.\n  - intros.\n    apply H2.\n    destruct H1.\n    destruct H2.\n    destruct H2.\n    destruct H2.\n    destruct H2.\n    destruct H1.\n    destruct H1.\n    destruct H2.\n    destruct H2.\n    destruct H2.\n    destruct H2.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H4.\n    destruct H4.\n    destruct H3.\n    destruct H4.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H4.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H3.\n    destruct H4.\n    destruct H3.\n    destruct H3.\n    destruct H4.\n    destruct H4.\n    destruct H4.\n    destruct H3Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8967,
                "proof_end_offset": 9084,
                "proof": "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  induction 1; intros.\n  + simpl.\n    simpl.\n    + simpl.\n      * simpl.\n      * simpl.\n      * simpl.\n        * simpl.\n      * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n        * simpl.\n       Qed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply R_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_Qed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite <- R' in H.\n  auto.\n  destruct (eq_dec _ _ _ H) as [x [y' [y' [z' [y' [y' [y' [y' [y' [y' [y' [z' [y' [y' [y' [y' [y' [y' [y' [z' [y' [z' [z' [y' [z' [y' [z' [z' [z' [z' [z' [y' [z'z' [z'z' [z' [z' [z' z' [z'z' z' [z'z' [z' [z'z' [z'z' [z' z' z' [z'z'z' [z'z'z'z' [z' [z' z'z' [z'z'z' z' z' [z' [z' z' [z' z' z' [z'z' [z'z' z' [z' z' z' z'z' z' [zQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply (fun x => x); auto.\n  destruct x; destruct x; destruct y; destruct y; destruct y; destruct y; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct z; destruct zQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  applyQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold R'.\n  simpl.\n  intros.\n  apply (H0 (fun x => R' x) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) y) (f y) (f y) (f y) (f y) (f y) (f y) y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) y)) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f y) (f yQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite <- H1.\n  reflexivity.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  assert (forall a, R a -> R (f a) (R x y) -> (f y) = f y).\n  { intros.\n    assert (forall a, R a x -> R a) (f x) = f x y) by auto.\n    clear H0.\n    intros.\n    assert (forall a, R a x -> R (f x) = f x) by auto.\n    clear H0.\n    intros.\n    assert (forall a, R a x = f a) by auto.\n    clear H0.\n    assert (forall a, R a x = f a) by auto.\n    clear H0.\n    assert (forall a, R a x) by auto.\n    clear H0.\n    assert (forall a, R a x -> R a x) by auto.\n    clear H0.\n    assert (forall a, R a x a = f a) by auto.\n    clear H0.\n    assert (forall a, R a x a = f a) by auto.\n    clear H0.\n    assert (forall a, R a x = a) by auto.\n    clear H0.\n    assert (forall a, R a aQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold R', R', R'.\n  intros.\n  apply R'.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.\n  intros.\n  apply R'.Qed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold R in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n  simpl in H.\n  unfold R in H.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 9180,
                "proof_end_offset": 9343,
                "proof": "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply rel_pull_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  apply rel_allp_2.\n  applyQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y H.\n  apply rel_sumbool_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_sumbool_false; intros.\n  apply rel_sumbool_false; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_sumbool_false; intros.\n  apply rel_sumbool_false; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_sumbool_false; intros.\n  apply rel_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_true; intros.\n  apply rel_sumbool_false; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_true; intros.\n  apply rel_sumbool_true; intros.\n  apply rel_true; intros.\n  apply rel_sumbool_false; intros.\n  apply rel_falseQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y h.\n  induction x; intros.\n  - exists (fun a => a = b); split; auto.\n    - exists (fun a => a = b); split; auto.\n      destruct a; auto.\n    - exists (fun a => a = b)); split; auto.\n      destruct a; auto.\n    - exists (fun a => a = b); split; auto.\n      destruct a; auto.\n      destruct a; auto.\n      destruct a; auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y.\n  apply rel_prod_2 with (x := y) (g := (g x) (g y)).\n  auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  induction (Rell_pull_1 (fun x => x) (f y) (g x) (g y) (g y) (g y)).\n  auto.\n  rewrite <- H.\n  apply rel_pull_2 with (fun x => x) (g y) (g y) (g y)).\n  auto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply rel_exist with (P:=fun a => a) (x :: l2).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_3 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_3 with (P:=fun a => a) (x :: l2)).\n  apply rel_pull_2 with (PQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  exists (fun x => (f x) (g y)).\n  split; auto.\n  intros.\n  exists (f x).\n  exists (f x).\n  exists (f x).\n  split; auto.\n  intros.\n  exists (f x).\n  exists (f x).\n  split; auto.\n  exists (f x).\n  split; auto.\n  apply H.\n  exists (f x).\n  split; auto.\n  intros.\n  exists (f x).\n  exists (f x).\n  split; auto.\n  intros.\n  exists (f x).\n  split; auto.\n  exists (f x).\n  split; auto.\n  exists (f x).\n  split; auto.\n  apply H.\n  exists (f x).\n  split; auto.\n  apply H.\n  exists (f x).\n  split; auto.\n  intros.\n  exists (f x).\n  split; auto.\n  exists (f x).\n  split; auto.\n  intros.\n  exists (f x).\n  split; auto.\n  exists (f x).\n  split; auto.\n  intros.\n  exists (f x).\n  split; auto.\n  exists (f x).\n  exists (Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rewrite <- (rel_pull_1_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp2_imp_imp2_imp2_imp2_imp2_imp_imp2_imp2_imp_imp2_imp2_imp_imp2_imp2_imp2_imp2_imp_imp2_imp_2_imp2_imp2_imp2_imp2_imp2_imp_imp2_imp2_imp2_imp2_imp_imp2_imp2_imp2_imp2_imp2_imp2_imp_imp_imp2_imp2_imp2_imp2_imp_imp2_imp2_imp2_imp_imp2_imp2_imp_imp_2_imp_Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_prod.\n  eapply rel_Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros A B f g x y.\n  induction x; simpl; auto.\n  constructor; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ", opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\nLemma rel_pull_2:\n  forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y,\n    Monotonic g (\u22a4 ==> R @@ f) ->\n    (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_all] *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 9367,
                "proof_end_offset": 9486,
                "proof": "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  unfold rel_prod.\n  intros.\n  apply rel_prod_1.\n  apply rel_prod_2.\n  apply rel_prod_2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod2.\n  apply rel_prod.\n  apply rel_prod.\n  apply relQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_in_rel with (a:=a) (a:=a) (a:=a) (a:=a) (a:=a) (a:=a) (a:=b) (a:=b) (a:=a) (a:=a) (a:=a) (a:=a) (a:=a) (a:=b) (a:=b) (a:=b) (a:=b) (a:=a) (a:=b) (a:=b) (a:=a) (a:=a) (a:=a) (a:=b) (a:=a) (a:=a) (a:=b) (a:=a) (a:=a) (a:=a) (a:=a) (a:=a) (a:=b) (a:=a) (a:=a) (a:=a) (a:=a) (a:=a) (a:=b) (a:=b) (a:=a) (a:=a) (a:=a) (a:=a) (a:=b) (a:=a) (a:=a) (a:=a) (aQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_eq.\n  apply rel_Qed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct x.\n  apply rel_iff_2.\n  eapply rel_impl_2.\n  eapply rel_impl_1.\n  eapply rel_impl_2.\n  eapply rel_impl_2.\n  eapply rel_impl_3.\n  eapply rel_impl_2.\n  eapply rel_impl_2.\n  eapply rel_impl_2.\n  eapply rel_impl_3.\n  eapply rel_impl_3.\n  eapply rel_impl_2.\n  eapply rel_impl_3.\n  eapply rel_impl_2.\n  eapply rel_impl_2.\n  eapply rel_impl_2.\n  eapply rel_impl_3.\n  eapply rel_impl_2.\n  eapply rel_impl_3.\n  eapply rel_impl_2.\n  eapply rel_impl_2.\n  eapply rel_impl_2.\n  eapply rel_impl_3.\n  eapply rel_impl_1.\n  eapply rel_impl_3.\n  eapply rel_impl_3.\n  eapply rel_impl_2.\n  eapply rel_impl_3.\n  eapply rel_impl_3.\n  eapply rel_impl_3.\n  eapply rel_impl_Qed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_prod_2; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_in_all_1; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  unfold rel_eq.\n  destruct x.\n  + simpl.\n    simpl.\n    simpl.\n    auto.\n    simpl.\n    auto.\n    simpl.\n    auto.\n    auto.\n    simpl.\n    auto.\n    simpl.\n    auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  firstorder.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_in_rel with x; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  assert (x = y) by (apply (H x); apply (H x); apply (H x); apply (H x); apply (H x); apply (H x); apply (H x); apply H; apply (H x); apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H; apply H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n",
                "context_tokens": 600,
                "proof_start_offset": 7145,
                "proof_end_offset": 7615,
                "proof": "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 C1 D2 R1 R2 R3 R3 R3 R3 R4 R5 R4 R5 R5 R5 R5 R6 R6 R6 R6 R7 R7 R7 R7 R6 R7 R6 R7 R7 R7 R7 R8 R9 R10 R10 R10 R12 R14 R12 R14 R12 R12 R12 R12 R13 R13 R13 R13 R14 R14.\n  intros A1 B2 R3 R4 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R15 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R14 R15 R14 R14 R14 R14 R14 RQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 C2 R1 R2.\n  rewrite <- HRb2.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 C1 C2 D2 R1' D2' R1 R2' R2' R3 R1' R2' R3' R3 R1' R2' R3' R2' R' R3' R3' R' R1' R3' R' R' R1' R2' R3' R2' R2' R3 R' R3' R' R3' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R R' R' R' R' R' R R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R R' R' R' R' R' R' R' R' R' R' R' R' R R' R' R' R' R' R R' R' R' R' R' R' R' R' R' R' RQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C1 B2 C1 D1 D2 D2 D2 R3 R3 R4 R4 R4 R4 R5 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R7 R6 R6 R6 R6 R6 R6 R7 R7 R6 R7 R6 R6 R7 R7 R6 R6 R7 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 RQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 B1 C2 R1 R2 R1 R1 R2 R2 R2 R2 R3 R3 R3 R4.\n  apply R1_1_2_1_1_2 with R1 R2 R3 R3 R4 R3 R4 R4.\n  apply R1_2_3_2 with R1 R2 R3 R3 R4.\n  apply R2_3_3_1 with R1 R2 R3 R4.\n  apply R1_1_2_2_2 with R3 R3 R4.\n  apply R1_2_2_3 with R1 R2.\n  apply R2_3_2_1_3 with R1 R2 R3.\n  apply R2_2_3_1 with R2 R3 R3 R3 R4.\n  apply R3_2_3_2_3 with R3 R2 R3.\n  apply R1_1_2_2 with R2 R3 R3 R3.\n  apply R2_2_3_2 with R1 R2 R3.\n  apply R1_2_Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 C1 C1 R2 R1 R2 R2 R3.\n  rewrite <- HR1.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 B3 R1 C2 R3 R3 R4 R4 R4.\n  intros B2 C3 R4 R4 R4 R5 R5 R5 R5 R6 R5 R6 R6 R6.\n  apply R6.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C1 B1 C2 C2 D1 R2 R2' R1' R3' y' y' y' H' H'0' H'0.\n  rewrite HR'0.\n  rewrite HR'0.\n  apply HR'0.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 C2 R2 R1 R1 R2 R2 R3 R3 R3 R1 R3 R3 R4 R4 R5 R5 R5 R5 R5 R5 R5 R5 R5 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R7 R7 R6 R6 R6 R6 R6 R7 R6 R7 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R7 R6 R6 R7 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6 R6Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B1 B2 C2 R2 R1 R1' R2' R1' R2' R2' R2' R' R2' R3' R2' R2' R3' R' R3' R' R' R' R' R1' R' R' R' R' R'1' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R R' R' R' R' R' R' R' R' RQed."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n.\n unfold prime.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 0); intros.\n case (Z.compare n 0); intros.\n case (Z.compare n 0); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 0); intros.\n case (Z.compare n 0); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 0); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 1); intros.\n case (Z.compare n 0); intros.\n case (Z.compare n 1); intros.\n case (Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply le_trans with (n:=n) (p:=n) (p:=n) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p:=p) (p:=p) (p:=p) (p:=p:=p) (p:=p) (p:=p) (p:=p) (p:=p:=p) (p:=p) (p:=p:=p) (p:=p) (p:=p) (p:=p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p) (p:=p:=p) (p:=p) (p:=p)Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nunfold not; intros n.\n apply zero_le_div.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros n H; rewrite H; auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n unfold prime, prime; intros.\n apply Z_div_div_div_div.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  intros n H; unfold Zsucc in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in *; rewrite <- H; simpl in *; rewrite <- H; simpl in |- *; rewrite <- H; simpl in |- *; rewrite <- H; simpl inQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n m p H' H'0.\n apply H'0.\n apply H'.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n H.\ngeneralize (H (Z.add_lt n n)).\ngeneralize (Z.add_lt n n).\ninduction n.\nintros n H.\ngeneralize (Z.add_lt n n).\nunfold divides; intros n H.\ngeneralize (Z.add_lt n n).\ninduction n.\nintros n H0.\ngeneralize (Z.add_lt n n).\ninduction n.\nintros n.\nunfold divides; intros n0 H1.\ngeneralize (Z.add_lt n n).\ninduction n.\nintros n0 H0.\nsimpl in |- *.\ngeneralize (Z.add_lt n n).\ninduction n.\nintros n0 H1.\nunfold modulo; intros n0 H1.\ngeneralize (Z.add_lt n n).\ninduction n.\nintros n0 H1.\nsimpl in |- *.\ngeneralize (Z.add_lt n n0).\nelim H1.\nintros n1 H2.\ngeneralize (Z.add_lt n n0).\ninduction n0.\nintros n0 H2.\ngeneralize (Z.add_lt n n0).Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nunfold mod in |- *.\nintros.\nunfold mod in |- *.\nintros.\nunfold mod in |- *.\nunfold mod in |- *.\nintros.\nrewrite H.\nsimpl in |- *.\nintros.\napply H.\nsimpl in |- *.\nintros.\napply H.\nsimpl in |- *.\nintros.\napply H.\nsimpl in |- *.\nauto with *.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n.\n apply pos_min_div_div_div_div.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  simpl.\n  split.\n  auto with arith.\n  apply zero_min_div.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  auto with arith.\n  simpl in arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  auto with arith.\n  apply zero_min_div.\n  auto with arith.\n  auto with arith.\n  apply zero_Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  intro.\n  rewrite <- (mult_comm (a+q)) at 1.\n  elim (mult_comm (a+q)) at 1.\n  rewrite <- (mult_comm (a+q)) at 1.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply multQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  apply neg_max_div.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  apply zero_min_r.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n intros.\n  red.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  red.\n  apply one_max_div.\n  auto with arith.\n  apply Z_le_max_div.\n  auto with arith.\n  apply Z_le_max_div.\n  auto with arith.\n  apply Z_le_max_div.\n  auto with arith.\n  apply Z_le_max_div.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  apply Z_le_max_r.\n  auto with arith.\n  rewrite <- Z_le_max_l.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  apply Z_le_max_l.\n  auto with arith.\n  rewrite <- Z_le_max_l.\n  autoQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_and in |- *.\n  unfold zero_andQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  unfold not in |- *.  intros.\n  apply succ_min_div_div_div_div_div_div_div_div_div_div_div_div.\n  intros.\n  apply zero_min_div_div_div_div_div_div_div_div_div_div.\n  intros.\n  apply zero_odd_div_div_div_div_div_div.\n  intros.\n  apply zero_odd_div_div_div_div.\n  intros.\n  apply zero_odd_div_div_div.\n  intros.\n  apply zero_odd_div_div_div.\n  intros.\n  apply zero_odd_div_div_div_div.\n  intros.\n  apply zero_odd_div_div_div_div.\n  intros.\n  apply zero_odd_div_div.\n  intros.\n  apply zero_odd_div_div_div.\n  intros.\n  apply zero_odd_div_div_div.\n  intros.\n  apply zero_odd_div_div_div.\n  intros.\n  apply zero_odd_div_div.\n  intros.\n  apply zero_odd_Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in H0.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  red in |- *.\n  intros.\n  redQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  auto with arith.\n  apply mod_le_mono.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  exists (n:=nat).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red in |- *.\n  unfold divides in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfoldQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  exists (p~1); auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  unfold modulo.\n  case (sumbool_of_bool (Neqb a).\n  intro.\n  simpl.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  unfold prime; intros.\n  red in |- *.\n  unfold divides; intros.\n  red in |- *.\n  unfold prime; intros.\n  red in |- *.\n  unfold divides; intros.\n  red in |- *.\n  unfold prime; intros.\n  red in |- *.\n  unfold prime; intros.\n  red in |- *.\n  unfold prime; intros.\n  red in |- *.\n  unfold prime; intros.\n  red in |- *.\n  unfold prime; intros.\n  red in |- *.\n  unfold prime; intros.\n  red in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  unfold prime in |-Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  intros.\n  elim H.\n  apply H.\n  elim H.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H0.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H2.\n  intros.\n  elim H2.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H2.\n  intros.\n  elim H2.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  elim H4.\n  intros.\n  elim H3.\n  intros.Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  intros.\n  exists 0.\n  simpl.\n  unfold modulo.\n  apply mod_le_upper_bound; auto with arith.\n  exists 1.\n  exists 0.\n  apply mod_le_upper_bound; auto with arith.\n  apply mod_le_upper_bound; auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists (a:nat)(b:nat)(b:nat)(b:nat)(b:nat)(b:nat)(b:nat)(b:nat)(c:nat)(b:nat)(c:nat)(b:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:nat)(c:natQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  intro.\n  unfold prime in |- *.\n  unfold prime in |- *.\n  apply le_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists 1.\n  auto with arith.\n  unfold modulo.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.\n  apply mod_le.Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply H.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists x.\n  auto with arith.\n  intros.\n  apply H.\n  exists x.\n  auto with arith.\n  apply H.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists (x, y).\n  intuition.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.\n  exists (x, y).\n  auto with arith.Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nintros.\n  red.\n  exists (n+1).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply Z.divide_trans with (b:=b)(a':=b)(b':=b) (b':=b') (b':=b') (b':=c') (b':=c') (b':=c') (b':=b') (c':=c') (b':=c') (b':=c') (c':=c') (b':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c':=c') (c':=c) (c':=c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c') (c':=c':=c') (c':=c') (c':=c') (Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\n  intro.\n  exists 0.\n  auto with arith.\n  elim H.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  intros.\n  simpl.\n  case (is_zero a) as [q|q|q].\n  exists q.\n  apply exists q.\n  exists q.\n  auto.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n  apply mod_le_compat.\n Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  simpl.\n  exists 0.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  red in |- *.\n  intros.\n  elim H;intro q; intro.\n  rewrite H1 in H0.\n  exists (q * q).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  assert (H : 0 < a)%nat.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  apply mod_le.\n  auto with arith.\n  intros.\n  elim H; intro q; elim q; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; intro.\n  elim H; introQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  generalize (divide_trans a b).\n  exists (q * q).\n  apply (divide_trans a b).\n  exists (q * q).\n  intros.\n  apply H1.\n  split; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H; intro q; elim q; intro.\n  elim H0; intro q.\n  exists 0.\n  auto with arith.\n  unfold prime.\n  intros.\n  elim H1; intro q.\n  elim H; intro q.\n  auto with arith.\n  apply H1; intro q.\n  elim H0; intro q.\n  elim H0; intro q.\n  elim H1; intro q.\n  auto with arith.\n  unfold prime.\n  elim H0; intro q.\n  elim H1; intro q.\n  auto with arith.\n  unfold prime.\n  elim H0; intro q.\n  elim H0; intro q.\n  elim H1; intro.\n  elim H1; intro q.\n  elim H1; intro q.\n  elim H0; intro q.\n  auto with arith.\n  elim H1; intro q.\n  elim H1; intro q.\n  auto with arith.\n  intro q.\n  elim H0; intro q.\n  elim H1; intro.\n  elim H0; intro q.\n  elim H2; intro.\n  elim H0; intro q.\n  elim H0; intro.\n  elim H1; intro.\n  elimQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  elim H;intro q; elim H;intro q; elim H; intro q; elim q; intro.\n  elim H; intro q; elim q; intro q; elim q; intros q; elim q; intro q; elim q; intros q; elim q; elim q; intro q; elim q; intros q; elim q; clear q; intros q; elim q;\n intros q q; elim q; clear q; intros q q; elim q; intros q; elim q;\n clear q; intros q; elim q; clear q; intros q q; elim q; intros q; elim q; clear q; intros q; elim q;\n intros q q; elim q; clear q; intros q; elim q; intros q q; elim q; intros q q; elim q;\n clear q; intros q q q q; elim q; intros q; elim q; clear q;\n intros q q; elim q; clear q; intros q q; elim q; intros q; elim q q;\n clear q; intros q; elim q; clear q; intros q q; elim q;\n clear q; intros q q q q; elim q; introsQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  red in H.\n  exists (q' * q).\n  exists (q' * q').\n  auto with arith.\n  intros.\n  elim H0; intro q; elim q';intro.\n  exists q'.\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n  apply neg_le_trans with (q * q').\n  auto with arith.\n Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  apply mod_le.\n  exists (q * q).\n  auto with arith.\n  apply mod_le.\n  exists (q * q).\n  auto with arith.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; elim H; intro q; elim H; intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro q; elim q; intro q.\n  elim H; intro q; elim q; intro.\n  elim H; intro q.\n  elim H; intro q.\n  elim q; intro q.\n  elim H; intro q; elim q; intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro q; elim q; intro q.\n  elim (H q); intro.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim (H q); intro q.\n  elim H; intro q.\n  elim H; intro q.\n  elim H; intro.\n  elim q; intro q.\n  elim H; intro.\n  elim (H q); intro.\n  elim H; intro.\n  elim H; intro.\n  elim q; intro.\n  elim H; intro.Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  intros.\n  unfold divides in |- *.\n  intros.\n  elim H; intro q; elim q;intro; intro.\n  rewrite H1 in H1.\n  apply H2.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  destruct a;simpl in H1.\n  destruct b;simpl in H1; destruct H2.\n  destruct b;simpl in H1; destruct H2; destruct H2.\n  destruct b;simpl in H1; destruct H2; destruct H2; destruct H2; destruct H2; destruct H3; destruct H2; destruct H3; destruct H3; destruct H2; destruct H3; destruct H3; destruct H3; destruct H3; destruct H3; destruct H3; destruct H4; destruct H3; destruct H3; destruct H3; destruct H3; destruct H4; destruct H4; destruct H3; destruct H4; destruct H4; destruct H4; destruct H3; destruct H3; destruct H4; destruct H3; destruct H3; destruct H4; destruct H4; destruct H3; destruct H3; destruct H3; destruct H4; destruct H3; destruct H4; destruct H4; destruct H4; destruct H4; destruct H4; destruct H4; destruct H4; destruct H4; destruct H4; destruct H5; destruct H4; destruct H4; destruct HQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n intros.\n destruct x.\n  rewrite mult_comm.\n  rewrite <- mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assocQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  induction x;simpl;intro;auto with arith.\n  destruct m.\n  rewrite mult_comm.\n  rewrite mult_comm;rewrite mult_assoc;rewrite mult_assoc;rewrite mult_assoc; rewrite mult_assoc;rewrite mult_assoc; rewrite mult_comm; rewrite mult_assoc; rewrite mult_comm; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc;Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros x y z t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t t tQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  rewrite <- mult_assoc;rewrite plus_comm; rewrite plus_comm; rewrite plus_comm;rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_assoc; rewrite plus_comm; rewrite plus_assoc; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_assoc; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  induction x;simpl;auto.\n  replace (S x) with (S x + y + y); [try omega | ring ].\n  replace (S x) with (S x + y); auto with arith.\n  replace (S x) with (S x + y); auto with arith.\n  replace (S x + y) with (S x + y)); auto with arith.\n  replace (S x + y) with (S x + y); auto with arith.\n  replace (S x + y) with (S x + y); auto with arith.\n  replace (S x + y) with (S x + y)); auto with arith.\n  replace (S x + y) with (S x + y); auto with arith.\n  replace (S x + y) with (S x + y + y)); auto with arith.\n  replace (S x + y + y) with (S y + y)); auto with arith.\n  replace (S x + y) with (S x + y); auto with arith.\n  replace (S x + y) with (S x + y); auto with arith.\n  replace (S x + y + y) with (S x +Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n intros.\n rewrite mult_comm;trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  induction x;simpl;intros.\n  apply mult_minus_eq;intros;auto.\n  rewrite mult_comm;rewrite mult_assoc;rewrite mult_assoc;rewrite mult_assoc;rewrite mult_comm;rewrite mult_assoc; rewrite mult_assoc;rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite multQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  induction x;simpl;intros;trivial.\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm; rewrite plus_comm; rewrite plus_comm;rewrite plus_comm; rewrite plus_comm; rewrite plus_comm;rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plusQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\n  intros.\n  rewrite plus_comm;rewrite mult_assoc;rewrite plus_comm;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  apply le_trans with (n*a) (S n*a) (S n)+a=0.\n  apply le_trans with (n*a) (S n)).\n  apply le_trans with (n*a) (S n) (S n)).\n  apply le_trans with (n*a) (S n)).\n  apply le_trans with (n*a) (S n)).\n  apply le_trans with (n*a)); auto with arith.\n  apply le_trans with (n*a) (S n)).\n  apply le_trans with (n*a) (S n)).\n  apply le_trans with (n*a) (S n).\n  apply le_trans with (n*a) (S n)).\n  apply le_trans with (n*a) (S n)).\n  apply le_trans with (n*a) (S n).\n  apply le_trans with (n*a) (S n).\n  apply le_trans with (n*a) (S n).\n  apply le_trans with (n*a) (S n + a)).\n  apply le_trans with (n*Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n intros.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_assoc.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n  rewrite plus_assoc.\n  rewrite plus_comm.\n Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\nrewrite <- mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_assoc;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_assoc;rewrite mult_assoc;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_assoc;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_assoc;rewrite mult_assoc; rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm; rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_assoc; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_assoc; rewrite mult_comm; rewrite mult_comm; rewrite mult_comm; rewrite mult_assoc; rewrite mult_comm; rewrite mult_comm; rewriteQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\n  reflexivity.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  replace (S (n-a) = (S (n-a)) with (S (n-a)) by omega.\n  apply mult_lemma2;intro;auto with arith.\n  rewrite <- minus_n_O;trivial.\n  apply plus_le_compat; auto.\n  rewrite mult_comm; rewrite plus_assoc; rewrite <- minus_n_O;trivial.\n  apply plus_le_compat; auto.\n  rewrite <- minus_n_O;trivial.\n  replace (S (n-a)) with (S (n-a) + (S (n-a)) by omega.\n  rewrite plus_n_O;trivial.\n  rewrite plus_comm; rewrite <- minus_n_O;trivial.\n  rewrite <- minus_n_O;trivial.\n  rewrite mult_n_O;trivial.\n  rewrite <- minus_n_O;trivial.\n  rewrite <- minus_n_O;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_n_O;trivial.\n  rewrite <- minus_n_O;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_plus_comm;trivial.\n  rewrite mult_commQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\nassert (a=a \\/ a=b).\nintros.\nassert (a=b).\nrewrite mult_assoc;rewrite plus_comm;auto.\nassert (a=b).\napply mult_assoc;auto.\nassert (a=b).\nrewrite mult_assoc;auto.\nassert (a=b).\napply mult_assoc;auto.\nassert (a=b).\napply mult_assoc;auto.\nassert (a=b).\napply mult_assoc;auto.\nassert (a=b).\nrewrite mult_comm;auto.\nassert (a=b).\nrewrite mult_assoc;auto.\nassert (a=b).\nrewrite mult_assoc;auto.\nassert (a=b).\nrewrite mult_assoc;auto.\nassert (a=b).\nrewrite mult_comm;auto.\nassert (a=b).\nrewrite mult_comm;auto.\nassert (a=b).\nrewrite mult_assoc;auto.\nassert (a=b).\nrewrite mult_assoc;auto.\nassert (a=b).\nrewrite mult_assoc;auto.\nassert (a=b).\nrewriteQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n intros.\n  ring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\n  rewrite plus_comm.\n  reflexivity.\n  apply mult_lemma_1;intro.\n  omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply mult_lemma2;intro;auto with arith.\n  apply mult_lemma2;intro;auto with arith.\n  apply mult_lemma2;intro;auto with arith.\n  apply mult_lemma2;intro;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma_2;intro;auto with arith.\n  apply mult_lemma2;intro;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma2;intro;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma2;intro;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma_2;auto with arith.\n  apply mult_lemma_3;auto with arith.\n  apply mult_lemma_2;auto with arith.\n  apply mult_lemma_3;auto with arith.\n  apply mult_lemma2;auto with arith.\n  apply mult_lemma_3;auto with arith.\n  apply mult_lemma2;auto with arith.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  rewrite <- (div2_lemma n m);trivial.\n  apply mult_mult_minus.\n  simpl; rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl; rewrite mult_comm.\n  rewrite mult_comm.\n  simpl; rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  rewrite mult_comm.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_comm.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl; rewrite mult_comm.\n  simpl; rewrite mult_comm.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  simpl; rewrite mult_assoc.\n  rewriteQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nintros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  apply minus_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma2; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma2; auto with arith.\n  apply le_lemma2; auto with arith.\n  apply le_lemma1; auto with arith.\n  apply le_lemma1; auto with arith.Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  apply plus_minus2;auto.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n intros.\n  apply le_minus_lemma2;intro.\n  elim (lt_irrefl (S m)) H0); intros H1; elim H1; auto.\n  intros; elim H1; auto.\n  intros; elim H1; auto.\n  intros; elim H2; auto.\n  intros; elim H2; auto.\n  intros; elim H2; auto.\n  intros; elim H1; auto.\n  intros; elim H2; auto.\n  intros; elim H2; auto.\n  intros; elim H1; auto.\n  intros; elim H2; auto.\n  intros; elim H2; auto.\n  intros; elim H3; auto.\n  intros; elim H2; auto.\n  intros; elim H2; auto.\n  intros; elim H3; auto.\n  intros; elim H3; auto.\n  intros; elim H4; auto.\n  intros; elim H4; auto.\n  intros; elim H4; auto.\n  intros; elim H4; auto.\n  intros; elim H4; auto.\n  intros; elim H4; auto.\n  intros; elim H4; auto.\n  intros; elim H4; auto.\n  intros;Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\n  intros.\n  rewrite <- mult_assoc.\n  rewrite <- plus_comm.\n  rewrite <- plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n Qed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nintros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n intros.\n  apply plus_le_reg_l with (x:=y) (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_r with (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_r with (x:=y); auto.\n  apply plus_le_reg_r with (x:=y); auto.\n  apply plus_le_reg_r with (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_r with (x:=y); auto.\n  apply plus_le_reg_l with (x:=y); auto.\n  apply plus_le_reg_l withQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  apply mult_le_reg_l with (n:=n);trivial.\n  rewrite mult_comm;trivial.\n  apply mult_le_compat_l with (n:=n);trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite multQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nintros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n  apply plus_minus_lemma2.\n  rewrite mult_minus_plus_distr_l;trivial.\n  rewrite mult_minus_distr_r;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewriteQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_minus_lemma2.\n  apply plus_plus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n  apply plus_assoc_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_le_reg_l with (n:=n) in H; rewrite plus_comm;simpl;auto with arith.\n  apply plus_minus_lemma2.\n  apply plus_minus_minus_lemma2.\n  apply plus_minus_minus_lemma2.\n  apply plus_plus_lemma2.\n  apply plus_minus_lemma2.\n  apply plus_le_reg_l with (n:=n)(n:=n)(n)).\n  rewrite plus_minus_distr_l;rewrite plus_minus_distr_l;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_assoc;rewrite plus_assoc;rewrite plus_comm;rewrite plus_assoc;rewrite plus_comm;rewrite plus_comm;rewrite plus_plus_assoc;rewrite plus_assoc;rewrite plus_assoc;rewrite plus_assoc;rewrite plus_comm;rewrite plus_comm; rewrite plus_assoc;rewrite plus_assoc; rewrite plus_comm; rewrite plus_assoc; rewrite plus_comm; rewrite plus_assoc; rewrite plus_assoc; rewrite plus_assoc;Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_eq;auto with arith.\n  apply plus_minus_plus_distr.\n  apply plus_minus_distr_l.\n  apply plus_minus_minus_distr_l.\n  apply plus_minus_minus_distr_l.\n  apply plus_minus_minus_distr_r.\n  apply plus_minus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_l.\n  apply plus_minus_distr_l.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_l.\n  apply plus_minus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_l.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_r.\n  apply plus_minus_distr_l.\n Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\n  intros.\n  rewrite mult_comm.\n  apply mult_minus_mult_strong_lemma1.\n  simpl.\n  rewrite mult_plus_comm.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_assoc;simpl.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewrite mult_assoc.\n  simpl.\n  rewriteQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n  rewrite <- plus_minus_assoc;trivial.\n  rewrite <- plus_assoc;trivial.\n  rewrite plus_comm;trivial.\n  rewrite plus_minus_distr_r;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite mult_plus_assoc;trivial.\n  rewrite plus_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_assoc;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivial.\n  rewrite mult_comm;trivialQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n  rewrite plus_minus_plus_distr.\n  apply plus_minus_lemma2;auto with arith.\n  assert (x<>y).\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_assoc.\n  rewrite (plus_comm (b-a)).\n  rewrite mult_assoc;simpl;rewrite mult_plus_distr_l;rewrite mult_comm;rewrite mult_assoc;rewrite mult_assoc;rewrite plus_assoc;rewrite mult_comm;rewrite mult_comm;rewrite plus_assoc;rewrite mult_assoc;rewrite mult_assoc;rewrite mult_assoc;rewrite mult_assoc; rewrite mult_assoc;rewrite mult_assoc;rewrite mult_assoc; rewrite mult_assoc;rewrite mult_assoc; rewrite mult_assoc; rewrite mult_comm; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assoc; rewrite mult_assocQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n  rewrite <- (le_plus_mult z y z);try (apply plus_minus_lemma2 y z);intro.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minus_lemma2;auto with arith.\n  apply plus_minusQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite <- minus_plus_minus;rewrite <- minus_plus;rewrite <- plus_minus;simpl;rewrite <- minus_plus;auto with arith.\n  rewrite minus_plus_minus;rewrite mult_plus_minus;rewrite <- minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x y);try (auto with arith).\n  rewrite plus_plus_minus;auto with arith.\n  rewrite plus_minus_minus;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_minus_distr;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n intros.\n  rewrite (le_plus_minus_lemma2 y z);try (auto with arith).\n  rewrite minus_plus_minus.\n  rewrite mult_assoc;rewrite mult_assoc;rewrite plus_comm;rewrite plus_plus_distr_r;rewrite plus_plus_distr_r;rewrite plus_comm;rewrite plus_minus_distr_r;rewrite plus_comm;rewrite plus_minus_minus_distr_r;rewrite plus_minus_distr_r;rewrite plus_minus_distr_r;rewrite plus_comm;rewrite plus_minus_distr_r;rewrite plus_minus_distr_r;rewrite plus_minus_distr_r;rewrite plus_minus; rewrite plus_comm; rewrite plus_minus_distr_l;rewrite plus_minus_distr_r;rewrite plus_minus_distr_r;rewrite plus_minus_distr_r;rewrite plus_minus_distr_r; rewrite plus_minus_distr_r; rewrite plus_plus_distr_r; rewrite plus_plus_distr_r; rewrite plus_minus_distr_r; rewrite plus_minus; rewrite plus_minus_distr_r; rewrite plus_minus; rewriteQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite <- (le_plus_minus x y);try (auto with arith).\n  rewrite <- minus_minus;simpl;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_comm x y);try (auto with arith).\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_r;auto with arith.\n  rewrite plus_minus_distr_l;auto with arith.\n  rewrite plus_minus_distr_l;auto withQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply plus_minus_eq;auto with arith.\n  apply mult_minus_le_minus.\n  apply minus_le_minus.\n  apply mult_minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_minus_minus.\n  apply plus_le_minus.\n  apply minus_minus_minus.\n  apply plus_minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_minus_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_plus_minus.\n  apply minus_minus_minus.\n  apply minus_le.\n  apply minus_le.\n  apply minus_minus_minus.\n  apply minus_le_minus.\n  apply minus_le.\n  apply minus_minus_minus.\n  apply minus_minusQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n intros.\n  rewrite (le_plus_minus x y);try (auto with arith).\n  rewrite plus_plus_minus;trivial.\n  rewrite plus_plus_distr_l;rewrite plus_minus_distr_l;trivial.\n  rewrite <- plus_comm;rewrite plus_assoc;rewrite plus_minus_distr_r;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply minus_le_n_le.\n  apply minus_le_minus.\n  apply minus_le_n_le.\n  apply minus_le_O.\n  apply minus_le_n_O.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le_n_O.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_le.\n  apply minus_leQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_eq y z);try (auto with arith).\n  rewrite mult_minus_minus_distr;trivial.\n  rewrite <- minus_plus_plus_distr;trivial.\n  rewrite (le_minus_plus_distr_r (S n) (S n)).\n  rewrite plus_plus_distr_r;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plus_minus_distr_l;trivial.\n  rewrite plus_assoc;trivial.\n  rewrite plusQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite minus_plus;rewrite <- minus_plus;rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus_minus;trivial.\n  rewrite <- minus_minus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_minus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_minus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_minus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plus;trivial.\n  rewrite <- minus_plusQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x y);try (auto with arith).\n  rewrite minus_plus_minus;rewrite plus_plus_minus;rewrite plus_minus_minus;rewrite plus_assoc;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite <- (le_plus_minus z x);trivial.\n  rewrite (plus_minus z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (plus_comm z);trivial.\n  rewrite mult_plus_distr_l;trivial.\n  rewrite <- minus_plus_distr_l;trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (mult_comm z);trivial.\n  rewrite (multQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_plus z x);trivial.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite (le_minus_minus z);trivial.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_minus_minus z x);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite (le_minus_minus z x);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus_minus z x);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus_minus z x);trivial.\n  rewrite (le_minus_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite (le_minus_minus z);trivial.Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y z);trivial.\n  rewrite plus_minus_assoc;rewrite <- mult_plus_minus_distr;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_plus_plus z x);trivial.\n  rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite <- plus_minus_distr_r;trivial.\n  rewrite plus_assoc;rewrite plus_minus_distr_l;trivial.\n  rewrite plus_minus_distr_r;trivial.\n  rewrite plus_minus_distr_r;trivial.\n  rewrite plus_minus_distr_l;trivial.\n  rewrite plus_minus_distr_r;trivial.\n  rewrite plus_minus_distr_r;trivial.\n  rewrite plus_minus_distr_r;trivial.\n  rewrite plus_plus_distr_r;trivial.\n  rewrite plus_minus_distr_l;trivial.\n  rewrite plus_comm;trivial.\n  rewrite plus_minus_distr_l;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_comm;trivial.\n  rewrite plus_plus_distr_r;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_minus_distr_l;trivial.\n  rewrite plus_plus_distr_r;trivialQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite plus_comm;rewrite plus_minus;auto with arith.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n intros.\n  apply minus_mult_minus_lemma2.\n  intros.\n  apply minus_le_plus.\n  rewrite mult_plus_comm;rewrite plus_comm;rewrite plus_minus_comm;auto with arith.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_plus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_plus_lemma2;Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite minus_plus;rewrite plus_minus;trivial.\n  rewrite plus_comm;rewrite <- minus_plus_minus;trivial.\n  rewrite plus_minus;rewrite <- plus_minus_assoc;rewrite mult_minus;trivial.\n  rewrite plus_plus_minus;trivial.\n  rewrite plus_minus;trivial.\n  rewrite <- mult_minus;trivial.\n  rewrite plus_plus_distr_r;trivial.\n  rewrite mult_plus_minus;trivial.\n  rewrite plus_minus;trivial.\n  rewrite <- plus_minus;trivial.\n  rewrite mult_plus_distr_r;trivial.\n  rewrite plus_minus;trivial.\n  rewrite mult_plus_distr_r;trivial.\n  rewrite plus_plus_comm;trivial.\n  rewrite mult_minus_distr_l;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite plus_comm;trivial.\n  rewrite plus_minus;trivial.\n  rewrite plus_minus_minus;trivial.\n  rewrite mult_plus_distr_reverse;trivial.\n  rewrite plus_plus_distr_l;trivial.\n  rewrite mult_plus_distr_Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply minus_minus_lemma2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nrewrite (le_plus_comm a);trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec y z);intro.\n  simpl;rewrite (le_plus_minus z x);auto.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;trivial.\n  intros.\n  case y;simpl;trivial.\n  intros.\n  case y;simpl;trivialQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite (le_plus_plus_1 (fun a:nat => a=b)).\n  intros.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_plus_comm z);trivial.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_plus_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewrite (le_minus z);trivial.\n  rewriteQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite (le_plus_minus_distr x y);trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  intros.\n  rewrite (le_plus_minus_distr x y);trivial.\n  rewrite plus_comm;trivial.\n  rewrite minus_plus_assoc;trivial.\n  apply minus_plus_n_lemma.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  replace (a+(b-b)) with (a*(a-b)).\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_assoc; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_assoc; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_assoc; rewrite plus_assoc; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_comm; rewrite plus_assoc;Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply plus_plus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_plus_lemma2.\n  apply plus_le_minus_lemma2.\n  apply mult_plus_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_minus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_lemma2.\n  apply mult_plus_Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n intros.\n  apply minus_gt_0_lemma2.\n  apply minus_gt_eq_0.\n  apply minus_le_le_compat; assumption.\n  apply minus_le_compat; assumption.\n  apply minus_le_n_minus_lemma2.\n  apply minus_gt_0_lemma.\n  apply minus_gt_0_lemma.\n  apply minus_gt_1.\n  apply minus_le_n_minus_lemma.\n  apply minus_le_n_plus_lemma.\n  apply minus_gt_gt_0.\n  apply minus_le_n_n_plus_lemma.\n  apply minus_gt_0_n_lemma.\n  apply minus_gt_n_minus_lemma.\n  apply minus_le_minus_n_lemma.\n  apply minus_gt_n_n_plus_lemma.\n  apply minus_gt_n_plus_lemma.\n  apply minus_le_n_gt_0.\n  apply minus_le_n_plus_lemma.\n  apply minus_gt_n_plus_lemma.\n  apply minus_gt_n_plus_lemma.\n  apply minus_gt_n_minus_lemmaQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply minus_n_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_plus_lemma2.\n  apply minus_n_lemma2.\n  apply minus_le_le_lt.\n  apply minus_le_minus.\n  apply minus_n_le.\n  apply minus_le_plus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_minus_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le.\n  apply minus_le_plus_minus.\n  apply minus_le.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le_minus.\n  apply minus_le.\n  apply minus_le_minus.\n  apply minus_le.\n  apply minus_le_Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nintros.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_plus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n  apply minus_minus_lemma2;trivial.\n Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  rewrite <- minus_plus;rewrite <- minus_plus;rewrite <- minus_plus;rewrite <- minus_plus;trivial.\n  rewrite minus_plus;rewrite <- minus_plus;trivial.\n  rewrite plus_plus;rewrite <- minus_plus;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n destruct n.\n simpl in |- *.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m p H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m H.\nunfold mult_lemma in |- *.\nintros n m.\nunfold mult_lemma in |- *.\nintros nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m H.\n apply mult_lemma1.\n apply mult_lemma2.\n apply mult_lemma2.\n apply mult_lemma2.\n apply mult_lemma_2.\n apply mult_lemma_2.\n apply mult_lemma2.\n apply mult_lemma_2.\n apply mult_lemma_lemma2.\n apply mult_lemma2_1.\n apply mult_lemma_lemma2.\n apply mult_lemma_lemma_1.\n apply mult_lemma_lemma_2.\n apply mult_lemma_2_1.\n apply mult_lemma_lemma_2.\n apply mult_lemma_lemma_2.\n apply mult_lemma_lemma_2.\n apply mult_lemma_2_lemma_2.\n apply mult_lemma_2_lemma_2.\n apply mult_lemma_lemma_2.\n apply mult_lemma_lemma_1.\n apply mult_lemma_2_lemma_lemma_2.\n apply mult_lemma_lemma_2.\n apply mult_lemma_2_lemma_1.\n apply mult_lemma_lemma_2.\n apply mult_lemma_lemma_2.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m n m H0 H1 H2.\n apply plus_lemma_1.\n apply plus_lemma_1.\n apply plus_lemma_reg_l with (n:=n) (n:=m).\n apply plus_lemma_reg_l with (n:=n) (n:=n).\n apply plus_lemma_reg_l with (n:=n) (n:=n).\n apply plus_lemma_reg_l with (n:=n) (n:=n)).\n apply plus_lemma_reg_l with (n:=n) (n:=n).\n apply plus_lemma_reg_l with (n:=n) (n:=n)).\n apply plus_lemma_reg_l with (n:=n).\n apply plus_lemma_reg_l with (n:=n) (n:=n).\n apply plus_lemma_reg_l with (n:=n) (n:=n).\n apply plus_lemma_reg_l with (n:=n).\n apply plus_lemma_reg_l with (n:=n) (n:=n) (n:=n).\n apply plus_lemma_reg_lQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  intros n m Hn Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm HmQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m H.\n apply mult_lemma_1.\n apply mult_lemma_1.\n apply mult_lemma_1.\n apply mult_lemma_2.\n apply mult_lemma_1.\n apply mult_lemma_1.\n apply mult_lemma_1.\n apply mult_lemma_lemma_1.\n apply mult_lemma_2.\n apply mult_lemma_lemma_1.\n apply mult_lemma_1_lemma_1.\n apply mult_lemma_lemma_1.\n apply mult_lemma_1_lemma_2.\n apply mult_lemma_lemma_1.\n apply mult_lemma_lemma_1_lemma_1.\n apply mult_lemma_1_lemma_1.\n apply mult_lemma_lemma_1.\n apply mult_lemma_lemma_1.\n apply mult_lemma_lemma_1_lemma_2.\n apply mult_lemma_2_lemma_1.\n apply mult_lemma_1_lemma_lemma_lemma_1.\n apply mult_lemma_lemma_1.\n apply mult_lemma_1_lemma_lemma_1.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m H H1.\ncase (lt_eq_dec n m); intro H1.\ncase (lt_eq_dec n m); intro H1.\ncase (lt_eq_dec m n m); intro H1.\ncase (lt_eq_dec m n m); intro H1.\ncase (lt_eq_dec m n m); intro H2.\ncase (lt_eq_dec m n m); intro H2.\ncase (lt_eq_dec m n m); intro H3.\ncase (lt_eq_dec m n m); intro H3.\ncase (lt_eq_dec m n m); intro H3.\ncase (lt_eq_dec m n m); intro H3.\ncase (lt_eq_dec m n m); intro H3.\ncase (lt_eq_dec m n m); intro H3.\ncase (lt_dec m n); intro H3.\ncase (lt_dec m n m); intro H4.\ncase (lt_dec m n m); intro H5.\ncase (lt_dec m n); intro H5.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm Hm HmQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m H.\n induction n.\n simpl in |- *.\n trivial.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nunfold mult_1 in |- *.\napply mult_gt_0.\napply mult_le_reg_l with (n := m) (n := m) (n := m) (n := m) (n := n) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := n) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := m) (n := mQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  apply mult_lemma2_1.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_2_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_2_1_l.\n  apply mult_lemma_1_l.\n  apply mult_lemma_1_l.Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nintros.\n  rewrite mult_assoc.\n  induction m;simpl;auto with arith.\n  elim H0;trivial;trivial; auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros.\n  rewrite mult_assoc.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H1;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n intros.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  induction m;simpl;auto with arith.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H2;trivial.\n  elim H0;trivial.\n  elim H2;trivial.\n  elim H0;trivial.\n  elim H0;trivial.\n  elim H2;trivial.\n  elim H3;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H3;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H1;trivial.\n  elim H2;trivial.\n  elim H1;trivial.\n  elim H0;trivial.\n  elim H2;trivial.\n  elim H3;trivial.\n  elim H1;trivial.\n  elim H1;trivialQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1_lemma.\n  apply mult_lemma_1_lemma.\n  apply mult_lemma_lemma_2.\n  apply mult_lemma_lemma_2.\n  apply mult_lemma_lemma_1_lemma_lemma_3.\n  apply mult_lemma_lemma_2_lemma_1_lemma_lemma_lemma_2.\n  apply mult_lemma_lemma_1_lemma_lemma_2.\n  apply mult_lemma_lemma_1_lemma_lemma_lemma_lemma_1.\n  apply mult_lemma_lemma_lemma_1_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma_lemma__lemma_lemmaQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  destruct n.\n  tauto.\n  apply mult_lemma2.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  unfold mult_plus_distr_r.\n  induction m.\n  auto with arith.\n  intros.\n  rewrite mult_assoc.\n  apply mult_left_lemma.\n  intros.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in |- *.\n  elim (eq_dec m n).\n  intros.\n  unfold mult in |- *.\n  elim (eq_dec m n).\n  tauto.\n  intros.\n  apply mult_le_compat; auto with arith.\n  simpl in |- *.\n  elim (eq_dec m n).\n  tauto.\n  simpl in |- *.\n  elim H0.\n  intros.\n  apply mult_le_compat; auto with arith.\n  simpl in |- *.\n  elim (eq_dec m n).\n  tauto.\n  simpl in |- *.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H1.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  elim H4.\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  elim H4.\n  intros.\n  elim H3Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_assoc.\n  assert (m <= S m)%nat by omega.\n  apply mult_lemma_3.\n  assert (m <= S m)%nat by omega.\n  assert (m <= S m)%nat by omega.\n  assert (m < S m)%nat by omega.\n  assert (m <= S m)%nat by omega.\n  rewrite mult_comm.\n  assert (m <= S m)%nat by omega.\n  assert (m <= S m)%nat by omega.\n  assert (m <= S m)%nat by omega.\n  rewrite mult_assoc.\n  assert (m <= S m)%nat by omega.\n  rewrite mult_comm.\n  assert (m <= S m)%nat by omega.\n  rewrite plus_comm.\n  assert (m <= S m)%nat by omega.\n  omega.\n  assert (m <= S m)%nat by omega.\n  omega.\n  assert (m <= S m)%nat by omega.\n  omega.\n  assert (m <= S m)%nat by omega.\n  omega.\n  assert (m <= S m)%nat by omega.\n  omega.\n  assert (m <= S m)%nat by omega.\n  omega.\n  assert (m <=Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_assoc.\n  apply mult_right.\n  apply mult_comm.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply mult_le_compat.\n  apply multQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  induction n.\n  tauto.\n  simpl in |- *.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  rewrite mult_comm.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_comm.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_comm.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n  repeat rewrite mult_assoc.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_assoc.\n  induction m;simpl;auto with arith.\n  apply mult_lemma_2.\n  trivial.\n  intros.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  case (leb m n); auto with arith.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  elim H0;trivial.\n  intros.\n  simpl in H1.\n  elim H1;trivial.\n  intros.\n  simpl in H2.\n  elim H1;trivial.\n  intros.\n  simpl in H2.\n  elim H0;trivial.\n  intros.\n  simpl in H2.\n  elim H2;trivial.\n  intros.\n  simpl in H2.\n  elim H1;trivial.\n  intros.\n  simpl in H2.\n  elim H2Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  simpl in |- *.\n  rewrite <- plus_assoc.\n  auto.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  apply mult_gt_compat.\n  applyQed."
                ]
            }
        ]
    }
}