{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 4,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "d6ca15d94f30cb6c9419c7b69673b5d38d203572"
    },

    "projects": {
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H H0; elim H0; intros H1 H2; elim H2; intros H3 H4; elim H4;\n intros H5 H6; elim H6; intros H6 H7; elim H7;\n intros H8 H9; rewrite H9; apply H11.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H; elim H; auto with sets.\nintros x0 H'0; elim H'0; auto with sets.\nintros x1 H'1; elim H'1; auto with sets.\nintros x2 H'2; elim H'2; auto with sets.\nintros x3 H'3; elim H'3; auto with sets.\nintros x4 H'4; elim H'4; auto with sets.\nintros x5 H'6; elim H'6; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros x y z H0; elim H0; intros H1 H2;\n    elim (H2 _ H3); intros H4 H5; elim H5; intros H6 H7;\n      elim H7; intros H8 H9; elim H8; intros H10 H11;\n        elim (H10 _ H11); intros H11 H12; elim H12; intros H12 H13;\n          elim H12; intros H14 H15; rewrite H15; apply H16;\n          elim (H14 _ H15); intros H15 H16; rewrite H15; apply H16;\n            apply H17; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros H H' H'0; elim H'0; intros H'1 H'2.\nelim H'1; intros H'3 H'4.\nelim H'5; intros H'6 H'7.\nrewrite H'7.\nrewrite H'7.\nrewrite (H'3 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'5 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'5 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'5 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'4 y).\nrewrite (H'5 y).\nrewrite (H'4 y).\nrewriteQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  apply (is_group (fun y z : S => in_part (E:=E) (inv_part_prop x y) H)).\n  apply (is_group (fun y z : S => in_part (E:=E) (inv_part_prop y) H)).\n  apply H.\n  intros.\n  cut (exists z : S, in_part (E:=E) (inv_part_prop x y) H).\n  intro.\n  elim H2.\n  intros.\n  exists x.\n  rewrite <- (inv_part_prop x).\n  apply in_part_comp with (E:=E) (inv_part_prop x y) H1).\n  apply in_part_comp with (E:=E) (inv_part_prop y) H1.\n  apply in_part_comp with (E:=E) (inv_part_prop x y) H2.\n  assumption.\n  assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H; elim H; clear H; intros H1 H2.\nelim H2; clear H2; intros H3 H4.\nelim H3; clear H3; intros H5 H6.\nelim (H6 x); clear H3; intros H6 H7.\nelim H6; clear H6; intros H7 H8.\nelim (H7 x); clear H6; intros H7 H8.\nexists x0; split; [ auto with sets | apply (H9 x0 H11) ].\nrewrite (G0 x0); auto with sets.\nrewrite <- H6; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros y z H'; try assumption.\napply (Build_Map (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Ap:=fun x : S => x = S) (Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H H0; elim H0; clear H0; intros y z H1 H2.\nelim (H0 y z H2); clear H H0; intros y z H2.\nrewrite (H2 y z H1 z H2); auto with *.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H0 H1 H2; try assumption.\nelim H1; intros H3 H4; elim H4; intros H5 H6; elim H6; intros H7 H8;\n elim H7; intros H8 H10; elim H11; intros H12 H13; elim H13;\n intros H14 H14; elim H14; intros H15 H16; elim H15;\n intros H16 H17; elim H16; intros H17 H17; elim H17;\n intros H17 H18; elim H17; intros H17 H18; elim H18;\n intros H17 H20; elim H20; intros H17 H18; elim H19;\n intros H20 H21; elim H20; intros H21 H20; elim H21;\n intros H20 H22; elim H21; intros H22 H22; elim H22;\n intros H24 H25; elim H25; intros H25 H25;\n elim H24; intros H26 H26; elim H26; intros H27 H28; elim H27;\n intros H29 H29 H30 H30 H29 H29 H29 HQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros x y z H H0; elim H0; intros y0 H1; elim H1; intros z1 H2; elim H2;\n intros z2 H3; elim H3; intros z3 H4; elim H4;\n intros z4 H5; elim H5; intros z5 H6; elim H6; \n intros z7 H8; elim H8; intros z8 H9; elim H9;\n intros z8 H9; elim H9; intros z11 H12; elim H12; \n intros z11 H12; elim H12; intros z12 H13; elim H14; \n intros z15 H16; elim H16; intros z15 H16; elim H16; \n intros z15 H16; elim H16; intros z15 H17; elim H16; \n intros z15 H17; elim H17; intros z15 H16; elim H17; \n intros z15 H17; elim H17; intros z15 H16; elim H17; \n intros z15 H17; elim H17; intros z15 H17; elim H17; \n intros z15 H16; elim H17Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros. \nclear H4 H5 H6 H7 H8.\n(* use of the opposite *)\nelim (H5 (Add x y1) y2); elim (H6 (Add x y2) y2); intros;\n elim H6; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nelim H0; simpl in |- *; auto.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (add_add (Add x1 y1) x2 y1); elim (add_add x1 y1 y2);\n intros; elim H4; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H6; \n intros; elim H6; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; \n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H10; intros; elim H11;\n intros; elim H12; intros; elim H13; intros; elim H14;\n intros; elim H14; intros; elim H15; intros; elim H15;\n intros; elim H15; intros; elim H15; intros; elim H15;\n intros; elim H15; intros; elim H15; intros; elim H15;\n intros; elim H15; intros; elim H15; intros; elim H15;\n intros; elim H15; intros; elim H15; intros; elim H15;\n intros; elim H15; intros; elim H15; intros; elim H15;\n intros; elim H15;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nrewrite (add_comm x1 y1 x2 y2).\nrewrite (add_comm x1 y1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm x1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm y1 y2).\nrewrite (add_comm y1 y2).\nrewriteQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H7; \n intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n clear H5 H8 H9 H10.\n(* use of the opposite *)\nelim (H8 y1 H0); intros; elim H8; intros; elim H9; intros; elim H8; \n intros; elim H8; intros; elim H9; intros; elim H9; \n intros; elim H11; intros; elim H12; intros; elim H11; \n intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x1 y1); elim (H0 y2); reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\napply add_comm.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_comm.\napply add_assoc.\napply add_assoc.\napply add_comm.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_comm.\napply add_comm.\napply add_assoc.\napply add_assoc.\napply add_comm.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_comm.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_comm.\napply add_assoc.\napply add_comm.\napply add_comm.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_assoc.\napply add_Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros. \nclear H0 H1 H2 H3 H4 H5 H6.\n(* use of multiplication *)\nelim (H0 (Add x1 y1) y1); intros; elim H0; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H2; intros; elim H3; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1;\n clear H0; intros; elim H1; intros; elim H1; intros; elim H2;\n clear H1; intros; elim H2; intros; elim H2; intros; elim H3;\n clear H2; intros; elim H3; intros; elim H3; intros; elim H4;\n clear H3; intros; elim H4; intros; elim H4; \n clear H4; intros; elim H4; intros; elim H4; \n clear H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5; intros; elim H5; intros; elim H5; intros; elim H6; \n clear H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros.\nclear H4 H5 H5 H6.\n(* use of multiplication *)\nelim (H0 x0 y); intros; elim H5; intros; elim H5; intros; elim H6; intros.\nclear H5 H6.\n(* use of multiplication *)\nelim (H0 y1 y2); intros; elim H5; intros; elim H6; intros; elim H6; intros.\nclear H5 H6.\n(* use of multiplication *)\nelim (H0 y1 y2); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (is_transitive S D); intros; elim H1; intros; elim H2; intros.\nclear H3 H4 H5 H6.\nelim (H7 (Add x1 y1) y0); elim (H7 y1 y2); elim (H7 y1 y2);\n intros; elim H7; intros; elim H8; intros.\nclear H3 H4 H5 H6.\nelim (H7 y2 H4); intros; elim H8; intros.\nclear H4 H5 H6.\nelim (H8 y2 H5); intros; elim H8; intros.\nclear H5 H6.\nelim (H8 y2 H6); intros; elim H8; intros.\nclear H5 H6.\nelim (H8 y2 H6); intros; elim H8; intros.\nclear H5 H6.\nelim (H8 y2 H5); intros; elim H8; intros.\nclear H5 H6.\nelim (H8 y2 H6); intros; elim H8; intros.\nclear H5 H6.\nelim (H8Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros commult; elim (inv_inv_inv_inv_inv_inv_inv x y); auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros. \nclear H0; intros. \nclear H0; intros. \nclear H0; intros.\nclear H0; intros.\nclear H1; intros.\nclear H0; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H; intros.\nclear H1; intros.\nclear H0; intros.\nclear H0; intros.\nclear H1; intros.\nclear H0; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H0; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1; intros.\nclear H1;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros. \nrewrite (Add_opp x y); rewrite (Add_opp x y); rewrite (Add_opp x y); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x); elim (H0 x); intros; elim H0; intros; elim H1;\n clear H0; intros; elim H1; intros; elim H2; intros; elim H2;\n clear H1; intros; elim H2; intros; elim H3;\n clear H2; intros; elim H4; intros; elim H4; intros; elim H5; \n clear H4; intros; elim H5; intros; elim H5; intros; elim H6;\n clear H5; intros; elim H5; intros; elim H5; \n clear H5; intros; elim H5; intros; elim H6; intros; elim H6; \n clear H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n clear H6; intros; elim H6; intros; elim H6; \n clear H6; intros; elim H6; intros; elim H6; intros; elim H6; \n clear H6; intros; elim H6; intros; elim H6; \n clear H6; intros;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1;\n clear H0; intros.\nclear H1.\nrewrite (H0 x2 y2 y1); rewrite (ass x1 y2 y2 y2); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x y); elim (H0 x y); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x H.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite (Ropp_involutive x).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive x).\nrewrite (Ropp_involutive y).\nrewrite <- (Ropp_involutive y).\nrewrite (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive x).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive y).\nrewrite (Ropp_involutive x).\nrewrite (Ropp_involutive yQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x; elim x; intros; elim x; intros; elim x; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply opp_zero.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H0; intros.\nrewrite H0.\nrewrite H1; rewrite <- H1; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H0; intros; elim H1; intros.\nunfold Add in |- *; auto with arith.\nintros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; intros;\n elim H8; intros; elim H8; intros; elim H6;\n intros; elim H8; intros; elim H9; intros; elim H10;\n intros; elim H12; intros; elim H13; intros; elim H12;\n intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; elim H13;\n intros; elim H12; intros; elim H13; intros; elim H12;\n intros; elim H13; intros; elim H13; intros; elim H13; \n intros; elim H13Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nunfold is_symmetric; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros.\nclear H H5 H6 H7 H8 H9 H10 H11.\n(* f(x) = 0 *)\nelim H10; intros; elim H12; intros; elim H12; intros; elim H13;\n intros; elim H13; intros; elim H14; intros; elim H15; \n intros; elim H15; intros; elim H15; intros; elim H15; \n intros; elim H15; intros; elim H15; intros; elim H15; \n intros; elim H15; intros; elim H15; intros; elim H15; intros; elim H15; \n intros; elim H15; intros; elim H16; intros; elim H15; intros; \n elim H16;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold is_power in |- *.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; intros.\nclear H4 H5 H6.\n(* x=0 *)\nelim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H7; \n intros; elim H8; intros; elim H8; intros; elim H7; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H8; intros; elim HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x; rewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutive x).\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite Ropp_involutive.\nrewrite <- (Ropp_involutiveQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H5; intros; elim H5; intros; elim H6; intros.\nclear H5 H6 H7 H8.\n(* [x+x] *)\nelim (H10 x H1); intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply opp_involutive; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": ". \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) (Opp y y) H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite (opp_unicity H (Opp x y) H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity H (Opp x y) y H).\nrewrite <- (opp_unicity HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) x H).\nunfold is_midpoint in |- *; split.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H7; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H10; \n intros; elim H11; intros; elim H10; intros; elim H10; \n intros; elim H12; intros; elim H11; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H13; intros; \n elim H12;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (inv x) y).\nunfold is_symmetric in |- *; split.\nelim H0; intros; elim H2; intros; elim H4; intros; elim H5; intros.\nelim (H0 x H4); intros; elim H6; intros; elim H6; intros; elim H6; \n clear H6 H7; intros.\nelim (H0 x H4); intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H7; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H12; intros; \n elim H10; intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H13; intros; elim H12;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_symmetric in |- *; split; trivial.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H7; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_law_l H (Opp x y) y).\nunfold is_symmetric in |- *; split.\nelim H0; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H10; intros; elim H10; \n intros; elim H12; intros; elim H12; intros; elim H13; intros; elim H13; \n intros; elim H12; intros; elim H13; intros; elim H13; intros; \n elim H12; intros; elim H14; intros; elim H13; intros; \n elim H14; intros; elim H14; intros; elim H14; intros; elim H15; \n intros; elim H15; intros; elim H15;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) x).\nunfold is_symmetric in |- *; split.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n clear H5 H6 H7.\nelim (H7 x H7); intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8;\n intros; elim H9; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H11; intros; elim H11; intros; \n elim H10; intros; elim H11; intros; elim H11; intros; elim H12; \n intros; elim H11; intros; elim H12; intros; elim H13; \n intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros x y H0; unfold is_symmetric in |- *; split.\nelim H0; intros; elim H1; intros.\nclear H0; rewrite <- H0; rewrite <- H; rewrite H; auto.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) (Opp y y)).\napply (opp_uniqueness H (Opp y x) y).\napply (opp_uniqueness H (Opp x y) (Opp y y)).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniqueness H (Opp x y) y).\napply (opp_uniquenessQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_uniqueness H (Opp x y)).\nunfold is_midpoint in |- *; split.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp x y) y).\nunfold is_symmetric in |- *; split.\napply (opp_uniqueness H (Opp xQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nauto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; symmetry  in |- *; apply opp_cancel.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_integral; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero_l.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_is_symmetric; apply opp_is_symmetric; apply opp_lt_cancel;\n apply opp_cancel; apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_cancel; apply opp_cancel;\n apply opp_Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; unfold opp in |- *; unfold opp in |- *; unfold opp in |- *;\n unfold opp in |- *; intros; elim H; intros; elim H; intros; elim H; \n intros; elim H; intros; elim H; intros; elim H2; intros; clear H2 H2.\nelim (H2 x H2); intros; elim H4; intros; elim H4; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H6; intros; \n intros; elim H7; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H10Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, opp, opp; simpl in |- *.\nintros x H; elim H; simpl in |- *; intros.\nelim H; intros; elim H; simpl in |- *; intros.\nrewrite H0; rewrite H0; rewrite H1; reflexivity.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold is_group in |- *; intros x Hx; elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; intros; elim Hx; intros; elim Hx; intros; \n elim Hx; intros; elim Hx; introsQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold is_group in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n",
                "context_tokens": 44,
                "proof_start_offset": 215,
                "proof_end_offset": 725,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hd Hd Hd.\n case (Z_lt_dec 0 (a - c) 0); intro Hd.\n apply Zlt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_le_weak.\n apply Z.lt_Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n   intros a b c d H H0.\n   elim H0.\n   intro H1. rewrite H0 in H. discriminate H0.\n   intro H1. rewrite H0 in H. discriminate H0.\n   intro H1. rewrite H0 in H. discriminate H0.\n   intro H1. rewrite H0 in H. discriminate H0.\n   intro H1. rewrite H in H. discriminate H0.\n   intro H1. rewrite H in H. discriminate H0.\n   intro H1. rewrite H in H. discriminate H0.\n   intro H1. rewrite H in H. discriminate H0.\n   intro H1. rewrite H in H. discriminate H0.\n   intro H1. rewrite H in H. discriminate H0.\n   intro H1. rewrite H in H. discriminate H0.\n   intro H. rewrite H in H. discriminate H0.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H H0.\n case (Z_eq_dec a b); intro H1.\n rewrite H1 in H.\n rewrite H0 in H.\n discriminate H.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H.\n apply (gcd_unique_aux_aux_1 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_1 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (gcd_unique_aux_2 a b c d H).\n apply (Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d [Hb|Hb] Hd.\n apply Z.mul_cancel_l with (a := b).\n apply Zmult_lt_reg_r with (a := (- b)%Z).\n apply Zmult_gt_reg_r with (a := (- c)%Z).\n apply Zmult_gt_reg_l with (a := (- b)%Z).\n apply Zmult_gt_reg_l with (b := (- c)%Z).\n apply Zmult_gt_reg_r with (b := (- c)%Z).\n apply Zmult_gt_reg_r with (b := (- c)%Z).\n apply Zmult_gt_reg_l with (b := (- c)%Z).\n apply Zmult_gt_reg_l with (b := (- c)%Z).\n apply Zmult_gt_reg_l with (b := (- c)%Z).\n apply Zmult_gt_reg_l with (b := (- c)%Z).\n apply Zmult_gt_reg_l with (b := (- c)%Z).\n apply Zmult_gt_reg_r with (b := (- c)%Z).\n apply Zmult_gt_reg_lQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hd H_rec.\n apply gcd_unique_exact.\n apply gcd_unique_exact.\n apply gcd_unique_exact.\n apply gcd_unique_exact.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hd H_rec H_rec H_rec H_rec H_rec H_rec H_rec H_rec.\n apply H_rec with (P := fun x : Z => x = (1 + x)%Z) (a := b) (c := d) (c := d) (c := d) (d := d).\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hd Hd.\n rewrite <- (Z_div_plus_full _ _ Hd) in Hd.\n apply (Z_div_pos a b c d Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd Hd d Hd Hd d hyp ].\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H H0.\n case (Z_eq_dec (Zpos a) 0); intro H1.\n rewrite H0; rewrite H1; rewrite H0; ring.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hd H_rec.\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n apply (Z_eq_cases 0).\n applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\nLemma gcd_unicity_apart_sign :\n forall a b c d : Z,\n is_gcd Z IdZ Zmult 0%Z a b c ->\n is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\n",
                "context_tokens": 238,
                "proof_start_offset": 727,
                "proof_end_offset": 1860,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (Z_le_gt_dec 0 b); intros.\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nintros; exact H0.\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nright.\nsplit; auto with zarith.\nexists (-1)%Z; split.\nexact I.\nauto with zarith.\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (- x)%Z.\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n apply gcd_greatest_nonneg.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (gcd_bezout_non_zero ZintvalZ); intros.\n elim (gcd_bezout_non_zero ZintvalZ); intros.\n apply gcd_bezout_nonneg; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n rewrite <- (Zabs_eq 0).\n apply gcd_absorb_l with 0%Z.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\n apply Zabs_eq.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (gcd_bezout_nonneg ZZero); auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n case (gcd_bezout_divisors Z 0%Z 1%Z); intros.\n case (gcd_bezout_divisors Z 1%Z 1%Z); intros.\n apply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_exact.\napply Z_div_Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (gcd_bezout_pos _ _ H).\n intros.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H1.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H1.\n rewrite <- H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite <- H1.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite H0.\n rewrite <- H0.\n rewrite H0.\n rewrite <- H0.\n rewrite <- H0.\n rewrite <- H0.Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (gcd_bezout_non_zero _ _ H); intros.\nright.\n elim H1; intros; elim H2; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H2; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nright.\n elim H1; intros.\nleft.\n elim H1; intros.\nleft.\n elim H1; intros.\nright.\n elim H1; intros.\nleft.\n elim H1; intros.\nright.\n elim H1; intros.\nleft.\n elim H1; intros.\nright.\n elim H1;Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n rewrite <- (Zabs_eq 0).\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n apply Zabs_eq; apply Zabs_eq; apply Zabs_eqQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (gcd_bezout_non_zero _ H).\n intros.\n right. elim H; intros.\n right. elim H1; intros.\n right. elim H0; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n left. elim H1; intros.\n left. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n left. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\n right. elim H1; intros.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n apply gcd_absorb_l with Z.opp 0%Z.\n apply Z.abs_nonneg.\n apply Z.abs_nonneg.\n apply Z.abs_nonneg.\n apply Z.abs_nonneg.\n apply Z.abs_nonneg.\n apply Z.abs_nonneg.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 2271,
                "proof_end_offset": 2745,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros.\ncase (Z_zerop n); intro.\nunfold P in |- *.\nintro.\nsplit with (Zabs b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (Zdiv_eucl_extended n0 b).\nintro p; elim p; intros q r H0; elim H0; clear p H0; intros.\ncut (Zabs r < Zabs n)%Z; intros.\nelim (H r H2 n).\nintros.\nsplit with x.\napply gcd_mod with q r; trivial.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n Hn H_ind H_rec.\napply (f_equal Z.le_lt_succ_r n Hn).\nexact (f_equal Z.le_lt_succ_r n Hn).\nexact (f_equal Z.le_gt_succ_r n Hn).\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n. apply (Build_P (fun m => Zabs n)%Z).\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply P_ind.\n apply P_ind.\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply P_ind.\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply P_ind.\n apply (fun m n => Zabs_eq_lt_dec n m).\n apply P_ind.\n apply (fun m n => Zabs_Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n; elim n; auto.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n.\nassert (forall m : Z, (Zabs m < Zabs n)%Z -> P m).\n intros m H1; case (Z_le_gt_dec n m); intros.\nexists (Zabs m).\n exists (Zabs m).\n split.\n rewrite Zabs_eq; auto with zarith.\n rewrite Zabs_eq; auto with zarith.\n intros m H2; apply H2.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros.\n apply (Build_P_of_P_of_P_of_P_of_P_of_P m).\n split.\n unfold Zminus in |- *.\n unfold Z.succ in |- *.\n rewrite inj_S.\n apply Zlt_succ_le.\n apply lt_trans with (m := Zpos p0).\n apply Z.lt_gt.\n apply Z.lt_trans with (m := Zpos p0).\n apply Z.lt_le_trans with (m := Zpos p0).\n apply Z.lt_gt.\n apply Z.lt_le_trans with (m := Zpos p0).\n apply Z.lt_gt.\n apply Z.lt_trans with (m := Zpos p0).\n apply Z.lt_gt.\n apply Z.lt_trans with (m := Zpos p0).\n apply Z.lt_gt.\n apply Z.lt_trans with (m := Zpos p0).\n apply Z.lt_gt.\n apply Z.lt_trans with (m := Zpos p0).\n apply Z.lt_gt.\n apply Z.lt_trans with (m := Zpos pQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n H1 H2; apply (H2 n); auto with zarith.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n. unfold P in |- *.\n case (P_decidable (Zabs n) 0).\n intro.\n case (Z_le_gt_dec n 0).\n intro.\n case (Z_le_gt_dec m 0).\n intro.\n apply (H (Zpos p0) (Zpos p0) (Zpos p0) (Zpos p0) (Zpos p0) (Zpos p0) H1).\n apply H.\n apply Z.lt_gt_trans with (Zpos p0 + Zpos p0)%Z.\n apply H.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply (H (Zpos p0) (Zpos p0) (Zpos p0) (Zpos p0) (Zpos p0) H0).\n apply H.\n apply Z.lt_gt.\n apply (H (Zpos p0) (Zpos p0) (Zpos p0) (Zpos p0) H0).\n apply H.\n assumption.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros.\n apply (Build_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_P_of_P_of_P_of_P_succ_nat)\n  (P_of_P_of_P_of_P_of_P_of_succ_nat)\n    (P_of_P_of_succ_nat)\n     (P_of_P_of_succ_nat)\n     (P_of_succ_nat) (P_of_succ_nat)\n       (P_of_succ_nat) (P_of_succ_nat) (P_of_succ_nat)\n        (P_of_succ_nat) (P_of_succ_nat) (P_of_succ_nat)\n       (P_of_succ_nat) (P_of_succ_nat) (P_of_succ_nat)\n       (P_of_succ_nat) (P_of_succ_nat)\n       (P_ofQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n H H0 H1.\n apply (Build_P_of_P_of_P n) in H1.\n apply (Build_P_of_P_of_P n) in H2.\n apply (Build_P_of_P_of_P n) in H3.\n apply (Build_P_of_P n) in H4.\n apply (Build_of_P_of_P_of_P n) in H4.\n apply (Build_P_of_P n) in H4.\n apply (Build_of_P_of_P n) in H4.\n apply (Build_of_P_of_P n) in H5.\n apply (Build_P_of_P n) in H5.\n apply (Build_of_P_of_P n) in H5.\n apply (Build_of_P_of_P n) in H5.\n apply (Build_of_P n) in H5.\n apply (Build_of_P n) in H5.\n apply (Build_of_P n) in H5.Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n.\nunfold P in |- *.\ngeneralize (Z_mod_pos_pos n).\nintros.\napply H.\napply Zabs_eq.\nexact H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Qed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2747,
                "proof_end_offset": 2841,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout in |- *.\n  unfold Bezout inQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  case (Z_zerop b); intro.\n  unfold Z_modulo in |- *.\n  unfold Z_modulo in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Z_modulo in |- *.\n  unfold Z_modulo in |- *.\n  unfold Zmod_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zmod_eucl in |- *.\n  unfold Zmod_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.\n  unfold Zdiv_eucl in |- *.Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold a, b, a, b, 0%Z in |- *.\n  intros a b.\n  unfold spec_ind in |- *.\n  split.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |- *.\n  unfold Zminus in |-Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold a, b, it_P in |- *.\n  intro.\n  split.\n  unfold Z. intro.\n  split with (Zabs b).\n  rewrite e.\n  rewrite <- Zabs_eq; auto with zarith.\n  unfold Z. intro.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p; elim p; intros.\n  unfold Z. intro.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p; elim p; intros.\n  unfold Z. intro.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p.\n  split with (Zabs b).\n  rewrite e.\n  rewrite Zabs_eq; auto with zarith.\n  unfold Z. intro.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p; elim p; intros.\n  unfold Z. intro.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p.\n  split with (Zabs b).\n  rewrite e.\n  rewrite Zabs_eq; auto with zarith.\n  unfold Z. intro.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p; elim p; intros.\n  unfold Z. intro.\n Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  unfold Euclid_gcd in |- *.\n  unfold Z. intro.\n  elim (Z_zerop b); intro.\n  split.\n  apply gcd_refl.\n  intros p H; elim (Zdiv_eucl_extended n0 b).\n  intro p; elim p; intros q H0; elim H0; clear H0; intros.\n  split with x.\n  apply gcd_refl.\n  intros p H1.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p; elim p; intros q H0; elim H0; clear H0; intros.\n  split with (Zpos p0).\n  apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.\n  split; apply gcd_refl.Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  case (Z_zerop b); intro.\n  split with (Zabs b).\n  rewrite e.\n  rewrite Zabs_eq; auto with zarith.\n  apply Zabs_eq.\n  rewrite <- Zabs_eq; auto with zarith.\n  rewrite <- Zabs_eq; auto with zarith.\n  unfold Z in |- *; apply Zle_lt_trans with (Zabs b).\n  apply Zabs_eq.\n  rewrite <- Zabs_eq; auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  case (Z_zerop a); intro.\n  case (Z_zerop b); intro.\n  case (Z_zerop b); intro.\n  apply (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  case (Z_zerop b); intro.\n  apply (Z_zerop_pos b); intro.\n  rewrite e.\n  rewrite e.\n  apply Z_zerop_pos; intro.\n  generalize (Z_zerop_pos b); intro.\n  generalize (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  generalize (Z_zerop_pos b); intro.\n  apply (Z_zerop_pos b); intro.\n  rewrite e.\n  apply Z_zerop_pos; intro.\n  generalize (Z_zerop_pos b);Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold divide in |- *. intros.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in |- *.\n  unfold P in H0.\n  unfold P in H1.\n  unfold P in |- *.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P in H1.\n  unfold P inQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intro.\n  case (Z_zerop b); intro.\n  exists (Zabs b).\n  rewrite e.\n  apply gcd_refl.\n  exists (Zabs b).\n  split.\n  rewrite <- (Zabs_eq a).\n  split.\n  rewrite <- (Zabs_eq b).\n  split.\n  rewrite <- Zabs_eq; auto with zarith.\n  rewrite <- Zabs_eq; auto with zarith.\n  rewrite <- Zabs_eq; auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold a, b in |- *.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  unfold Z.\n  intro.\n  elim H1; intros.\n  split with (Zabs b).\n  rewrite e.\n  apply H.\n  unfold Z.\n  apply Zlt_succ_pred.\n  unfold Z.\n  unfold Z.\n  apply Z.lt_pred.\n  unfold Z.\n  unfold Z.\n  apply Zle_succ_pred.\n  unfold Z.\n  unfold Z.\n  apply Z.lt_pred.\n  unfold Z.\n  unfold Z.\n  apply Zlt_pred_pred.\n  apply Zle_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2843,
                "proof_end_offset": 3586,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros.\nelim H.\nintros.\napply (gcd_OZ_absZ b0).\nclear H a b d; intros.\nunfold is_gcd in |- *.\nelim H3; clear H3; intros.\nelim H4; clear H4; intros.\nsplit.\nexact H4.\nsplit.\nrewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4.\nexact I.\nexact H3.\nintros.\napply (H5 q0).\ncut (r = (a - b * q)%Z); intros.\nrewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. apply (Z_lt_is_gcd_pos _ _ H).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_lt_is_gcd _ _ (Z_lt_is_gcd _ _ (Z_lt_is_gcd _ _ (Z_lt_is_gcd _ _ _ H))).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_lt_is_gcd_pos _ _ _ H).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_lt_abs_rec _ _ (Zabs_pos a)).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_lt_is_gcd _ _ (Z_lt_is_gcd _ _ _ H)).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_is_gcd_is_gcd _ _ _ (Z_le_is_gcd_is_gcd _ _ _ H)).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_lt_is_gcd_alt _ _ _ _ H).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop d); intro.\n  unfold Z.abs in |- *. unfold Z.abs in |- *. unfold Z.abs in |- *. unfold Z.abs in |- *.\n  unfold Z. simpl in |- *. unfold Z.abs in |- *. unfold Z. unfold Z.abs in |- *.\n  unfold Z. simpl in |- *. unfold Z.abs in |- *. unfold Z. simpl in |- *. unfold Z.abs in |- *. unfold Z. simpl in |- *.\n  rewrite Zmult_1_r. rewrite Zmult_1_r. apply Zlt_le_weak.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. apply (Z_lt_abs_induction _ _ _ H).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  exact (Z_lt_is_gcd _ _ _ (Z_lt_is_gcd _ _ _ H)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3657,
                "proof_end_offset": 3793,
                "proof": "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply gcd_refl.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply (gcd_bezout a b).\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\n  unfold is_gcd, gcd, gcdZ, gcdZ, gcdZ_eq.\n  intros.\n  elim (Z_eq_dec a 0).\n  intro. elim (Zle_lt_or_eq _ _ H0). intros.\n  rewrite <- H1.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\n  intros. apply Z_divide_antisym. apply Z_divide_trans with (Zabs b). apply Zabs_eq.\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq; apply Zabs_eq;\n  apply Zabs_Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros a b; unfold gcd, is_gcd, gcdZ_spec in |- *.\nelim (Z_zerop b); intro.\nsplit with (Zabs b).\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply Zis_gcd_for_euclid with (a := b); auto with zarith.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros a b.\ngeneralize (Z_div_mod a b).\ngeneralize (Z_mod_eq (Zabs b) (Zabs_nat a) (Zabs_nat b)).\ngeneralize (Z_mod_eq (Zabs_nat a) (Zabs_nat b)).\nintros H'.\nelim H'.\nintros x H'0; elim H'0; clear H'0.\ngeneralize (Zabs_eq_bool (Zabs_nat b) (Zabs_nat b)).\nintros H'.\ngeneralize (Zabs_eq_bool (Zabs_nat b) (Zabs_nat b)).\nintros H'.\nelim H'.\nintros x H'0; elim H'0; clear H'0; intros.\ngeneralize (Zabs_eq_bool (Zabs_nat b) (Zabs_nat b)).\nintros H'.\nrewrite Zabs_eq; auto with zarith.\ngeneralize (Zabs_eq_bool (Zabs_nat b) (Zabs_nat b)).\nintros H'.\nrewrite Zabs_eq; auto with zarith.\napply Zabs_eq_mult_l; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\ngeneralize (Zabs_Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nrewrite <- (gcd_divide a b).\napply gcd_divide.\napply gcd_divide.\napply gcd_divide.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nunfold gcd, gcd, gcd, gcdZ, gcdZ.\ngeneralize (Z_div_eucl_extended n); case (Z_zerop a); intros.\napply gcd_eq; simpl; auto with zarith.\napply gcd_eq; simpl; auto with zarith.\napply gcd_eq; simpl; auto with zarith.\napply gcd_eq; simpl; auto with zarith.\napply gcd_eq; simpl; auto with zarith.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply (gcd_divide_l (Zpos a) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos a) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos a) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos b) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos a) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos b) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos b) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos b) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos b) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos b) (Zpos b)).\nclear a b; intros.\napply (gcd_divide_r (Zpos b) (Zpos b)).\nclear a bQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": ",\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3795,
                "proof_end_offset": 3912,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d; case (Z_zerop d); intro.\nexists 0%Z; rewrite e; ring.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\nelim H.\nintros.\napply gcd_refl.\napply gcd_refl.\napply gcd_refl.\nintros.\napply gcd_refl.\napply gcd_refl.\nintros.\napply gcd_refl.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\ngeneralize (Z_div_mod a b d).\ncase (Z_div_eucl_ext a b d).\nintros H0.\napply (H0 (a - b)%Z).\napply (H (b - d)%Z).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nexact (fun a b : Z => a).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\nelim H.\napply Zle_lt_trans with (Zabs b).\napply Zabs_is_gcd.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_pos.\napply Zabs_Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\n exact (fun a b : Z => a = 0%Z).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply (Build_gcd_divide_l _ _ (is_gcd_divide_r _ _ _)).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\nelim H.\nintros.\nelim H0.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim HQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nexact (fun a b : Z => a = b).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\n exact (fun a b : Z => a = b /\\ a = b).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 3914,
                "proof_end_offset": 4352,
                "proof": "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d [|c|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d] [|d|d|d] [|d|d] [|d|Qed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 4354,
                "proof_end_offset": 4506,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H.\napply gcd_is_gcd; auto with zarith.\nintros.\napply gcd_is_gcd; auto with zarith.\nintros.\napply gcd_is_gcd; auto with zarith.\nintros.\napply gcd_is_gcd; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\ngeneralize (gcd_is_gcd_is_gcdZ a b d H); intro.\ncut (d = 0%Z).\nintro eq; rewrite eq; auto with zarith.\napply gcd_eq; auto with zarith.\napply gcd_eq; auto with zarith.\napply gcd_eq; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\ngeneralize (gcd_is_gcdZ a b d (gcdZ_is_gcd a b d H) (gcdZ_is_gcd a b d H0)).\nintros.\napply gcd_is_gcd_l with b; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_is_gcdZ a b d (gcdZ_is_gcd a b d H) (gcdZ_is_gcd_gcd b d H0)).\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros.\napply H0.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H0.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1.\nintros.\napply H1Qed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_integral_gcdZ a b d (gcdZ_is_gcd_bool a b d H) (gcdZ_is_gcd_bool b d H0)).\nintros; exact (gcd_is_gcd_Z b d H).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_is_gcdZ a b d (gcdZ_is_gcd_is_gcd a b d H0)).\nintros; exact H1.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (gcd_bezout_is_gcdZ a b d (gcdZ_is_gcd_Z a b d H) (gcdZ_is_gcd_Z b d H)).\ngeneralize (gcd_bezout_is_gcdZ b d (gcdZ_is_gcd_Z a b d H)).\nintros.\napply (gcd_bezout_is_gcdZ b d (gcdZ_is_gcd_Z b d H) (gcdZ_is_gcd_Z b d H)).\napply (gcd_bezout_is_gcd_Z b d (gcdZ_is_gcd_Z b d H)).\napply (gcd_bezout_is_gcdZ b d (gcdZ_is_gcd_Z b d H)).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_bezout_algorithm a b d (gcdZ_is_gcd_Z a b d H) (gcdZ_is_gcd_Z a b d H)).\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nintros; apply H1.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_greatest_apart_sign a b c d (gcdZ_is_gcd a b d H) (gcdZ_is_gcd b d H)).\nintros; try exact (gcd_greatest_nonneg_pos a b d H).\nintros; try exact (gcd_greatest_pos a b d H).\nintros; try exact (gcd_greatest_pos a b d H).\nintros; try exact (gcd_greatest_pos b d H).\nintros; try exact (gcd_greatest_pos b d H).\nintros; try exact (gcd_greatest_pos a b d H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 4508,
                "proof_end_offset": 4744,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim (gcd_eq_0_0_r a b q r (gcd_comm b q r) (gcd_0 b q r)); intros.\nrewrite H1; rewrite H2; rewrite H3; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (unique_gcd_bezout_is_gcdZ r (gcdZ a b) (gcdZ_is_gcd_alt b b q r) (gcdZ_is_gcd_alt b q r) (gcdZ_is_gcd_alt b q r) (gcdZ_is_gcd_alt b q r) (gcdZ_is_gcd b q r)).\nintros; apply (unique_gcd_bezout_is_gcdZ r (gcdZ a b) (gcd_is_gcd_alt b q r) (gcdZ_is_gcd_alt b q r) (gcdZ_is_gcd b q r)).\nintros.\nrewrite <- (gcd_mul_assoc r (gcdZ_is_gcd_l b q) (gcdZ_is_gcd_alt b q r) (gcdZ_is_gcd_alt b q r) (gcdZ_is_gcd b q r)).\nintros.\nrewrite <- (gcd_mul_assoc b q r (gcdZ_is_gcd_alt b q r) (gcdZ_is_gcd_alt b q r) (gcdZ_isQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (unicity_preserves_gcdZ a b q r (gcd_comm b q) (gcd_comm b q) (gcd_comm b q) H0).\napply gcd_divide; trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (unique_least_bound Z 0 r H H H0).\napply gcd_eq_0.\napply gcd_eq_0; trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim (gcd_eq_0 a b q r); auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0; auto with zarith.\nintros; apply gcd_eq_0Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\napply (unicity_is_gcdZ a b q r (gcdZ_is_gcd_Z b q r H1)); auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (unicity_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros. apply (unique_divide_l (a * b) (a * b) (b * q + r)%Z (gcdZ r b));\n auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim (gcd_bezout_non_gcdZ a b (gcd_comm a b) r (gcd_comm b r) (gcd_comm b r) H0).\nintros; apply (H (a * q + r)%Z r d).\nrewrite H; auto with zarith.\nrewrite H0; auto with zarith.\nintros; apply (H (a * q + r)%Z r d).\nrewrite H; auto with zarith.\napply (H (a * q + r)%Z r d).\napply (H (a * q + r)%Z r d).\nrewrite H; auto with zarith.\napply (H (a * q + r)%Z r d).\nrewrite H; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\ncase (gcd_eq_bool r b); intros H4.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napply gcd_eq; try assumption.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4939,
                "proof_end_offset": 5677,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros q f.\nelim (Z_zerop q); intro e.\nunfold Q in |- *; intro b.\nsplit with 1%Z (Zsgn b).\nrewrite e.\nsimpl in |- *.\nrewrite (Zsgn_Zabs b).\napply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (Zdiv_eucl_extended e b).\nintro p; elim p; clear p.\nintros div r; intros.\ncut (Zabs r < Zabs q)%Z; intros.\nelim (f r H q).\nintros.\nsplit with (v + - (div * u))%Z u.\nelim p.\nintros.\nelim H1.\nintros.\nintros.\npattern b at 1 in |- *.\nrewrite H0; auto with zarith.\nrewrite <- (gcd_modZ b q div r); auto with zarith.\nrewrite <- e0.\nring.\nelim p; intros; elim H0; intros.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\ngeneralize (Z_div_mod a n); unfold Q.\ngeneralize (Z_div_mod b n); unfold Z.div; intros.\ngeneralize (Z_div_mod a n); unfold Z.div; intros.\ngeneralize (Z_div_mod b n); unfold Z.div; intros.\ngeneralize (Z_div_mod a n); unfold Z.div; intros.\ngeneralize (Z_div_mod a n); unfold Z.div; intros.\ngeneralize (Z_div_mod a n); unfold Z.div; intros.\nrewrite Z_div_mod.\ngeneralize (Z_div_mod a n); unfold Z.div; intros.\nrewrite Z_div_mod.\nrewrite Z_div_mod; auto with zarith.\ngeneralize (Z_mod_eq n m); unfold Z.div; intros.\nrewrite Z_div_mod.\ngeneralize (Z_div_mod a n); unfold Z.div; intros.\nrewrite Z_div_mod.\ngeneralize (Z_mod_eq n n); unfold Z.div; intros.\nrewrite Z_div_mod.\nrewrite Z_Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply Bezout_i with (1 := H0).\nexact (fun m : Z => n = m).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\ngeneralize (pos_is_gcd_Z n (Zabs_nat m)).\ncase (Z_is_gcd_alt n (Zabs_nat m) (Zabs_nat n)).\nintros; apply (H (Zabs_nat m)).\nintros; apply (H (Zabs_nat m)).\nintros m; apply (H (Zabs_nat m)).\nintros; apply (H (Zabs_nat m)).\nintros; apply (H (Zabs_nat m)).\nintros; apply H; rewrite Zabs_nat_is_gcd_pos; auto.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\nunfold Q, gcd_mult.\npattern (Zabs n) at 1; rewrite gcd_mult_full_r; auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\ngeneralize (Z_div_mod_pos_pos_bound n (Zabs m)).\nintros.\ngeneralize (Z_div_mod_pos_bound n (Zabs m)).\nintros.\nrewrite H0.\napply Zmult_le_reg_r with (Zabs n); auto with zarith.\napply Zlt_gt.\nrewrite Zabs_eq; auto with zarith.\napply Zlt_gt.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\nsplit.\napply IH; auto with zarith.\napply Bezout_i with (Zabs (Zpos m)); auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H.\ngeneralize (Z_div_mod_eq_dec n m); intro.\nrewrite H.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply Zis_gcd_for_euclid2; auto.\nintros.\napply ZisQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (Zabs m)).\napply (pre_is_gcdZ n (ZabsQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcdZ n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_Z n (Zpos m) (Zpos n)).\napply (pre_is_gcd_is_gcd_Z n (Zpos m)Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\nintros.\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\nintros.\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\nintros.\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\nintros.\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\nintros.\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\nintros.\napply (fun m : Z => forall m : Z, (Zabs m < Zabs n)%Z -> Q m).\nintros.\napply (fun m : Z => Zabs n = Zabs n).\nintros.\napply Zabs_eq; auto with zarith.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5679,
                "proof_end_offset": 5780,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  split; auto with zarith.\n  intros.\n  split; auto with zarith.\n  intros; apply Zis_gcd_for_euclid2; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (Zis_gcd_is_gcd_Z 0 b (Zabs b)).\n  apply (Zis_gcd_is_gcd_Z 0 b (Zabs b)); apply gcd_bezout.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nintros.\nelim (gcd_unique_apart_sign a b); intros.\nexists (a * b).\nsplit; trivial.\nrewrite <- H1; rewrite <- H2; ring.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  destruct b as [a|a].\n  destruct b as [b|b].\n  simpl in |- *. rewrite (Zsgn_abs b); apply gcd_abs.\n  unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros.\n  split with (- a * b)%Z.\n  rewrite e; auto with zarith.\n  replace (- a * b)%Z with (- (a * b))%Z.\n  apply gcd_divide_r.\n  unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros.\n  split with (- a * b)%Z.\n  rewrite e; auto with zarith.\n  replace (- a * b)%Z with (- (a * b))%Z.\n  apply gcd_divide_r.\n  unfold Z.opp in |- *.\n  ring.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nintros a b.\nunfold Q in |- *.\napply Zis_gcd_for_euclid with (a := b); auto with zarith.\nintros a b.\ncut (0 < a * b * b)%Z.\nintro H; rewrite H0.\nrewrite <- (gcd_modZ_is_gcd a b); auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nintros a b.\nelim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\nintros div r; intros.\napply (valid_gcd_bezout_apart_sign a b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\napply (gcd_bezout_is_gcd_Z 1 b (Zabs b)); apply gcd_bezout.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros.\n  apply (pre_is_gcd_abs_is_gcd a b (gcdZ_is_gcd a b)).\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; unfold Q in |- *; intro b.\n  split with (- a)%Z; try apply gcd_bezout.\n  apply Zis_gcd_for_euclid2; auto.\n  apply Zis_gcd_for_euclid2; auto.\n  apply Zis_gcd_for_euclid2; auto.\n  apply Zis_gcd_for_euclid2; auto.\n  apply Zis_gcd_for_euclid2; auto.\n  apply Zis_gcd_for_euclid2; auto.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply Bezout_i with b; auto with zarith.\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_i with (a * b).\n  apply Bezout_iQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros a b H.\n unfold Q in |- *.\n split with 0%Z.\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_sym; apply Zis_gcd_sym; apply Zis_gcd_sym;\n apply Zis_gcd_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 5858,
                "proof_end_offset": 6105,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x y n; unfold divide in |- *; intro b.\n  split with (2 * x).\n  replace (Zabs (Z_of_nat n) + 1)%Z with (Zabs (Z_of_nat n) + 1)%Z.\n  replace (Zabs (Z_of_nat n) + 1)%Z with (Zabs (Z_of_nat n) + 1)%Z.\n  apply zmod_mult; auto.\n  replace (Zabs (Z_of_nat n) + 1)%Z with (Zabs (Z_of_nat n) + 1)%Z.\n  apply zmod_mult; auto.\n  replace (Zabs (Z_of_nat n) + 1)%Z with (Zabs (Z_of_nat n) + 1)%Z.\n  apply zmod_mult; auto.\n  replace (Zabs (Z_of_nat n) + 1)%Z with (Zabs (Z_of_nat n) + 1)%Z.\n  apply zmod_mult; auto.\n  replace (Zabs (Z_of_nat n) + 1)%Z with (Zabs (Z_of_nat n) + 1)%Z.\n  apply zmod_mult; autoQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x.\n  elim (Zle_lt_or_lt _ _ H).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x.\n  unfold divide in |- *.\n  elim (Z_zerop x). intro.\n  elim (Zle_lt_or_eq _ _ H).\n  intros.\n  generalize (Z_lt_succ_pred x).\n  elim (Zle_lt_or_eq _ _ H0).\n  intros.\n  generalize (Z_lt_succ_pred x).\n  elim (Zle_lt_or_eq _ _ H1).\n  intros.\n  generalize (Z_lt_succ_pred x).\n  elim (Zle_lt_or_eq _ _ H2).\n  intros.\n  elim H4.\n  intros.\n  elim H4.\n  intros.\n  elim H5.\n  intros.\n  generalize (Z_lt_succ_pred x).\n  elim (Zle_lt_or_eq _ _ H4).\n  intros.\n  generalize (Z_lt_succ_pred x).\n  elim (Zle_lt_or_eq _ _ H4).\n  intros.\n  apply H5.\n  split.\n  split.\n  replace (Zdiv m (Z.abs x) - Z.abs y + -1 * x)%Z with y.\n  apply gcd_absQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  unfold divide in |- *.\n  rewrite <- (Zabs_eq n).\n  rewrite <- (Zabs_eq n).\n  apply (gcd_eq (Zabs n) 0).\n  apply (gcd_eq (Zabs n) 0).\n  apply (gcd_eq (Zabs n) 0).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  unfold divide in |- *.\n  elim (Z_lt_abs_rec x y).\n  elim (Zdiv_eucl_mod_mod_eq x y).\n  intro p; elim p; clear p.\n  intros (H1,H2).\n  elim (Zdiv_eucl_mod_eq x y).\n  intro p; elim p; clear p.\n  intros (H1,H2).\n  elim (Zdiv_eucl_mod_eq x y).\n  intro p; elim p; clear p.\n  intros (H1,H2).\n  elim (Zdiv_eucl_mod_eq x y).\n  intro p; elim p; clear p.\n  intros (H1,H2).\n  elim (Zdiv_eucl_mod_eq x y).\n  intro p; elim p; clear p.\n  intros (H1,H2).\n  elim (Zdiv_eucl_mod_eq x y).\n  intro p; elim p; clear p.\n  intros (H1,H2).\n  elim (Zdiv_eucl_mod_eq x y).\n  intro p; elim p; clear p.\n  intros (H1,H2).\n  elim (Zdiv_Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  rewrite <- (Z_lt_abs_eq x y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewrite <- (Zabs_eq y).\n  rewriteQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  unfold divide in |- *.\n  intros x y n H; elim (Z_mod_mult_full x n). intro p; elim p; clear p.\n  intros.\n  split.\n  rewrite H; rewrite Z_div_plus_full; auto with zarith.\n  rewrite Z_div_plus_full; auto with zarith.\n  rewrite Z_div_plus_full; auto with zarith.\n  rewrite Z_div_plus_full; auto with zarith.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_rec _ _ _ _ _ (Z_lt_abs_rec _ _ _ _ _ _ (Z_lt_abs_rec _ _ _ _ _ (Z_lt_abs_rec _ _ _ _ H0 H1)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  exact (Z_lt_abs_eq _ _ (Z_lt_abs_eq _ _ _ (Z_lt_abs_eq _ _ _ (Z_lt_abs_eq _ _ _ H0)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\nLemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (Z_zerop x); intros. left; exact a.\nright; split. exact b. exists 1%Z. split. exact I. auto with zarith.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6107,
                "proof_end_offset": 7147,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (x * (b * v) + y * (a * u))%Z.\nunfold congruentZ in |- *; split.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - x)%Z with (a * (u * (y - x)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop a); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (u * (y - x))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (b * v)%Z with (1 + - (a * u))%Z; auto with zarith.\nring.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - y)%Z with (b * (v * (x - y)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (v * (x - y))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (a * u)%Z with (1 + - (b * v))%Z; auto with zarith.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  apply (gcd_unique_pos a b (gcdZ a b) x y H0 H1).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold Bezout in |- *. split. exact I. split; exact I. split; exact I.\n  intros. exists (Zabs (Z_of_nat x)). apply Zabs_eq; split. exact I. split.\n  exact I. split. apply Zabs_eq; split. exact I. split; exact I. split; exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  unfold divide in |- *. split. exact I. split; intros.\n  exists (Zabs b); split; auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\n  apply Z_lt_le_trans with (Zabs b); auto with zarith.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  split.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * y)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_trans with (Zabs z * x)%Z.\n  apply Z_le_transQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros. apply (gcd_unique (Z_mod a b) (Z_mod b y) H).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y.\n unfold gcd in |- *. split. exact (Z_lt_abs_pos a b y H).\nintros H. apply (Z_lt_abs_pos b x y H).\nintros.\nabsurd (0 <= a * 0)%Z. apply (Z_lt_lt_trans _ _ _ H).\napply (Z_lt_le_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _ H).\napply (Z_le_lt_trans _ _ _Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold divide in |- *. split. exact I. split. exact I. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  destruct b.\n  - intros.\n    apply (Zis_gcd_unique_pos a b (gcdZ a b) (gcdZ b b)); auto with zarith.\n    apply gcd_greatest; auto with zarith.\n    apply gcd_greatest; auto with zarith.\n    apply gcd_greatest; auto with zarith.\n  - intros.\n    apply (Zis_gcd_unique_pos a b (gcdZ b b) (gcdZ b b)); auto with zarith.\n    apply gcd_greatest; auto with zarith.\n    apply gcd_greatest; auto with zarith.\n    apply gcd_greatest; auto with zarith.\n    apply gcd_greatest; auto with zarith.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold Bezout in |- *. split. exact I. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  apply (Zis_gcd_unique_abs_pos a b (gcdZ b x) (gcdZ b y) H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.abs at 1.\nintros H.\nrewrite <- Z_to_group.\nrewrite <- Z_to_group.\nrewrite <- Z_to_group.\nrewrite <- Z_to_group.\napply sym_eq.\nrewrite <- Zopp_mult_distr_l_reverse.\nnow apply Zlt_le_weak.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro x.\nunfold Z_group in |- *.\nunfold Z_group in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold Z_group_inverse in |- *.\nintros x y.\nunfold ZQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro x.\nunfold Z.abs.\napply Z_to_group_mult.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.swap.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.abs.\nunfold Z.abs.\nunfold Z.abs.\nunfold Z.abs.\nunfold Z.abs.\napply Z.ge_0.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.abs.\nrewrite <- Z_to_nat_complete.\napply Z_to_nat_complete.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n unfold Z.abs.\n case Z.abs_spec; intros; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro x.\napply False_ind.\napply sym_eq.\napply refl_equal.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro x.\napply Z_eq_reg_l with (Z_of_nat x).\nunfold Z_of_nat in |- *.\nsimpl in |- *.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\napply Zmult_comm.\napply Zmult_comm.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nnow rewrite <- Z_div_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat,\n Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat,\n Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat,\n Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat,\n Z_to_nat, Z_to_nat, Z_to_nat, ZQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; intros H; apply H; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_natQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z_ring_mult, Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_mult, Z_ring_mult,\n  Z_ring_mult, Z_ring_multQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat.\nintros H; apply Z_to_nat_o_nat_o_nat_o_nat_o_nat_o_nat_of_P.\napply Z_to_nat_o_nat_o_nat_of_P.\napply Z_to_nat_o_nat_of_P.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nred in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nsimpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nsimpl in |- *.\nauto with zarith.\nunfold Z_to_nat in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napply Z_div_eq.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nunfold not in |- *; auto with zarith.\nintros.\napply Z_div_exact_2.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nunfold is_ring in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfold opp in |- *. intros. exact I.\nsplit.\nunfoldQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nexact Z_unit.\nunfold inv_inverse in |- *. intros. exact I.\nsplit.\nunfold opp_inverse in |- *. intros. exact I.\nsplit.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\napply Z_unit.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nunfold is_ring_simplify in |- *; auto with zarith.\nunfold is_ring_simplify in |- *; auto with zarith.\nunfold is_ring_simplify in |- *; auto with zarith.\nunfold is_ring_simplify in |- *; auto with zarith.\nunfold is_ring_simplify in |- *; auto with zarith.\nunfold is_ring_simplify in |- *; auto with zarith.\nunfold is_ring_simplify in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nunfold is_ring in |- *.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ring_mult in |- *; simpl in |- *.\nintros. exact I.\nunfold is_ringQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\napply Z_to_Q_nonneg_pos.\nunfold is_ring in |- *.\nsplit.\napply Z_to_Q_nonneg.\napply Z_to_Q_nonneg.\napply Z_to_Q_nonneg.\napply Z_to_Q_nonneg.\napply Z_to_Q_nonneg.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nunfold not in |- *; intros. exact I.\nunfold not in |- *; intros. exact I.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nunfold is_ring in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nsimpl in |- *. intros. exact I.\nsplit. exact Z_unit.\nintros.\napply Z_unit_equiv.\napply Z_unit_equiv.\napply Z_unit_equiv.\napply Z_unit_equiv.\napply Z_unit_equiv.\napply Z_unit_equiv.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nrewrite <- Z_to_nat_o_Z_plus_l_reverse.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nrewrite <- Z_to_nat_o_Z_plus_r_reverse.\nunfold Z_inverse in |- *.\nrewrite <- Z_to_nat_o_Z_plus_l_reverse.\nunfold Z_inverse in |- *.\nrewrite <- Z_to_nat_o_Z_plus_r_reverse.\nunfold Z_inverse in |- *.\nrewrite <- Z_to_nat_o_Z_plus_r_reverse.\nunfold Z_inverse in |- *.\nrewrite <- Z_to_nat_o_Z_plus_r_reverse.\nunfold Z_inverse in |- *.\nrewrite <- Z_to_nat_o_Z_plus_r_reverse.\nunfold Z_inverse in |- *.Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\nintros x y Hxy.\napply sym_eq.\napply sym_eq.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equalQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverse in |- *.\nunfold Z_inverseQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\nrewrite Z_mult_distr_r; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\napply Z_to_Z.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_natQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_inverse in |- *.\nintros H.\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\napply Z_mult_reg_l with (Z_of_nat (S x)).\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_nat, Z_to_natQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succ in |- *.\nunfold Z.succQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_unit in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; case x; simpl in |- *; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; elim Hx; simpl in |- *.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H1 H2; rewrite <- (inversibleZ (Z_to_nat x)) in H1.\nrewrite <- (inversibleZ (Z_to_nat x)) in H1.\nrewrite <- (inversibleZ (Z_to_nat x)) in H2.\nrewrite <- (inversibleZ (Z_to_nat x)) in H1.\nrewrite <- (inversibleZ (Z_to_nat x)) in H2.\nrewrite <- (inversibleZ (Z_to_nat x)) in H2.\nrewrite <- (inversibleZ (Z_to_nat x)) in H2.\nrewrite <- (inversibleZ (Z_to_nat x)) in H1.\nrewrite <- (inversibleZ (Z_to_nat x)) in H2.\nrewrite <- (inversibleZ (Z_to_nat x)) in H1.\nrewrite <- (inversibleZ (Z_to_nat x)) in H1.\nrewrite <- (inversibleZ (Z_to_nat x)) in H1.\nrewrite <- (inversQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold integCNRS Fy in |- *.\nintros a b; elim a.\n(* a = b *)\nintros; right.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply f_equal.\napply fQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold integenter in |- *.\nintros x; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; case x; intros; right.\ncut (x = (-1)%Z); [ intros H1; trivial | idtac ].\nintro H1; right; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nintros x; case x; simpl in |- *.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H.\n(* pos n *)\nintros; right.\nrewrite <- (inversibleZ (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (Zpos (xI xH)))))))))) _ x))) x))) x)).\nsimpl in |- *; trivial.\napply Z_div2; trivial.\nrewrite <- (inversibleZ (Z_div2 (Z_div2 (Z_div2 (Zpos (Zpos (Zpos (Zpos (Zpos (xI (Zpos (xI xH))))) x))) x))).\nsimpl in |- *; trivial.\napply Z_div2; trivial.\nrewrite <- (inversibleZ (Z_div2 (Z_div2 (Zpos (Zpos (Zpos (xI (Zpos (xI xH))))) x))).\nsimpl in |- *; trivial.\napplyQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; elim Hx; simpl in |- *.\nintros; left; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; simpl in |- *; auto.\nintros; right.\nrewrite <- oppz; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n",
                "context_tokens": 187,
                "proof_start_offset": 546,
                "proof_end_offset": 679,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; elim (H0 x); intros; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold E; simpl in |- *; auto with *.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintro S; induction S as [| x y E S IH S IH S IH]; intros x y.\nrewrite (H (inv_comm (inv_comm x) (inv_comm y) (inv_comm x)) in H0.\ncase (inv_assoc_r_r_reverse x y); case (inv_assoc_r_reverse x y); auto.\nintros; rewrite (H0 (inv_comm y) (inv_comm x)) in H0.\ncase (inv_assoc_r_reverse x y); auto.\nintros; rewrite (H0 (inv_comm x) (inv_comm x)) in H0.\ncase (inv_assoc_r_reverse x y); auto.\nintros; rewrite (H0 (inv_comm y) (inv_comm x)) in H0.\ncase (inv_assoc_r_reverse x y); auto.\nintros; rewrite (H0 (inv_comm x)) in H0.\ncase (inv_assoc_reverse x y); auto.\nintros; rewrite (H0 (inv_comm x) (inv_comm x)) in H0.\ncase (inv_Qed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nmove=>plusE; elim: S O => // x y H; rewrite (plusE x y).\nrewrite (plusE x y).\nrewrite (plusE x y).\nauto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros S.\nrewrite (add_comm (S x)) in H0.\napply Trans with (add_comm (S x)) (add_comm x (S x)));\n [ idtac | reflexivity ].\napply Trans with (add_comm (S x)) (add_comm (S x)) (add_comm x (S x)));\n auto with *.\napply Trans with (add_comm (S x) (S x))); auto with *.\napply Trans with (add_comm x) (add_comm x (S x)));\n auto with *.\napply Trans with (add_comm x) (add_comm x)); auto with *.\napply Trans with (add_comm x) (add_comm x)); auto with *.\napply Trans with (add_comm x) (add_comm x)); auto with *.\napply Trans with (add_comm x); auto with *.\napply Trans with (add_comm x); auto with *.\napply Trans with (add_comm x); auto with *.\napply Trans with (add_comm x); auto with *.\napply Trans with (add_comm x); auto with *.\napply Trans with (add_comm x); autoQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\napply (fun (x : S) (y : S) =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y z : S =>\n   fun x y : S =>\n   fun x y : S =>\n   fun x y : S =>\n   fun xQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\nunfold op in |- *.\nauto with *.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintro S; case S; intros.\nrewrite <- H1; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; elim (zero_add_1 O); intros.\nrewrite (zero_add_1 O); rewrite (zero_add_2 O); auto with arith.\nrewrite (zero_add_1 O); auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros S x y z; elim z; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\nLemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n",
                "context_tokens": 267,
                "proof_start_offset": 760,
                "proof_end_offset": 981,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y Hx Hy; elim Hy; intros.\nrewrite <- (id_eq _ _ Hy); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H0; intros; elim (H0 O H1); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H0; intros; elim (H1 O H1); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; intros; auto.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; intros; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H1; intros; elim (H0 O H1); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H0; intros; elim (H1 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; symmetry  in |- *.\nelim H0; intros; elim (H1 O H1); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n",
                "context_tokens": 114,
                "proof_start_offset": 397,
                "proof_end_offset": 1206,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x x Hx.\nunfold is_ring in |- *.\nintros x Hx.\nelim Hx.\nintros x Hx.\nrewrite <- Hx in Hx.\nrewrite <- Hx in Hx.\nrewrite <- Hx in Hx.\napply mult_O_l with (x := x).\nassumption.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x x.\nrewrite <- plus_n_O.\napply refl_equal.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x x.\ncase (le_gt_dec x 0); intros H1; elim (le_gt_O _ H1).\nelim (le_lt_eq_dec x 0); intros H2; elim (le_gt_O _ H2).\nrewrite <- H2 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite H2 in H1.\nrewrite <- H1 in H1.\nrewrite H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in HQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intros x x.\n  elim x.\n  intros x0 H1.\n  rewrite <- (mult_comm x0).\n  rewrite (mult_comm x0).\n  apply mult_comm.\n  assumption.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x x; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\n  intro x; elim x; simpl in |- *; auto with arith.\n  rewrite plus_comm; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nsimple induction x; intros.\nelim (mult_O_Sn_O x).\nrewrite <- plus_assoc.\napply plus_comm.\napply plus_comm.\napply plus_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_commQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x H.\napply le_antisym.\napply S_pred with x.\napply le_trans with (S (S x)).\napply le_n_S.\napply le_trans with (S x).\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x H.\nrewrite H.\napply le_trans with (S x).\napply le_S_n.\napply mult_le_compat.\napply S_pred with 0.\napply mult_le_compat.\napply S_pred with 0.\napply mult_le_compat.\napply lt_O_Sn.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x x H.\nrewrite <- (mult_comm x O).\nrewrite <- (mult_comm x O).\nrewrite mult_assoc.\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_comm x O).\nrewrite (mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n",
                "context_tokens": 463,
                "proof_start_offset": 1208,
                "proof_end_offset": 1952,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H6; intros; \n clear H7 H8 H9 H10 H11 H12; intros.\nelim (H12 x O); intros; elim H8; intros; elim H9; intros; elim H5; intros;\n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H6; intros.\nelim H6; intros; elim H5; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H7; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H7; intros.\nelim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; introsQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nunfold is_ring, is_ring in |- *.\nintros x y H H0; elim H0; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n clear H6 H7 H8 H9 H10 H11 H12 H13; elim H13; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; \n elim H6; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\napply mult_O_O.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napplyQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros; apply mult_zero_l.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros.\nelim (H12 x O H14); intros; rewrite H15; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros; elim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H2; intros;\n elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros.\nelim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; \n rewrite H6; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nrewrite H1; rewrite H2; rewrite H3; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros.\nrewrite H0; rewrite H1; rewrite H2; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n",
                "context_tokens": 721,
                "proof_start_offset": 1954,
                "proof_end_offset": 2696,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nelim (H5 x0 H6).\nelim (H6 x0 H6).\nrewrite <- H3; rewrite <- H1; rewrite <- H2; rewrite <- H3; reflexivity.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; \n elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros.\nclear H2 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13.\nsplit.\nexact (H8 x y H2).\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim mult_O_O; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim (H8 (conj x H4)).\nelim (H8 (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H5)).\nelim (conj (conj x H5)).\nelim (conj (conj x H4)).\nelim (conj (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conj x H4)).\nelim (conj (conjQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nelim H3; intros; elim H4; intros.\nrewrite H4; rewrite H5; rewrite H6; reflexivity.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nclear H1 H2 H3.\nelim (H4 x x0 (mult_O_O x0 (mult_O_O x0 (mult_O_O x1 x1) (mult_O_O x1 x2) H3));\n intros; rewrite H2; rewrite H3; rewrite H4; rewrite H2; reflexivity.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nclear H H H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14.\nsplit.\nexact (H14 x x y H0 H2).\nsplit.\nexact (conj H6 x y H0 H5).\nsplit.\nexact (conj H7 y H1 H5).\nsplit.\nexact (conj H7 y H1 H7).\nsplit.\nexact (conj H7 y H1 H2 H4).\nsplit.\nexact (conj H7 y H3 H4).\nsplit.\nexact (conj H7 y H1 H5).\nsplit.\nexact (conj H7 y H3 H4).\nsplit.\nexact (conj H7 y H4 H5 H6).\nsplit.\nexact (conj H7 y H5 H6 H7).\nsplit.\nexact (conj H7 y H1 H4 H7).\nsplit.\nexact (conj H7 y H2 H5).\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros.\nclear H4 H5 H6 H7 H9 H10 H11 H12 H13.\nelim (H13 x (conj H4 x H1)); intros; rewrite H5; rewrite H5; reflexivity.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; \n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H7; intros; \n elim H9; intros; elim H8; intros; elim H9; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2698,
                "proof_end_offset": 3190,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim (H7 x H4); intros; elim H5; intros; elim H5; intros; elim H5; intros.\nclear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H17 H18.\napply (inv_zero_or_zero x y H3 H3 H4).\nrewrite (mult_comm x y0 (mult_comm x y0 (mult_comm y0 (mult_comm y0 (mult_comm x y1))) (mult_comm y0 (mult_comm x y1)));\n auto with arith.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H1; intros; elim H2; intros.\nunfold mult in |- *; apply mult_plus_distr_l with x; auto with arith.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H4; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H6; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; \n elim H11; intros; elim H12; intros; elim H11; intros; \n elim H12; intros; elim H12; intros; elim H13; intros; \n elim H12; intros; elim H13; intros; \n elim H12; intros; elim H12; intros; elim H13; intros; \n elim H12;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nclear H H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H17 H18 H19.\napply (plus_par (mult_comm x) y); auto with arith.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros.\nelim (H12 x y H1); intros; rewrite H1; rewrite H2; auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim (H5 x x0 y (conj H5 H6)); intros; rewrite H; auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H1;\n intros; elim H1; intros; elim H1; intros.\nelim (H4 x y H5); intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n apply H8; split; [ apply H8; assumption | auto with * ].\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nclear H2; elim H2; intros; elim H3; intros; elim H4; intros.\nclear H2; elim H4; intros; elim H5; intros.\nclear H2; elim H5; intros.\nelim H6; intros; elim H5; intros; elim H5; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclear H6; elim H6; intros.\nclearQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; \n intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3490,
                "proof_end_offset": 3729,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H' H'0.\nelim (le_or_lt a b); intro H'1; elim H'1; intros; elim H'1; intros; elim H'1; intros;\n elim H'2; intros; elim H'3; intros; elim H'3; intros; \n elim H'4; intros; elim H'4; intros; elim H'5; intros; \n elim H'5; intros; elim H'6; intros; elim H'6; intros; \n elim H'6; intros; elim H'6; intros; elim H'6; intros; \n elim H'6; intros; elim H'6; intros; elim H'6; intros; \n elim H'7; intros; elim H'6; intros; elim H'6; intros; \n elim H'6; intros; elim H'6; intros; elim H'6; intros; \n elim H'7; intros; elim H'8; intros; elim H'7; intros; \n elim H'8; intros; elim H'8; intros; elim H'8; intros; \n elim H'8; intros;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H3; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H6; intros; \n elim H8; intros; elim H8; intros; \n elim H6; intros; elim H7; introsQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b.\ncase (le_or_lt a 0); intros H1.\nrewrite (div_plus_zero a b H1).\nrewrite (div_plus_zero a b H1).\nrewrite (div_plus_zero a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one b a H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1).\nrewrite (div_plus_one a b H1Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros a b H; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H9; intros; elim H8; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H11; intros; \n elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H13; intros; \n elim H12; intros; elim H13; intros; elim H13; intros; \n elim H13; intros; elim H13;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; \n elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro H'.\nelim (div_O_O _ H'); intros; elim H'; intros; elim H'; intros.\nelim (div_O_O _ H'); intros; elim H'0; intros; elim H'0; intros; elim H'1; intros;\n elim H'2; intros; elim H'3; intros; elim H'4; intros;\n elim H'5; intros; elim H'5; intros; elim H'5; intros; \n elim H'6; intros; elim H'6; intros; elim H'6; intros; \n elim H'6; intros; elim H'6; intros; elim H'6; intros; \n elim H'6; intros; elim H'6; intros; elim H'7; intros; \n elim H'6; intros; elim H'6; intros; elim H'6; intros; \n elim H'7; intros; elim H'7; intros; elim H'6; intros; \n elim H'7; intros; elim H'7; intros; elim H'8; intros; \n elim H'8; intros; elim H'8; intros; elimQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\napply (div_unique_0 a b H); auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nrewrite (H1 (S q)).\nrewrite (H2 (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S q)).\nrewrite (mult_comm (S qQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H.\napply (le_trans (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) 0 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) 0 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) 0 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) 0 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) 0 (Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold not in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H12; intros; \n elim H11; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3731,
                "proof_end_offset": 4957,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H4; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H8; intros; elim H6; intros; \n elim H6; intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H13; \n intros; elim H13; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\napply div_unique with (b := b).\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H2.\nrewrite H0.\nrewrite H2.\nrewrite H0.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H3.\nrewrite H0.\nrewrite H3.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nrewrite H1.\nrewrite H3.\nrewrite H2.\nrewrite H0.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H2.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nring.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H0; intros; elim H2; intros; elim H4; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H8; intros; elim H9; intros; elim H9;\n intros; elim H10; intros; elim H11; intros; elim H10; intros; \n elim H11; intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H13; intros; elim H13; intros; \n elim H12; intros; elim H13; intros; elim H13; intros; elim H13; \n intros; elim H13; intros; elim H13; intros; elim H13; intros; \n elim H13; intros; elim H13; intros; elim H14; intros; \n elim H14; intros; elim H14; intros; elim H15; intros; \n elim H14; intros; elim H15; intros; elim H15; intros; \nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1 H2; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; \n elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros.\nrewrite H5 in H6; apply H6; split.\nexact (H8 x y H5).\nsplit. exact (H7 y H5).\nsplit. exact (H8 y H5).\nsplit. exact (H8 y H6).\nsplit. exact (H8 y H5).\nsplit. exact (H8 y H5).\nsplit. exact (H9 y H5).\nsplit. exact (H8 y H5).\nsplit. exact (H8 y H5).\nsplit. exact (H8 y H6).\nsplit. exact (H8 y H5).\nsplit. exact (H8 y H5).\nsplit. exact (H8 y H5).\nsplit. exact (H8 y H5).\nsplit. exact (H9 y H5).\nsplit. exact (HQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim (div_O_O _ H1).\nintros.\nelim (div_O_O _ H0).\nintros.\nelim (div_S_O _ H0).\nintros.\nelim (div_S_O _ H1).\nintros.\nelim (div_S_O _ H1).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelim (div_S_O _ H).\nintros.\nelimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nelim (div_or_eq _ _ H0); intros.\nelim (H0 _ H1).\nsplit. exact H11.\nsplit. exact H12.\nsplit. exact H12.\nsplit. exact H13.\nsplit. exact H12.\nsplit. exact H12.\nsplit. exact H12.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H12.\nsplit. exact H12.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H14.\nsplit. exact H13.\nsplit. exact H12.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exact H13.\nsplit. exactQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\napply div_unique with (a := a) (b := b); auto with arith.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nelim (div_eucl_unique (div_eucl a b) (div_eucl b d) H).\nintros H1 H2.\nelim (div_eucl_unique (div_eucl a b) (div_eucl b d) H1).\nintros H3.\nelim (div_eucl_unique (div_eucl b d) (div_eucl b d) H3).\nintros H4.\nelim (div_eucl_unique (div_eucl b d) (div_eucl b d) H4).\nintros H5.\nelim (div_eucl_unique (div_eucl b d) (div_eucl b d) H4).\nintros H5.\nelim (div_eucl_unique (div_eucl b d) (div_eucl b d) H5).\nintros H5.\nelim (div_eucl_unique (div_eucl b d) (div_eucl b d) H5).\nintros H5.\nelim (div_eucl_unique (div_eucl b d) (div_eucl b d) H5).\nintros H6.\nelim (div_eucl_unique (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\n(* [A d] *)\nelim H0; trivial.\nsplit.\n(* [A (a+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 4959,
                "proof_end_offset": 5659,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\nsplit.\nexact H.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nsplit.\nexact H0.\nsplit.\nexact H3.\nsplit.\nexact H1.\nsplit.\nexact H3.\nsplit.\nexact H1.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H1.\nsplit.\nexact H3.\nsplit.\nexact H1.\nsplit.\nexact H3.\nsplit.\nexact H3.\nsplit.\nexact H3.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H3.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H1.\nsplit.\nexact H3.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\napply div_unique with (a:=A) (b:=A) (B:=A) (B:=C) (B:=C) (B:=C) (B:=C).\nsplit.\nexact H2.\nsplit.\nexact H1.\nsplit.\nexact H3.\nsplit.\nexact H3.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H3.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nsplit.\nexact H4.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *.\nintros.\nelim H; intros.\nelim (H b H0); intros.\nelim (H0 b H1); intros.\nelim (H3 (H0 b H2)); intros.\nelim (H2 (H4 b H2)); intros.\nelim (H4 (H0 b H2)); intros.\nelim (H5 (H5 b H3)); intros.\nelim (H5 (H6 b H2)); intros.\nrewrite H6.\nelim (H6 b H3); intros.\nelim (H7 b H3); intros.\nelim (H7 b H4); intros.\nelim (H8 b H5); intros.\nelim (H6 b H5); intros.\nelim (H8 b H6); intros.\nelim (H7 b H8); intros.\nelim (H7 b H8); intros.\nelim (H8 b H5); intros.\nelim (H8 b H8); intros.\nelim (H8 b H8); intros.\nelim (H8 b H8); intros.\nelim (H8 b H8); introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\nsplit.\n(* [a+b] *)\nelim H.\n(* [a+b] *)\nelim H0; intros.\nrewrite <- H0 in H1.\nelim (H0 a H1).\nrewrite <- H1 in H1.\nelim (H0 b H1).\nrewrite <- H0 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H0 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- H1 in H1.\nrewrite <- HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros.\nelim (H3 a H4).\nelim (H0 a H4).\nelim (H0 a H5).\nelim (H0 a H4).\nelim (H0 a H4).\nelim (H0 a H4).\nelim (H1 (H1 a H5)).\nelim (H0 a H4).\nelim (H0 a H4).\nelim (H0 a H4).\nelim (H1 a H5).\nelim (H1 (H1 a H4)).\nelim (H1 (H0 a H4)).\nelim (H0 a H4).\nelim (H0 a H4).\nelim (H1 a H5).\nelim (H0 a H4).\nelim (H0 a H5).\nelim (H1 a H4).\nelim (H1 a H4).\nelim (H1 a H5).\nelim (H0 a H5).\nelim (H1 a H5).\nelim (H1 a H5).\nelimQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H_le H_le_compat_l with (A := B).\nsplit.\n(* [A] *)\nelim (H_le_or_lt _ _ H_le_compat_l (A := A) (B := A) (B := C).\nelim (H_le_or_lt _ _ H_le_compat_l (A := B) (B := C)).\nintros H1 H2; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0.\nelim H0; intros; elim H0; intros.\nelim H1; intros.\nelim (H1 a H2); intros.\nelim (H2 (H3 (Mult a b) d H0 H1 H2)).\nelim H2; intros.\nelim (H4 (H2 a b H2)); intros.\nelim (H4 (H2 (Mult a b) d H0 H2)).\nelim (H6 (H7 a b H2)).\nelim (H7 (H2 (Mult b c) d H0 H2)).\nelim (H7 (H8 (Mult b c) d H2 H0 H3)).\nelim (H8 (H9 (Mult b c) d H2)).\nelim (H8 (H8 (Mult b c) d H0 H2)).\nelim (H8 (H9 (Mult b c) d H2 H3)).\nelim (H9 (H10 (Mult b c) d H2 H3)).\nelim (H8 (H9 (Mult c c) d H2 H3)).\nelim (H9Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\napply div_unique with (a*b) (a*b) (a*b).\nsplit.\napply div_unique with (a*b) (a*b).\nsplit.\napply div_unique with (a*b) (b*a).\nsplit.\napply div_unique with (b*a).\nsplit.\napply div_unique with (b*b) (a*b).\nsplit.\napply div_unique with (a*b) (b*a).\nsplit.\napply div_unique with (b*a).\nsplit.\napply div_unique with (b*a).\nsplit.\napply div_unique with (b*b).\nsplit.\napply div_unique with (b*a).\nsplit.\napply div_unique with (b*a).\napply div_unique with (b*a).\nsplit.\napply div_unique with (b*a).\napply div_unique with (b*a).\nsplit.\napply div_unique with (b*b).\nsplit.\napply div_unique with (b*a).\nsplit.\napplyQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold is_equiv in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros.\nelim (H2 b H3); intros.\nelim (H3 b H4); intros.\nelim (H0 b H5); intros.\nelim (H0 b H5); intros.\nelim (H0 b H5); intros.\nelim (H2 b H6); intros.\nelim (H3 b H6); intros.\nelim (H1 b H6); intros.\nelim (H2 b H6); intros.\nrewrite H2.\nelim (H3 b H6); intros.\nrewrite H2.\nelim (H2 b H6); intros.\nelim (H2 b H6); intros.\nrewrite H4.\nelim (H3 b H6); intros.\nrewrite H5.\nelim (H3 b H6); intros.\nelim (H3 b H6); intros.\nelim (H6 b H6); intros.\nrewrite H4.\nelim (H6 b H7); intros.\nrewrite H6.\nelim (H6 b H7Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\n(* [a|b] *)\nelim H; intros.\nelim H0; intros.\nrewrite H0.\nelim (H0 b H0).\nrewrite H2.\nrewrite H3.\nrewrite <- H4.\nrewrite <- H5.\nrewrite <- H.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H2.\nrewrite H3.\nrewrite H3.\nrewrite <- H3.\nrewrite <- H0.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H4.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 5661,
                "proof_end_offset": 6477,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a|a] *)\nelim H; intros.\n(* x=0 *)\nelim H; intros.\nelim H; intros.\napply (H2 (a*b) (a*d)); auto with arith.\nelim H; intros.\napply (H2 (a*d)); auto with arith.\n(* x=0 *)\nelim H; intros.\napply (H2 (a*d) (a*d)); auto with arith.\n(* x=0 *)\nelim H0; intros.\napply (H2 (a*d)); auto with arith.\n(* x=0 *)\nelim H; intros.\napply (H2 (a*d)); auto with arith.\n(* x=0 *)\nelim H0; intros.\napply (H2 (a*d)); auto with arith.\n(* x=0 *)\nelim H0; intros.\napply (H (a*d)); auto with arith.\n(* x=0 *)\nelim H0; intros.\napply (H (a*d)); auto with arith.\n(* x=0 *)\nelim H0;Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a=0] *)\nelim H; intros.\n(* a=0 /\\ b=0 /\\ d=0 *)\nelim H; intros.\n(* a=0 /\\ b=0 /\\ d=0 *)\nelim H; intros.\n(* a=0 /\\ d=0 /\\ d=0 *)\nelim H; intros.\n(* a=0 /\\ b=0 /\\ d=0 *)\nelim H; intros.\n(* a=0 /\\ b=0 *)\nelim H0; intros.\n(* a=0 /\\ b=0 /\\ d=0 *)\nelim H; intros.\n(* a=0 /\\ b=0 /\\ b=0 *)\nelim H0; intros.\n(* a=0 /\\ b=0 /\\ d=0 *)\nelim H0; intros.\n(* a=0 /\\ b=0 /\\ c=0 /\\ d=0 *)\nelim H0; intros.\n(* a=0 /\\ b=0 /\\ c=0 /\\ b=0 *)\nelim H1; intros.\n(* a=0 /\\ b=0 /\\ b=0 /\\ c=0 *)\nelim H2Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a|a] *)\nelim H; intros.\nelim H; intros.\nclear H.\nelim H; intros.\napply H; split.\napply (H0 (A:=fun x : Z => in_dom_comp x (A:=A)) x).\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply in_dom_comp; assumption.\napply inQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros.\nelim H; intros.\n(* [a=0] *)\nelim (H0 _ H).\n(* [b=0] *)\nelim (H0 _ H).\n(* [b=0] *)\nelim (H0 _ H).\n(* [b=0] *)\nelim (H0 _ H).\n(* [b=0] *)\nelim (H1 _ H).\n(* [b=0] *)\nelim (H0 _ H).\n(* [b=0] *)\nelim (H1 _ H).\n(* [b=0] *)\nelim (H1 _ H).\n(* [b=0] *)\nelim (H1 _ H); intros.\n(* [b=0] *)\nelim (H1 _ H).\n(* [b=0] *)\nelim (H2 _ H).\n(* [b=0] *)\nrewrite (H2 _ H1).\n(* [b=0] *)\nelim (H1 _ H).\n(* [c=0] *)\nelim (H2 _Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a = 0] *)\nelim H; intros.\nrewrite <- (mult_0_r a) at 1.\nelim H; intros.\nelim (mult_O_eq a a0 b H0); intros.\nelim (mult_O_eq b a0 b H0); intros.\nrewrite <- (mult_0_r b0) at 1.\nrewrite <- (mult_plus_distr_r b0) at 1.\nrewrite (mult_assoc b0 b0).\nrewrite (mult_comm a0).\nrewrite (mult_comm a0).\nrewrite (mult_comm b0).\nrewrite (mult_comm a0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0).\nrewrite (mult_comm b0Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a|a] *)\nelim H0; intros.\n(* a=0,a=0,a=0,b=0,a=0,b=0, d*q *)\nelim H0; intros.\n(* a=0,a=0,a=0,a=0,b=0 *)\nelim H; intros.\n(* a=0,b=0,a=0,b=0, d=0 *)\nelim H; intros.\n(* a=0,a=0,b=0 *)\nelim H; intros.\n(* a=0,a=0,a=0 *)\nelim H; intros.\n(* a=0,a=0,a=0,b=0,0 *)\nelim H; intros.\n(* a=0,a=0,a=0,a=0,b=0 *)\nelim H; intros.\n(* a=0,a=0,a=0,b=0 *)\nelim H; intros.\n(* a=0,a=0,b=0, a=0, bQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H; elim H; intros.\n(* [a=0] *)\nelim H; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H0; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H0; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H1; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H1; intros.\n(* a=0 *)\nelim H0; intros.\n(* a=0 *)\nelim H0; intros.\n(* a=0 *)\nelim H; intros.\n(* a=0 *)\nelim H1; intros.\n(* a=0 *)\nelim H1; intros.\n(* a=0 *)\nelim H1; intros.\n(* aQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *.\nintros.\nelim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H2 H3).\nelim (H4 H5).\nelim (H4 H5).\nelim (H5 H6).\nelim (H6 H6).\nrewrite (H7 d x0 d).\nrewrite <- H1.\napply gcd_opp; assumption.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a = 0] *)\nelim H; intros.\n(* a = 0 *)\nelim H; intros.\n(* a = 0 *)\nelim H0; intros.\n(* a = 0 *)\nelim H; intros.\n(* a = 0 *)\nrewrite H1; rewrite H2; reflexivity.\n(* a = 0 *)\nelim H0; intros.\n(* a = 0 *)\nrewrite H1; rewrite H2; reflexivity.\n(* a = 0 *)\nrewrite H1; rewrite H2; reflexivity.\n(* a = 0 *)\nelim H0; intros.\n(* a = 0 *)\nelim H0; intros.\n(* a = 0 *)\nrewrite H1; reflexivity.\n(* a = 0 *)\nrewrite H2; reflexivity.\n(* a = 0 *)\nelim H0; intros.\n(* a = 0 *)\nrewrite H1; reflexivity.\n(* a = 0 *)\nelim H0; intros.\n(* a = 0 *)\nrewrite H2; reflexivity.\n(* a = 0 *)\nelim H0; intros.\n(* a = 0 *)\nrewrite H2; reflexivity.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [a*a] *)\nelim H; intros.\nrewrite <- H0.\nelim (mult_O_le_or _ _ H).\nrewrite <- H.\nelim (mult_O_le_or _ _ H).\nrewrite <- H0.\nelim (mult_O_le_or _ _ H).\nrewrite <- H0.\nelim (mult_O_le_or _ _ H).\nrewrite <- H.\nelim (mult_O_le_or _ _ H).\nrewrite <- H0.\nrewrite <- H1.\nelim (mult_O_le_or _ _ H).\nrewrite <- H.\nelim (mult_O_le_or _ _ H).\nrewrite <- H0.\nelim (mult_O_le_or _ _ H).\nrewrite <- H0.\nelim (mult_O_le_or _ _ H).\nrewrite <- H0.\nelim (mult_O_le_or _ _ H).\nrewrite <- H0.\nelim (mult_O_le_or _ _ H).\nrewrite <- H.\nelim (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6601,
                "proof_end_offset": 6974,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim H; intros.\nelim H0; intros.\nelim H2; intros.\nrewrite H2.\nelim H1; intros.\napply H3.\nrewrite <- H2.\nrewrite <- H4.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H1.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H3.\nrewrite H4.\nrewrite <- H1.\nrewrite <- H4.\nrewrite H3.\nrewrite <- H4.\nrewrite <- H1.\nrewrite <- H4.\nrewrite <- H4.\nrewrite H4.\nrewrite <- H4.\nrewrite H3.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H3.\nrewrite H3.\nrewrite <- H3.\nrewrite <- H4.\nrewrite H1.\nrewrite <- HQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nrewrite <- gcd_abs; trivial.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold divide in |- *; intros.\ncase (gcd_spec a b H0); intros.\nsplit.\nexact (H a H0 H1).\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto with *.\napply gcd_intro with b; auto withQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\napply gcd_intro with (a' := a').\nelim H; intros.\nelim (gcd_gt_0 a' H0); intros.\nrewrite H0.\nelim (gcd_gt_0 a' H0); intros.\nsplit. exact (gcd_0_l a' H1).\napply gcd_gt_0; assumption.\nrewrite H0.\nelim (gcd_gt_0 a' H0); intros.\nsplit. exact (gcd_0_l b' H1).\nsplit. exact (gcd_0_r b' H2).\nsplit. exact (gcd_0_l b' H0).\nsplit. exact (gcd_0_r b' H1).\nsplit. exact (gcd_0_l b' H1).\nsplit. exact (gcd_0_r b' H1).\nsplit. exact (gcd_0_l b' H1).\nsplit. exact (gcd_0_l b' H2).\nsplit. exact (gcd_0_l b' H1).\nsplit. exact (gcd_0_l b' H2).\nsplitQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\nassert (H0 : forall q : S, gcd a b -> a = q).\n apply gcd_intro; split; auto.\n intros q H1.\nelim H1; intros; elim H1; intros. \nrewrite <- H0.\napply gcd_intro.\nrewrite <- H1.\napply gcd_intro.\nrewrite <- H2.\napply gcd_intro.\nrewrite <- H1.\napply gcd_intro.\nrewrite <- H2.\napply gcd_intro.\nrewrite <- H3.\napply gcd_intro.\nrewrite <- H1.\napply gcd_intro.\nrewrite <- H3.\napply gcd_intro.\nrewrite <- H4.\napply gcd_intro.\nrewrite <- H4.\napply gcd_intro.\nrewrite <- H4.\napply gcd_intro.\nrewrite <- H1.\napply gcd_intro.\nrewrite <- H4.\napply gcd_intro.\nrewrite <- H4.\napply gcd_intro.\nrewrite <- H4.\napply gcd_intro.\nrewrite <- H4.\napply gcd_intro.\nrewrite <- H4.Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold divide in |- *; intros.\nelim (gcd_eq_0_0_l a b H0); intros.\nrewrite H0 in H.\nelim (gcd_eq_0_l a b H0); intros.\nrewrite H1 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H1 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H1 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H0 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H1 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H0 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H1 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H1 in H.\nelim (gcd_eq_0_l b b H0); intros.\nrewrite H1 in H.\nelim (Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H0 H1.\napply gcd_eq; intros.\nrewrite H0.\napply gcd_sym.\nrewrite H1.\napply gcd_sym.\nrewrite <- H2.\napply gcd_sym.\nrewrite <- H0.\napply gcd_sym.\nrewrite <- H2.\napply gcd_sym.\nrewrite <- H2.\napply gcd_sym.\nrewrite <- H2.\napply gcd_sym.\nrewrite <- H1.\napply gcd_sym.\nrewrite <- H2.\napply gcd_sym.\nrewrite <- H0.\napply gcd_sym.\nrewrite <- H3.\napply gcd_sym.\nrewrite <- H1.\napply gcd_sym.\nrewrite <- H2.\napply gcd_sym.\nrewrite <- H3.\napply gcd_sym.\nrewrite <- H3.\napply gcd_sym.\nrewrite <- H4.\napply gcd_sym.\nrewrite <- H1.\napply gcd_sym.\nrewrite <- H4.\napply gcd_sym.\napply gcd_sym.\nrewrite <- H3.\napply gcd_sym.\nrewrite <- HQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd, is_gcd; intros.\nelim H; intros.\nrewrite <- (inj_abs_divide a a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewrite <- (inj_abs_divide a b H).\nrewriteQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H.\nelim H; intros.\nrewrite H1.\nrewrite <- H.\nrewrite <- H.\nrewrite (gcd_0 a b).\nrewrite (gcd_0 b a).\nrewrite (gcd_0 b a).\nrewrite (gcd_comm a b).\nrewrite (gcd_comm a b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm a b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).\nrewrite (gcd_comm b b).Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\napply gcd_is_gcd; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6976,
                "proof_end_offset": 7247,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim (is_gcd_spec_for_euclid_aux a b d H H1); intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nsplit. exact H3.\nelim H1; intros.\nsplit. exact H3.\nsplit. exact H4.\nintros.\nsplit. exact H4.\nelim H1; intros.\nsplit. exact H3.\nelim H2; intros.\nsplit. exact H4.\nsplit. exact H4.\nelim H4; intros.\nsplit. exact H5.\nelim H5; intros.\nsplit. exact H4.\nsplit. exact H5.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H5.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.\nsplit. exact H4.Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros.\nelim H1; intros; elim H1; intros.\nsplit. exact (H0 d H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim (is_gcd_spec (gcd a d)); intro.\nelim (is_gcd_spec (gcd a d)); intro.\nelim (is_gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (gcd_spec (gcd a d)); intro.\nelim (Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros.\nelim (gcd_0_l _ _ H1); intros.\nelim (gcd_0_l _ _ H1); intros.\nelim (gcd_0_l _ _ H1); intros.\nelim (gcd_0_l _ _ H1); intros.\nsplit.\nexact (gcd_0_l _ _ H2).\nelim (gcd_0_l _ _ H1); intros.\nelim (gcd_0_l _ _ H1); intros.\nsplit.\nexact (gcd_0_r _ _ H2).\nelim (gcd_0_l _ _ H2); intros.\nelim (gcd_0_l _ _ H3); intros.\nsplit.\nexact (gcd_0_l _ _ H1).\nelim (gcd_0_l _ _ H1); intros.\nsplit.\nexact (gcd_0_l _ _ H3).\nsplit.\nexact (gcd_0_l _ _ H1).\nsplit.\nexact (gcd_0_l _ _ H1).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim (is_gcd_spec a b); intros.\nelim (is_gcd_spec a b); intros.\nelim (is_gcd_spec b b); intros.\nelim (is_gcd_spec b b); intros.\nelim (is_gcd_spec b b); intros.\nelim (is_gcd_spec b a); intros.\nelim (is_gcd_spec b a); intros.\nelim (is_gcd_spec b a); intros.\nelim (is_gcd_spec b a); intros.\nrewrite H0 in H.\nelim (is_gcd_spec b a); intros.\nrewrite H0 in H.\nelim (is_gcd_spec b a); intros.\nrewrite H in H.\nelim (is_gcd_spec b a); intros.\nrewrite H in H.\nelim (is_gcd_spec b a); intros.\nrewrite H1 in H.\nelim (is_gcd_spec b a); intros.\nrewrite H0 in H.\nelim (is_gcd_spec b a); intros.\nrewrite H in H.\nelimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nelim H0; intros.\nelim (gcd_not_eq _ _ H1); intros.\napply (gcd_0_l b d H H0).\nelim (gcd_not_eq _ _ H1); intros.\napply (gcd_0_r b d H H0).\nrewrite (gcd_0_l b d H0).\nrewrite (gcd_0_r b d H1).\nrewrite (gcd_0_r b d H0).\nrewrite (gcd_0_l b d H1).\nrewrite (gcd_0_r b d H1).\nrewrite (gcd_0_l b d H0).\nrewrite (gcd_0_l b d H1).\nrewrite (gcd_0_r b d H1).\nrewrite (gcd_0_r b d H0).\nrewrite (gcd_0_l b d H1).\nrewrite (gcd_0_l b d H0).\nrewrite (gcd_0_l b d H0).\nrewrite (gcd_0_l b d H0).\nrewrite (Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nsplit. exact H6.\nelim H7; intros.\nsplit. exact H7.\nsplit. exact H7.\nelim H8; intros.\nsplit. exact H7.\nelim H8; intros.\nsplit. exact H8.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros.\nelim (gcd_0_or_eq _ _ H0); intros.\nsplit. exact (gcd_0_iff _ _ H2).\nelim (gcd_0_or_eq _ _ H0); intros.\nsplit. exact (gcd_0_iff _ _ H2).\nelim (gcd_0_or_eq _ _ H2); intros.\nsplit. exact (gcd_0_iff _ _ H1).\nelim (gcd_0_or_eq _ _ H2); intros.\nsplit. exact (gcd_0_iff _ _ H2).\nelim (gcd_0_or_eq _ _ H1); intros.\nsplit. exact (gcd_0_iff _ _ H2).\nelim (gcd_0_or_eq _ _ H1); intros.\nsplit. exact (gcd_0_iff _ _ H2).\nelim (gcd_0_or_eq _ _ H2); intros.\nsplit. exact (gcd_0_iff _ _ H2).\nsplit. exact (gcd_0Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nintros; elim H0; intros; elim H1; intros; elim H1; intros.\nsplit. exact H6.\nelim (gcd_0_r (gcd a b) 0 H).\nelim (gcd_0_r (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nelim (gcd_0_l (gcd a b) 0 H).\nintros; elim H0; intros; elim H1; intros; elim HQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\n unfold is_gcd in |- *; intros.\nelim H; intros.\nelim H; intros; elim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 7249,
                "proof_end_offset": 8153,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros.\nelim (H0 O (div_0_O H1)); intros; elim H2; intros.\nelim H2; intros.\nrewrite H3 in H2.\nelim H2; intros.\nrewrite H1 in H2.\nelim (H2 O (div_S_O H1)); intros; elim H3; intros.\nrewrite H2 in H2.\nelim (H2 (S (div_S_O H1) (div_S_O H2) H3)); intros; elim H4; intros.\nrewrite H4 in H2.\nelim (H4 (S (div_S_O H1) (div_S_O H3) H4)); intros; elim H4; \n intros.\nrewrite H4 in H2.\nelim (H4 O (div_S_O H1) (div_S_O H2) (div_S_O H3) (S (div_S_O H4) H4));\n intros; elim H5; intros.\nrewrite H6 in H2Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\ncase H; intros.\nelim (H1 a H0); intros.\nelim (H1 a H2); intros.\nelim H2; intros.\nrewrite H2; rewrite H2; reflexivity.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_inv in |- *; intros.\nelim H; intros.\nelim (lt_irrefl _ H); intros.\nelim (H x H0); intros.\nelim H; intros.\nrewrite H2; rewrite H0; reflexivity.\n\nelim (le_not_le _ _ H); intros.\nrewrite H3; reflexivity.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_mult in |- *; intros.\nelim H; intros.\nelim H0; intros.\nelim (H0 _ H1); intros.\nrewrite (mult_comm a x).\nelim (H0 _ H2); intros.\nrewrite (mult_comm a x0).\nrewrite (mult_comm a x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm a x0).\nrewrite (mult_comm a x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0).\nrewrite (mult_comm b x0Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros.\nelim (H0 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S S (S (S n)))))))))) m x))) 0) 0) 0) 0) 0).\napply eq_ind; intros.\nrewrite H2 in H0; inversion H0.\nrewrite H2 in H0; inversion H0.\nrewrite H3 in H0; inversion H0.\nrewrite H3 in H0; inversion H0.\nrewrite H3 in H0; inversion H0.\nrewrite H3 in H0; inversion H0.\nrewrite H3 in H0; inversion H0.\nrewrite H3 in H0; inversion H0.\nrewrite H3 in H0; inversion HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_div in |- *. intros.\nelim H; intros.\nelim (le_gt_dec 0 x); intros.\nelim (le_gt_dec 0 x); intros.\nelim (le_gt_dec 0 x); intros.\nelim (le_gt_dec 0 x); intros.\nrewrite H1.\nrewrite <- H1; rewrite <- H2; rewrite <- H3; rewrite <- H4; reflexivity.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold Is_div in |- *; intros.\nelim H0; intros.\nelim H1; intros.\nelim (H0 O (div_0_O H) (div_1_O H)); intros; elim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim (H1 O (div_1_O H0) (div_S_O H0) (div_S_O H0) H5); intros; elim H6;\n intros.\nelim H8; intros.\nelim H8; intros.\nelim (H4 O (div_S_O H0) (div_S_O H4) (div_S_O H4)); intros; elim H6;\n intros.\nelim H8; intros.\nelim (H9 (S n) H6); intros.\nelim (H9 (S n) H6); intros.\nsplit.\nexact (div_S_O H4) (div_S_O H4) (div_S_O H5) H6).\n\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_div in |- *. intros.\nelim H0; intros.\nelim H1; intros.\nelim (H2 (A:=A) H2); intros; elim H2; intros.\nelim (H2 (A:=A) H3); intros; elim H4; intros.\nsplit.\nexact (H (B:=A) H2).\nelim (H3 (B:=A) H4); intros; elim H5; intros; elim H6; intros.\nsplit.\nexact (H (B:=A) H1).\nelim (H4 (B:=A) H4); intros; elim H5; intros.\nsplit.\nexact (H (B:=A) H2).\nelim (H4 (B:=A) H4); intros; elim H5; intros.\nsplit.\nexact (H (B:=A) H2).\nelim (H (B:=A) H4); intros; elim H5; intros.\nsplit.\nexact (H (B:=A) H4).\nsplit.\nexact (H (B:=A) H4).\nelim (H4 (B:=Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_rel in |- *; intros.\nelim H; intros.\nelim (H0 x H); intros.\nrewrite <- H1; apply H; apply H0.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nunfold Val in |- *; intros.\nelim H; intros.\nelim (H0 O (div_O_O H0)).\nelim (H1 O (div_O_O H0)).\nelim (H1 O (div_O_O H0)).\nelim (H0 O (div_S x)).\nelim (H2 O (div_S x)).\nelim (H1 O (div_S x)).\nelim (H2 O (div_S x)).\nelim (H0 (S x)).\nelim (H2 O (div_S x)).\nelim (H2 (S x)).\nelim (H2 (S x)).\nelim (H2 (S x)).\nelim (H3 (S x)).\nelim (H2 (S x)).\nelim (H4 (S x)).\nelim (H4 (S x)).\nelim (H4 (S x)).\nelim (H4 (S x)).\nelim (H4 (S x)).\nelim (H4 (S x)).\nelim (H4 (S x)).\nelim (H4 (S x)).\nelim (H4Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "rewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n",
                "context_tokens": 684,
                "proof_start_offset": 8155,
                "proof_end_offset": 9563,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros.\nelim (H0 x H1); intros.\nelim (H x H2).\nintros; elim H3; intros.\nrewrite H5; rewrite H5; rewrite H6; rewrite H6; reflexivity.\n\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros a b d1 d2 H1 H2 H3.\nelim H1; intros; elim H2; intros.\napply (H3 (H4 (H5 (H6 H7))) (H8 (H8 H9))).\napply (H6 (H7 (H8 (H9 H9)))) with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))))))))))\n   (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))))))))))))\n   (S (S (S (S (S (Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H; intros.\nelim (H0 (H2 a)).\nrewrite <- H1; rewrite <- H2; rewrite <- H1; auto.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\ncut (exists x : S, invR x /\\ invR x /\\ invR x /\\ invR x /\\ invR x /\\ invR x /\\ invR x).\nelim H; intros.\nelim H0; intros; elim H1; intros.\nelim (H1 x H2); intros.\nelim (H3 x H3); intros.\nelim (H5 x H5); intros.\nelim (H6 x H6); intros.\nelim (H6 x H6); intros.\nelim (H6 x H7); intros.\nelim (H7 x H6); intros.\nelim (H8 x6); intros.\nelim (H8 x6 H7); intros.\nelim (H8 x6 H7); intros.\nelim (H8 x6 H7); intros.\nelim (H7 x8 H7); intros.\nelim (H8 x8 H8); intros.\nelim (H8 x8 H9); intros.\nelim (H8 x8 H9); intros.\nelim (H9 x9); intros.\nelim (H9 x9); intros.\nelim (HQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim (H0 a b H0); intros; elim H1; intros.\nelim (H0 a0 b H1); intros; elim H2; intros.\nelim (H2 b0 H2); intros; elim H3; intros.\nelim H4; intros.\nelim (H3 b0 H5); intros; elim H6; intros.\nrewrite H5; rewrite H6; rewrite H6; rewrite H6; reflexivity.\n\nelim (H0 b0 H5); intros; elim H6; intros.\nrewrite H5; rewrite H6; rewrite H6; rewrite H6; reflexivity.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros.\nelim H1; intros; elim H2; intros.\nelim (H3 (H0 x)); intros.\nelim (H4 (H2 x)); intros.\nrewrite H1; rewrite H2; rewrite H3; rewrite H4; reflexivity.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim (H0 (is_gcd_divisors a b d1)); intros.\nelim (H1 (is_gcd_divisors a b d1)); intros.\nrewrite H1; rewrite H2; rewrite H3; rewrite H1; reflexivity.\n\nelim (H1 (is_gcd_divisors a b d1)); intros.\nelim (H2 (is_gcd_divisors a b d1)); intros.\nrewrite H2; rewrite H3; rewrite H2; rewrite H3; reflexivity.\n\nelim (H1 (is_gcd_divisors a b d1)); intros.\nrewrite H2; rewrite H3; rewrite H3; rewrite H3; reflexivity.\n\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros a b d1 d2.\nelim (is_gcd_divisors a b d1); intros.\nexists (1 + b).\nrewrite <- H1.\nrewrite <- H2.\nrewrite (mult_comm (mult_comm a b d1)).\nrewrite (mult_comm (mult_comm b d1)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm b d1)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewrite (mult_comm (mult_comm d1 d2)).\nrewriteQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *. intros.\nelim H; intros; elim H; intros.\nelim (H0 x H0); intros.\nelim (H x H0); intros.\nelim (H0 x H0); intros.\nelim (H0 x H1); intros.\nelim (H1 x H0 H1); intros.\nelim (H0 x H2); intros.\nelim (H x H1 H3); intros.\nelim (H0 x H1); intros.\nelim (H x H2); intros.\nelim (H0 x H3); intros.\nelim (H0 x H3); intros.\nelim (H0 x H3); intros.\nelim (H1 x H4); intros.\nelim (H2 x H5); intros.\nelim (H2 x H4); intros.\nelim (H4 x H5); intros.\nelim (H5 x H6); intros.\nelim (H5 x6); intros.\nelim (H7 x8); intros.\nelim (H7 x8); intros.\nelim (H6 x8); intros.\nelim H7Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros a b d1 d2 H H0; elim H; intros.\nelim H0; intros.\nelim (H0 a (S b) (S d1) H1); intros.\nelim (H1 (S d1) (S d2) H2); intros.\nelim (H3 (S d1) H2); intros.\nelim (H4 (S d1) H4); intros.\nelim H5; intros.\nelim (H6 (S d2) H5); intros.\nelim (H6 (S d2) H6); intros.\nelim (H7 (S d2) H6); intros.\nelim (H6 (S d2) H6); intros.\nelim H8; intros.\nelim (H6 (S d1) H6); intros.\nelim (H6 (S d1) H6); intros.\nelim (H7 (S d2) H6); intros.\nelim (H8 (S d2) H6); intros.\nelim (H8 (S d1) H7); intros.\nelim (H9 (S d2)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* [d2 = O] *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* [d2 <> 0] *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* [d1 <> 0] *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 9565,
                "proof_end_offset": 9774,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros.\nelim (H H1); intros.\nelim (H2 H2); intros.\nelim H3; intros.\nelim (H3 H1); intros.\nrewrite H4.\nrewrite H4.\nrewrite H1.\nrewrite H4.\nrewrite H5.\nrewrite H3.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H5.\nrewrite H3.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H5.\nrewrite H5.\nrewrite H6.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H3.\nrewrite H4.\nring.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H; intros.\nelim H; intros.\nrewrite H0; rewrite H1; rewrite H2; reflexivity.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nsplit; [ exact H | exact H0 ].\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros; elim x; intros; elim x; intros; elim x0; intros; elim x1; intros.\nelim H; intros; elim H2; intros.\nelim H3; intros; elim H4; intros.\nelim H5; intros; elim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nrewrite H8.\nelim H7; intros.\nrewrite H8.\nelim (H6 (conj H7 H7)); intros.\nrewrite H8.\nelim H7; intros; elim H8; intros.\nrewrite H9.\nelim (H7 (conj H8 H9)); intros.\nrewrite H9.\nelim (H8 (conj H8 H9)); intros.\nrewrite H10.\nelim (H8 (conj H8 H10)); intros.\nrewrite H10.\nelim (H10 (conj H11 H12)); intros.\nrewrite H10.\nelim (conj H8 (conj H8 H9)); intros.\nrewrite H10.\nelim (H12 (conj H10 H12));Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nrewrite H5.\nrewrite H6.\nelim (H0 a H5).\nrewrite H7.\nelim (H8 a H5).\nrewrite H7.\nrewrite H8.\nrewrite H9.\nelim (H4 a H5).\nrewrite H7.\nrewrite H9.\nelim (H4 a H5).\nrewrite H5.\nelim (H6 b H6).\nrewrite H6.\nelim (H6 b H5).\nrewrite H8.\nelim (H4 a H5).\nrewrite H9.\nelim (H6 b H5).\nrewrite H7.\nelim (H6 b H5).\nrewrite H6.\nelim (HQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros.\nsplit; [ exact (opp_O _ _ H1) | auto with arith ].\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros.\nelim (H H1); intros.\nelim H2; intros.\nelim (H H2); intros.\nelim (H1 H2); intros.\nelim H4; intros.\nelim (H1 H4); intros.\nelim H5; intros.\nelim (H5 H5); intros.\nelim (H6 H7); intros.\nelim (H6 H8); intros.\nelim H6; intros.\nelim (H7 H8); intros.\nelim H9; intros.\nelim (H8 H8); intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim (H9 H9); intros.\nelim H12; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim (H9 H10); intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H12; intros.\nelim H14; intros.\nelim H13;Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H0; intros; elim H0; intros; elim H1; intros.\nsplit.\nelim (H0 x); intros; elim H2; intros.\nsplit.\nelim (H2 x); intros; elim H3; intros.\nsplit.\nelim (H3 x); intros; elim H5; intros.\nsplit.\nelim (H2 x); intros; elim H5; intros.\nsplit.\nelim (H2 x); intros; elim H5; intros.\nsplit.\nelim (H3 x); intros; elim H5; intros.\nsplit.\nelim (H4 x); intros; elim H5; intros.\nsplit.\nelim (H4 x); intros; elim H6; intros.\nsplit.\nelim (H5 x); intros; elim H5; intros.\nsplit; elim H5; intros.\nsplit.\nelim (H6 x); intros; elim H6; intros.\nsplit.\nelim (H8 x); intros.\nsplit.\nelim (H8 x); intros; elim H6; intros.\nsplit; elim H6; intros.\nsplit.Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nrewrite H4 in H1; elim H3; intros.\nrewrite H5 in H2; elim H3; intros.\nrewrite H5 in H2; elim H3; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H4; intros.\nrewrite H5 in H3; elim H3; intros.\nrewrite H5 in H3Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros.\nelim H2; intros.\nelim H2; intros.\nelim H4; intros.\nelim H4; intros.\nrewrite H4.\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nrewrite (plus_comm x0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nintros A P H x.\nexact (H x).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x H0; elim H0; auto.\nintros A H0 H1; elim H1; auto.\nintros A H1 H2; elim H1; auto.\nintros A H1 H2; elim H2; auto.\nintros A H1 H2; elim H2; auto.\nintros A H2 H3; elim H2; auto.\nintros A H3 H4; elim H3; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P.\n  exact (H (fun x y => H (fun y => H (H x))).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H0.\nexact H0.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P.\n  elim (classic (P (fun x : A => P x)) (classic (P (fun x : A => P x))) H0).\n  intro x; elim H1; intro.\n  apply H1; assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x0 H1.\n  cut (forall x : A, R x x -> P x).\n  intro H2.\n  elim H1; intro.\n  cut (forall x : A, R x x -> P x).\n  intro H3.\n  elim H3; intro.\n  rewrite H4 in H1.\n  cut (forall x : A, R x x -> P x).\n  intro H4.\n  elim H5; intro.\n  rewrite H5 in H1.\n  cut (forall x : A, R x x -> P x).\n  intro H5.\n  apply H4.\n  assumption.\n  apply H5.\n  assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H.\n  elim H; intro H0; elim H0; intro H1;\n    [ intro H2; elim (H2 x); assumption\n      | intro H3; elim (H3 x); assumption ].\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intro A; red in |- *; intros.\n  elim (H x); intros.\n  elim H1; intros.\n  elim H2; intros.\n  apply H1; assumption.\n  elim H2; intros.\n  apply H2; assumption.\n  elim H2; intros.\n  apply H2; assumption.\n  elim H3; intros.\n  elim H3; intros.\n  apply H3; assumption.\n  elim H3; intros.\n  elim H4; intros.\n  apply H4; assumption.\n  elim H3; intros.\n  apply H4; assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition pi2 : forall (A : Set) (R : A -> A -> Prop),\n  (forall x y : A, R x y -> R x y) -> forall x : A, R x y -> R x y.\nintros A R H x H'.\nelim H'; intros.\napply H'.\napply H'.\nexact H'.\nexact H'.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nintros A P x.\napply (Build_Map (A:=A) (B:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (R:=A) (Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; intros; inversion 1.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n simple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n simple induction p; intros.\n inversion H; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H1; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0; simpl in |- *.\ninversion H0Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\n simpl in |- *.\nrewrite <- plus_n_Sm.\n rewrite <- plus_n_Sm.\n rewrite plus_n_Sm.\n simpl in |- *.\n replace (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros.\ninversion_clear H.\napply inv_clear with (S x0) (S x0) (S x0) (S x) (S x0)).\ninversion_clear H1; trivial.\n\ninversion_clear H1; trivial.\n\ninversion_clear H1.\napply inv_clear with (S x0) (S x0) (S x0) (S x0)); trivial.\n\ninversion_clear H1; trivial.\n\napply inv_clear with (S x0) (S x0) (S x) (S x0)); trivial.\n\ninversion_clear H1; trivial.\n\ninversion_clear H1.\napply inv_clear with (S x0) (S x0) (S x0)); trivial.\n\ninversion_clear H1.\napply inv_clear with (S x) (S x0) (S x0) (S x0)); trivial.\n\ninversion_clear H1; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintros; elim H; intros.\nelim H1; intros.\nelim H0; intros.\nelim H2; intros.\nexists x0; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H1; inversion H2.\nintros; inversion H2.\nintros; inversion H2.\napply inv_add; assumption.\napply inv_add; assumption.\napply inv_add; assumption.\napply inv_add; assumption.\napply inv_add; assumption.\napply inv_add; assumption.\napply inv_add; assumption.\napply inv_add; assumption.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold subersible in |- *; intros.\n inversion_clear H0; trivial.\nQed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\n",
                "context_tokens": 200,
                "proof_start_offset": 1664,
                "proof_end_offset": 2222,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H; elim H; intros x0 H1 H2; elim H1;\n intros x1 H2 H3 H4; elim H3; intros H5 H6; elim H6;\n intros y1 H6; elim H6; intros H7 H8; elim H8;\n intros H9 H10; elim H10; intros H12 H12; elim H12;\n intros H12 H13; elim H13; intros H13 H14; elim H15; \n intros H15 H15; elim H15; intros H16 H16; elim H16; \n intros H15 H16; elim H16; intros H16 H17; elim H16; \n intros H16 H17; elim H16; intros H17 H18; elim H17; \n intros H16 H17; elim H17; intros H17 H18; elim H18; \n intros H17 H17; elim H18; intros H17 H18; elim H18; \n intros H18 H20; elim H19; intros H20 H21; elim H20; \n intros H20 H20; elim H21; intros H20 H20; elim H21Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\ncut (exists x : S, x = S x /\\ x = y).\nintros.\napply H.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H0.\napply H2.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H H'0 H'1; elim H'1; intros x H'2 H'3.\nsplit.\napply Trans with (x2 := y); auto with sets.\nelim H'2; intros H'4 H'5; elim H'5; intros H'6 H'7.\nexists x; split.\napply Trans with (y2 := y); auto with sets.\nelim H'5; intros H'7 H'8; elim H'9; intros H'10 H'11.\nexists x; split.\napply Trans with (y2 := x); auto with sets.\nelim H'5; intros H'10 H'11; elim H'11; intros H'11 H'12.\nexists x; split.\napply Trans with (y2 := y); auto with sets.\nelim H'6; intros H'13 H'14; elim H'14; intros H'15 H'15.\nexists (x'16 x'16).\nsplit.\napply Trans with (y2 := y); auto with sets.\napply Trans with (y2 := y); auto with sets.\nelim HQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nunfold is_group in |- *.\nintros x y z H H'0; try assumption.\napply (H'0 y z H'0); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nelim H1; intros.\nleft; assumption.\nelim H1; intros.\nright; assumption.\nelim H2; intros.\nleft; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nleft; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nleft; assumption.\nelim H3; intros.\nright; assumption.\nelim H3; intros.\nleft; assumption.\nelim H3; intros.\nright; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; auto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; intros.\nunfold is_group in |- *.\nelim (H y z H0); intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nrewrite H4.\nrewrite H5.\nrewrite H5.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nrewrite H6.\nauto.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; auto.\nintros.\napply (H1 (inv S)).\napply H1; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; intros.\napply (H1 y z H1 H2).\napply H3; auto with sets.\napply H1; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1.\nintros.\napply (H (S x)).\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtype_elt (subtype_elt x)); auto with algebra.\napply Trans with (subtypeQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 434,
                "proof_start_offset": 2239,
                "proof_end_offset": 2567,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H6; intros; elim H8; \n intros; elim H8; intros; elim H9; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H10; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10; intros; elim H11; intros; \n clear H11 H12 H13 H14 H15 H15 H15 H16 H17 H17 H17Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros.\nclear H3 H5 H6 H7 H8 H9.\n(* use of opposite *)\nelim (H1 y1); intros; elim H5; intros; elim H6; intros.\nclear H5 H6 H7 H8.\n(* use of opposite *)\nelim (H0 y1); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H5; intros; elim H5; intros; elim H6;\n clear H5 H6 H7 H8.\n(* add of a par b *)\nelim (H8 (Add x1 y1) y2); elim (H8 (Add x2 y2) y1);\n intros; elim H5; intros; elim H6; intros; elim H7; intros. \nclear H5 H6 H7 H8 H9.\n(* add of a par b *)\nelim (H8 y1); intros; elim H8; intros; elim H8; intros; elim H9; intros. \nclear H5 H6 H7 H8 H9 H10.\n(* add of a par b *)\nelim (H8 (Add x1 y1) y2); elim (H8 (Add x1 y2) y2);\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H12; intros; elim H10; intros; elim H12; intros; \n elim H12;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H6; intros.\nclear H5 H6 H7 H8 H9.\nrewrite <- H4; rewrite <- H5; rewrite <- H6; rewrite <- H6; rewrite H6; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nunfold add in |- *; intros.\nrewrite (add_comm (Add x1 y1) (Add x2 y2) (Add x1 y2) (Add x1 y2) H0).\nelim H0; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nsimple induction x1; simpl in |- *; auto with *.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n apply H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros.\nclear H3 H0 H1 H2 H3 H4.\n(* add of zero *)\nelim (H1 (Add x x2)); elim (H2 x0); elim (H2 x1); reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H9; \n intros; elim H8; intros; elim H9; intros; elim H9; \n intros; elim H8; intros; elim H9; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H10;\n intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H13; intros; elim H13; \n intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H7; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H8; intros; \n elim H8;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nelim H; elim H0; elim H0; elim H0; intros; elim H1; intros; elim H2; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H7; \n intros; elim H6; intros; elim H8; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H6; intros; elim H6; intros; \n elim H8; intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "                                                  *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 549,
                "proof_start_offset": 2588,
                "proof_end_offset": 3197,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nunfold is_finite in |- *.\nintros x y H'; elim H'; intros; elim H'0; intros; elim H'0; intros.\nclear H'0 H'1; rewrite H'0; reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros.\nclear H1 H2.\nrewrite (H1 (Add x y1) y1); elim (H2 (Add x1 y2)); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\napply opp_injective; auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y; elim y; simpl in |- *; auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y; rewrite (ass (Add x y)); elim (H0 (Add x y)); auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H; elim H; auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nintros x y; elim x; elim y; simpl in |- *; auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite <- (opp_uniqueness (Add x y) x y).\nrewrite <- (opp_uniqueness (Add x y) y).\nrewrite <- (opp_uniqueness (Add x y) y).\nrewrite <- (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y) y).\nrewrite (opp_uniqueness (Add x y)Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H; elim H; intros; elim H; intros; elim H; intros; elim H0;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; \n clear H6 H7 H8 H9 H10 H11.\n(* add add add add *)\nelim (H6 (Add x1 y1) y1); elim (H6 (Add x1 y2)); elim (H6 x1 y2);\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nclear H3 H4 H5 H6.\nrewrite (H6 x1 y1); rewrite (H6 x2 y2); rewrite (H6 y1 y2); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": " Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\n",
                "context_tokens": 733,
                "proof_start_offset": 3214,
                "proof_end_offset": 3568,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nunfold is_midpoint.\nintros.\nunfold not in |- *; intro.\nelim H; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite oppQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply opp_zero.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x; unfold is_symmetric; apply opp_inv; auto.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros; unfold is_midpoint in |- *; auto with *.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nunfold is_midpoint, is_midpoint, is_midpoint.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H1;\n clear H0 H1 H2; intros.\nrewrite H; rewrite H0; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintro x; elim x; intros; elim x; intros; elim x0; intros; elim x0; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H6; \n intros; elim H8; intros; elim H8; intros; \n elim H8; introsQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nunfold is_midpoint; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H4; intros; elim H4; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\n",
                "context_tokens": 716,
                "proof_start_offset": 3585,
                "proof_end_offset": 4727,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y).\nrewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y).Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_symmetric in |- *.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; \n intros; elim H8; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H8; intros; elim H6; \n intros; elim H8; intros; elim H9; intros; elim H8; \n intros; elim H9; intros; elim H10; intros; elim H12; \n intros; elim H11; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; elim H12;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) y H H0).\nunfold is_midpoint in |- *; split.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; \n intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H9; intros; elim H9; \n intros; elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H10; \n intros; elim H12; intros; elim H11; intros; elim H10; intros; \n elim H12; intros; elim H12; intros; elim H12Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elim H12; intros; \n elim H11; intros; elim H12; intros; elim H12; \n intros; elim H13; intros; elim H14; intros; elim H15; \n intros; elim H17;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_opp (opp x)).\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_add.\napply opp_opp.Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\ncase H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nrewrite H0; rewrite H1; rewrite H2; rewrite H0; reflexivity.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold is_upper_bound in |- *.\nelim H; intros; elim H1; intros.\nelim (H1 (Or x y)); intros; elim H2; intros; elim H3; intros.\nelim (H3 (Or y x)); intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (inv_add (inv_opp x) y); auto with *.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_uniqueness H (Opp x y) y H).\nunfold is_symmetric in |- *; split.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; \n clear H6 H7 H8 H9.\nelim (H9 x H9); intros; elim H9; intros; elim H10; intros; elim H10; \n intros; elim H12; intros; elim H13; intros; elim H13; intros; \n clear H13 H13 H14.\nelim (H10 x H10); intros; elim H14; intros; elim H15; intros; elim H15; \n intros; elim H14; intros; elim H15; intros; elim H15; intros; elim H15; \n intros; elim H15; intros; elim H15; intros; elim H15; \n intros; elim H15; intros; elim H15Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) (Opp y x)); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\n\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* G (x+y) *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* G ((-x)+(-y)) *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* (x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0 *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* x+(-x) = 0 (-x)+x = 0 *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* y+(-y) = 0 (-y)+y = 0 *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* 0+0 = 0 *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n(****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 4748,
                "proof_end_offset": 4967,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *.\nunfold Opp in |- *.\nintros x y H.\nelim H; intros; elim H; intros; clear H; intros; elim H; intros; \n elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nrewrite H5; rewrite H5; rewrite H5; rewrite H6; reflexivity.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold opp, is_group in |- *; intros x y H.\nelim (H x y); intros; elim H; intros; clear H; auto with *.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_zero.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply opp_integral; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold is_group in |- *; intros.\nrewrite H; rewrite H; rewrite H0; rewrite H0; simpl in |- *;\n reflexivity.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; auto with real.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold opp in |- *; unfold opp in |- *; intros x; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply opp_id.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintro; elim H; intros.\nelim H; intros; apply (H1 (opp_inv_l x)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n simple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros n; elim n; simpl; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros n; elim n; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros n.\n rewrite plusZ_comm.\n apply le_0_n.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n induction n; simpl; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n unfold multZ in |- *.\n rewrite mult_comm.\n rewrite <- (mult_comm (S n)).\n apply mult_plus_distr_l.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros.\napply plusZ_eq1.\napply multZ_eq1.\napply multZ_eq1.\napply multZ_eq2.\napply multZ_eq1.\napply multZ_eq2.\napply multZ_eq1.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_eq2.\napply multZ_Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n simple induction n; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros.\nsimpl in |- *.\napply plusZ_eq.\nrewrite <- plusZ_plus_distr.\napply plusZ_eq.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\napply plusZ_eq.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\napply plusZ_eq.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.\nrewrite <- plusZ_plus_distr.Qed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intros; unfold multNat.\n  rewrite mult_comm; rewrite mult_comm; apply mult_comm; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* negQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; auto.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elimQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof multZ_eq_3.\n\n(* double n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof multZ_eq3.\n\nLemma mult_cst_r : forall x y : Z, multZ (Zneg x) y = FOR A (multZ x y).\nProof multZ_eq3.\n\nLemma mult_cst_r : forall x y : Z, multZ (Zpos x) y = multZ x y.\nProof multZ_eq3.\n\nLemma mult_cst_r : forall x y : Z, multZ x (Zneg y) = multZ x y.\nProof multZ_eq3.\n\nLemma mult_cst_r : forall x y : Z, multZ x (Zpos y) = multZ x y.\nProof multZ_eq3.\n\nLemma mult_cst_r : forall x y : Z, multZ x (Zpos y) = multZ x y.\nProof multZ_eq3.\n\nLemma mult_cst_r : forall x y : Z, multZ (Zpos x) y = multZ x y.\nProof.\n intros; elim x.\n (* pos n *)\n simpl in |- *; reflexivity.\n (* pos n *)\n simpl in |- *; reflexivity.\n (* pos nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; rewrite (add_comm (neg n)) in H.\nelim (mult_comm (neg n) (mult_comm (neg n) y) (neg (S n))).\nelim (mult_comm (neg n) y).\nelim (mult_comm (neg n) (mult_comm (neg n) y) (neg (S n))).\nelim (mult_comm (neg n) (mult_comm (neg n) y) (neg (S n))).\nelim (mult_comm (neg n) y).\nelim (mult_comm (neg n) (mult_comm (neg n) y) (neg (S n))).\nelim (mult_comm (neg n) y).\nelim (mult_comm (neg n) (mult_comm (neg n) y) (neg (S n))).\nelim (mult_Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x; auto.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nsimple induction x; simpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nintros; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimpl in |- *; reflexivity.\n(* pos x *)\nsimple induction n.\n(* pos x *)\nsimple induction n.\n(* pos x *)Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* pos 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_O_neg x).\n(* pos 0 *)\nintros x H; rewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nrewrite (mult_comm x) in H.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintro; auto with arith.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* neg *)\nreflexivity.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H; ring.\n(* pos *)\nintros x H;Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nunfold mult at 2 in |- *.\nintros x; elim x.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nintros n0 H; rewrite (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_comm 0 (mult_commQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; elim x.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimplQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm 0); rewrite (mult_comm 0); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm 0); rewrite (mult_comm 0); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm 0); rewrite (mult_comm 0); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm 0); rewrite (mult_comm 0); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm 0); rewrite (mult_comm 0); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm 0); rewrite (mult_comm 0); reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimplQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos (S y) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_negZ n0); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_mult_negZ x Zero H); rewrite H; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintro x; rewrite (tech_mult_negZ (neg 0) 0 H); rewrite H; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintro x; rewrite (tech_negZ (neg 0) 0 H); rewrite H; reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_plus_negZ x IZ); rewrite H; reflexivity.\n(* pos n *)\nelim (pred_discr (pred_discr (pred_discr (pred_discr (pred_discr (pos n)))) y).\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (tech_plus_neg_Z x pos); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (tech_plus_neg_Z x pos); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (tech_plus_neg_Z x pos); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (tech_plus_neg_Z x pos); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (tech_plus_neg_Z x pos); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (tech_plus_neg_Z x pos); rewrite H; reflexivity.\n(* pos n *)\nsimpl inQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_negZ n0); rewrite H; reflexivity.\n(* neg n0 *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_negZ n0); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nrewrite (mult_comm (pos 0)).\nrewrite (mult_comm (pos 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (pos 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (mult_comm (neg 0)).\nrewrite (Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x); rewrite (tech_negZ x); reflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x); rewrite (tech_negZ x); reflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x); rewrite (tech_negZ x); reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x); rewrite (tech_negZ x); reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x); rewrite (tech_negZ x); reflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x); rewrite (tech_negZ x); reflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negZ x); rewrite (tech_negZ x); reflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_negQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_plus_negZ y shift); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n H; rewrite (tech_negZ (pos n) (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_plus_negZ (neg n) (neg n)) in H.\nrewrite (plus_comm (neg n) (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_plus_negZ (neg n) (neg n)) in H.\nrewrite (plus_comm (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x H; rewrite (tech_plus_negZ (neg n) (neg n)) in H.\nrewrite (plus_comm (neg n)) in H.\nrewrite (plus_comm (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_plus_negZ (neg n)) in H.\nrewrite (plus_comm (neg n)) in H.\nrewrite (plus_comm (neg n)).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x; auto.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nintros x H; rewrite (tech_Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ (neg x) (neg 0)) (neg 0).\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_plus_negZ (neg x) (neg 0)) (neg 0).\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ (neg x) (neg 0)) (neg 0).\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ (neg x) (neg 0)).\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ (neg x)) (neg 0).\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ (neg x) (neg 0)) (neg 0).\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ (neg x) (neg 0)) (neg 0).\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ (neg x) (neg 0)).\nreflexivity.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n; simpl in |- *; auto.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* pos O *)\nintros x H; rewrite (tech_oppZ x (neg 0)); rewrite H; unfold neg in |- *;\n rewrite (add_0_involutive (neg 0)); reflexivity.\n(* pos O *)\nintros x H; rewrite (tech_oppZ x (neg 0)); rewrite H; unfold neg in |- *;\n rewrite (add_0_involutive (neg 0)); reflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x H; rewrite (tech_oppZ x (neg 0)); rewrite H; unfold neg in |- *;\n rewrite (add_0_involutive (neg 0)); reflexivity.\n(* pos 0 *)\nintros x H; rewrite (tech_oppZ x (neg 0)); rewrite H; unfold neg in |- *;\n rewrite (add_0_involutive (neg 0)); reflexivity.\n(* pos O *)\nintros x H; rewrite (tech_oppZ x (neg 0)); rewrite H; unfold neg in |- *;\n rewrite (add_0_involutive (neg 0)); reflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ x (neg 0)); rewrite H; unfold neg in |-Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction n.\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintro H; rewrite (tech_plus_pos_negZ x IZ); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |-Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x H; rewrite (tech_opp_posZ (neg x) pos).\nrewrite (neg_opp_pos x); rewrite (neg_opp_pos x); reflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x H; rewrite (tech_opp_negZ (neg x) pos).\nrewrite (neg_opp_pos x); rewrite (neg_opp_neg x); reflexivity.\n(* neg O *)\nreflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nintros x H; rewrite (tech_opp_negZ (neg x) pos).\nrewrite (neg_opp_neg x); rewrite (neg_opp_neg x); reflexivity.\n(* pos O *)\nreflexivity.\n(* pos O *)\nsimpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Z y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 8247,
                "proof_end_offset": 8887,
                "proof": "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_IZ y).\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H.\nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (mult_mIZ y).\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H.\nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_commutativity : commutativity Z multZ.\nelim multZ_commutativity.\nelim multZ_commutativity.\nelim multZ_commutativity.\nelim multZ_commutativity.\nelim multZ_commutativity.\nelim multZ_commutativity.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_comm.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_comm.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZ_assoc.\nelim multZQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; auto with real.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ (pos x)) in H; rewrite H.\nrewrite (add_mHNabs n); rewrite H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; auto with real.\n(* pos n *)\nsimpl in |- *; auto with real.\n(* pos n *)\nsimpl in |- *; auto with real.\n(* pos n *)\nsimpl in |- *; auto with real.\n(* pos n *)\nsimpl in |- *; auto with real.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ (neg x)) in H; rewrite H.\nelim (mult_pos_pos x); intros H1 H2.\nelim (mult_neg x); intros H3 H4.\nelim (mult_neg x); intros H5.\nelim (mult_neg x); intros H5.\nelim (mult_neg x); intros H6.\nelim (mult_negQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros z; rewrite (tech_mult_negZ z (pos z)); rewrite H.\nelim (mult_pos_negZ z (pos z)); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros z; rewrite (tech_mult_negZ z (pos z)); rewrite H.\nelim (mult_neg_negZ z (neg 0)); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros z; rewrite (tech_mult_negZ z (neg 0)); rewrite H.\nelim (mult_neg_negZ z (neg 0)); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimpl in |-Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ (neg 0)); rewrite H.\nrewrite (tech_plus_negZ (neg 0)); rewrite H.\nrewrite (add_comm (neg 0)); rewrite (add_comm (neg 0)); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ (neg 0)); rewrite H.\nrewrite (tech_plus_negZ (neg 0)); rewrite H.\nrewrite (add_comm (neg 0)); rewrite H.\nrewrite (add_comm (neg 0)); rewrite (opp_involutive (neg 0)); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x H; rewrite (tech_plus_negZ (neg 0)); rewrite H.\nrewrite (opp_involutive (neg 0)); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *.\nsimple destruct x.\n(* pos (S y) *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nintros x y H; rewrite (tech_mult_negZ y H); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *.\nsimple destruct x; simpl in |- *; auto with arith.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z (pos 0)); rewrite H; simpl in |- *;\n assumption.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z (neg 0)); rewrite H; simpl in |- *;\n assumption.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; auto with arith.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z (neg 0)); rewrite H; simpl in |- *;Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nunfold IZR, multZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros x H; rewrite (tech_mult_negZ y zero); rewrite H.\nelim (opp_add Z oppZ); rewrite H.\nrewrite (add_0_involutive (neg x)); reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros x H; rewrite (tech_mult_negZ y 0); rewrite H.\nrewrite (opp_involutive (neg x)); reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |-Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\napply (add_mIZN (Zpos (Zneg (xI (xO (xI xH)))) (Zpos (xI (xO (xO (xO xH))))\n    (Zpos (xI (xO (xI (xO (xO (xO xH))))) (Zpos (xO (xI xH))))))\n     (Zpos (xO (xI (xO (xO (xI xH))))) (Zpos (xO (xO (xO (xI xH))))))\n     (Zpos (xI (xO (xO (xI xH)))))) (Zpos (xO (xO (xO (xI xH))))))\n     (Zpos (xI (xI (xO (xI xH)))))) (Zpos (xO (xI (xO (xI xH))))))\n     (Zpos (xI (xI (xO (xI (xI xH)))))) (xI (xI (xO (xI xH))))))\n     (Zpos (xI (xI (xI (xI xH))))))\n     (xI\n       (xI\n         (xI\n           (xI\n           (xI\n            (xI\n              (xI\n              (xI\n              (xI\n              (xI\n              (xI\n              (xI\n              (xI\n              (xI\n                 (xI\n                 (xI\n                 (xI\n                 (xI\n                 (xI\n                 (xI\n                       (xI\n                 (xI\n                 (xI\n                 (xI\n                 (xI\n                 (xI\n                 (xI\n                 (xIQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nexact (plusZ_commutativity (Zpos (pos 0)) (Zpos (pos 0))) (Zpos (pos 0))) (Zpos (neg 0)).\n(* pos 0 *)\napply plus_lt_reg_l with (pos 0).\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_r.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_l.\napply plus_gt_compat_r.\napply plus_gt_Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nexact (mult_mIZ_nat (pos 0)).\n(* pos m *)\nelim mult_comm.\n(* pos m *)\nintros n; rewrite (tech_mult_negZ y (neg 0)); rewrite H. \napply (mult_comm (neg 0)); assumption.\n(* pos m *)\nelim mult_comm.\n(* pos m *)\nintros n0 H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\napply (mult_comm (neg 0)); assumption.\n(* pos m *)\nintros n0 H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\napply (mult_comm (neg 0)); assumption.\n(* pos m *)\nintros n0 H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\napply (mult_comm (neg 0)); assumption.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\napply (mult_comm (neg 0)); assumption.\n(* pos m *)\nintros n0 H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8912,
                "proof_end_offset": 9098,
                "proof": "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nProof.\nunfold neutral in |- *.\nsplit.\nexact I.\nintros.\nsplit.\nelim (multZ_commutativity IZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold neg in |- *; intros; elim x.\n(* pos n *)\nunfold multZ in |- *; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mRec 0 n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0 n).\n(* negQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold IZR in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nintros; elim x.\n(* neg n *)\nintros y H; rewrite (mult_comm y); rewrite (mult_comm y); reflexivity.\n(* neg n *)\nintros y H; rewrite (mult_comm y); rewrite (mult_comm y); reflexivity.\n(* neg n *)\nintros y H; rewrite (mult_comm y); rewrite (mult_comm y); reflexivity.\n(* neg n *)\nintros y H; rewrite (mult_comm y); rewrite (mult_comm y); reflexivity.\n(* neg n *)\nintros y H; rewrite (mult_comm y); rewrite (mult_comm y); reflexivity.\n(* neg n *)\nintros y H; rewrite (mult_comm y); rewrite (mult_comm y); reflexivity.\n(* neg n *)\nintros y H; rewrite (mult_comm y); rewrite (mult_comm y); reflexivity.\n(* neg n *)\nintros y H; rewrite (mult_comm y); reflexivity.\n(* neg n *)\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold absZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *.\nsimpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *.\nsimpl in |- *.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold oppZ in |- *; simpl in |- *; auto with arith.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold absZ in |- *; intros; elim x.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_ Scope nat)\n (apply mult_mRec; assumption).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_ Scope nat)\n (apply mult_n_Sm; assumption).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_ Scope nat)\n (apply mult_n_S; assumption).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_ Scope nat)\n (apply mult_n_S; assumption).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_ Scope nat)\n (apply mult_n_S; assumption).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_ Scope nat)\n (apply mult_n_S; assumption).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_S _ _ H).\n(* posQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold absZ in |- *; intros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nauto.\n(* pos n *)\nintros z; rewrite (tech_posZ y0); rewrite (tech_negZ y0); rewrite (tech_negZ y0); rewrite (tech_negZ y0); reflexivity.\n(* neg n *)\nintros z; rewrite (tech_negZ y0); rewrite (tech_negZ y0); rewrite (tech_negZ y0); reflexivity.\n(* neg n *)\nintros z; rewrite (tech_negZ z); rewrite (tech_negZ z); rewrite (tech_negZ z); reflexivity.\n(* pos n *)\nintros z; rewrite (tech_negZ z); rewrite (tech_negZ z); rewrite (tech_negZ z); reflexivity.\n(* pos n *)\nintros z; rewrite (tech_negZ z); rewrite (tech_negZ z); rewrite (tech_negZ z); reflexivity.\n(* pos n *)\nintros z; rewrite (tech_negZ z); rewrite (tech_negZ z); rewrite (tech_negZ z); reflexivity.\n(* posQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold IZR in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ_prf (neg 0)).\n(*Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Rminus in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0).\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y (pos x)); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0).\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y (neg x)); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0).\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y (pos y)); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 0).\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ y (neg x)); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  inQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nred in |- *; intros; elim x.\n(* pos O *)\napply (mult_reg_l (z:=0) (z:=0) (z:=0) (z:=0));\n unfold multZ in |- *; reflexivity.\n(* pos n *)\napply (mult_reg_l (z:=0) (z:=0) (z:=0) (z:=0));\n unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm z z0).\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z); rewrite H; rewrite H.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z); rewrite H; rewrite H.\n(* pos n *)\nrewrite (mult_comm z); unfold multZ in |- *; reflexivity.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z); rewrite H.\n(* pos n *)\nintros z H; rewrite (tech_mult_negZ z); rewrite H; rewrite H.\n(* pos n *)\nintros z H; rewrite (tech_mult_Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold absZ in |- *; intros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros H; rewrite (tech_plus_negZ z (pos n)) in H0.\nelim (mult_comm (pos n) (pos n)); unfold predZ in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros H; rewrite (tech_plus_negZ z (pos n)) in H0.\nelim (mult_comm (pos n) (pos n)); unfold succZ in |- *; reflexivity.\n(* pos n *)\nintros H; rewrite (tech_plus_negZ z (pos n)) in H0.\nelim (mult_comm (pos n) (neg n)); unfold succZ in |- *; reflexivity.\n(* pos n *)\nelim (mult_comm (pos n) (neg n)); unfold negZ in |- *; reflexivity.\n(* pos n *)\nintros H; rewrite (tech_plus_negZ z (pos n)) in H0.\nelim (mult_comm (neg n) (negQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\n",
                "context_tokens": 743,
                "proof_start_offset": 9133,
                "proof_end_offset": 10783,
                "proof": "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nProof.\nunfold distributivity in |- *; intros; case x.\nsplit; reflexivity.\nsimple induction n.\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z).\nreflexivity.\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\nsimple induction n.\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z).\nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nintros y0 H.\nsplit.\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros.\nrewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim (add_add Z addZ addZ_commutativity addZ_associativity (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold IZR, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ,\n  oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ,\n  oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros H H0 H1 H2; rewrite (mult_comm H1 H2); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold associative in |- *.\nsplit. exact I.\nintros x y H'; rewrite (mult_comm x y); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold associative in |- *.\nsplit. exact I.\nintros x y H'; rewrite (mult_comm x y); rewrite (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\napply (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_assoc y x); reflexivity.\n(* <- *)\nelim (mult_assoc y x y); reflexivity.\n(* <- *)\nelim (mult_assoc x y); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_assoc y x); reflexivity.\n(* <- *)\nelim (mult_assoc y x); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_comm x y); reflexivity.\n(* <- *)\nelim (mult_Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Rminus in |- *.\nunfold Rminus in |- *.\nunfold Rminus in |- *.\nintros; elim x.\nintros; elim x0.\nintros; elim x1.\nintros; elim x2.\nintros; elim x3.\nintros; elim x4.\nintros; elim x4.\nintros; elim x5.\nintros; elim x5.\nintros; elim x5.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x7.\nintros; elim x6.\nintros; elim x6.\nintros; elim x6.\nintros; elim x7.\nintros; elim x8.\nintros; elim x6.\nintros; elim x8.\nintros; elim x8.\nintros; elim x6.\nintros; elim x6.\nintros; elim x7.\nintros; elim x8.\nintros; elim x8.\nintros; elim x8.\nintros; elim x8.\nintros; elim x9.\nintros; elim x9.\nintros; elim x9.\nintros; elim x9.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Rminus in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O 1).\n(* pos n *)Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Numer in |- *.\nunfold Numer in |- *.\nunfold Numer in |- *.\nunfold Numer in |- *.\nunfold Numer in |- *.\nunfold Numer in |- *.\napply plus_reg_l with (mult_pos_nat (mult_pos_nat (mult_pos_nat (pos y0) (pos (pos (S y0))) (pos (S y1))) 0).\napply mult_reg_l with (mult_pos_nat (mult_pos y0) (pos (S y0)));\n auto with arith.\napply mult_reg_l with (mult_pos_nat (mult_pos y0) (neg (S y0)));\n auto with arith.\napply mult_reg_l with (mult_pos_nat (mult_pos y0) (neg (S y0)));\n auto with arith.\napply mult_reg_l with (mult_pos_nat (mult_pos y0) (neg (S y0)));\n auto with arith.\napply mult_reg_l with (mult_pos_nat (mult_pos y0) (neg (S y0)));\n auto with arith.Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold decEq in |- *.\nelim (mult_comm (S x) (S y) (S x) (S y)).\n(* pos n *)\nintro H; rewrite (plus_comm (S y)); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm (S x) (S y)).\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm (S x) (S y)).\n(* pos n *)\nintros n0; elim n0.\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm (S x) (S y)).\n(* pos n0 *)\nintros n0; elim n0.\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm (S x) (S y)).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm (S x) (S y)).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Rminus in |- *.\nintros; elim x.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O_neutral x).\n(* pos n *)\nsimpl in |- *; symmetry Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold Num in |- *.\nunfold Num in |- *.\nunfold Num in |- *.\napply (plus_reg_l (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))))))\n     (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S S))))))))))\n       (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))\n       (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfoldeasy in |- *.\nunfold IZR in |- *; intros; elim x.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 1).\n(* pos O *)\nauto.\n(* pos n *)\nintro H; rewrite (mult_comm 0 1); rewrite H.\n(* pos n *)\nauto.\n(* pos n *)\napply mult_reg_l with (n := 0); auto.\n(* pos n *)\napply mult_reg_l with (n := 0); auto.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 1).\n(* pos n *)\napply mult_reg_l with (n := 0); auto.\n(* pos n *)\napply mult_reg_l with (n := 0); auto.\n(* pos n *)\nsimpl in |- *; rewrite (mult_comm 0 1); rewrite H.\n(* pos n *)\nelim (mult_comm 0 0); simpl in |- *; auto.\n(* pos n *)\nintros n; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm 0 1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\nTheorem mult_add_distributivity : distributivity Z addZ multZ.\n\nunfold distributivity in |- *; intros; case x.\n(* OZ *)\nsplit; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z). \nreflexivity.\n(* pos (S y0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 10804,
                "proof_end_offset": 11399,
                "proof": "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros; case x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) y) y I I).\nelim H; reflexivity.\nintros; elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintro x; case x.\nintros; reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nunfold mult, mult, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ in |- *;\n ring.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nreflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nsimple induction x.\n(* x = y *)\nintros.\nrewrite <- (mult_assoc (- x) (multZ_comm (pos y) z)).\nrewrite <- (mult_assoc (- x) (multZ_comm (neg y) z)).\nrewrite (mult_comm (- x) z).\napply mult_plus_distr_r.\nrewrite (mult_comm (multZ_comm (neg y) z) (multZ_comm (neg y) z)).\napply mult_assoc_reverse.\nrewrite (mult_comm (multZ_comm (neg y) z) (multZ_comm (neg y) z)).\nrewrite (mult_comm (multZ_comm (neg y) z)).\nrewrite (mult_comm (mult_comm (multZ_comm (neg y) z) z)).\nrewrite (mult_comm (multZ_comm (neg y) z)).\nrewrite (mult_comm (multZ_comm (neg y) z) (multZ_comm (neg y) z)).\nreflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros x y; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nreflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nreflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros x y; rewrite (mult_oppZ_r x y); rewrite (mult_oppZ_r x y); rewrite (mult_oppZ_r x y);\n rewrite (mult_oppZ_opp x y); rewrite (mult_oppZ_opp y y);\n rewrite (mult_oppZ_opp y); rewrite (mult_oppZ_opp y y); rewrite (mult_opp_Z y).\nreflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nsimple induction x.\n(* x = 0 *)\nsimpl in |- *.\nelim plus_O_r.\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite (mult_comm (mult x y)).\nrewrite plus_assoc.\nrewrite (mult_comm (mult x y)).\nrewrite mult_assoc.\nrewrite (mult_comm (mult y x)).\nrewrite mult_assoc.\nrewrite (mult_comm (mult x y)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult x y)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite mult_assoc.\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult yQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nunfold mult, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; case x; case y; simpl; intros;\n try rewrite oppZ_eq4; rewrite oppZ_eq4;\n rewrite oppZ_eq4; rewrite oppZ_eq4;\n rewrite oppZ_eq4; rewrite oppZ_eq4; rewrite oppZ_eq4;\n rewrite oppZ_eq4; rewrite oppZ_eq4;\n rewrite oppZ_eq4; rewrite oppZ_eq4; rewrite oppZ_eq5;\n rewrite oppZ_eq4; rewrite oppZ_eq4; rewrite oppZ_eq4;\n rewrite oppZ_eq4; rewrite oppZ_eq4; rewrite oppZ_eq4;\n rewrite oppZ_eq4; rewrite oppZ_eq4; rewrite oppZ_eq4;\n rewrite oppZ_eq4; rewrite oppZ_eq4; rewrite oppZ_neq0;\n rewrite oppZ_eq4; rewrite oppZ_eqQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 11420,
                "proof_end_offset": 12246,
                "proof": "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nProof.\nsimple destruct y.\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\nintros; elim (multZ_commutativity (pos n) (oppZ x)).\nelim (multZ_commutativity (pos n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) x) x I I).\nintros; elim (multZ_commutativity (neg n) (oppZ x)).\nelim (multZ_commutativity (neg n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) x) (oppZ x) I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nreflexivity.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nsimple induction n; simpl in |- *; auto.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nunfold mult, oppZ, oppZ, oppZ, oppZ in |- *; auto with arith.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros x y; do 2 rewrite (tech_mult_negZ y).\nrewrite (mult_comm x y); rewrite (mult_comm x y).\nrewrite (mult_comm y (mult x y)).\nrewrite (mult_comm x (mult y x)).\nrewrite (mult_comm y (mult y x)).\nrewrite (mult_comm y (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult x (mult y x))).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult x (mult y x))).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult x y)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult y (mult y x))).\nrewrite (mult_comm (mult y x)).\nrewrite (mult_comm (mult x (mult y x))).\nrewrite (mult_comm (mult y (mult x (mult y x))).\nrewriteQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nsimple induction x; simpl in |- *; auto.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_oppZ (neg y0) y); rewrite (tech_oppZ (neg y0) y0);\n reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_oppZ (neg y0) y); rewrite (tech_oppZ (neg y0) y0);\n reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_oppZ (neg y0) y); rewrite (tech_oppZ (neg y0) y0);\n reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_oppZ (neg y0) y); rewrite (tech_oppZ (neg y0) y0);Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* pos of S n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nsimpl in |- *.\nauto.\n(* pos n *)\nauto.\n(* pos n *)\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x; simpl; auto.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nunfold mult, mult, oppZ, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult,\n mult, mult, mult, mult, mult, mult, mult, mult, mult,\n mult, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult,\n mult, mult, mult, mult, mult, mult, mult, mult, mult, mult,\n mult, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult,\n mult, mult, mult, mult, mult, mult, mult, mult, mult, mult,\n mult, mult, mult, mult, mult, mult, mult, mult, mult, mult, mult,\n and, mult, mult, mult, mult, mult, mult, mult, mult,\n and, mult, mult, mult, mult, mult, mult, mult, mult, mult,\n and mult, mult, mult, mult, mult, mult, mult, mult, mult, plus, mult, mult,\n and, mult, mult, mult, mult, mult, mult, mult, mult, plus, mult,Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nProof.\nintros; apply mult_opp_l.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; rewrite (tech_oppZ_r x).\nrewrite (opp_add Z oppZ); rewrite (mult_oppZ_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_opp).\nrewrite (mult_opp_oppQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12380,
                "proof_end_offset": 12674,
                "proof": "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; elim (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); rewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (mult_comm m n); trivial.\n(* pos n *)\nrewrite (Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; elim n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; elim (mult_comm (pos n) (pos m)).\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; reflexivity.\n(* pos n *)\nrewrite (mult_comm (pos n)); reflexivity.\n(* pos n *)\nrewrite (mult_comm (pos n)); reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; elim (mult_neg_pos_pos_pos_pos n m); intros; reflexivity.\n(* pos n *)\nrewrite (mult_comm (neg n) (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nrewrite (mult_comm (neg m)).\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; reflexivity.\n(* pos n *)\nintros; elim (mult_comm (pos n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg m) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivity.\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg m)); reflexivityQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; rewrite (mult_comm (pos n)); rewrite (mult_comm (neg n)); reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; elim (mult_comm m n); elim (mult_comm m n); elim (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); elim (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); elim (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); elim (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); reflexivity.\n(* pos m *)\nintros n m; rewrite (mult_comm m n); reflexivity.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ").\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12702,
                "proof_end_offset": 13018,
                "proof": "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H; unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n; reflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *.\nintros; elim n.\n(* pos n *)\nsimpl in |- *.\nrewrite <- plus_n_O.\napply le_plus_r; assumption.\n(* pos n *)\nsimpl in |- *.\nrewrite <- plus_n_O.\napply le_plus_r; assumption.\n(* pos n *)\nsimpl in |- *.\nrewrite <- plus_n_O.\napply le_plus_r; assumption.\n(* pos n *)\nsimpl in |- *.\nrewrite <- plus_n_O.\napply le_plus_l; assumption.\n(* pos n *)\nsimpl in |- *.\nrewrite <- plus_n_O.\napply le_plus_r; assumption.\n(* pos n *)\nsimpl in |- *.\nrewrite <- plus_n_O.\napply le_plus_r; assumption.\n(* pos n *)\nsimpl in |- *.\nrewrite <- plus_n_O.\napply le_plus_Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(*Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* n = 0 *)\nreflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivity.\n(* 0 = 0 *)\nintros; reflexivityQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(*Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nsimple induction n; simpl in |- *; intros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* neg m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(* pos m *)\nintros; elim n.\n(* pos m *)\nreflexivity.\n(* pos m *)\nreflexivity.\n(*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13046,
                "proof_end_offset": 13355,
                "proof": "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x y H; rewrite (tech_mult_negZ x y H); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x y H; rewrite (tech_mult_negZ (y * x) y H); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x y H; rewrite (tech_plus_negZ (neg n) y); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ (neg n) y); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x y H; rewrite (tech_plus_negZ (neg n) y); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ (neg n) y); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x y H; rewrite (tech_plus_negZ (neg n) y); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ (neg n) y); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x y H; rewrite (tech_oppZ (neg n) y); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ (neg n) y); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x yQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* S n *)\nreflexivity.\n(* 0 *)\nintros y H; rewrite (tech_mult_negZ (y * m + (y + m)) m); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros y H; rewrite (tech_mult_negZ (x * y) y H); rewrite H;\n unfold oppZ in |- *; reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros x H; rewrite (tech_mult_neg_posZ x (pos m)) in H;\n unfold addZ in |- *.\nrewrite (tech_add_neg_negZ (x * m + (y + m)) m).\nelim (tech_mult_neg_posZ (x * m + (y + m))) m); reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\n(* pos *)\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13383,
                "proof_end_offset": 13714,
                "proof": "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *; rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n; reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |- *; reflexivity.\n(*O *)\nsimpl in |-Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n; simpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivityQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n; simpl in |- *; reflexivity.\n(* 0 *)\nintros y H; rewrite (tech_mult_negZ (neg n)); rewrite H.\nrewrite (tech_opp_negZ (neg n)); reflexivity.\n(* 0 *)\nintros y H; rewrite (tech_neg_posZ (neg n)); rewrite H.\nrewrite (tech_opp_neg_negZ (neg n)); reflexivity.\n(* 0 *)\nintros y H; rewrite (tech_neg_negZ (neg n)); rewrite H.\nrewrite (tech_opp_neg_negZ (neg n)); reflexivity.\n(* 0 *)\nintros y H; rewrite (tech_neg_negZ (neg n)); rewrite H.\nrewrite (tech_opp_neg_negZ (neg n)); reflexivity.\n(* 0 *)\nintros y H; rewrite (tech_neg_negZ (neg n)); rewrite H.\nrewrite (tech_opp_negZ (neg n)); reflexivity.\n(* 0 *)\nintros y H; rewrite (tech_neg_negZ (neg n)); rewrite H.\nrewrite (tech_neg_negZ (neg n)); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nsimple induction n.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 13745,
                "proof_end_offset": 14428,
                "proof": "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nreflexivity.\nsimple induction n.\nunfold multZ in |- *; reflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros.\nelim H0.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_oppZ_l y z).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros.\nelim H0.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_associativity : associativity Z multZ.\napply le_Z_right.\napply mult_left_pos_pos_pos.\napply mult_right_pos_pos_pos.\napply mult_left_pos_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos_pos.\napply mult_right_pos_pos_pos.\napply mult_right_pos_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_pos_pos.\napply mult_right_Qed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nexact multZ_sym.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold multZ in |- *; simpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ (y * y) (neg m)); unfold oppZ in |- *;\n rewrite H; simpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (y * y) (neg m)); unfold oppZ in |- *;\n rewrite H; simpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |-Qed.",
                    "Theorem multZ_associativity : associativity Z multZ.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZ_comm.\napply plusZQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nexact (multZ_congr 0 (fun _ => 0)).\n(* 0 *)\nunfold mult at 1 in |- *; unfold mult at 1 in |- *; unfold mult at 1 in |- *;\n unfold mult at 2 in |- *; unfold mult at 2 in |- *; \n unfold mult at 2 in |- *; unfold mult at 3 in |- *; \n unfold mult at 2 in |- *;\n unfold mult at 3 in |- *; \n unfold mult at 2 in |- *; repeat rewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (x + 0)).\nrewrite (mult_comm (xQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nexact multZ_comm.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nexact multZ_left.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZ_right.\nexact multZQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nelim n.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.Qed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nexact (plusZ_permute (z * m)) (z * m + (z * m + (n + m))).\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold Z.mult, Z.mul, Z.mul, Z.mul, Z.mul, Z.mul, Z.mul, Z.mul, Z.mul, Z.mul.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 739,
                "proof_start_offset": 14446,
                "proof_end_offset": 14693,
                "proof": "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold is_ring in |- *.\nsplit.\nexact addZ_commutativity.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit.\nexact multZ_associativity.\nexact mult_add_distributivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold not in |- *; intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* neg n *)Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nintros x y H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_negZ_oppZ x).\nrewrite H; elim (mult_negZ_negZ x).\nrewrite H; elim (mult_negZ_negZ x).\nrewrite H; elim (mult_negZ_negZ y).\nreflexivity.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold oppZ in |- *; intros; elim x.\n(* neg n *)\napply Z_ring.\n(* neg n *)\napply Z_ring.\n(* neg n *)\napply Z_ring.\n(* neg n *)\napply Z_ring.\n(* neg n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* neg n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* neg n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* pos n *)\napply Z_ring.\n(* pos n *)\napply Z_mult_neg_posZ.\n(* pos n *)\napply Z_mult_neg_posZ.\n(* pos n *)\napply Z_mult_neg_posZ.\n(* pos n *)\napply Z_mult_neg_posZ.\n(* pos n *)\napply Z_mult_neg_posZQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold not in |- *; intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\napply sym_equal.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napply not_eq_sym.\napplyQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold oppZ in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold is_ring, oppZ in |- *; reflexivity.\n(* of 0 *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold is_ring in |- *; intros; elim x.\n(* pos *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_mult_negZ (pos n)) y0); rewrite H;\n rewrite (tech_mult_neg_negZ (neg n)) y0);\n rewrite (tech_mult_neg_negZ (neg n)) (neg n);\n rewrite (tech_mult_neg_negZ (neg n)) y0);\n rewrite (tech_mult_neg_neg_negZ (neg n)) y0);\n rewrite (tech_mult_neg_neg_negZ (neg n)) y0);\n rewrite (tech_mult_neg_neg_negZ (neg n)) y0);\n rewrite (tech_mult_neg_neg_negZ (neg n)) y0);\n rewrite (tech_mult_neg_neg_neg_Z (neg n)) (neg n);\n rewrite (tech_mult_neg_neg_negZ (neg n)) y0);\n rewrite (tech_mult_neg_neg_neg (neg n)) y0);\n rewrite (tech_mult_negQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nintros x y; do 2 rewrite (tech_mult_neg_posZ (y0 * x) (pos y0)).\nrewrite H; elim (mult_neg_pos_posZ (y0 * x) (neg y0)).\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_r x z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_r x z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_r y z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l x z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_r x z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l x z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (multQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold is_ring; intros; elim x.\n(* pos *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_r x y).\n(* pos *)\nintros z H; do 2 rewrite (tech_mult_neg_posZ z).\nrewrite H; rewrite H; rewrite H; reflexivity.\n(* pos *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_r x y).\n(* pos *)\nintros z H; do 2 rewrite (tech_mult_neg_posZ z).\nrewrite H; elim (mult_oppZ_l x y).\nelim (mult_oppZ_l x y).\nreflexivity.\n(* pos *)\nintros z H; do 2 rewrite (tech_mult_neg_posZ z).\nrewrite H; rewrite H; rewrite H; reflexivity.\n(* pos *)\nintros z H; do 2 rewrite (tech_mult_neg_posZ z).\nrewrite H; rewrite H; rewrite H; reflexivity.\n(* pos *)\nintros z H; do 2 rewrite (tech_mult_neg_posZ z).\nrewrite H; rewrite H; rewrite H; reflexivityQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\n",
                "context_tokens": 728,
                "proof_start_offset": 14731,
                "proof_end_offset": 14951,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nexact multZ_commutativity.\nexact multZ_neutral.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_commutative_ring.\nunfold is_ring in |- *. intros; elim x.\n(* pos n *)\nunfold multZ in |- *; rewrite H; rewrite <- H0.\napply mult_reg_l with (S n).\nrewrite <- mult_plus_distr_r; assumption.\n(* neg n *)\nunfold multZ in |- *; rewrite H; rewrite H0.\napply mult_reg_l with (S n).\nrewrite <- mult_plus_distr_r; assumption.\n(* neg n *)\nunfold multZ in |- *; rewrite H; rewrite H0.\napply mult_reg_l with (S n).\nrewrite <- mult_plus_distr_r; assumption.\n(* neg n *)\nunfold multZ in |- *; rewrite H; rewrite H0.\napply mult_reg_l with (S n).\nrewrite <- mult_plus_distr_r; assumption.\n(* neg n *)\nunfold multZ in |- *; rewrite H; rewrite H0.\napply mult_reg_l with (S n).\nrewrite <- mult_plus_distr_r; assumption.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring, Z.abs in |- *.\napply Z_unit.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nintros n m H; do 2 rewrite (tech_mult_neg_negZ n m); auto with *.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_ring.\nexact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nexact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nsplit. exact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_left in |- *.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nsplit. exact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_commutative_ring.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nsplit. exact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_commutative_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitary_ring.\nexact Z_unitQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15006,
                "proof_end_offset": 15394,
                "proof": "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x; case x.\n(* Focus 1 *)\nintros x H; do 2 rewrite (tech_mult_pos_posZ n x H).\nsimpl in |- *; reflexivity.\n(* Focus 1 *)\nintros x H; do 2 rewrite (tech_mult_neg_posZ n x H).\nsimpl in |- *; reflexivity.\n(* Focus 2 *)\nintros x H; do 2 rewrite (tech_mult_pos_posZ n x H).\nsimpl in |- *; reflexivity.\n(* Focus 2 *)\nintros x H; do 2 rewrite (tech_mult_neg_posZ n x H).\nsimpl in |- *; reflexivity.\n(* Focus 3 *)\nintros x H; do 2 rewrite (tech_mult_neg_posZ n x H).\nsimpl in |- *; reflexivity.\n(* Focus 3 *)\nintros x H; do 2 rewrite (tech_mult_neg_posZ n x H).\nsimpl in |- *; reflexivity.\n(* Focus 2 *)\nintros x H; do 2 rewrite (tech_mult_neg_posZ n x H).\nsimpl in |- *; reflexivity.\n(* Focus 3 *)\nintros x H; do 2 rewrite (tech_multQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros.\nrewrite tech_integ_posZ; auto with *.\napply Z_div_exact; auto with *.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- mult_IZR.\nrewrite <- mult_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plus_IZR.\nrewrite <- mult_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- mult_IZR.\nrewrite <- plus_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plus_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plus_IZR.\nrewrite <- plus_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plusZ_IZR.\nrewrite <- plus_IZR.\nrewrite plusZ_IZR.\nrewrite <- plus_IZR.\nrewrite plusZ_IZR.\nrewrite <- plus_IZR.\nrewrite plusZ_Qed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x; elim n; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros; elim n.\nintros n x H; rewrite (tech_mult_negZ x).\nrewrite H; rewrite (tech_oppZ x).\nrewrite H; reflexivity.\napply le_mult_pos_posZ.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros.\nelim n.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\n(* pos *)\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x.\nelim x.\nintros x0 H; elim H.\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (multQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nunfold not in |- *; intros.\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).Qed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15419,
                "proof_end_offset": 15807,
                "proof": "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n *)\nunfold multZ in |- *; reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_mult_negZ n n0); intros.\nabsurd (pos (n * n0 + n0) = pos (n0 + (n0 + n0))).\n discriminate.\napply pos_n_O.\n(* pos n *)\nrewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0) = pos (n0 + n0)).\n discriminate.\napply pos_n_O.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_opp_posZ n0);\n intros.\nabsurd (neg (n * n0) = pos (n0 + (n0 + n0))).\n discriminate.\napply pos_n_O.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_opp_negZ n0);\n intros.\nabsurd (neg (n * n0) = pos (n0 + n)).\n discriminate.\napplyQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nintros x H; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = false). discriminate.\nexact H.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nreflexivity.\n(* pos n0 *)\nreflexivity.\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_neg_pos_posZ nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x; simpl in |- *; auto.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos (n0 + n0)).\n discriminate.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos (n0 * n0)).\nrewrite (tech_mult_neg_posZ n0 n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos (n0 * n0)).\nrewrite (tech_mult_neg_posZ n0 n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos (n0 * n0)).\nrewrite (tech_mult_neg_posZ n0 n0); intros.\nabsurd (neg (n0 * n0 + (n0 + n0)) = pos (n0 * n0)).\nrewrite (tech_mult_neg_posZ n0 n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos (n0 * n0)).\nrewrite (tech_mult_neg_posZ n0 n0); intros.Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_negZ n n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos (n0 * n0 + n0)).\nrewrite <- plus_n_Sm.\nrewrite H; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_negZ n n0); intros.\nabsurd (neg (n * n0 + n0) = pos (n0 * n0 + n0)).\nrewrite <- plus_n_Sm.\nrewrite H; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_negZ n0 n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos (n0 * n0 + n0)).\nrewrite <- plus_n_Sm.\nrewrite H; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_negZ n n0Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nsimple induction n; simpl in |- *; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_negZ n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos n0); trivial.\nrewrite (tech_mult_negZ n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos n0); trivial.\nrewrite (tech_mult_negZ n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos n0); trivial.\nrewrite (tech_mult_negZ n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos n0); trivial.\nrewrite (tech_mult_negZ n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos n0); trivial.\nrewrite (tech_mult_negZ n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos n0); trivial.\nrewrite (techQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros x; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos x).\n discriminate.\napply H; assumption.\n(* pos n *)\nintros x; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos x).\n discriminate.\napply H.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_opp_posZ n0); intros.\nabsurd (neg (n * n0 + (n0 + n0)) = pos n0 + pos n0).\n discriminate.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Qed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 15829,
                "proof_end_offset": 16089,
                "proof": "Theorem integrityZ : integrity Z multZ OZ.\nProof.\nunfold integrity in |- *; intros a b; elim a.\nintros; left; reflexivity.\nintros; right; apply (tech_integ_posZ n b); exact H.\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z multZ OZ.\n(* (Z_of_nat n0) *)\n\nTheorem Z_of_nat_o_nat :\n forall n : nat, n <> 0 -> nat_of_nat (S n) = n.\nintros n; elim n.\n(* pos n *)\nunfold nat_of_nat, nat_of_P in |- *; simpl in |- *.\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (0 <= n0); auto with arith.\nrewrite <- H; auto with arith.\n(* pos n *)\nunfold nat_of_P in |- *; simpl in |- *.\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + n0) = 0); auto with arith.\nrewrite <- H; auto with arith.\n(* pos n *)\nunfold nat_of_P in |- *; simpl in |- *.\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0) = 0); auto with arith.\nrewrite <- H; auto with arith.Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\napply (Z_plus_pos_pos 2).\nexact integsegZ_negZ.\nexact integsegZ_negZ.\nexact integsegZ_negZ.\nexact integsegZ_negZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_negZ.\nexact integsegZ_negZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_negZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integsegZ_posZ.\nexact integQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold intadherent in |- *.\nintros n x; elim x.\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_plus_pos_posZ n0).\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n0 n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos n0 + pos n0).\nrewrite <- mult_n_O.\nrewrite H; rewrite (mult_comm (n0 + n0) (n0 + n0)).\nrewrite H; rewrite (mult_comm (n0 + n0) (n0 + n0)).\nrewrite H; rewrite (mult_comm (n0 + n0) (n0 + n0)).\nrewrite H; rewrite (mult_comm (n0 + n0) (n0 + n0)).\nrewrite H; rewrite (mult_comm (n0 + n0) (n0 + n0)).\nrewrite H; rewrite (mult_comm (n0 + n0) (n0 + n0)).\nrewrite H; rewrite (mult_comm (Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold z in |- *.\nsimpl in |- *.\nelim x.\n(* pos n0 *)\nsimpl in |- *; elim x.\n(* pos n0 *)\nintros n1; rewrite (tech_mult_neg_posZ n1 n0); intros.\nabsurd (neg (n * n0 + (n0 + n1)) = pos (n0 + n1)).\napply pos_or_eq; auto.\nrewrite <- (mult_oppZ_opp (n0 + n1)) in |- *; auto with arith.\nrewrite <- (mult_oppZ_opp (n0 + n1)) in |- *; auto with arith.\nrewrite <- (mult_oppZ_opp (n0 + n1)) in |- *; auto with arith.\nrewrite <- (mult_oppZ_opp (n0 + n1)) in |- *; auto with arith.\nrewrite <- (mult_oppZ_opp (n0 + n1)) in |- *; auto with arith.\nrewrite <- (mult_oppZ_opp (n0 + n1)) in |- *; auto with arith.\nrewrite <- (mult_oppZ_opp (n0 + n1)) in |-Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\n(* Zes decoding *)\n(* Zes a definition of a non-negative integers *)\n\nDefinition Z2Z (n : nat) :=\n  match n with\n  | O => 0\n  | S n' => 0\n  | S n' => 1\n  end.\n\nTheorem Z2Z_pos_neg :\n forall (n : nat) (x : Z), Z2Z (n * x) = x.\nintros n; elim x.\nrewrite <- (mult_comm (n * x) x); rewrite <- (mult_comm x).\nrewrite <- (mult_comm (n * x) (n * x)).\nrewrite <- (mult_comm (n * x) (n * x)).\nrewrite <- (mult_comm (n * x) (n * x)).\nrewrite (mult_comm (n * x) (n * x)).\nrewrite (mult_comm (n * x) (n * x)).\nrewrite (mult_comm (n * x) (n * x)).\nrewrite (mult_comm (n * x)).\nrewrite (mult_comm (n * x) (n * x)).\nrewrite (mult_comm (n *Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold one, multZ in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfold multZ in |- *.\nunfold multZ in |- *.\nsimpl in |- *.\nunfoldQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold oppZ in |- *.\nunfold multZ in |- *.\nintros x y z; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = pos (n0 + n0)). discriminate.\nrewrite H; elim z; reflexivity.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold Zd in |- *.\nsimpl in |- *.\nelim x.\n(* pos n0 *)\nintros n1 n2; rewrite (tech_mult_neg_posZ n n1); intros.\nabsurd (neg (n * n0 + n1)) = pos n0). discriminate.\napply tech_inte_posZ with n1; trivial.\napply H; rewrite <- multZ_plus_distr_l; rewrite <- multZ_plus_distr_r;\n rewrite <- multZ_plus_distr_l; rewrite <- multZ_plus_distr_l;\n rewrite <- multZ_plus_distr_l; rewrite <- multZ_plus_distr_r;\n rewrite <- multZ_plus_distr_l; rewrite <- multZ_plus_distr_r;\n rewrite <- multZ_plus_distr_l; rewrite <- multZ_plus_distr_r;\n rewrite <- multZ_plus_distr_l; rewrite <- multZ_plus_distr_l;\n rewrite <- multZ_plus_distr_r; rewrite <- multZ_plus_distr_l;\n rewrite <- multZ_plus_distr_l;Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold oppZ in |- *.\nunfold oppZ in |- *.\nsimpl in |- *.\nrewrite plus_comm.\napply multZ_comm.\napply multZ_comm.\napply multZ_comm.\napply multZ_comm.\napply multZ_comm.\napply multZ_comm.\napply multZ_comm.\napply multZ_comm.\napply mult_comm.\napply mult_Z_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_commQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold one, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros n x; elim x.\nintros n1 x0; rewrite (tech_mult_neg_posZ n n1); intros.\nabsurd (neg (n * n0 + n0)) = pos (n0 * n1 + n0)).\n discriminate.\napply opp_pos_zero; auto.\napply opp_neg_zero; auto.\napply opp_pos_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_pos_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zero; auto.\napply opp_neg_zeroQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\n",
                "context_tokens": 722,
                "proof_start_offset": 16118,
                "proof_end_offset": 16787,
                "proof": "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros; elim m.\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros.\nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)).\nrewrite (mult_neutr (S n)).\nunfold posOZ in |- *; reflexivity.\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)); elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n(* 0 *)\nintros n m; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\n(* Focus 2 *)\nintros; left; reflexivity.\n(* Focus 2 *)\nintros; right; reflexivity.\n(* Focus 2 *)\nintros; right; reflexivity.\n(* Focus 3 *)\nintros; right; reflexivity.\n(* Focus 2 *)\nintros; right; reflexivity.\n(* Focus 2 *)\nintros; left; reflexivity.\n(* Focus 3 *)\nintros; left; reflexivity.\n(* Focus 2 *)\nintros; right; reflexivity.\n(* Focus 3 *)\nintros; right; reflexivity.\n(* Focus 2 *)\nintros; right; reflexivity.\n(* Focus 3 *)\nintros; right; reflexivity.\n(* Focus 3 *)\nintros; right; reflexivity.\n(* Focus 2 *)\nintros; left; reflexivity.\n(* Focus 3 *)\nintros; left; reflexivity.\n(* Focus 2 *)\nintros; left; reflexivity.\n(* Focus 3 *)\nintros; right; reflexivity.\n(* Focus 3 *)\nintros; right; reflexivity.\n(* Focus 3 *)\nintros; right; reflexivity.\n(* Focus 3 *)\nintros; left; reflexivity.\n(* Focus 3 *)\nintros; left; reflexivity.\n(* Focus 3 *)\nintros;Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n(* Proof of the following properties *)\nintros n m; elim n; simpl in |- *; auto with arith.\n(* pos n *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0) = 0); auto with arith.\nrewrite H; apply lt_O_Sn.\n(* pos n *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0) = 0); auto with arith.\nrewrite H; apply lt_O_Sn.\n(* pos n *)\nintros; right; apply (tech_integ_negZ n0 b); exact H.\n(* pos n *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0) = 0); auto with arith.\nrewrite H; apply lt_O_Sn.\n(* pos n *)\nintros; right; apply (tech_integ_negZ n n0); exact H.\n(* pos n *)\nintros n0; rewrite (tech_mult_neg_Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n(* Proof of the following theorem *)\nintros n m; elim m.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n m);Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n; simpl in |- *; auto with arith.\nintros m; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_integ_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_integ_posZ n m); exact H.\n(* pos nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros n m; elim n.\n(* n0 *)\nreflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; rightQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n b); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_posZ n b); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n b); exact H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n b); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n b); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_pos_posZ n b); exact H.\n(* pos n *)\nsimpl in |- *; apply (tech_integ_Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\n(* 0 *)\nreflexivity.\n(* pos n *)\nintros n0; rewrite (tech_expeg_pos_negZ n n0); intros.\nabsurd (pos (n * n0 + n0) = pos n0). discriminate.\n(* 0 *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0; rewrite (tech_expeg_pos_posZ n0 n0); intros.\nabsurd (pos (n * n0 + n0) = pos n0). discriminate.\n(* 0 *)\nreflexivity.\n(* pos n *)\nintros n0; rewrite (tech_expeg_pos_posZ n0); intros.\nabsurd (neg (n * n0) = pos n0). discriminate.\n(* 0 *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0; rewrite (tech_expeg_pos_posZ n0); intros.\nabsurd (neg (n * n0) = pos n0). discriminate.\n(* 0 *)\nreflexivity.\n(* pos n *)\nintros n0; rewrite (tech_expegQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m; simpl in |- *; auto with arith.\nintros n0; elim m; simpl in |- *; auto with arith.\nintros m; right; apply (tech_integ_posZ n0 m); exact H.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; right; reflexivity.\n(* pos n *)\nsimpl in |- *; right; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; right; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; left; reflexivity.\n(* pos n *)\nsimpl in |- *; right; reflexivity.\n(*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\n",
                "context_tokens": 721,
                "proof_start_offset": 16816,
                "proof_end_offset": 17035,
                "proof": "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim (le_plus_neg_pos_pos_pos m n); intros.\nabsurd (pos (n * n0 + (n0 + m0)) = pos (S n0 + m0)).\n apply (mult_reg_l (pos n0 * n0 + (n0 + m0) + m0)).\nrewrite (mult_comm (pos n0) (neg n0)).\nrewrite (mult_comm (pos n0) (neg n0)).\nunfold pos at 2 in |- *; rewrite (mult_comm (neg n0)).\nrewrite (mult_plus_neg_pos_pos m n0); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(*Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros n m; elim m.\n(* 0 *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n; simpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; right; apply (tech_mult_pos_pos_pos_pos_pos_pos m); assumption.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim m.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(*Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* pos n *)\nintros; right; apply (tech_mult_pos_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_pos n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_neg_pos n m); exact HQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nintros n0 H; elim (mult_comm (pos n) (pos m)); intros. \napply (tech_mult_pos_pos_pos_pos m n0); apply H.\nrewrite (mult_comm (pos n) (pos m)).\nunfold neg at 1 in |- *; rewrite (mult_comm (pos m)); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros n m; elim m.\nrewrite (tech_mult_neg_pos_pos m n); elim (mult_n_Sm (S n) m); elim (mult_n_Sm (S n) m);\n elim (mult_n_Sm (S m) y); elim (mult_n_Sm (S n) y);\n elim (mult_n_Sm (S n) y); elim (mult_n_Sm (S n) y);\n reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nsimple induction n; intros; elim (le_or_eq n m); intros.\nabsurd (neg (S m) = pos (S n)).\nrewrite H1.\nrewrite (tech_mult_neg_pos (S n) (pos m) (neg m) (neg m)).\nrewrite (mult_comm (pos n) (neg m)).\nrewrite (mult_comm (neg m) (neg m)).\nreflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 17054,
                "proof_end_offset": 17961,
                "proof": "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n q r; elim q.\nelim r.\nintros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *; reflexivity.\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n1 q r H; elim H; elim H; elim H; elim H0;\n simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (tech_div2 (pos n) (posEsg q)) (posOZ q)); auto.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nsimple induction n0; intros; elim (tech_mult_pos_ Scope pos => pos n0);\n simpl in |- *; elim (mult_n_Sm m n); elim (mult_n_Sm n0);\n reflexivity.\n(* 0 *)\nintros n0 q r H H0 H1 H2.\nelim H1; elim (mult_n_Sm m n); elim (mult_n_Sm m n0);\n reflexivity.\n(* 0 *)\nintros n0 q r H H0 H1 H2.\nelim (mult_n_Sm m n); elim (mult_n_Sm m n); elim (mult_n_Sm m n0);\n reflexivity.\n(* 0 *)\nintros n0 q r H H0 H2.\nelim H1; elim (mult_n_Sm m n); elim (mult_n_Sm m n0);\n reflexivity.\n(* 0 *)\nintros n0 q r H H0 H1 H2.\nelim H1; elim (mult_n_Sm m n0); elim (mult_n_Sm m n0);\n reflexivity.\n(* 0 *)\nintros n0 qQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 q r; elim r; elim r; elim r; elim r; elim r; elim r;\n intros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nsimple induction n0; simpl in |- *; intros; rewrite (tech_mult_pos_pos_pos n0 q r).\nrewrite (mult_comm (pos n0) (pos _)), (mult_comm (pos n0) (pos _)), (mult_comm (pos n0)).\nreflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (mult_n_Sm n0 q r); elim (mult_n_Sm q r); elim (mult_n_Sm q r);\n elim (mult_n_Sm (S n0) (S q) (plus_n_Sm q r));\n intros; rewrite H1; rewrite H2; reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nsimple induction n0; intros; elim r; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nsimple induction n0.\n(* n0 *)\nintros; left; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; left; reflexivity.\n(* n0 *)\nintros; left; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; left; reflexivity.\n(* n0 *)\nintros; left; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; left; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right; reflexivity.\n(* n0 *)\nintros; right;Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nsimple induction n0; simpl in |- *; intros.\nrewrite (tech_mult_neg_pos_pos (pos r) (pos Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (neg Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (pos Mptr) (neg Mptr) (neg Mptr) (pos Mptr) (neg Mptr) (neg Mptr) (pos Mptr) (pos Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (pos Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr) (neg Mptr)Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 q r; elim r; elim r; elim r; elim r; elim r; elim r;\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 17980,
                "proof_end_offset": 18420,
                "proof": "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nintros n0 n q; elim q.\nsimpl in |- *; intros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold negOZ in |- *.\nrewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(*O *)\nintros y H; unfold neg at 2 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 2 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 2 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 2 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 2 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 2 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 3 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 1 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 1 in |- *; rewrite (mult_comm y); reflexivity.\n(*O *)\nintros y H; unfold neg at 2 in |- *; rewrite (mult_comm yQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nintros n0 n q; elim q.\n(* n0 = n0 *)\nintros n1 n2; elim q.\n(* n1 = n1 *)\nintros n2 n3; elim q.\n(* n1 = n2 *)\nintros n1 n3; elim q.\n(* n1 = n2 *)\nintros n2 n3; elim q.\n(* n1 = n3 *)\nintros n3 n3; elim q.\n(* n1 = n3 *)\nintros n1 n3; elim q.\n(* n1 = n3 *)\nintros n3 n4; elim q.\n(* n1 = n4 *)\nintros n4 n5; elim q.\n(* n1 = n1 *)\nintros n4 n5; elim q.\n(* n1 = n3 *)\nintros n4 n5; elim q.\n(* n1 = n3 *)\nintros n4 n5; elim q.\n(* n1 = n3 *)\nintros n5 n6; elim q.\n(* n1 = n4 *)\nintros n6 n7; elim q.\n(* n1 = n4 *)\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = q *)\nelim (plus_n_Sm n0 q).\n(* S n0 = qQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* 0 *)\nintros n0 q; elim q.\n(* 0 *)\nintros n0 q0; elim q.\n(* 0 *)\nintros n1 q0; elim q0.\n(* 0 *)\nintros n1 q0; elim q0.\n(* 0 *)\nintros n1 q0; elim q0.\n(* 0 *)\nintros n1 q1; elim q0.\n(* 0 *)\nintros n2 q1; elim q1.\n(* 0 *)\nintros n2 q1 q2; elim q1.\n(* 0 *)\nintros n1 q1 q2; elim q1.\n(* 0 *)\nintros n2 q2; elim q1.\n(* 0 *)\nintros n3 q2; elim q2.\n(* 0 *)\nintros n4 q3; elim q2.\n(* 0 *)\nintros n4 q3; elim q3.\n(* 0 *)\nintros n4 q3; elim q4.\n(* 0 *)\nintros n4 q3; elim q4.\n(* 0 *)\nintros n4 q3; elim q4.\n(* 0 *)\nintrosQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nsimple induction n0; intros; simpl in |- *; auto with arith.\nintros; absurd (0 = 0).\ndiscriminate.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nintros n0 q; elim q.\n(*O *)\nintros n0 q0 H; elim (mult_comm n0 q0).\n(*O *)\nintros n0 q0 H; elim (mult_comm n0 q0).\n(*O *)\nintros n1 q0 H; elim (mult_comm n1 q0).\n(*O *)\nintros n2 q0 H; elim (mult_comm n1 q0).\n(*O *)\nintros n2 q0 H; elim (mult_comm n2 q0).\n(*O *)\nintros n2 q0 H; elim (mult_comm n2 q0).\n(*O *)\nintros n2 q0 H; elim (mult_comm n2 q0).\n(*O *)\nintros n3 q0 H; elim (mult_comm n2 q0).\n(*O *)\nintros n3 q0 H; elim (mult_comm n3 q0).\n(*O *)\nintros n4 q0 H; elim (mult_comm n4 q0).\n(*O *)\nintros n4 q0 H; elim (mult_comm n3 q0).\n(*Qed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* Focus 1 *)\nintros n0 q0; rewrite (mult_comm 0 q0).\nrewrite (mult_comm (pos n0) (neg _)), (mult_comm (pos n0) q0).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0) (neg q0)).\nrewrite (mult_comm (neg n0Qed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(* Focus 2 *)\nintros; absurd (S n0 = 0).\nintro H1; rewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H0.\nrewrite H.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H3.\nrewrite H1.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite HQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nintros n0 n q; elim q.\n(*O *)\nintros n1 n2 q0; elim q.\n(*O *)\nintros n2 n3 q0; elim q0.\n(*O *)\nintros n1 n2 q0; elim q0.\n(*O *)\nintros n2 q0; elim q0.\n(*O *)\nintros n2 q0; elim q0.\n(*O *)\nintros n2 q0; elim q0.\n(*O *)\nintros n2 q0; elim q0.\n(*O *)\nintros n2 q0; elim q0.\n(*O *)\nintros n2 q2; elim q0.\n(*O *)\nintros n2 q2; elim q0.\n(*O *)\nintros n2 q2; elim q2.\n(*O *)\nintros n2 q2; elim q2.\n(*O *)\nintros n2 q2; elim q2.\n(*O *)\nintros n2 q2; elim q2.\n(*O *)\nintros n2 q2; elim q2.\n(*O *)\nintros n2 q2; elim qQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 q; elim q.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y H; elim H; intros; assumption.\n(*O *)\nintros x y HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 711,
                "proof_start_offset": 18440,
                "proof_end_offset": 19318,
                "proof": "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros; elim q.\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)).\ncut (IZ = pos 0); intros.\nelim H.\nrewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity.\nreflexivity.\nintros y H; unfold posOZ in |- *; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y) (pos n)) (pos n) I I).\nelim (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* Focus 1 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (tech_mult_neg_pos_pos_neg_pos p y);\n reflexivity.\n(* Focus 1 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (tech_mult_neg_pos_pos_pos p y);\n reflexivity.\n(* Focus 2 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (tech_mult_neg_pos_pos_neg_pos p y);\n reflexivity.\n(* Focus 2 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (tech_mult_neg_pos_neg_pos p y);\n reflexivity.\n(* Focus 3 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (tech_mult_neg_pos_pos p y);\n reflexivity.\n(* Focus 3 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (tech_mult_neg_pos_pos p y);\n reflexivity.\n(* Focus 2 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (tech_multQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0). discriminate.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(*O *)\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nintros; absurd (0 < q).\napply lt_le_trans with (pred (pos n) + pos q); auto with arith.\napply lt_trans with (pred (pos n) + pos q); auto with arith.\napply lt_le_trans with (pred (pos n) + pos q); auto with arith.\napply lt_le_trans with (pred (pos n) + pos q)); auto with arith.\napply lt_trans with (pred (pos n) + pos q); auto with arith.\napply lt_le_trans with (pred (pos n) + pos q); auto with arith.\napply lt_le_trans with (pred (pos n) + pos q); auto with arith.\napply lt_le_trans with (pred (pos n)); auto with arith.\napply lt_le_trans with (pred (pos n)); auto with arith.\napply lt_le_trans with (pred (pos n)); auto with arith.\napply lt_le_trans with (pred (pos n)); auto with arith.\napply lt_pred_n; autoQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* Focus 2 *)\nintros x y H; unfold neg at 1 in |- *; rewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y (nat_of_P x)).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm (nat_of_P x)).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y (nat_of_P y)).\nrewrite (mult_comm (nat_of_P y)).\nrewrite (mult_comm y (nat_of_P y)).\nrewrite (mult_comm x y).\nrewrite (mult_comm y (nat_of_P y)).\nrewrite (mult_comm x y).\nrewrite (mult_comm y (nat_of_P y)).\nrewrite (mult_comm x y).\nrewrite (mult_comm y (nat_of_P x)).\nrewrite (mult_comm y (nat_of_P y)).\nrewrite (mult_Qed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 < 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).\n discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0).Qed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nsimple induction n.\nsimpl in |- *; intros; rewrite (mult_comm (pos n)).\nsimpl in |- *; intros; elim (mult_comm (pos n) (pos n)).\nrewrite (mult_comm (pos n)).\nsimpl in |- *; intros; elim (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nsimpl in |- *; intros; elim (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nsimpl in |- *; intros; elim (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nsimpl in |- *; intros; elim (mult_comm (neg n)).\nsimpl in |- *; intros; elim (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nsimpl in |- *; intros; elim (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nsimpl in |- *; intros; elim (mult_comm (neg n)).\nsimpl in |- *; intros; elim (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nsimpl in |- *; intros; elim (mult_comm (negQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros n q; elim q.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 = 0).\n discriminate.\n(* 0 *)\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (0 = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *; intros; absurd (S n = 0). discriminate.\n(*O *)\nsimpl in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 719,
                "proof_start_offset": 19338,
                "proof_end_offset": 19708,
                "proof": "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim r.\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n)); elim (minus_n_O n).\nreflexivity.\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry in |- *.\nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nsimple induction n.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\nrewrite H0; auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\nrewrite H0; auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arith.\n(* 0 *)\nsimpl in |- *; intros; absurd (0 < r); auto with arithQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim r; simpl in |- *; intros.\nrewrite (mult_comm (pos n) (pos q)).\nrewrite (mult_comm (pos n) (pos q)); simpl in |- *; elim (plus_comm (pos n));\n rewrite (mult_comm (pos n) (pos q)); simpl in |- *; elim (mult_comm (pos n));\n rewrite (mult_comm (pos n) (pos q)); simpl in |- *; elim (mult_comm (pos n));\n rewrite (mult_comm (pos n) (neg q)); simpl in |- *; elim (mult_comm (neg n));\n rewrite (mult_comm (pos n) (neg q)); simpl in |- *; elim (mult_comm (pos n));\n rewrite (mult_comm (neg n) (neg q)); simpl in |- *; elim (mult_comm (neg n));\n rewrite (mult_comm (neg n) (neg q)); simpl in |- *; elim (mult_comm (neg n));\n rewrite (mult_comm (neg n) (neg q)); simpl in |- *; elim (mult_comm (neg n));\n rewrite (mult_comm (negQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim q.\n(* 1 *)\nunfold neg at 1 in |- *; rewrite (mult_comm 0).\napply opp_pos_pos.\nrewrite <- opp_pos_neg; rewrite <- opp_pos_neg; reflexivity.\n(* 2 *)\nunfold neg at 1 in |- *; rewrite (mult_comm 1).\napply opp_neg_pos.\nrewrite <- opp_pos_neg; rewrite <- opp_pos_neg; reflexivity.\n(* 2 *)\nunfold neg at 1 in |- *; rewrite (mult_comm 0).\napply opp_neg_neg.\nrewrite <- opp_neg_neg; rewrite <- opp_neg_neg; reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim q; simpl in |- *; intros.\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (negQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r H; elim H; auto.\n(* O *)\nintros y H; unfold neg at 1 in |- *; rewrite (mult_comm y).\napply (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\napply (mult_comm (pos n)).\napply (mult_comm (pos n)).\napply (mult_comm (pos n)).\napply (mult_comm (pos n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (neg n)).\napply (mult_comm (negQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim q; elim r; elim r; elim r; elim r; simpl in |- *;\n reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros; elim (mult_comm (pos n) (pos r)); simpl in |- *; elim (mult_comm (pos n));\n reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim r.\n(*O *)\nunfold pos at 1 in |- *; rewrite (plus_comm 0).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros n q r; elim r.\n(*O *)\nunfold neg at 1 in |- *; rewrite (mult_comm (pos n)).\ncut (neg (n - r) = pos n).\nintro H0; rewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nelim (mult_comm (pos n) (pos n)); simpl in |- *; elim (mult_comm (pos n));\n reflexivity.\n(*O *)\nunfold neg at 1 in |- *; rewrite (mult_comm (pos n)).\ncut (neg (n - r) = pos n).\nintro H0; rewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nelim (mult_comm (pos n) (pos n)); simpl in |- *; elim (mult_comm (pos n));\n reflexivity.\n(*O *)\nunfold neg at 1 in |- *; rewrite (mult_comm (neg n)).\ncut (neg (n - r) = pos n).\nintro H1; rewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nelim (Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim q.\n(*O *)\nunfold neg at 1 in |- *; rewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (mult_comm (neg n)).\nrewrite (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 19727,
                "proof_end_offset": 20249,
                "proof": "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r))) .\nrewrite (tech_div31 n q).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nunfold pos')).\nunfold pos at 2 in |- *; rewrite (add_comm (pos n)).\nrewrite <- (add_assoc (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (pos n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (neg n)).\nrewrite (plus_comm (neg n)).Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(* O *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKr (neg n)).\nelim (mult_assoc y (S n0) (pos q)); simpl in |- *; elim (mult_assoc y (S n0) (pos q));\n simpl in |- *.\nreflexivity.\n(* O *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKr (neg n)).\nelim (mult_assoc y (S n0) (pos q)); simpl in |- *.\nreflexivity.\n(* O *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKl (neg n)).\nelim (mult_assoc y (S n0) (neg q)); simpl in |- *.\nreflexivity.\n(* O *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKr (neg n)).\nelim (mult_assoc y (S n0) (neg q)); simpl in |- *.\nreflexivity.\n(* O *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKr (neg n)).\nelim (mult_assoc y (SQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros n0 q r H; elim H.\n(* O *)\nunfold neg at 2 in |- *; unfold oppZ in |- *; rewrite (mult_comm (pos n0)).\ncut (pos n > r); [ intros H1 | apply H1; elim H1; intros; rewrite H2;\n | rewrite H1; reflexivity ].\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros n0 q r; elim r.\n(*O *)\nunfold neg at 1 in |- *; unfold oppZ in |- *; rewrite (mult_comm r).\nelim (mult_comm r (S n0)); simpl in |- *; elim (mult_comm r (S n0));\n reflexivity.\n(*O *)\nunfold neg at 1 in |- *; unfold oppZ in |- *; rewrite (mult_comm r).\nelim (mult_comm r (S n0)); simpl in |- *; elim (mult_comm r (S n0));\n reflexivity.\n(*O *)\nunfold pos at 2 in |- *; unfold oppZ in |- *; rewrite (mult_comm r).\nelim (mult_comm r (S n0)); simpl in |- *; elim (mult_comm r (S n0));\n reflexivity.\n(*O *)\nunfold pos at 1 in |- *; unfold oppZ in |- *; rewrite (mult_comm r).\nelim (mult_comm r (S n0)); simpl in |- *; elim (mult_comm r (S n0));\n reflexivity.\n(*O *)\nunfold neg at 1 in |- *; unfold oppZ in |- *; rewrite (mult_commQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r H H0; elim H0; simpl in |- *.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto with arith.\nintros; absurd (S n0 = 0); auto withQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(*O *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKl y);\n elim (mult_comm (S n) y); simpl in |- *.\nreflexivity.\n(* S y *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKr y);\n elim (mult_comm (S n) y); simpl in |- *.\nreflexivity.\n(* S y *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKr y);\n elim (mult_comm (S n) y); simpl in |- *.\nreflexivity.\n(* S y *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKr y);\n elim (mult_comm (S n) y); simpl in |- *.\nreflexivity.\n(* S y *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKl y);\n elim (mult_comm (S n) y); simpl in |- *.\nreflexivity.\n(* S y *)\nintros y H; unfold neg at 1 in |- *; rewrite (add_multKl y);\n elim (mult_comm (SQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(*O *)\nunfold neg at 1 in |- *; rewrite (add_RN_plus_pos_neg_neg_neg_pos).\nelim (plus_n_O n0).\nrewrite (mult_comm (pos n0)).\napply le_trans with (pos n0 + pos q); [ idtac | auto with arith ].\nrewrite (mult_comm (pos n)).\napply le_trans with (neg q); [ idtac | auto with arith ].\nrewrite (mult_comm (pos n)).\napply le_trans with (pos n0 + pos q); [ idtac | auto with arith ].\nrewrite (mult_comm (neg n)).\napply le_trans with (neg q); [ idtac | auto with arith ].\napply le_trans with (neg q); [ idtac | auto with arith ].\napply le_trans with (neg q); [ idtac | auto with arith ].\napply le_trans with (neg q); [ idtac | auto with arith ].\nrewrite (mult_comm (pos n)).\napply le_trans with (neg q); [ idtac | auto with arith ].\nrewrite (mult_comm (neg n)).Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 q r; elim r.\n(*O *)\nunfold neg at 2 in |- *; unfold pos at 1 in |- *;\n rewrite (mult_comm (pos n0) q).\napply Rplus_lt_reg_l with (pos n0);\n [ rewrite <- (mult_comm (pos n0) q) | ring ].\napply Rplus_lt_reg_l with (pos n0);\n [ apply lt_O_Sn | apply lt_O_Sn ].\napply Rplus_lt_reg_l with (pos n0);\n [ rewrite <- (mult_comm (pos n0) q) | ring ].\napply Rplus_lt_reg_l with (pos n0);\n [ rewrite <- (mult_comm (pos n0) q) | ring ].\napply Rplus_lt_reg_l with (pos n0);\n [ apply lt_O_Sn | apply lt_O_Sn ].\napply Rplus_lt_reg_l with (pos n0);\n [ rewrite <- (mult_comm (pos n0) q) | ring ].\napply Rplus_lt_reg_l with (pos n0);\n [ apply lt_Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nsimple induction n0; simpl in |- *; auto with arith.\nintros; absurd (0 < r); auto with arith.\nintros; absurd (0 < r); auto with arith.\nintros; absurd (0 < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (r < r); auto with arith.\nintros; absurd (Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nsimple induction n0; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 20268,
                "proof_end_offset": 20706,
                "proof": "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros.\nelim (tech_inv_neg_neg_neg_neg_neg (pos n) 0 r); intros; elim H0.\nrewrite (mult_neg_pos n0).\nrewrite (mult_neg_pos n0).\nrewrite (mult_neg_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg_neg n0).\nrewrite (mult_neg n0).\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros n0 q r; elim r.\n(* S n0 *)\nunfold neg at 1 in |- *; rewrite (mult_comm r 0); rewrite (mult_comm r 0);\n rewrite (mult_comm r 0); reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros n0 q r; elim r.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold pos at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold neg at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold neg at 1 in |- *; rewrite (mult_comm 0); reflexivity.\n(*O *)\nunfold neg at 1 in |- *;Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros.\nelim (tech_div2 n0 q r); intros; elim H1; intros; elim H2; intros;\n rewrite H2; rewrite (plus_comm 0); rewrite (plus_comm 0);\n rewrite (mult_comm 0); rewrite (mult_comm 0); rewrite (mult_comm 0);\n rewrite (mult_comm 0); rewrite (mult_comm 1);\n rewrite (mult_comm (pos n)); rewrite (mult_comm 0); rewrite (mult_comm 0);\n rewrite (mult_comm (pos n)); rewrite (mult_comm (pos n));\n rewrite (mult_comm 0); rewrite (mult_comm 0); rewrite (mult_comm (neg n));\n rewrite (mult_comm (pos n)); rewrite (mult_comm (pos n)); rewrite (mult_comm 0);\n rewrite (mult_comm (pos n)); rewrite (mult_comm (pos n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nsimple induction n0; simpl in |- *; intros; elim H0.\n(* O *)\nintros; rewrite H; rewrite H0; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; rewrite H0; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; rewrite H0; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; rewrite H0; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; rewrite H0; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; rewrite H0; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; simpl in |- *; reflexivity.\n(* O *)\nintros; rewrite H; simpl in |- *; reflexivity.\n(* O *)\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros.\nelim (tech_div2 n0 q r); intros; elim H1; reflexivity.\n(* 0 *)\nunfold pos at 1 in |- *; unfold pos at 1 in |- *;\n rewrite (mult_comm 1).\nrewrite (mult_comm 0).\nrewrite (mult_comm 1).\nrewrite (mult_comm (pos n0) (neg q)); rewrite (mult_comm (neg n0) (neg q)));\n rewrite (mult_comm (neg n0) (neg q))); reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros; elim q; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros n0 q r; elim r; reflexivity.\n(* 0 *)\nintros n0 q r; rewrite (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\nrewrite (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\nrewrite (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0).\napply (mult_comm (neg n0)).\nrewrite (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0)).\napply (mult_comm (neg n0).Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros.\nelim (tech_opp_pos_neg_neg_neg_neg_neg n0 q r); intros; elim H1; intros.\nrewrite H2; reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nsimple induction n0; simpl in |- *; auto with arith.\nsimple induction n0; simpl in |- *; auto with arith.\nsimple induction n0; simpl in |- *; auto with arith.\nsimple induction n1; simpl in |- *; auto with arith.\nsimple induction n1; simpl in |- *; auto with arith.\nsimple induction n1; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n2; simpl in |- *; auto with arith.\nsimple induction n3; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 20725,
                "proof_end_offset": 21054,
                "proof": "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; cut (posOZ q = oppZ (negOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; apply tech_div5; assumption.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim H; reflexivity.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; apply tech_div4; auto.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (neg Automatic n = oppZ (pos 53) (neg 53)).\nintros; elim (mult_neg_pos_neg_pos n); intros; reflexivity.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (neg n) (neg Datatypes.Lt q) = multZ (neg n) (pos Datatypes.Lt q)).\nrewrite <- (mult_neg_pos n q); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (multQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (neg n) (neg Datatypes.Lt q)); intros.\nrewrite H; intros; apply (tech_opp_neg_neg n0 q r H).\nrewrite (mult_neg_pos (pos n0) (neg Datatypes.Lt q) I);\n rewrite (mult_neg_pos (pos n0) (neg Datatypes.Gt q) I);\n rewrite (mult_neg_pos (pos n0) (neg Datatypes.Gt q) I);\n rewrite (mult_neg_neg (pos n0) (neg Datatypes.Gt q) I);\n rewrite (mult_neg_neg (pos n0) (neg Datatypes.Lt q) I);\n rewrite (mult_neg_neg (pos n0) (neg Datatypes.Gt q) I);\n rewrite (mult_neg_neg (neg n0) (neg Datatypes.Gt q) I);\n rewrite (mult_neg_neg (neg n0) (neg Datatypes.Gt q) I);\n rewrite (mult_neg_neg (neg n0) (neg Datatypes.Gt q) I);\n rewrite (mult_neg_neg (neg n0) (neg Datatypes.Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; elim (tech_opp_neg_neg_neg_neg_neg_neg n); intros; elim H1.\nrewrite (mult_opp_Z_opp (neg n) (neg _)), (tech_opp_neg n0 q); rewrite (tech_opp_neg n0 q);\n assumption.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros n0 q r; elim r.\n(*O *)\nunfold neg at 1 in |- *; unfold oppZ in |- *; rewrite (add_comm 0 1);\n apply (mult_opp_neg_pos_neg_pos_neg_pos_neg_neg q);\n rewrite (add_comm 0 1); rewrite (add_comm 0 1); rewrite (add_comm 0 1);\n apply (mult_opp_neg_pos_neg_neg q);\n assumption.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; rewrite H; apply tech_div5; apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div2; apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div4; apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div; apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div2; apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div4; apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div2; apply tech_div4; apply tech_div4;\n apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div4; apply tech_div4; apply tech_div4;\n apply tech_div4;Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; rewrite H; rewrite H0; rewrite (add_comm (pos _)), H;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;\n rewrite opp_Z_div; rewrite opp_Z_div; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;\n rewrite opp_Z_div; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div;\n apply div2_opp; rewrite opp_Z_div; rewrite opp_Z_div;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 21073,
                "proof_end_offset": 21415,
                "proof": "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros; elim (tech_div2 n0 q r r H); auto.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; elim (tech_opp_pos_neg_neg_pos_pos_neg n); intros; elim H1.\nrewrite (mult_comm (neg n) (pos q)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n) (pos q)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewrite (mult_comm (neg n)); rewrite (mult_comm (neg n));\n rewriteQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nsimple induction n0; simpl in |- *; auto with arith.\nintros; elim H1; elim H1; elim H1;\n reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nsimple induction n0.\nrewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (neg n0) (neg q));\n reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros; elim (tech_div2 n0 n0 q r); simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; elim (tech_opp_neg_pos_neg_neg n0); intros; elim H1.\napply (plus_pos_pos_pos (pos n) (pos q) (pos q)); rewrite (tech_div2 n q r);\n rewrite (tech_div2 (pos n) (pos q) (pos q)); rewrite (tech_div2 (pos n) (neg q)));\n rewrite (tech_div2 (pos n) (pos q) (pos q)); rewrite (tech_div2 (pos n) (pos q));\n rewrite (tech_div2 (pos n) (pos q) (pos q)); rewrite (tech_div2 (pos n) (pos q) (pos q));\n rewrite (tech_div2 (pos n) (pos q) (pos q) (pos q));\n rewrite (tech_div2 (pos n) (neg q) (pos q)));\n rewrite (tech_div2 (pos n) (neg q) (neg q));\n rewrite (tech_div2 (pos n) (neg q) (neg q)));\n rewrite (tech_div2 (pos n) (pos q) (Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros n0 q r; elim r; reflexivity.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros; elim (tech_opp_neg_neg_neg_neg n); intros; elim H1.\nrewrite (mult_neg_neg_neg_neg_neg_neg n); assumption.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (neg (/ r)) = - r); intros.\nrewrite H0; intros; exact (tech_div2 n0 q r H).\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros; rewrite H0; intros; exact (tech_div2 n0 n0 q r H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 21436,
                "proof_end_offset": 22829,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nsimple destruct x.\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\nsimple induction n.\nintros; left; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (pos (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\nsimple induction n.\nright; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (neg (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nsimple induction x; intros.\napply (tech_pos_neg_neg_pos (pos x) (pos y) H0).\nrewrite H0; intros; elim H0.\nrewrite (mult_neg_neg_neg (pos x) (neg y) H0).\nrewrite (mult_neg_neg (neg y) (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (neg y) H0).\nrewrite (mult_neg_neg (negQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim (tech_opp_pos_neg_pos_neg_neg x); intros; elim H;\n reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim (tech_opp_neg_neg_neg x); intros; elim H0.\nrewrite (mult_opp Z oppZ oppZ oppZ real); auto with arith.\nrewrite (mult_opp_neg_neg x); auto with arith.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nrewrite H.\nrewrite (mult_opp_neg_neg_neg_pos (pos x) (neg pos)).\nrewrite (mult_neg_neg (neg x)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.\nrewrite (mult_neg_neg (neg y)) in H0.Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nelim (inversibleZ x); intros; elim H0.\nrewrite (mult_opp_neg_neg_pos x); auto.\nrewrite (mult_opp_neg_neg x); auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nelim (tech_opp_pos_neg_pos x); intros; elim H2.\nrewrite (mult_opp_neg x); simpl; auto with arith.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nelim (tech_opp_neg_neg x); intros; elim H0.\nrewrite (mult_neg_neg_neg x); intros; elim H1.\nrewrite (mult_neg_neg y); intros; elim H2.\nrewrite (mult_neg_neg y); intros; elim H3.\nrewrite (mult_neg_neg y); intros; elim H3.\nrewrite (mult_neg_neg y); intros; elim H3.\nrewrite (mult_neg_neg y); intros; elim H3.\nrewrite (mult_neg_neg y); intros; elim H4.\nrewrite (mult_neg_neg y); intros; elim H4.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H6.\nrewrite (mult_neg_neg yQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nelim (tech_opp_pos_neg_neg_neg_neg x); intros; elim H0.\nrewrite (mult_neg_neg_neg_neg_neg_neg_neg x); intros; elim H2.\nrewrite (mult_neg_neg_neg_neg x); intros; elim H3.\nrewrite (mult_neg_neg_neg x); intros; elim H3.\nrewrite (mult_neg_neg x); intros; elim H3.\nrewrite (mult_neg_neg x); intros; elim H3.\nrewrite (mult_neg_neg x); intros; elim H3.\nrewrite (mult_neg_neg x); intros; elim H3.\nrewrite (mult_neg_neg x); intros; elim H4.\nrewrite (mult_neg_neg y); intros; elim H4.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_neg_neg y); intros; elim H5.\nrewrite (mult_Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros; elim H.\nrewrite (negitis_neg_neg_neg_neg_neg_neg_neg x); intros; elim H.\nrewrite (negitis_neg_neg_neg_neg_neg x); intros; elim H.\nrewrite (negitis_neg_neg_neg x); intros; elim H.\nrewrite (negitis_neg_neg x); intros; elim H.\nrewrite (negitis_neg_neg x); intros; elim H.\nrewrite (negitis_neg_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_neg x); intros; elim H.\nrewrite (negitis_Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros x H; elim H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\nLemma inversibleZ :\n forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\n\nsimple destruct x.\n(* OZ *)\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nintros; left; reflexivity.\n(* pos (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (pos (S y))). discriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\n(* neg n *) \nsimple induction n.\n(* neg O *)\nright; reflexivity.\n(* neg (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (neg (S y))). discriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.\n\n(************)\n",
                "context_tokens": 734,
                "proof_start_offset": 22846,
                "proof_end_offset": 23040,
                "proof": "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple destruct x.\nreflexivity.\nintros; exact (mult_IZ (pos n)).\nintros; exact (mult_mIZ (neg n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; left; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; left; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; left; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; right; reflexivity.\n(* a variable *)\nintros; left; reflexivityQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple destruct x; simpl in |- *; auto.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nintros; elim (mult_neg_neg_neg x); intros; rewrite H0; rewrite H1; reflexivity.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* pos *)\nintros x H; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; \n rewrite H1; rewrite H2; rewrite H0; rewrite H1; reflexivity.\n(* pos *)\nintros x H; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; \n rewrite H1; rewrite H2; rewrite H0; reflexivity.\n(* pos *)\nintros x H; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; \n rewrite H1; rewrite H1; rewrite H0; reflexivity.\n(* pos *)\nintros x H; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; \n rewrite H1; rewrite H0; rewrite H0; reflexivity.\n(* pos *)\nintros x H; elim H; intros; elim H0; intros; elim H0; intros; elim H0; \n intros; rewrite H1; rewrite H0; rewrite H1; reflexivity.\n(* pos *)\nintros x H; elim H; intros; elimQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* pos O *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; right; reflexivity.\n(* pos n *)\nintros; left; reflexivityQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* env *)\nintros; elim H; intros; elim H0; intros; elim H0; intros.\nabsurd (pos x = neg x).\nrewrite H; rewrite H0; reflexivity.\n(* env *)\nintros; elim H0; intros; elim H0; intros; elim H1; intros.\nabsurd (neg x = neg x).\nrewrite H; rewrite H0; reflexivity.\n(* env *)\nintros; elim H0; intros; elim H0; intros.\nabsurd (neg x = neg x).\nrewrite H0; rewrite H0; reflexivity.\n(* env *)\nintros; elim H0; intros; elim H0; intros.\nabsurd (neg x = neg x).\nrewrite H0; rewrite H0; reflexivity.\n(* env *)\nintros; elim H0; intros; elim H0; intros.\nabsurd (neg x = neg x).\nrewrite H0; rewrite H0; reflexivity.\n(* env *)\nintros; elim H0; intros; elim H0; intros.\nabsurd (neg x = neg x).\nrewrite H0; rewrite H0; reflexivity.\n(* env *)\nintros; elimQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple destruct x; simpl in |- *; auto.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x; simpl in |- *.\nauto.\nrewrite (mult_comm (mult_comm x)).\napply (mult_comm (mult x (mult x (mult y (mult x y0)))); simpl in |- *.\napply (mult_comm (mult x (mult y (mult x y0)))); simpl in |- *.\napply (mult_comm (mult x (mult y (mult y0 (mult y0 (mult y0 (mult x0 y1))));\n simpl in |- *.\napply (mult_comm (mult y (mult y0 (mult y0 (mult y1 (mult y0 (mult y1 y2)))); simpl in |- *.\napply (mult_comm (mult y0 (mult y1 (mult y1 (mult y1 (mult y1 y2)))); simpl in |- *.\napply (mult_comm (mult y0 (mult y1 (mult y1 (mult y1 y2)))); simpl in |- *.\napply (mult_comm (mult y1 (mult y1 (mult y1 (mult y2 y2)))); simpl in |- *.\napply (mult_comm (mult y1 (mult y1 (mult y2 (mult y1Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple induction x.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; left; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; left; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; left; reflexivity.\n(* pos *)\nintrosQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* zero *)\nintros; left; reflexivity.\n(* zero *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; left; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; left; reflexivity.\n(* pos *)\nintros; left; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; left; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; right; reflexivity.\n(* pos *)\nintros; left;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\n",
                "context_tokens": 307,
                "proof_start_offset": 1870,
                "proof_end_offset": 2140,
                "proof": "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nunfold succZ in |- *.\nintros x; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.\nintros n H; case x.\nauto with arith.Qed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nintros x; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n simple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x; simpl in |- *; intros.\napply pos_pred with (pred n); auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x.\nintros.\nleft.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nleft.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nleft.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nleft.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nright.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nright.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nleft.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nleft.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nright.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nleft.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nright.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nright.\napply abs_pos.\nassumption.\nelim H0.\nintros.\nleft.\napply abs_posQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x; auto with arith.\nintros x0 H; elim H; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nintro x; case x.\ncase x; case x; auto.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nintros.\nelim (classic (exists y : Z, succ y = succ (pos x)).\nelim (classic (exists y : Z, succ y = succ (pos x))).\nelim (classic (exists y : Z, succ y = succ (pos x))).\nintros.\nelim (classic (exists y : Z, succ y = succ (pos y))).\nintro.\nelim (H1 y).\nintros.\nrewrite H1 in |- *.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napply succ_inj.\napplyQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2160,
                "proof_end_offset": 2430,
                "proof": "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\n(* rvarlift1 *)\nsimpl in |- *; reflexivity.\n(* rvarlift2 *)\nsimpl in |- *; reflexivity.\n(* rvarlift2 *)\nsimpl in |- *; reflexivity.\n(* rvarlift2 *)\nsimpl in |- *; reflexivity.\n(* rvarlift2 *)\nsimpl in |- *; reflexivity.\n(* rvarlift2 *)\nsimpl in |- *; reflexivity.\n(* rvarlift2 *)\nsimpl in |- *; reflexivity.\n(* contexte gauche *)\nunfold succ in |- *; reflexivity.\n(* contexte droit *)\nunfold succ in |- *; reflexivity.\n(* contexte droit *)\nunfold succ in |- *; reflexivity.\n(* contexte droit *)\nunfold succ in |- *; reflexivity.\n(* contexte droit *)\nunfold succ in |- *; reflexivity.\n(* contexte droit *)\nunfold succ in |- *; reflexivity.\n(* contexte droit *)\nunfold succ in |- *; reflexivity.\n(* contexte droit *)\nunfold pred in |- *; reflexivity.\n(* contexte droit *)\nunfold pred in |- *; reflexivity.\n(* contexte droit *)\nunfold pred in |- *; reflexivity.\n(* contexte droit *)\nunfold pred in |- *; reflexivity.\n(* contexte droit *)\nunfold pred in |- *; reflexivity.\n(*Qed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros; elim x; auto.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl inQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; apply pred_pos_pos; assumption.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; rewrite <- succ_://plus_assoc.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\napply opp_neg.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros; elim x.\n(* real *)\nsimpl in |- *; reflexivity.\n(* real *)\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* real *)\nintros; elimQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros; apply succ_inj.\napply succ_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napplyQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; apply succ_discr; assumption.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nsimple induction x; auto.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros; apply succ_inj; apply succ_inj; apply succ_inj; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "******************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 471,
                "proof_start_offset": 2460,
                "proof_end_offset": 2604,
                "proof": "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivityQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; apply succ_pred_pred_pos; assumption.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintrosQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros;Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; apply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succ_pred_pos.\napply succQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros;Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; rewrite succ_succZ.\npattern x in |- *; elim x.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* clos *)\nintros; elim n.\nsimpl in |- *;Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros;Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nsimple induction x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                    *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\n",
                "context_tokens": 513,
                "proof_start_offset": 2627,
                "proof_end_offset": 2801,
                "proof": "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro; elim n; intro.\nelim (lt_n_O 0); exact H.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_succZ x); exact (pred_succZ x).\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; intros; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl inQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; simpl in |- *; auto.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.Qed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; simpl in |- *; intros; auto.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nreflexivity.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elimQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; apply pred_pos_pos_Z.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                  INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\nLemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\n\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H. intros; simpl in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 566,
                "proof_start_offset": 2826,
                "proof_end_offset": 2975,
                "proof": "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; elim n; simpl in |- *; reflexivity; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nelim (lt_n_O 0); exact H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nrewrite <- pred_pos_pos; assumption.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nrewrite tech_pred_posZ; apply H.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nrewrite tech_succ_pos; rewrite <- (pred_predZ n); apply le_pred_posZ;\n auto.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; elim n; intro.\nrewrite <- (pred_succZ y); exact (pred_predZ y).\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nsimple induction n; intro.\nelim H; auto.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nrewrite <- H; apply tech_pred_posZ; apply tech_pred_posZ.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nrewrite <- tech_succ_pos; assumption.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nrewrite tech_succ_pos; assumption.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\n",
                "context_tokens": 158,
                "proof_start_offset": 1436,
                "proof_end_offset": 1965,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nexact (mult_IZ d1).\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n  intros.\n  apply (H (fun d : Z => Z_of_nat (S d1)) (Z_of_nat (S d1)) (Z_of_nat (S d1))\n     (Z_of_nat (S d1)) (Z_of_nat (S d1)))\n      (Z_of_nat (S d1)) (Z_of_nat (S d1)))\n      (Z_of_nat (S d1)) (Z_of_nat (S d1)) (Z_of_nat (S d2)) (S d2)).\n  apply (H (fun d : Z => Z_of_nat (S d1)) (Z_of_nat (S d1)) (S d1))).\n  apply (H (fun d : Z => Z_of_nat (S d)) (Z_of_nat (S d1)) (S d1)).\n  apply (H (fun d : Z => Z_of_nat (S d)) (Z_of_nat (S d)) (S d1))).\n  apply (H (fun d : Z => Z_of_nat (S dQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n   simple induction 1; intros.\n   simpl in |- *.\n   elim (le_gt_dec 0 0).\n   intro. rewrite <- H2. rewrite <- H2. simpl in |- *.\n   rewrite <- H2. simpl in |- *.\n   rewrite <- H2. simpl in |- *.\n   rewrite <- H2. simpl in |- *.\n   rewrite <- H2. simpl in |- *. rewrite <- H2. simpl in |- *.\n   rewrite <- H2. simpl in |- *.\n   rewrite <- H2. simpl in |- *. rewrite <- H2. simpl in |- *.\n   rewrite <- H3. simpl in |- *. reflexivity.\n   intro. rewrite <- H2. simpl in |- *. rewrite <- H2. simpl in |- *. rewrite <- H2. simpl in |- *.\n   rewrite <- H2. simpl in |- *. reflexivity.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b d1 d2 H; elim H; clear H.\nunfold spec_div in |- *.\nintros H1 H2; elim H1; clear H1.\nunfold spec_div in |- *.\nintros H2; elim H2; clear H2.\nunfold spec_div in |- *.\nintros H3; elim H3; clear H3.\nunfold spec_div in |- *.\nintros H4; elim H4; clear H4.\nunfold spec_div in |- *.\nintros H4; elim H4; clear H4.\nunfold spec_div in |- *.\nintros H5; elim H5; clear H5.\nunfold spec_div in |- *.\nintros H6; elim H5; clear H5.\nunfold spec_div in |- *.\nintros H6; elim H5; clear H5.\nunfold spec_div in |- *.\nintros H5; elim H5; clear H5.\nunfold spec_div in |- *.\nintros H6; elim H6; clear H6.\nunfold spec_div in |- *.\nintros H7; elim H6; clear H6.\nunfold spec_div in |-Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n   simple induction a; simpl in |- *; intros. elim (le_O_O _ H).\n   rewrite <- H0; rewrite <- H1.\n   rewrite <- H0; rewrite <- H2; rewrite H1; reflexivity.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nsimple induction 1; intros.\nauto.\nauto.\napply sym_eq; assumption.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n simple induction a; simpl in |- *; intros.\napply mod_trans with (a - b)%Z; auto with arith.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n simple induction a; simple induction 1; auto with arith.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n  simple induction a; intros.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n   intros a b d1 d2 H H0.\n   elim H.\n   intros.\n   rewrite H0.\n   rewrite <- H0.\n   rewrite <- H0.\n   rewrite <- H0.\n   rewrite <- H0.\n   rewrite <- H1.\n   rewrite <- H0.\n   rewrite <- H0.\n   rewrite <- H1.\n   rewrite <- H0.\n   rewrite <- H1.\n   rewrite <- H1.\n   rewrite <- H0.\n   rewrite <- H0.\n   rewrite <- H0.\n   rewrite <- H0.\n   rewrite <- H1.\n   rewrite <- H1.\n   rewrite H0.\n   rewrite H0.\n   reflexivity.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n   simple induction a; intros.\n   simpl in |- *.\n   rewrite (inj_abs (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) d1 d2))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) d1 d1))) 0))) 0)) 0))\n     (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) d1 d2))) 0))) 0))\n     (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) d1 d2)))) 0)))\n     (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) d1 d2)))) 0)))\n     (S (S (S (S (S (S (S (S (S (S (SQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\nLemma gcd_unicity_apart_sign :\n forall a b d1 d2 : Z,\n is_gcd Z IdZ multZ OZ a b d1 ->\n is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\n\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ\n    Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2. \nexact (mult_IZ d1).\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\n",
                "context_tokens": 373,
                "proof_start_offset": 1981,
                "proof_end_offset": 3327,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (abs_eq_or_oppZ b); intro y.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ b).\nintros; exact H0.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split.\nexact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry in |- *; exact (mult_IZ b).\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (oppZ x).\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nsymmetry in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\n simple induction 1; simpl in |- *; auto with zarith.\nintros.\nelim (inversibleZ (posExp b)); intros.\nright.\nelim (inversibleZ (posExp b)); intros.\nleft. elim H1; intros.\nrewrite H2.\nsimpl in |- *; exact (mult_moins0 1).\nright.\nelim H1; intros.\nrewrite H2.\nsimpl in |- *; exact (mult_moins0 1).\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (is_gcd_bezout_pos Z oppZ expZ real).\nintros.\nelim (is_gcd_bezout_pos Z oppZ expZ real).\nintros.\nrewrite <- H.\napply gcd_sym; apply gcd_sym; apply gcd_0_pos.\napply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym;\n apply gcd_sym; apply gcd_symQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (is_gcd_bezout_apart_sign_pos_pos b); trivial.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\napply (is_gcd Z).\nelim (is_gcd_bezout Z).\nelim (is_bezout Z).\nelim (is_bezout Z).\nelim (is_bezout Z).\nelim (is_gcd Z).\nelim (is_gcd Z).\nelim (is_bezout Z).\nelim (is_gcd Z).\nelim (is_bezout Z).\nelim (is_ Intro; intros.\nleft. elim H1; intros. rewrite H2.\napply (invz_pos_pos z).\napply (is_gcd Z).\napply (is_gcd Z).\napply (is_gcd Z).\nelimQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (gcd_bezout_apart_sign_pos radix) with (b := (2 * (b * (b * (b * (b * d))) / 2)).\npattern (2 * (b * (b * (b * d))) / 2) at 2 in |- *.\nrewrite <- (mult_n_Sm_m n (b * (b * (b * (b * (b * (b * d)))) / 2) (b * (b * (b * (b * (b * d))) / 2) (b * (b * (b * (b * (b * d))) / 2))\n in |- *.\nrewrite <- (mult_n_Sm_m n (b * (b * (b * (b * (b * (b * d))) / 2)) (b * (b * (b * (b * (b * d))) / 2)\n in |- *.\nrewrite <- (mult_n_Sm_m n (b * (b * (b * (b * (b * d))) / 2) (b * (b * (b * (b * (b * d)))) / 2)\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nsimple induction 1; auto.\nintros.\nelim (divide_trans _ _ _ H H0).\nintros.\nelim (divide_trans _ _ _ H).\nintros.\nelim (divide_trans _ _ _ H0).\nintros.\nelim (divide_trans _ _ _ H2).\nintros.\nelim (divide_trans _ _ _ H2).\nintros.\nelim (divide_trans _ _ _ H0).\nintros.\nelim (divide_trans _ _ _ H0).\nintros.\nelim (divide_trans _ _ _ H1).\nintros.\nelim (divide_trans _ _ _ H0).\nintros.\nelim (divide_trans _ _ _ H2).\nintros.\nelim (divide_trans _ _ _ H2).\nintros.\nelim (divide_trans _ _ _ H3).\nintros.\nelim (divide_trans _ _ _ H2).\nintros.\nelim (divide_trans _ _ _ H3).\nintros.\nelim (divide_trans _ _ _ H3).\nintros.\nelim (divide_trans _ _ _ H4).\nintros.\nelim (Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (le_gt_dec (absZ b) (absZ b)).\nauto with zarith.\nintros.\nleft. elim H; intros. rewrite H0.\nsimpl in |- *; exact (mult_n_O_nat (posExp b)).\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (gcd_divisors Z (Zabs_nat b)); auto.\nintros; right.\nright.\nelim H0; intros; elim H1; intros.\nrewrite H1.\napply gcd_pos_1.\nelim H1; intros.\nrewrite H1.\napply gcd_pos_2.\napply gcd_pos_2.\nrewrite <- H1.\napply gcd_pos_1.\napply gcd_pos_1.\nrewrite <- H1.\napply gcd_pos_2.\napply gcd_pos_2.\nrewrite <- H1.\napply gcd_pos_2.\napply gcd_pos_2.\napply gcd_pos_1.\nrewrite <- H1.\napply gcd_pos_2.\nrewrite <- H1.\napply gcd_pos_2.\napply gcd_pos_1.\nrewrite <- H1.\napply gcd_pos_2.\napply gcd_pos_1.\nrewrite <- H1.\napply gcd_pos_1.\nrewrite <- H1.\napply gcd_pos_2.\napply gcd_pos_2.\nrewrite <- H1.\napplyQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (gcd_bezout_apart_sign_non_zero _ _ _ H H).\nintros.\nrewrite <- (absZ_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_oppQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (gcd_bezout_apart_signZ (Zpos a) (Zabs_nat b)).\nintros.\nelim (gcd_bezout_apart_signZ (Zpos a) (Zabs_nat b)).\nintros.\nrewrite Zabs_eq; auto.\nelim (gcd_bezout_apart_signZ (Zpos a) (Zabs_nat b)).\nintros.\nrewrite Zabs_eq; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\n\nintros. elim (abs_eq_or_oppZ b); intro y.\n(* |b|=b *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3865,
                "proof_end_offset": 4332,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros.\ncase (eq_OZ_dec n); intro.\nunfold P in |- *.\nintro.\nsplit with (absZ b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (divZ b n).\nintros.\ncut (lt_absZ r n); intros.\nelim (H r H0 n).\nintros.\nsplit with x.\napply gcd_mod with (2 := i); trivial.\ninversion i.\ndecompose [and] H1.\nunfold lt_absZ in |- *.\nrewrite (tech_le_pos_abs r H2).\nexact H4.\nexact n0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nsimple induction n; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros.\n  case (Z_le_gt_dec m n); intro H0.\n  apply H0.\n  exists (Z_of_nat m).\n  apply Z_of_nat_complete_eq; auto.\n  apply H0.\n  exists (Z_of_nat m).\n  apply Z_of_nat_complete_eq; auto.\n  apply H0.\n  exists (Z_of_nat n).\n  apply H0.\n  exists (Z_of_nat n).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_of_nat n).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_of_nat m).\n  apply H0.\n  exists (Z_Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros n H.\n  induction H.\n  apply le_ind; apply H.\n  apply le_ind; apply H.\n  apply lt_wf; apply H0.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  simple induction n.\n  simpl in |- *. intros. apply H. apply H. assumption.\n  apply H. assumption.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nsimple induction n.\nintros m H H0.\nelim (Z_ind m H0).\nintros m H1.\nelim H1.\nintros m H2.\napply (H2 m).\nintros m H2.\napply (H2 m).\nintros m H3.\napply (H2 m).\nintros m H3.\napply (H2 m).\nintros m H3.\napply (H3 m).\nintros m H3.\napply (H3 m).\nintros m H3.\napply (H2 m).\nintros m H3.\napply (H2 m).\nintros m H3.\napply (H m).\nintros m H3.\napply (H m).\nintros m H3.\napply (H m).\nintros m H3.\napply (H m).\nintros m H3.\napply (H2 m).\nintros m H3.\napply (H m).\nintros m H3.\napply (H2 m).\nintros m H3.\napply (H2 m).\nintros m H3.\napply (H2 m).\nintros m HQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nsimple induction n.\nintros.\nunfold P in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold lt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |- *.\nunfold gt in |-Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nsimple induction n.\nintros; elim (le_lt_or_eq n m); auto with zarith.\nintros; elim (le_or_lt n m); auto with zarith.\nintros m0 H0; elim (le_or_lt n m); auto with zarith.\nintros; elim (le_or_lt n m); auto with zarith.\nintros m0 H1; elim (le_or_lt m0); auto with zarith.\nintros H1; elim (le_or_lt n m0); auto with zarith.\nintros m0 H1; elim (le_or_lt n m); auto with zarith.\nintros m0 H1; elim (le_or_lt n m0); auto with zarith.\nintros m0 H1; elim (le_or_lt n m0); auto with zarith.\nintros m0 H1; elim (le_or_lt n m); auto with zarith.\nintros m0 H1; elim (le_or_lt n m); auto with zarith.\nintros m0 H1; elim (le_or_lt m n); auto with zarith.\nintros m0 H1; elimQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  unfold P in |- *; intros n H0 m H1 H2.\n  elim (lt_trichotomy m n); intro H3.\n  generalize H1; clear H1; intros m H2; elim (lt_trichotomy m n); intro H4.\n  assumption.\n  intros m H3; rewrite H3 in H3.\n  elim (lt_trichotomy m n); intro H5.\n  generalize H1; clear H1; intros m H3; elim (lt_trichotomy m n); intro H6.\n  generalize H3; clear H3; intros m H3; elim (lt_trichotomy m n); intro H6.\n  generalize H3; clear H3; intros m H3; elim (lt_trichotomy m n); intro H6.\n  generalize H3; clear H3; intros m H3; elim (lt_trichotomy m n); intro H6.\n  generalize H3; clear H3; intros m H3; elim (lt_trichotomy m n); intro H6.\n  generalize H3; clear H3; intros m H3; elim (lt_trichotomy m n); intro H6.\n  generalize H3; clear H3; intros m H3Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nsimple induction n; auto with arith.\nintros; elim n; auto with arith.\nintros m H1; elim H1; auto with arith.\nintros m H2 H3; elim H2; auto with arith.\nintros n H3; elim H3; auto with arith.\nintros m H3 H4; elim H3; auto with arith.\nintros n H4; elim H3; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5; auto with arith.\nintros m H5; elim H5Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n H0 H1.\ngeneralize H1; clear H1; intro H2.\nelim H1; intros m H2.\nexists (Z_of_nat n).\nintros m H1.\nexists (Z_of_nat n).\nintros m H2.\napply H1.\napply Zle_lt_trans with (m := Zpos m).\napply Zpower_nat_is_gcd_1.\napply Zle_lt_trans with (m := Zpos m).\napply Zpower_nat_is_gcd_2.\napply Zpower_nat_is_gcd_2.\napply Zle_lt_trans with (m := Zpos m).\napply Zpower_nat_is_gcd_2.\napply Zle_lt_trans with (m := Zpos m).\napply Zpower_nat_is_gcd_2.\napply Zpower_nat_is_gcd_2.\napply Zle_lt_trans with (m := Zpos m).\napply Zpower_nat_is_gcd_2.\napply Zpower_nat_is_gcd_2.\napply Zle_lt_trans with (m := Zpos m).\napply Zpower_natQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4334,
                "proof_end_offset": 4420,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (recZ P acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Zle_lt_or_eq (1 * a) (2 * b)); intro.\n  apply (gcd_bezout b). apply gcd_bezout. apply gcd_bezout. apply gcd_bezout. apply gcd_bezout. apply gcd_bezout. assumption.\n  unfold Bezout in |- *; intro. elim (modZ b n). intros.\n  split with (1 := H). rewrite e. apply gcd_bezout. apply gcd_bezout. assumption.\n  unfold Bezout in |- *; intro. elim (modZ b n). intros.\n  split with (2 := H). rewrite e. apply gcd_bezout. apply gcd_bezout. assumption.\n  unfold Bezout in |- *; intro. elim (modZ b n). intros.\n  split with (2 := H0). rewrite e. apply gcd_bezout. assumption.\n  unfold Bezout in |- *; intro. elim (modZ b n). intros.\n  split with (2 := H0). rewrite e. apply gcd_bezout. apply gcd_bezout. assumption.\n  unfold Bezout in |- *; intro. elim (modZ b n). intros.\n  split with (2 := H0). rewrite e. apply gcd_bezout. apply gcd_Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold have_gcd_exact; intros.\n  case (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (divZ b n). intros. elim (H0 n). intros.\n  split with x.\n  apply gcd_sym; apply gcd_sym.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  unfold P in |- *. intro. elimQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  simple induction a.\n  simple induction b.\n  simpl in |- *. apply (gcd_cancel_r a b).\n  intros. unfold P in |- *. intro. elim (gcd_bezout_r a b). intros.\n  elim (gcd_bezout_r a b). intros.\n  split with (1 := H0 (gcd_bezout_r a b)).\n  apply gcd_greatest; trivial. inversion i. now inversion i.\n  split with (1 := H0 (gcd_bezout_l a b)).\n  apply gcd_greatest; trivial. inversion i. now inversion i.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold have_gcdZ_exists.\n  unfold Z. intro. elim (modZ b (Zpos a)). intro.\n  split with (2 := H0).\n  rewrite e. apply gcd_sym. apply gcd_opp_r.\n  unfold divide in |- *; unfold absZ in |- *.\n  rewrite (tech_le_pos_abs r H2). exact H1.\n  unfold divide in |- *; unfold absZ in |- *.\n  rewrite (tech_le_pos_abs r H2). exact H2.\n  unfold divide in |- *; unfold absZ in |- *.\n  rewrite (tech_le_pos_abs r H2). exact H2.\n  unfold divide in |- *; unfold absZ in |- *.\n  rewrite (tech_le_pos_abs r H2). exact H2.\n  unfold divide in |- *; unfold absZ in |- *.\n  rewrite (tech_le_pos_abs r H2). exact H1.\n  unfold divide in |- *; unfold absZ in |- *.\n  rewrite (tech_le_pos_abs r H2). exact H1.\n  unfold divide in |- *; unfold absZ in |- *.\n  rewrite (tech_le_abs r HQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (eq_ty a); intro.\n  case (eq_ty b); intro.\n  right; assumption.\n  left; assumption.\n  right; assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfoldhave_gcdZ_exists : forall a b : Z, let (n, m) := a in a = b.\n  intro.\n  case (eq_ty a b); intros.\n  rewrite e.\n  apply (gcd_bezout a b).\n  unfold P in |- *; intro.\n  elim (divZ b n). intros.\n  split with (absZ b).\n  rewrite e.\n  rewrite e.\n  rewrite e.\n  rewrite (gcd_bezout a b).\n  rewrite (gcd_bezout b).\n  rewrite <- (gcd_mult_assoc (gcd a b) b).\n  rewrite <- (gcd_mult_assoc (gcd a b) b).\n  rewrite <- (gcd_mult_assoc b a).\n  rewrite <- (gcd_mult_assoc (gcd a b) b).\n  rewrite <- (gcd_mult_assoc (gcd a b) b).\n  rewrite <- (gcd_mult_assoc (gcd a b) b).\n  rewrite <- (gcd_mult_assoc (gcd a b) b).\n  rewrite <- (gcd_mult_assoc b b).\n  rewrite <- (gcd_mult_assoc (gcd a b) b).\n  rewrite <- (gcd_multQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (le_gt_dec 0 a). intro. unfold P in |- *. intro.\n  elim (divZ b n). intro. elim (H0 n). intro. split with x.\n  apply gcd_mod with (2 := x).\n  assumption.\n  intro. elim (H0 n). intros. elim (H0 n). intro. split with x. assumption.\n  assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Zle_lt_bool 0 a); intro. unfold P in |- *. intro.\n  elim (Z_le_gt_dec 0 a); intro.\n  split with 0%Z. rewrite e. apply gcd_gt_0.\n  apply gcd_0_r.\n  unfold P in |- *; intro.\n  elim (Z_le_gt_dec 0 a); intro.\n  split with 1%Z. rewrite e. apply gcd_gt_0.\n  apply gcd_0_r.\n  unfold P in |- *; intro.\n  elim (Z_le_gt_dec 0 a); intro.\n  split with (2 := H2).\n  apply gcd_pos_opp.\n  apply gcd_gt_0.\n  apply gcd_gt_1.\n  apply gcd_gt_1.\n  unfold P in |- *; intro.\n  elim (Z_le_gt_dec 0 a); intro.\n  split with (2 := H4).\n  apply gcd_gt_1.\n  apply gcd_gt_1.\n  apply gcd_gt_1.\n  unfold P in |- *; intro.\n  elim (Z_le_gt_dec 0 a); intro.Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intro. case (gcdZ_exists_pos a b). intro.\n  case (gcd_bezout_dec a b). intro.\n  split with (2 := H0); trivial. inversion i.\n  unfold P in |- *; intro. elim (divZ b n). intros. elim H0. intros. apply H1.\n  split with (2 := H0). apply gcd_opp_l.\n  unfold P in |- *; intro. elim (divZ b n). intros. elim H1. intros.\n  split with (2 := H1). apply gcd_opp_l.\n  unfold P in |- *; intro. elim (divZ b n). intros. apply H1. assumption.\n  split with (2 := H1). apply gcd_opp_l.\n  unfold P in |- *; intro. elim (divZ b n). intros.\n  split with (2 := H1). apply gcd_opp_r.\n  unfold P in |- *; intro. elim (divZ b n). intros.\n  split with (2 := H1). apply gcd_opp_r.\n  unfold P in |- *; intro. elim (divZ b n). intros.\n  split with (2 :=Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  unfold have_gcd_l := exists 1%Z. rewrite e.\n  apply (gcd_bezout b).\n  unfold P in |- *; intro.\n  elim (gcd_bezout b). intros.\n  elim (gcd_bezout b). intros.\n  unfold P in |- *.\n  split.\n  unfold lt_absZ in |- *.\n  rewrite (tech_le_pos_abs r H2).\n  unfold gt in |- *.\n  rewrite (tech_le_pos_abs r H2).\n  unfold gt in |- *.\n  rewrite (tech_le_abs_abs r H2).\n  rewrite (tech_le_abs_abs r H2).\n  apply (gcd_bezout b).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "rewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\n",
                "context_tokens": 721,
                "proof_start_offset": 4441,
                "proof_end_offset": 5553,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\nintros.\nelim H; intros.\napply (gcd_OZ_absZ b0).\nunfold is_gcd in |- *.\nsplit.\nelim H3; intros; elim H5; intros; exact H6.\nsplit.\nelim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros.\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros.\nelim H3; intros; elim H7; intros.\napply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros.\nrewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros.\nelim H17; intros.\nelim H19; intros.\nrewrite H20.\nsymmetry in |- *.\nexact (add_OZ r).\nexact H4.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  exact (recZ_is_gcd_pos a b d).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (well_founded_induction_type_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_ind_dep_ind_dep_ind_dep_ind_dep_ind_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_ind_dep_dep_ind_ind_dep_dep_ind_ind_dep_ind_dep_ind_dep_dep_ind_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_dep_ind_Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros a b d Hd H_eq H_0.\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos a b d Hd H_eq).\n  apply (recZ_is_gcd_pos b d Hd H_eq).\n  apply (recZ_is_gcd_pos b d HdQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (Zle_bool_spec _ _ H0).\n  intros. elim (Zle_or_lt 0 (Zabs_nat q)).\n  unfold Z.succ in |- *. rewrite abs_neq in |- *. rewrite abs_neq in |- *. reflexivity.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcd_bool_spec a b); intros.\n  case (gcd_bool_spec b d); intros.\n  case (gcd_spec a b); intros.\n  split with (gcd a b). rewrite e. rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n  split with (gcd a b). rewrite <- (gcd_abs_eq a b); trivial.\n Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (lt_trichotomy a b); intro.\n  split with (absZ b). rewrite e. apply gcd_pos_pos.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H). apply lt_le_trans with (1 := H0).\n  apply mod_trans with (1 := H0). apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_sym.\n  apply mod_trans with (1 := H0).\n  apply mod_trans with (1 := H0).\n  apply mod_sym.\n  apply mod_trans with (1 := H0).\n  apply mod_trans with 1.\n  apply mod_trans with 1.\n  apply mod_trans with (1 := H1).\n  apply mod_transQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_is_gcd_bool a b d); intro.\n  unfold P in |- *. intro. elim H; intro. elim H0; intro.\n  split with (2 * Zpos d). apply gcd_refl.\n  unfold P in |- *; intro. elim H1; intro.\n  split with (2 * Zpos d). apply gcd_sym. apply gcd_refl.\n  unfold P in |- *; intro.\n  split with (2 * Zpos d). apply gcd_sym. apply gcd_refl.\n  unfold P in |- *; intro.\n  split with (2 * Zpos d). apply gcd_refl.\n  unfold P in |- *; intro.\n  split with (2 * Zpos d). apply gcd_sym. apply gcd_refl.\n  unfold P in |- *; intro.\n  split with (2 * Zpos d). apply gcd_sym. apply gcd_sym. apply gcd_refl.\n  unfold P in |- *; intro.\n  split with (2 * Zpos d). apply gcd_sym. apply gcd_refl.\n  unfold P in |- *; intro.\n  split with (2 * Zpos d). apply gcd_sym. apply gcd_sym. apply gcd_sym.\n Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (Zle_bool_spec _ _ H). intros.\n  split with (2 := H).\n  apply gcd_divide. apply gcd_refl.\n  split with (2 := H0).\n  apply gcd_sym. apply gcd_sym. apply gcd_sym. apply gcd_sym.\n  apply gcd_sym. apply gcd_sym. apply gcd_sym. apply gcd_sym. apply gcd_sym. apply gcd_sym.\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (Zle_bool_spec _ _ H). intros.\n  unfold Bezout in |- *. apply H. intros.\n  apply H. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H0. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H0. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H0. intros.\n  apply H0. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H0. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply H1. intros.\n  apply HQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_is_gcd_pos a b d). intros.\n  apply (gcd_bezout a b d).\n  unfold P in |- *. intro. elim (gcd_bezout a b d). intros.\n  apply (gcd_bezout a b d). intros.\n  apply (gcd_bezout a b d). intros.\n  apply (gcd_bezout a b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout a b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout a b d). intros.\n  apply (gcd_bezout a b d). intros.\n  apply (gcd_bezout a b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.\n  apply (gcd_bezout b d). intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 5810,
                "proof_end_offset": 5941,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros; elim H; intros.\napply (sign_absZ b0).\nexact H3.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d H; apply (gcd_bezout a b d H).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d.\npattern (is_gcdZ a b) at 1 in |- *.\nelim (gcd_bezout_absZ a b d).\nelim (gcd_bezout_absZ a b d).\nintros.\napply (gcd_bezout_absZ a b d).\nelim (gcd_bezout_absZ a b d).\nintros.\napply (gcd_bezout_absZ a b d).\nelim (gcd_bezout_absZ a b d).\nintros.\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ a b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ a b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ b d).\napply (gcd_bezout_absZ b dQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d; apply (well_founded_induction_wf_ind_ind_dep a b d).\nexact (is_gcd_pos_pos_pos_pos a b d).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros a b d; unfold is_gcd; case (is_gcd_Z a b); intros.\n  rewrite (abs_1 a) at 2; rewrite <- (abs_2 b) at 2; rewrite <- (abs_2 b) at 2; rewrite <- (abs_2 b) at 2;\n   rewrite <- (abs_2 b) at 2; rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1;\n   rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1;\n   rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1;\n   rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1;\n   rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1; rewrite <- (abs_2 b) at 1;\n   rewrite <- (abs_2 b) at 1; rewrite <- (absQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros.\n  apply (is_gcdZ_correct a b (gcdZ_is_gcd_pos a b d)).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros. apply is_gcd_is_gcd. apply mod_eq_sym.\n  apply mod_eq_sym.\n  apply mod_eq_sym.\n  apply mod_eq_sym.\n  assumption.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros a b d H.\n  case (Z_eq_dec a b); intro.\n  left.\n  reflexivity.\n  right.\n  reflexivity.\n  right.\n  reflexivity.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d H.\ngeneralize (is_gcd_pos a b d).\nelim (is_gcd_pos a b d).\nintros H1 H2.\nelim (is_gcd_pos a b d).\nintros H3.\nelim (H3 (gcd_bezout a b d) H3).\nelim (is_gcd_pos a b d).\nintros H4.\nelim (H4 (gcd_bezout a b d) H4).\nintros H5.\nelim (H5 (gcd_bezout b d) H5).\nelim (H5 (gcd_bezout a b d) H5).\nelim (H6 (gcd_bezout b d) H5).\nintros H5.\nelim (H6 (gcd_bezout a b d) H6).\nelim (H6 (gcd_bezout b d) H6).\nintros H6.\nelim (H6 (gcd_bezout a b d) H6).\nelim (H6 (gcd_bezout a b d) H6).\nelim (H7 (gcd_bezout a b d) H6).\nintros H7.\nelim (HQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros.\n  apply (is_gcd_pos_pos a b); apply Zle_is_gcd; assumption.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros. apply (is_gcdZ_correct a b d).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\n",
                "context_tokens": 714,
                "proof_start_offset": 5966,
                "proof_end_offset": 6284,
                "proof": "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H) (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros; apply (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0) (positive_is_gcdZ a b d1 H)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros. apply (inj_inj_inj H).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napply (inj_inj H0).\napplyQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\n  simple induction a; intros; simpl in |- *. \n  rewrite <- H0; apply (abs_is_gcdZ b0 b0).\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros.\napply (abs_is_gcdZ b d1). exact H3.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros.\napply abs_is_gcdZ; apply mod_is_gcdZ; apply mod_is_gcdZ; apply mod_is_gcdZ; apply mod_is_gcdZ; apply mod_is_gcdZ.\napply mod_is_gcdZ; apply mod_is_gcdZ; apply mod_is_posZ; apply mod_is_gcdZ.\n apply mod_is_gcdZ; apply mod_is_pos; apply mod_is_gcdZ.\n apply mod_is_gcdZ; apply mod_is_pos; apply mod_is_pos; apply mod_is_gcdZ.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nsimple induction a; simpl in |- *; intros; trivial.\nelim H0; intros.\napply (inj_inj H0).\nrewrite <- H2; apply (inj_inj H0).\nrewrite <- H2; apply (inj_inj H0).\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\n  intros; elim H; intros.\n  apply (pos_pos_pos a b); apply (pos_pos_pos b); apply (pos_pos_pos a); apply (pos_pos b); apply (pos_pos a);\n  apply (pos_pos a); apply (pos_pos a); apply (pos_pos b); apply (pos_pos a);\n  apply (pos_pos a); apply (pos_pos b); apply (pos_pos a); apply (pos_pos a);\n  apply (pos_pos a); apply (pos_pos a); apply (pos_pos a); apply (pos_pos a); apply (pos_pos a);\n  apply (pos_pos a); apply (pos_pos a); apply (pos_pos a); apply (pos_pos a);\n  apply (pos_pos a); apply (pos_pos a); apply (pos_pos a); apply (pos_pos a); apply (pos_pos a);\n  apply (pos_pos a); apply (pos_pos a); apply (pos_pos a); apply (pos_pos a);\n  apply (pos_pos a); apply (pos_pos aQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros.\nelim H; intros. apply (is_gcd_intro_pos a b d1).\ncase (Z_eq_bool (gcdZ a b) (gcdZ_is_gcdZ a b d1)); intros.\nrewrite H2. apply (is_gcd_intro_pos b d1).\nrewrite <- (is_gcd_is_gcd_pos b d1). apply (is_gcd_is_pos a b d1).\nrewrite <- (is_gcd_is_gcd_pos b d1). apply (is_gcd_is_pos b d1).\nrewrite <- (is_gcd_is_gcd_pos b d1). apply (is_gcd_is_pos b d1).\nrewrite <- (is_gcd_is_gcd_pos b d1). apply (is_gcd_is_pos b d2).\nrewrite <- (is_gcd_is_gcd_pos b d2). apply (is_gcd_is_pos b d1).\nrewrite <- (is_gcd_is_gcd_pos b d1). apply (is_gcd_is_pos b d2).\nrewriteQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros a b d1 d2 H1 H2 H3.\nelim H1; intros. apply (inj_absZ b0). apply H3.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros. apply (one_div_mod_eq a b d1).\napply (one_div_mod_eq a b d1).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d1).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d1).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d1).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d2).\napply (one_div_mod_eq a b d2).\napply (one_divQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros.\napply (inj_inj (inj_inj H)).\nrewrite inj_absZ_correct; apply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\napply inj_absZ.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 6306,
                "proof_end_offset": 6452,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; intros.\napply (gcd_unique_divisors_l _ _ _ _ _ H0).\napply (gcd_refl a b d H0).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; intros.\napply (gcd_bezout_is_gcdZ b d b d (gcdZ_is_gcd_pos a b d H0) H).\nintros; apply (gcd_bezout_is_gcdZ a b d (gcdZ_is_gcd_pos a b d H0) H).\napply (gcd_bezout_is_gcdZ b d (gcdZ_is_gcd_pos a b d H0) H).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H.\napply gcd_sym. apply gcd_sym. apply gcd_sym.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b d H).\nintros; exact H1.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_unique_apart_sign a b d (gcdZ_is_gcd_pos a b d1 H)\n    (gcdZ_is_gcd_pos a b d2 H0)).\nintros; apply (gcd_unique_apart_sign a b d (gcdZ_is_gcd_pos a b d1 H0)\n      (gcdZ_is_gcd_pos a b d1 H0)).\napply (gcd_unique_greatest _ _ _ _ _ _ _ _ H).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros; elim H; intros.\napply (gcd_antisym a b d (gcdZ_is_gcd_bool a b d H) (gcdZ_is_gcd_bool b d H)).\napply gcd_eq; apply gcd_eq; apply gcd_eq; apply gcd_eq; assumption.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; intros.\napply (gcd_divide_r (a * b) (b * d)); auto.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcd_Z.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcdZ.\nrewrite <- gcd_eq_is_gcd_bool.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.\nrewrite <- gcd_eq_is_gcd_l.Qed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nsimple induction a; simpl in |- *; trivial.\nintros; apply (gcd_antisym a b d1 d2 H).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros; elim H; intros.\napply (gcd_trans _ _ _ _ _ _ _ _ _ _ H H1).\napply (gcd_trans _ _ _ _ _ _ _ _ _ H1).\napply (gcd_trans _ _ _ _ _ _ _ _ _ _ H1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\n",
                "context_tokens": 719,
                "proof_start_offset": 6470,
                "proof_end_offset": 6674,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H).\nrewrite <- (gcd_modZ a b q r H).\nrewrite <- (gcd_modZ a b q r H).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H0).\nrewrite <- (gcd_modZ a b q r H).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcd_unique_divide_l r (gcdZ_is_gcd_Z a b q) r (gcdZ_is_gcd_Z a b q) r H).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H.\ncase (gcd_or_gcdZ a b q r); intros.\nrewrite <- (gcd_gcd_0 a b q r H0).\nrewrite <- (gcd_gcd_0 a b q r H).\nrewrite <- (gcd_gcd_0 a b q r H).\nrewrite <- (gcd_gcd_0_l b q r H).\nrewrite <- (gcd_gcd_0 a b q r H).\nrewrite <- (gcd_gcd_0_r b q r H).\nrewrite <- (gcd_gcd_0_l b q r H).\nrewrite <- (gcd_gcd_0 a b q r H).\nrewrite <- (gcd_gcd_0_r b q r H).\nrewrite <- (gcd_gcd_0 a b q r H).\nrewrite <- (gcd_gcd_0_l a b q r H).\nrewrite <- (gcd_gcd_0_r b q r H).\nrewrite <- (gcd_gcd_0_l b q r H).\nrewrite <- (gcd_gcd_1 a b q r H).\nrewrite <- (gcd_gcd_0_Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcd_divide_l (gcd_is_gcdZ a b) (gcdZ_is_gcd_r b r)\n      (gcdZ_is_gcd_r b q) (gcdZ_is_gcd_r b q) r).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros; elim (gcd_unique_divisors _ _ _ _ H); auto.\nintros; apply (gcd_eq_is_gcd_Z b q r (gcdZ_is_gcd_pos b q r));\n auto.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros. apply (unique_divide_l r b); trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcd_eq_0_0_r a b q r (gcdZ_is_gcd_nonneg a b q r H0) (gcd_is_gcd_nonneg a b q r H0)).\napply gcd_eq_0_r.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\ncase (gcd_bezout_apart_sign_exact a b q r (gcd_gcd_nonneg a b q r) (gcd_gcd_nonneg a b q r)).\nintros.\napply (gcd_unique_exact a b q r (gcd_gcd_nonneg a b q r)).\nrewrite <- H0.\napply gcd_sym.\nrewrite <- H1.\napply gcd_sym.\nrewrite <- H0.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nintros.\nelim (gcd_divide_l a b q r (gcd_divide_l a b q r)).\nintros; apply (gcd_divide_r a b q r (gcd_divide_r a b q r H)).\nintros; apply (gcd_divide_r a b q r (gcd_divide_r b q r H)).\nintros; apply (gcd_divide_r a b q r (gcd_divide_r a b q r H)).\nintros; apply (gcd_divide_r b q r (gcd_divide_r a b q r H)).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim (gcd_unique_gcd_bezout a b q r H)\n    (gcd_sym_gcd_bezout a b q r H0)).\nintros; apply (H (gcd_0_bezout a b q r H0)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ")) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6945,
                "proof_end_offset": 8358,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros q f.\ncase (eq_OZ_dec q); intro.\nunfold Q in |- *; intro b.\nsplit with IZ (sgnZ b).\nrewrite e.\nsimpl in |- *.\nrewrite (sgn_abs b).\napply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (divZ b q).\nintros div rem; intros.\ncut (lt_absZ rem q); intros.\nelim (f rem H q).\nintros.\nsplit with (addZ v (oppZ (multZ div u))) u.\nelim i.\nintros.\nelim H1.\nintros.\nelim H3.\nintros.\npattern b at 1 in |- *.\nrewrite H5.\nelim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\nrewrite H7.\nelim (mult_add_distributivity (multZ q div) rem u); intros.\nrewrite H8.\nrewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\nelim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\nrewrite (add_add Z addZ addZ_commutativity addZ_associativity (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u) (multZ (multZ q div) u)).\nelim (addZ_commutativity (multZ rem u) (multZ q v)).\nrewrite e.\nelim (multZ_associativity q div u).\nelim (addZ_opposite (multZ q (multZ div u)) I); intros.\nelim H11; intros; elim H13; intros.\nrewrite H15.\nrewrite (add_OZ (gcdZ rem q)).\nexact (gcd_modZ b q div rem n i).\nunfold lt_absZ in |- *.\nelim i; intros; elim H0; intros.\nrewrite (tech_le_pos_abs rem H1).\nelim H2; trivial.\nexact n.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros.\napply (well_founded_induction_ind_strong_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\napply (pre_is_gcdZ n (Zpos m)).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\ngeneralize (n_non_gcd_is_gcdZ n m).\nunfold Q; intros.\napply (H (fun m : Z => forall m : Z, lt_absZ m n -> Q m)).\napply P_ind with (P := fun m : Z => forall m : Z, lt_absZ m n -> Q m).\nintros; apply P_ind with (P := fun m : Z => forall m : Z, lt_absZ m n -> P m).\nintros; apply P_ind with (P := fun m : Z => forall m : Z, P m).\nintros; apply P_ind with (P := fun m : Z => forall m : Z, P m).\nintros; apply P_ind with (P := fun m : Z => forall m : Z, P m).\nintros m; apply P_ind with (P := fun m : Z => forall m : Z, P m).\nintros; apply P_ind with (P := fun m : Z => forall m : Z, P m).\nintros; apply P_ind with (P := fun m : Z => forall m : Z, P m).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros.\napply (pre_is_gcdZ n (P:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=P) (Q:=Q) (Q:=P) (Q:=P) (Q:=P) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=P) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=P) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q:=Q) (Q) (Q:=Q) (Q:=Q) (QQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\napply (pre_is_gcdZ n (fun m : Z => forall m : Z, lt_absZ m n -> Q m)).\nexact (pre_is_gcdZ n (fun m : Z => forall m : Z, lt_absZ m n -> Q m)).\nexact (pre_is_gcdZ n (fun m : Z => forall m : Z, lt_absZ m n -> Q m)).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\napply (pre_is_gcdZ n 0).\napply spec_is_gcdZ with 0.\napply gcd_is_gcdZ with (a := a).\napply gcd_is_gcdZ with 0.\napply gcd_is_gcdZ.\napply gcd_is_gcdZ with 0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_0.\napply gcd_is_gcd_r.\napply gcd_is_gcd_0.\napply gcd_is_gcd_l.\napply gcd_is_gcd_0.\napply gcd_is_gcd_r.\napply gcd_isQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros. apply (pre_is_gcdZ n).\n apply P_is_gcd_is_gcdZ; trivial.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros.\ncase (gcd_bezout_non_gcdZ n 0); intros.\nexists (fun m : Z =>\n  (fun (q : Z) (n : Z) (q : Z) (n : Z) =>\n  (fun (q : Z) (n : Z) =>\n  (fun (q : Z) (n : Z) (q : Z) =>\n  (fun (n : Z) (q : Z) (n : Z) =>\n  (fun (n : Z) (q : Z) (n : Z) =>\n  (fun (q : Z) (n : Z) (q : Z) =>\n  (fun (n : Z) (q : Z) (n : Z) =>\n  (fun (q : Z) (n : Z) (n : Z) =>\n  (fun (n : Z) (q : Z) (n : Z) =>\n  (fun q : Z =>\n  (fun (n : Z) (q : Z) (n : Z) =>\n  (fun (q : Z) (n : Z) (n : Z) =>\n  (fun (n : Z) (q : Z)Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nsimple induction n; intros.\napply H; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclid2; trivial.\napply Zis_gcd_for_euclidQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nintros n H.\ngeneralize H; elim H; elim H; elim H0; elim H1; elim H2; elim H2; elim H2;\n elim H3; elim H4; elim H5; elim H5; elim H5;\n elim H5; elim H5; elim H5; elim H5; elim H6;\n elim H5; elim H6; elim H6; elim H6; elim H6;\n elim H6; elim H6; elim H6; elim H6; elim H6;\n elim H6; elim H6; elim H6; elim H7; elim H6;\n elim H7; elim H6; elim H6; elim H6; elim H6;\n elim H7; elim H6; elim H6; elim H6; elim H7;\n elim H6; elim H6; elim H7; elim H7; elim H6; elim H6;\n (elim H6; elim H7; elim H7; elim H6; elim H6; elim H7;\n | elim H7; elim H7; elim H7; elim H7; elim H7; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ".\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 8360,
                "proof_end_offset": 8453,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (recZ Q acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; unfold BezoutZ in |- *; intro b.\n  split with (Zpos (a * b)).\n  rewrite e.\n  rewrite 2!absZ_opp.\n  rewrite 2!absZ_opp.\n  rewrite 2!absZ_opp.\n  rewrite!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <- (absZ_opp b).\n  rewrite <-!absZ_opp.\n  rewrite <- (absZ_opp b).\n  rewrite <- (absZ_opp b).\n  rewrite absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <-!absZ_opp.\n  rewrite <- (absZ_opp b).\n  rewrite <- (absZ_opp b).\n  rewrite <- (absZ_opp b).\n  rewrite <- (absZ_opp b).\n  rewrite <- (absZ_opp b).\n  rewrite <- (absZ_opp b).\n  rewrite absQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  split with (fun z => gcdZ_is_gcd_pos a b).\n  apply (gcd_bezout_abs b a (gcdZ b a)); apply gcd_bezout. unfold Q in |- *; intro b.\n  split with (gcdZ b b).\n  elim H2. intros. elim H3. intros. elim H3. intros. apply H4. assumption.\n  split with (gcdZ b a). rewrite e. simpl in |- *. rewrite (Exp_mult_comm b a).\n  rewrite <- (Exp_mult_assoc b a). apply gcd_bezout. unfold Q in |- *; intro b.\n  elim b; intros. elim H4. intros. apply H4. assumption.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold verify_cofix_gcd; intros.\n  split with 0.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_c.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_u.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_u.\n  split.\n  apply Bezout_i.\n  split.\n  apply Bezout_Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros. apply (pre_is_gcdZ a b); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); intros.\n  apply (pre_is_gcdZ b (absZ b)); introsQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (well_founded_induction_ind_strong b).\n  apply (well_founded_induction_ind_strong b).\n  apply (well_founded_induction_ind_strong b).\n  apply (well_induction_ind_strong b).\n  apply (well_founded_induction_ind_strong b).\n  apply (well_induction_ind_strong b).\n  apply (well_founded_induction_ind_strong b).\n  apply (well_induction_ind_strong b).\n  apply (well_founded_induction_ind_strong b).\n  apply (well_induction_ind_strong b).\n  apply (well_induction_ind_well_founded_ind_strong b).\n  apply (well_induction_ind_well_founded_induction_ind_strong b).\n  apply (well_induction_ind_well_well_founded_ind_ind_strong b).\n  apply (well_founded_induction_well_ind_ind_well_induction_well_typed b).\n  apply (well_founded_induction_well_ind_wf_ind_type b).\n  apply (well_induction_ind_well_wfQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold verify_cofix_ind; intros.\n  apply (P2 Bezout_i a b (gcdZ a b)); apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);\n  apply (P2 Bezout_i a b); apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);\n  apply (P2 Bezout_i b a); apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);\n  apply (P2 Bezout_i b a); apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);\n  apply (P2 Bezout_i b a); apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);\n  apply (P2 Bezout_i b a); apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);\n  apply (P2 Bezout_i b a); apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);\n  apply (P2 Bezout_i b a); apply (P2 Bezout_i b a);Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros.\n  apply (well_founded_induction_wf (fun b => a=b)).\n  apply (well_founded_induction_wf (fun b => a=b)).\n  apply wf_induction_wf; intros.\n  split with (fun z => a=b). apply Bezout_intro; intros.\n  split with (Zpos z); trivial. apply Bezout_intro; intros.\n  elim (gcd_modZ b q).\n  apply Bezout_intro; intros.\n  split with (Zpos z); trivial. apply Bezout_intro; intros.\n  elim H3; intros.\n  elim H5; intros.\n  split with (Zpos z); trivial. apply Bezout_intro; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  split with (Zpos z); trivial. apply Bezout_intro; intros.\n  elim H6; intros.\n  elim H6; intros.\n  split with (Zpos z); trivial. apply Bezout_intro; intros.\n  elim H6; intros.\n  elim H6; intros.\n  split with (Zpos z); trivial. apply Bezout_intro; intros.\n  elimQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  split with (gcdZ (a + b) (gcdZ a b)).\n  split with (gcdZ (a + b) (gcdZ a b)).\n  split with (gcdZ (a + b) (gcdZ a b)).\n  split with (gcdZ (a + b) (gcdZ a b)).\n  split with (gcdZ (a + b) (gcdZ a b)).\n  split with (gcdZ (a + b) (gcdZ b b)).\n  split with (gcdZ (a + b) (gcdZ b a)).\n  split with (gcdZ (a + b) (gcdZ b b)).\n  split with (gcdZ (a + b) (gcdZ a b)).\n  split with (gcdZ (a + b) (gcdZ a b)).\n  split with (gcdZ (a + b) (gcdZ b b)).\n  split with (gcdZ (a + b) (gcdZ b a)).\n  split with (gcdZ (a + b) (gcdZ b a)).\n  split with (gcdZ (a + b) (gcdZ b a)).\n  split with (gcdZ (a + bQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold verify_BezoutZ in |- *; intros a b H.\n  unfold Q in |- *; intros n Hn.\n  elim (gcd_gcd_is_gcdZ a b (absZ b)); intro.\n  unfold Q in |- *; intros n Hn.\n  elim (gcd_gcd_is_gcdZ a b (absZ b)); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_Z a b (absZ b)); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_Z b (absZ b)); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_Z a b); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_l b b); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_l b); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_l b); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_l b); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_l b); intro.\n  rewrite H. elim (gcd_gcd_is_gcd_l bQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros. case (gcdZ_is_gcd_bool (gcdZ a b) b); trivial.\n  intros. apply Bezout_intro with b. apply gcd_euclid2; trivial.\n  apply Bezout_intro with b. apply gcd_euclid2; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "Lemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\n",
                "context_tokens": 736,
                "proof_start_offset": 8579,
                "proof_end_offset": 8840,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros; apply (relZ_is_gcdZ); auto.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  exact (gcdZ_is_gcd_divide a (Zabs_nat x)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros. apply (divide_refl (fun x y => conj (conj (conj (conj (conj (conj x y))) (conj (conj (conj (conj (conj (conj x y)))) (conj (conj (conj (conj x y)))) z))).\n  unfold inv_int, inv_int, inv_int; simpl; reflexivity.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  unfold divide in |- *.\n  intros x y.\n  elim (Z_div_eucl x y).\n  intros H.\n  elim H.\n  intros.\n  elim H0.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H3.\n  intros.\n  elim H4.\n  intros.\n  rewrite H1.\n  rewrite H2.\n  apply H3.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros x y.\n  elim (gcd_divide_1 x y H).\n  intros.\n  apply divide_refl.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros. apply divide_antisym. apply divide_refl.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  elim H; simpl in |- *; auto.\n  intros x y H; simpl in |- *; auto.\n  intros x y H; simpl in |- *; auto.\n  intros x y H; simpl in |- *; auto.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros x.\n  unfold divide in |- *.\n  apply (gcd_refl y).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  unfold divide in |- *. intros.\n  unfold divide in |- *. intros.\n  elim (divide_antisym x y).\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  split with (Zpos (Z_of_nat x)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Z_of_nat_Z (x * y)).\n  rewrite <- (Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  apply (gcd_sym z x).\n  apply (gcd_sym z x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\nLemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\n\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec x); intros. left; exact a.\nright; split. exact b. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ x).\nQed.\n\n(**********************************)\n",
                "context_tokens": 717,
                "proof_start_offset": 8879,
                "proof_end_offset": 12106,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (addZ (multZ x (multZ b v)) (multZ y (multZ a u))).\nunfold congruentZ in |- *; split.\nreplace (multZ b v) with (addZ IZ (oppZ (multZ a u))).\nelim (mult_add_distributivity x IZ (oppZ (multZ a u))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ x).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring a u I I).\nrewrite (multZ_associativity x a (oppZ u)).\nelim (multZ_commutativity a x).\nelim (multZ_associativity a x (oppZ u)).\nrewrite (multZ_associativity y a u).\nelim (multZ_commutativity a y).\nelim (multZ_associativity a y u).\nelim (addZ_associativity x (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))).\nelim (addZ_commutativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x).\nelim (addZ_associativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x (oppZ x)).\nelim (addZ_opposite x I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)) a).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ x (oppZ u)) a (divide_selfZ a) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ y u) a (divide_selfZ a) I).\nelim H.\nelim e.\nelim (addZ_commutativity (multZ b v) (multZ a u)).\nelim (addZ_associativity (multZ b v) (multZ a u) (oppZ (multZ a u))).\nelim (addZ_opposite (multZ a u) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nexact (add_OZ (multZ b v)).\ncut (multZ a u = addZ IZ (oppZ (multZ b v))); intros.\nrewrite H0; clear H0.\nelim (mult_add_distributivity y IZ (oppZ (multZ b v))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ y).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring b v I I).\nrewrite (multZ_associativity y b (oppZ v)).\nelim (multZ_commutativity b y).\nelim (multZ_associativity b y (oppZ v)).\nrewrite (multZ_associativity x b v).\nelim (multZ_commutativity b x).\nelim (multZ_associativity b x v).\nelim (addZ_commutativity (multZ b (multZ y (oppZ v))) y).\nrewrite (addZ_associativity (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) y) .\nelim (addZ_associativity (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v)))) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) b).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ x v) b (divide_selfZ b) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ y (oppZ v)) b (divide_selfZ b) I).\nelim H.\nelim e.\nelim (addZ_associativity (multZ a u) (multZ b v) (oppZ (multZ b v))).\nelim (addZ_opposite (multZ b v) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nsymmetry in |- *; exact (add_OZ (multZ a u)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold Bezout in |- *. split. exact I. split; exact I. split; exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold Bezout in |- *. split. exact I. split. exact I. split. exact I. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold divide in |- *. split. exact I. split. exact I. split. exact I. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y.\n  apply (rel_prime_divisors a b x y); auto with *.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y; case (Rle_or_lt a b); intros.\n  left; apply Z.le_refl.\n  right; apply Z.le_refl.\n  right; apply Z.le_refl.\n  right; apply Z.le_refl.\n  right; apply Z.le_refl.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y z H.\n  elim (gcd_bezout a b x y z H). intros z H.\n  elim (gcd_bezout a b x y z H). intros z' H1.\n  rewrite (Zmult_comm z z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1).\n  rewrite (Zmult_comm z' z' z' H1Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold divide in |- *. split. exact I. split. exact I. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y H; unfold divide in |- *. split. exact I. split. exact I. split. exact I.\nelim (gcdZ_mod a b); intros. right; exact a.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nintros. unfold Bezout in |- *. split. exact I. split. exact I. split. exact I. split. exact I.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nintros a b x y z H H0.\ngeneralize (Z_div_mod_eq a b); intro H1.\nelim H1; intros; elim H1.\nrewrite (Zmult_comm z (Z_div_mod_eq a b)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_eq b (Zpos x) + 1)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_eq b (Zpos x) + 1)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_eq b (Zpos x) + 1)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_eq b (Zpos x) + 1)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_eq b (Zpos x) + 1)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_eq b (Zpos x) + 1)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_eq b (Zpos x) + 1)); auto with *.\nrewrite (Zmult_comm z (Z_div_mod_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\n",
                "context_tokens": 134,
                "proof_start_offset": 1314,
                "proof_end_offset": 1558,
                "proof": "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\n simple induction m.\n simpl in |- *.\n trivial.\n intros m0 H.\n apply le_O_n.\n simpl in |- *.\n apply le_O_n.\n simpl in |- *.\n apply lt_O_Sn.\n simpl in |- *.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_le_weak.\n apply ltQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\n unfold lt, lt, ge, pred in |- *.\nintros m; elim (lt_irrefl m).\nintros; elim (le_not_lt _ _ H0).\nintros; elim (le_not_lt _ _ H2).\nintros; elim (le_not_lt _ _ H3).\nintros; elim (le_not_lt _ _ H3).\nintros; elim (le_not_lt _ _ H3).\nintros; elim (le_not_lt _ _ H3).\nintros; elim (le_not_lt _ _ H4).\nintros; elim (le_not_lt _ _ H3).\nintros; elim (le_not_lt _ _ H3).\nintros; elim (le_not_lt _ _ H4).\nintros; elim (le_not_lt _ _ H3).\nintros; elim (le_not_lt _ _ H4).\nintros; elim (le_not_lt _ _ H4).\nintros; elim (le_not_lt _ _ H4).\nintros; elim (le_not_lt _ _ H4).\nintros; elim (Qed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction 1.\nintros m0 H; elim H.\nintros m1 H; elim H.\nintros m1 H; elim H.\nintros m1 H; elim H.\nintros m2 H; elim H.\nintros m2 H; elim H.\nintros m3 H; elim H; intros m3 H4; elim H4.\nintros m4 H5; elim H6.\nintros m4 H5; elim H5.\nintros m4 H5; elim H5.\nintros m5 H6; elim H5.\nintros m5 H6; elim H5.\nintros m5 H6; elim H6.\nintros m5 H6; elim H6.\nintros m6 H7; elim H7.\nintros m6 H7; elim H7.\nintros m5 H6; elim H7.\nintros m6 H7; elim H8.\nintros m6 H7; elim H7.\nintros m6 H7; elim H7.\nintros m7 H9; elim H10.\nintros m6 H10; elim H10.\nintros m6 H10; elim H10Qed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\n intros m H.\n cut (pos m > 0)%Z.\n intro.\n elim H.\n intro.\n rewrite H0 in H.\n discriminate.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction m; simpl in |- *; intros; auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction m.\nintros.\nrewrite <- (plus_n_O _ (S (S m))).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m))).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m))).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_comm (absZ m) (absZ m)).\nelim (mult_Qed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\n intros m H; elim H; intros m H; elim H0; intros m H1; elim H1; intros m H2; elim H2; intros m H3 H4;\n    rewrite (H2 m0 H4); rewrite (H2 m0 H4); reflexivity.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\n intros.\n apply abs_pos.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nsimple induction m; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\n",
                "context_tokens": 219,
                "proof_start_offset": 1573,
                "proof_end_offset": 1786,
                "proof": "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\n intros P H H0.\n cut (P m); [ intros H1 | intros m H1 ].\n cut (P m); [ intros H2 | intros m H2 ].\n apply H2.\n apply H0.\n apply H0.\n apply H0.\n apply H1.\n apply H0.\n apply H0.\n apply H0.\n apply H0.\n apply H0.\n apply H0.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros P H0 H1 H2; elim H1; intros n H2.\napply H1; assumption.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H H0 H1 H2; intros.\ncut (P m); [ intros H2 | apply H2; clear H2 H3 | idtac ].\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n3: assumption.\n2: assumption.\n3: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H0 H1 H2; apply (H0 H2).\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H; elim H; auto with arith.\nunfold lt_var in |- *; intros; exact H.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H' H'0.\nelim H'0; intros.\nexists (S n); auto with arith.\nexists (S n); auto with arith.\nexists (S n); auto with arith.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\n intros P H0 n H1 H2; case (Zle_or_lt n 0); intros H3.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n2: assumption.\n3: assumption.\n3: assumption.\n2: assumption.\n3: assumption.\n3: assumption.\n2: assumption.\n4: assumption.\n4: assumption.\n3: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4: assumption.\n4:Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H0 H1 H2; apply H2; assumption.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nsimple induction 1; intros.\napply H2.\napply H3.\napply H1.\napply H3.\napply H3.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H H0 H1.\ncut (exists n : nat, (exists m : Z, P m /\\ P m) /\\ (forall m : Z, P m /\\ P m)).\nintros P H H1.\ncut (exists n : nat, (exists m : Z, P m /\\ P m) /\\ (forall m : Z, P m /\\ P m)).\nintros P H1 H2.\ncut (exists n : nat, (exists m : Z, P m /\\ P m) /\\ (forall m : Z, P m /\\ P m)).\nintros P H1 H2.\ncut (exists n : nat, (exists m : Z, P m /\\ P m) /\\ (forall m : Z, P m /\\ P m)).\nintros P H1 H2.\ncut (exists n : nat, (exists m : Z, P m /\\ P m) /\\ (forall m : Z, P m /\\ P m)).\nintros P H1 H2.\ncut (exists n : nat, (exists m : Z, P m /\\ P m) /\\ (forall m : Z, P m /\\ P m)).\nintros P H1 H2.\ncutQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\n",
                "context_tokens": 413,
                "proof_start_offset": 2085,
                "proof_end_offset": 2498,
                "proof": "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\nelim (le_n_O_eq n H0).\napply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H H0 H1 H2 H3; apply H3.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nunfold and_recZ in |- *; intros.\n apply H0.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\n simple induction 1; intros.\n apply H.\n assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nsimple induction 1; intros.\nunfold iff in |- *; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold lt_zero in H0; apply H0.\nunfold not in |- *; intro; elim H0; intros.\nunfold lt_zero in H0; apply H0.\nunfold lt_zero in H0; apply H1.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nsimple induction 1; intros.\n(* H1 *)\n(* H1 *)\nsimple induction 1.\n(* H1 *)\n(* H2 *)\nsimple induction 1.\n(* H2 *)\n(* H3 *)\nintros.\napply H3.\n(* H1 *)\nsimple induction 1.\n(* H3 *)\n(* H3 *)\nsimple induction 1.\n(* H3 *)\n(* H2 *)\nsimple induction 1.\n(* H2 *)\nsimple induction 1.\n(* H3 *)\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* H3 *)\nsimple induction 1.\n(* HQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros P H; elim H; intros.\nright; red in |- *; intro; apply H; auto.\nright; red in |- *; intro; apply H; auto.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros.\napply (H m H2).\napply H0; unfold iff in |- *; intros; apply H1; assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nsimple induction 1; intros.\napply (H0 m).\napply H0; assumption.\napply H0; assumption.\napply H0; assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nsimple induction 1; intros.\nunfold lt_var_env in H0; unfold not in |- *; intro; elim H0; intros.\nunfold lt_var_env in H1; unfold not in |- *; intro; elim H1; intros.\nunfold lt_var_env in H1; unfold not in |- *; intro; elim H1; intros.\nunfold lt_var_env in H1; unfold not in |- *; intro; elim H1; intros.\nunfold lt_var_env in H1; unfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold lt_var_env in H1; unfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold lt_var_env in H1; unfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro; elim H1; intros.\nunfold not in |- *; intro;Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\n intros P H H0; apply (H0 H0); intros.\n unfold or_recZ in H0; unfold lt_opp_Z in H0; elim (lt_irrefl 0).\n unfold lt_opp_Z in H0; unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0; unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0; unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0; unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0; unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0; unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0; unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0;\n unfold lt_opp_Z in H0; unfold lt_opp_Z in HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "                                                                        *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\n",
                "context_tokens": 562,
                "proof_start_offset": 2513,
                "proof_end_offset": 3508,
                "proof": "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nsplit.\nelim (lt_succ n p H1); intros.\nelim (H0 n a); intros; trivial with arith.\nrewrite b.\napply (H (neg (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nelim (lt_succ n p H1); intros.\nelim (H0 n); intros; trivial with arith.\nrewrite b.\napply (H (pos (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros; apply or_ind; apply and_ind; apply and_ind; apply and_ind; apply and_ind;\n apply and_ind; apply and_ind; apply and_ind; apply and_ind; apply and_ind;\n apply and_ind; apply and_ind; apply and_ind; apply and_ind;\n apply and_ind; apply or_ind; apply and_ind; apply and_ind;\n apply or_ind; apply or_ind; apply or_ind; apply and_ind;\n apply or_ind; apply or_ind; apply and_ind; apply and_ind; apply and_ind;\n apply or_ind; apply or_ind; apply and_ind; apply or_ind;\n apply and_ind; apply or_ind; apply or_ind; apply or_ind;\n apply or_ind; apply or_ind; apply or_ind; apply or_ind;\n apply or_ind; apply or_ind; apply or_ind;\n apply or_ind; apply or_ind; apply or_ind; apply or_ind;\n apply or_ind; apply or_indQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros; apply and_ind_dep_dep; auto with arith.\n(* pos n *)\nelim (le_n_O_eq n H0).\n apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_RN m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\n apply (H (pos 0)); intros.\nrewrite (tech_le_abs_RN m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\n apply (H (pos 0)); intros.\nrewrite (tech_le_abs_RN m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\n apply (H (pos 0)).\n(* pos n *)\nelim (le_n_O m); apply (H (pos 0)); intros.\nrewrite (tech_le_abs_RN m). apply (Zrec1 P H). exact H1.\n(* posQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\n intros; apply and_ind_dep_ind; apply H; assumption.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nsimple induction 1; intros.\nrewrite (tech_le_abs_ 1994 m). apply (H (pos 0)); assumption.\n(* pos n *)\nelim (le_n_O_eq n H0).\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_numerator m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_thm m). apply (Zrec1 P H0).\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\n intros.\n apply or_ind_dep_eq_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_eq_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_ind_dep_no_exp.\n (* pos n *)\n apply or_Qed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\n intros.\n apply and_ind_dep_ind; apply H.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros; apply and_ind_eq; intros.\ncase (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_thm2 m). apply (Zrec2 P H). exact H0.\n(* pos n *)\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_thm2 m). apply (Zrec2 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_thm2 m). apply (Zrec2 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_thm2 m). apply (Zrec2 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros; apply and_ind_dep_strong; auto with arith.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_le_abs_thm2 m). apply (Zrec2 P H).\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros P p H0 H1 H2 H3; apply (H (pos 0)); intros.\ncase (le_n_O_eq n H3). apply (H (pos 0)); intros.\nexists (p - p).\n apply H3; symmetry  in |- *; apply H2.\n apply H3; symmetry  in |- *; apply H2.\n apply H3; symmetry  in |- *; apply H2.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros P p H H0 H1 H2; pattern p; apply and_ind;\n intros.\nelim (le_n_O_eq n H2).\n apply (H (pos 0)); intros.\nrewrite (tech_le_abs_absolu n). apply (Zrec p H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H1).\n apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_absolu m). apply (Zrec p H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\n apply (H (pos 0)); intros.\nrewrite (tech_le_abs_absolu m). apply (Zrec p H).\nexact H1.\n(* pos n *)\nelim (le_n_O_eq n H0).\n apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_absolu n). apply (Zrec p H).\n(* pos n *)\nelim (le_n_O_eq n H0).\n apply (H (pos 0)); intros.\nrewrite (techQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": " -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\n",
                "context_tokens": 707,
                "proof_start_offset": 3526,
                "proof_end_offset": 3740,
                "proof": "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros; elim p.\nexact (Zrec2 P H).\nintros; apply Zrec3; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros.\ncase (le_lt_eq_dec n p H0).\nintros.\nexists (S p).\napply (H0 (pos (S p))).\nintros.\napply H1; auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n(* P *)\nintros; apply P; intros.\napply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto with arith.\n(* P *)\nintros; apply H; auto withQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nsimple induction 1; intros.\n(* a case 1 *)\nleft; intros.\nelim H1; intros.\nelim H2; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros P H_rec_Z P H_rec_Z H_rec_Z.\n(* P *)\nelim (le_n_O_eq n p H_rec_Z H_rec_Z H_rec_Z H_rec_Z H_ind_eq_Z H_rec_Z H_ind_eq_Z.\n(* P *)\nelim (le_n_O_eq n p H_rec_Z H_rec_Z H_rec_Z H_ind_eq_Z H_rec_eq_Z H_rec_Z H_ind_eq_Z.\n(* P *)\nelim (le_n_O p); intros.\nrewrite (H (pos (S p)) (S p)); rewrite H.\napply (H (pos (S p)) (S p)); auto with arith.\n(* P *)\nelim (le_n_O p); intros.\nrewrite (H (pos (S p)) (S p)); rewrite H.\napply (H (pos (S p)) (S p)); auto with arith.\n(* P *)\nelim (le_n_O p); intros.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros; elim (lt_irrefl p); intros.\nunfold lt_absZ in |- *; unfold Zlt in |- *; apply Zgt_not_eq;\n assumption.\n(* P (neg n) *)\nelim (lt_irrefl p); intros.\nunfold lt_absZ in |- *; unfold lt_absZ in |- *; unfold boundZ in |- *;\n unfold align_compatible in |- *; unfold boundZ in |- *;\n unfold align_compatible in |- *; unfold boundZ in |- *;\n unfold boundZ in |- *; unfold lt in |- *; unfold boundZ in |- *;\n unfold boundZ in |- *; unfold Zle in |- *;\n unfold Zminus in |- *; apply Zplus_le_lt_reg_l with n; auto with zarith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P H H0 p H1 H2.\nelim H1; intros.\napply H2; auto with arith.\nintros m H1 H2; elim H2; intros.\napply H2; auto with arith.\nintros n H2; elim H2; intros.\napply H2; auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros; red in |- *; intros; apply and_ind; apply and_ind;\n intros; apply and_ind; apply and_ind; apply and_ind;\n intros; apply and_ind; apply and_ind; apply and_ind;\n intros; apply and_ind; apply and_ind; apply and_ind;\n intros; apply and_ind; apply and_ind; apply and_ind;\n intros; apply and_ind; apply and_ind; apply and_ind;\n intros; apply and_ind; apply or_ind; apply and_ind;\n intros; apply or_ind; apply or_ind; apply or_ind;\n intros; apply or_ind; apply or_ind; apply and_ind;\n intros; apply or_ind; apply and_ind; apply and_ind;\n intros; apply and_ind; apply and_ind; apply and_ind;\n intros; apply or_ind; apply and_ind; apply or_ind;\n intros; apply or_ind; apply or_ind; intros; apply and_ind;\n intros; apply or_ind; apply or_ind;\n intros; apply or_Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n(* P (neg n) *)\nProof.\nintros; apply (H0 n); intros.\napply (H (pos n)); intros.\napply (H (pos (S p)); auto with arith.\napply (H (pos (S p)); auto with arith.\n(* P (pos n) *)\nelim (le_n_O_eq n H0); intros.\napply (H (pos (S p))); auto with arith.\n(* P (pos n) *)\nelim (le_n_O n H0); intros.\nrewrite (H (pos (S p))); auto with arith.\n(* P (pos n) *)\nelim (le_n_O n H); intros.\nrewrite (H (pos (S p))); auto with arith.\n(* P (pos n) *)\nelim (le_n_O p); intros.\nrewrite (H (pos (S p))); auto with arith.\n(* P (pos n) *)\nelim (le_n_O p); intros.\nrewrite (H (pos (S p))); auto with arith.\n(* P (pos n) *)\nelim (le_n_O p); introsQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P H_ind; apply H_ind; apply H_ind; apply H_ind; apply H_ind; apply H_ind; apply H_ind;\n assumption.\n(* P (neg n) *)\nelim (le_n_O_eq n H1); intros.\nrewrite (tech_lt_abs_ONE n) in H0.\nelim (H0 n); auto with arith.\nintros; apply (H (pos (S p))).\napply (H0 (pos (S p))).\napply (H0 (pos (S p)).\napply (H0 (pos (S p))).\napply (H0 (pos (S p))).\napply (H0 (pos (S p))).\napply (H0 (pos (S p)).\napply (H0 (pos (S p)).\napply (H0 (pos (S p))).\napply (H0 (pos (S p))).\napply (H0 (pos (S p))).\napply (H (pos (S p)).\napply (le_S p).\napply (H0 (pos (S p))).\napply (H0 (pos (S p))).\napply (Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros P H_ind P p.\nelim (le_or_lt 0 p H_ind p H_ind).\nintros; elim (le_or_lt 0 p H_ind).\nintros; elim (le_or_lt 0 p H_ind).\nintros; apply (H (pos (S p))); auto with arith.\nintros; elim (le_or_lt 0 p H_ind).\nintros; apply (H (pos (S p))); auto with arith.\nintros; elim (le_or_lt 0 p H_ind).\nintros; apply (H (pos (S p))); auto with arith.\nintros; elim (le_or_lt 0 p H_ind).\nintros; apply (H (pos (S p))); auto with arith.\nintros; elim (le_or_lt 0 p H_ind).\nintros; apply (H (pos (S p))); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\nTheorem Zrec4 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n forall p : nat, and_recZ p P.\n\nintros; elim p. \nexact (Zrec2 P H). \nintros; apply Zrec3; trivial with arith.\nQed.\n\n(************)\n",
                "context_tokens": 711,
                "proof_start_offset": 3757,
                "proof_end_offset": 4149,
                "proof": "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p.\nexact (Zrec1 P H).\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p; intros.\napply (H (S p)); intros.\napply (H0 (S p)); auto with arith.\napply H0; auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p; simpl in |- *; intros.\ninversion H1; inversion H2; inversion H2; inversion H3; inversion H4; clear H3;\n (intros; inversion H2; inversion H2; inversion H4; inversion H5; inversion H6; inversion H6; inversion H6; inversion H6; inversion H6; inversion H6; inversion H7; inversion H7; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8; inversion H8Qed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P H p H0 H1.\nelim (le_or_lt 0 p); intros.\nleft; apply (H0 n); auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p. \nintros; elim H1; intros.\nrewrite (H1 (H H0)); auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p. \nintros; elim p; intros; apply (Zrec2 p).\nintros; apply (H0 n); intros.\napply (H1 p); intros.\napply (H2 n); intros.\napply H1.\napply (H2 n); intros.\napply H1; intros.\napply (H1 n); intros.\napply H0; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H0; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1; intros.\napply H1Qed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p. \nintros; elim H1. \nintros; elim H1; intros.\nrewrite <- H1; assumption.\nintros; elim H1; intros.\nrewrite <- H1; assumption.\nintros; elim H1; intros.\nrewrite <- H1; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros P H; elim H; intros.\nleft; apply H0; assumption.\nright; apply Z_ind; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p.\nintros; unfold Z.le_elim in |- *; intros.\napply (H (pos p)).\nelim (le_lt_eq_dec 0 p); intros.\nleft; red in |- *; intro; apply H1.\nrewrite (H (pos p)); auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P H; elim H. \nintros; elim H; intros; auto with arith.\nintros; elim H1; intros; auto with arith.\nintros; elim H1; intros; auto with arith.\nintros; elim H1; intros; auto with arith.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p. \nintros; elim H0; intros.\nrewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nintros; rewrite H1; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n unfold ptrofs_eq.\n intros; rewrite <- (addneg x2); rewrite <- (addneg x2); reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  elim (lt_irrefl x2).\n  intro.\n  left.\n  reflexivity.\n  right.\n  reflexivity.\n  right.\n  reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfold Zminus in |- *.\nintros y; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros; elim (Z_eq_dec y x); auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  simple induction y.\n  reflexivity.\n  simpl in |- *.\n  intros.\n  apply neg_zero.\n  apply neg_zero.\n  apply neg_zero.\n  apply neg_zero.\n  apply neg_zero.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold ptrofs_eq; auto with arith.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nunfold Zminus in |- *.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfold monotone in |- *.\nintros x y.\nelim x.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nintros z H; elim H; auto with arith.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold iff, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm in, eqm, eqm, eqm, eqm, eqm, eqm, eqm in |- with eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm in |- with y, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm, eqm,Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n simple induction n.\n trivial.\n intros. rewrite <- H0. apply addpos_eq1.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_)\u00f7_l.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_invol (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_))(pred_)/\\_l.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_))(Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ x y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ x y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 730,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Abelian_add_neg_ Scope forall x y : Z, \"__ mul_reg_neg_morphism x y.\n\n(**********************************************)\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(* This contribution was updated for Coq V5.10 by the COQ workgroup.        *)\n(* January 1995                                                             *)\n(****************************************************************************)\n(*                                                                          *)\n(*                                                                          *)\n(*  Coq V5.8                                                            *)\n(*                                                                          *)\n(*                                                                          *)\n(*      Meta-theory of the explicit substitution calculus lambda-env         *)\n(*                                                                          *)\n(*      September 1993                                                       *)\n(*                                                                          *)\n(*      September 1993                                                       *)\n(*                                                                          *)\n(*      September 1993                                                       *)\n(*                                                                          *)\n(*                                                                           *)\n(****************************************************************************)\n(*      September 1993                                                       *)\n(*                                                                           *)\n(****************************************************************************)\n\nRequire Import List.\nRequire Import syntax.\nRequire Import base.\nRequire Import exp.\nRequire Import exp.\nRequire Import lambda.\nRequire Import exp.\nRequire Import lambda.\nRequire Import lambda.\nRequire Import lambda.\nRequire Import env.\nRequire Import abs.\nRequire Import lambda.\nRequire Import sigma.\nRequire Import lambda.\nRequire Import sigmaQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Zmult_opp_permute.\n\n(* pos n *)\nsimple destruct n.\nreflexivity.\n(* pos n *)\nintro n.\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ y).\n(* pos n *)\nsimple destruct n.\nreflexivity.\n(* pos n *)\nintro n.\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ y).\n(* pos n *)\nsimple destruct n.\nreflexivity.\n(* pos n *)\nintro n.\nsimpl in |- *; symmetry  in |- *; exact (succ_srt (pos n)).\n(* pos n *)\nsimple destruct n.\nreflexivity.\n(* pos n *)\nintro n.\nsimpl in |- *; symmetry  in |- *; exact (succ_invol (neg n)).\n(* pos n *)\nsimple destruct n.\nreflexivity.\n(* pos n *)\nsimple destruct n.\nreflexivity.\n(* pos n *)\nintro n.\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (neg n)).\n(* pos n *)\nsimple destruct n.\nreflexivity.\n(* pos n *)\nintro n.\nsimpl in |- *; symmetry  in |- *; exactQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_eq_6.\n\n(* neg n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ caseEq n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ caseEq n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ caseEq n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ caseEq n).\n(* pos n *)\nintro n; rewrite pred_succZ; trivial.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ caseEq n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ caseEq n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ caseEq n).\n(* pos n *)\nsimpleQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_opp_neg_succZ.\n\n(* zero n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l (pos x) y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (pos y)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (neg x)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (pos x)).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (pos x)).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr (pos x)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_discr (pos x)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_discr (pos x)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_opp_discr.\n\nLemma tech_add_neg_neg_neg_neg :\n forall (x y : Z) (y : Z), succZ (powers (S x)) y = succZ (powers (S x) y).\nProof ptc_add_neg_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg :\n forall (x : nat) (y : Z), succZ (powers (S x)) y = succZ (powers (S x) y).\nProof Double_add_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall (x : nat) (y : Z), succZ (powers (S x)) y = succZ (powers (S x) y).\nProof mask_add_neg_neg_neg.\n\nLemma tech_add_neg_neg_neg_neg :\n forall (x : nat) (y : Z),\n succZ (powers (S x)) y = succZ (powers (S x) y).\nProof Abelian_add_neg_neg_neg.\n\nLemma tech_add_neg_negQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_opp_neg_predZ.\n\n(**************)\n(* a few other properties *)\nLemma opp_involutive : forall x : Z, opp x = x.\nProof ptc_opp_neg_succZ.\n\n(* a few other properties *)\nLemma opp_involutive : forall x : Z, opp x = x.\nProof ptc_opp_neg_predZ.\n\n(* a few other properties *)\nLemma opp_involutive : forall x : Z, opp x = x.\nProof ptc_opp_neg_absf.\n\n(* a few other properties *)\nLemma opp_involutive : forall x : Z, opp x = x.\nProof ptc_opp_neg_bijective.\n\n(* a few other properties *)\nLemma opp_involutive : forall x : Z, opp x = x.\nProof ptc_opp_neg_bijective.\n\n(* a few other properties *)\nLemma opp_involutive : forall x : Z, opp x = x.\nProof ptc_opp_neg_bijective.\n\n(* a few more properties *)\nLemma opp_involutive : forall x : Z, opp x = x.\nProof ptc_opp_involutive.\n\n(* a few other propertiesQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\n(* (c) Copyright 2006-2016 Microsoft Corporation and Inria.                  *)\n\nRequire Import ssreflect.\n\nLemma test1 : forall x : nat, x = 0.\nintros.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nassumption.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Abelian_add_neg_ Scope forall x y : Z,2018 x = pred_                                                     \n                                                                             \n          y.\nsimple induction x; simpl in |- *; intros; auto with arith.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ_l 0).\n(* pos n *)\nintros; rewrite <- H0; rewrite <- H1; rewrite <- H1; rewrite <- H1; rewrite <- H1; rewrite <- H1; rewrite <- H1;\n reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ_l 0).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_invol (pos n)).\n(* pos n *)\nintros; rewrite <- H0; rewrite <- H1; rewrite <- H1; rewrite <- H1; rewrite <- H0;\n reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ_l 0).\n(* pos n *)\nsimple destruct n.Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof ptc_add_neg_succZ.\n\n(* shift *)\nsimple destruct x; simpl in |- *; rewrite pred_predZ; trivial.\n(* var n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n).\n(* neg n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n).\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\nRequire Import Arith List.\nRequire Import Arith.\nRequire Import Omega.\nRequire Import Omega.\nRequire Import Omega.\nRequire Import Omega.\nRequire Import Omega.\n\nLocal Open Scope Z_scope.\n\nLemma tech_plus_l : forall x y z : Z, x + y = x + z -> y = z.\nProof.\n intros; elim x; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Monoid.op_assoc.\n\nLemma tech_opp_neg_neg_neg_neg : forall x y : Z,annot (neg x) y = succZ (addZ x y).\nProof Monoid.op_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg_neg : forall x y : Z,annot (neg x) y = negZ (addZ x y).\nProof Monoid.op_neg_neg.\n\nLemma tech_opp_neg_neg_neg : forall x y : Z,annot (neg x) y = negZ ( Evalof x y).\nProof Monoid.op_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg : forall x y : Z,annot (neg x) y = negZ ( Evalof x y).\nProof Monoid.op_neg_neg.\n\nLemma tech_opp_neg_neg : forall x y : Z,annot (neg x) y = negZ (neg x).\nProof Monoid.op_neg_neg.\n\nLemma tech_opp_neg_neg : forall x y : Z,annot (neg x) y = negZ (negQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof ptc_eq_2.\n\nLemma tech_add_neg_predZ :\n forall (x y : Z) (y : Z), distr x (Vlong y) = succZ (addZ x y).\nProof Abelian_add_neg_ Scope forall x y : Z, distr x (Vlong y) = succZ (Vlong y).\n\nintros; elim x; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_neg_ Scope forall x y : Z, oppZ (Vlong x) = succZ (Vlong y).\nrewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_predZ.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof using tech_add_neg_predZ.\n\nLemma tech_add_neg_predZ :\n forall x y : Z,)))); [ intro; elim x; reflexivity | intros; rewrite tech_add_neg_succZ; assumption ].\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Abelian_add_neg_ Scope forall x y : Z,iffP (tech (neg x) y) = succZ (addZ x y).\n\nintros; elim x.\n(* pos m *)\nsimple induction n.\n(* pos m *)\nsimpl in |- *; rewrite pred_predZ; trivial.\nintros; rewrite <- H0; apply add_neg_neg_predZ.\n(* pos n *)\nsimple induction n.\n(* pos m *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr m).\n(* pos m *)\nsimple induction n.\n(* pos m *)\nsimpl in |- *; rewrite pred_any_pos_prf; trivial.\n(* pos m *)\nsimple induction m.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn m).\n(* pos m *)\nintros; rewrite <- H0; apply add_neg_neg_pos_neg_neg.\n(* pos m *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn m).\n(* pos m *)\nintros; rewrite <- H0; apply add_neg_neg_neg_neg.\n(* pos n *)\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Abelian_add_neg_predZ.\n\n(***************)\n\nLemma opp_exp_l : forall x y : Z, succ_exp x y = succZ (Qdiv (neg x) y).\nProof Abelian_opp_exp.\n\nLemma opp_exp_l : forall x y : Z, succ_exp x y = succZ (Qdiv (neg x) y).\nProof Abelian_opp_exp.\n\nLemma opp_exp_l : forall x y : Z, opp_exp x y = succZ (Qdiv x y).\nProof Abelian_opp_exp.\n\nLemma opp_exp_r : forall x y : Z, opp_exp x y = exp (Qdiv (neg x) y).\nProof Abelian_opp_exp.\n\nLemma opp_exp_r : forall x y : Z, opp_exp x y = exp (Qdiv x y).\nProof Abelian_opp_exp.\n\n(***************)\n\nLemma opp_exp_distr : forall x y : Z, opp_exp x y = exp (mult x y).\nProof Abelian_opp_exp.\n\nLemma opp_exp_distr : forall x y : Z, oppQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Monoid.op_assoc.\n\nLemma tech_add_neg_neg_neg_neg_neg :\n forall x y : Z,))));\n pos_cancel (neg (neg (neg x)) y = neg (neg x).\nProof Monoid.op_neg_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg_neg_neg :\n forall x y : Z,))));\n pos_cancel (neg (neg x) y = neg (neg x).\nProof Monoid.op_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg_neg :\n forall x y : Z,))));\n pos_cancel (neg (neg x) y = neg (neg x).\nProof Monoid.op_neg_neg_neg.\n\nLemma tech_opp_neg_neg_neg :\n forall x y : Z,))));\n pos_cancel (neg (neg x) y = neg (neg x).\nProof Monoid.op_neg_neg.\n\nLemma tech_opp_neg_neg :\n forall x y : Z,))));\n pos_cancel (neg (neg x) y = neg (neg x).Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof strongly_add_neg_predZ.\n\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_succZ.\n(* neg n *)\nintros.\ndo 2 rewrite (tech_add_neg_bijective n0).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_predZ.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_succZ.\n(* pos n *)\nintro n; rewrite (tech_add_neg_bijective n0).\nelimQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof distr Coercion tech_opp_r : forall x y : Z,2018 x ->2018 y = - y.\n(* Proof of pred_addZ_r.\n\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_succZ.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_succZ.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_predZ.\n(* pos n *)\nintros; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_predZ.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_predZ.\n(* pos n *)\nintros; rewrite (tech_add_neg_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_predZ.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_succZ.\n(* pos nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof using tech_add_neg_ caseEq.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_IZ.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_IZ.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_IZ.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pos_discr.\n(* pos n *)\nsimple induction n.\n(* pos nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof Floats_r.\n\n(* pos n *)\nsimple induction n.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* - succ *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - pos n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - pos n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - pos n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivity.\n(* - neg n *)\nreflexivityQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 741,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nunfold oppZ in |- *; intros; elim x.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_neg_neg_neg_neg n).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_neg_neg n).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_double.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_addQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* pos n *)\nunfold not in |- *; apply succ_pred_succZ.\n(* pos n *)\nsimpl in |- *; apply succ_pred_predZ.\n(* pos n *)\nsimpl in |- *; apply succ_pred_predZ.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_neg.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_reverse n0).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_reverse n0).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nunfold symmetry  in |- *; exact (opp_involutive x).\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_opp.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pred_predZ.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply pred_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimpl in |- *; apply pred_pred_pos.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\n(* (neg (S x)) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x; trivial.\n(* neg n *)\nsimple induction n.\n(* (neg n) *)\nsimpl in |- *; apply succ_pred_discr.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (negQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x; reflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_predZ.\n(* pos n *)\nintro.\nrewrite (tech_opp_neg_neg_predZ n).\nrewrite H; apply add_neg_pos_pos.\n(* neg n *)\nintro.\nrewrite (tech_opp_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pos_neg.\n(* pos n *)\nintro.\nrewrite (tech_opp_neg_neg_neg_neg_neg n).\nrewrite H; apply add_neg_neg.\n(* pos n *)\nintro.\nrewrite (tech_opp_neg_neg_neg_neg n).\nrewrite H; apply add_neg_neg.\n(* neg n *)\nintro.\nrewrite (techQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x; simpl in |- *; auto with arith.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_neg_succZ n).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_succZ n).\nelim H; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_ Scope forall x y : Z, Zminus x y = pos y.\nsimple induction x; simpl in |- *; auto with arith.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_ caseEq (pos n) (neg y)); reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_predZ.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_ Scope forall x y : Z, Zminus x y = neg y.\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* var n *)\nreflexivity.\n(* (neg n) *)\nsimpl in |- *; apply succ_pred_pred_pos.\n(* (pos n) *)\nintros; apply succ_pred_pos.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nintros.\ndo 2 rewrite (tech_opp_neg_predZ n).\nelim H; reflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nintro.\nrewrite (tech_neg_neg_pos_neg n).\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (neg n) *)\nelim H; reflexivity.\n(* (negQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_succZ n).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_predZ n).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_predZ; trivial.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_bijective n).\nelim H; reflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_succZ; trivial.Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nintro.\ncut (neg n = neg n).\nintro.\nrewrite <- H1 in H.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewrite <- neg_neg_neg.\nrewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ") y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x; simpl in |- *; intros.\nrewrite tech_add_neg_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* a variable *)\nreflexivity.\n(* a variable *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (neg n) *)\nreflexivity.\n(* (Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pred_discr.\n(* pos n *)\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_neg_predZ n).\nelim H; reflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nassumption.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintro.\nunfold pred in |- *; apply succ_pred_double.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_addQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x; simpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nintros.\nunfold succ in |- *; rewrite pred_pos_prf; reflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; rewrite pred_pos_prf; reflexivity.\n(* neg n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nintros.\nunfold neg in |- *; rewrite pred_pos_prf; reflexivity.\n(* pos n *)\nintros.\nunfold pred in |- *; rewrite pred_pos_prf; reflexivity.\n(* pos n *)\nintros.\nunfold pred in |- *; rewrite pred_pos_prf; reflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nreflexivity.\n(* pos n *)\nintros.\nunfold neg in |- *; rewrite pred_pos_prf; reflexivity.\n(* pos n *)\nintros.\nunfoldQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nsimple induction x; simpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_discr.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_double.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x; simpl in |- *; auto with arith.\nintros; rewrite tech_add_neg_OZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple inductionQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 4952,
                "proof_end_offset": 5141,
                "proof": "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros.\ncut (predZ OZ = neg 0); intros.\nelim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\n(* a variable *)\nsimple induction n.\n(* a variable *)\nreflexivity.\n(* a variable *)\nsimple induction n.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\n(* a variable *)\nreflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\ncut (neg x = neg x); intro; elim H.\nrewrite (succ_addZ_r x mone); rewrite (add_0_neg x); reflexivity.\nreflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros.\nrewrite (tech_add_pos_predZ n0).\nrewrite (tech_add_pos_predZ n0).\nrewrite (tech_add_pos_predZ n0).\nrewrite (tech_add_neg_ Scope a = a + a + (0 + - 1)).\nrewrite (tech_add_pos_ Scope a = a + (0 + - 1)).\nrewrite (tech_add_neg_ Scope a = a + (0 + - 1)).\nrewrite (tech_add_neg_ Scope a = a + (0 + - 1)).\nrewrite (tech_add_neg_ Scope a = a + (0 + - 1)).\nrewrite (tech_add_neg_ Scope a = a + (0 + - 1)).\nrewrite (tech_add_neg_ Scope a = a + (0 + -1)).\nrewrite (tech_add_neg_ Scope a = a + (0 + - 1)).\nrewrite (techQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\ncut (neg x); auto.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\n(* zero *)\nreflexivity.\n(* zero *)\nreflexivity.\n(* zero *)\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_powers.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_double.\n(* pos n *)\nsimpl in |- *; symmetry  in |-Qed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\ncut (neg x = oppZ (neg 0)); intro; rewrite (opp_involutive x); reflexivity.\nreflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintro. elim H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\ncut (neg (pred x) = pos (pred x)).\nintros.\nrewrite (opp_predZ x).\nrewrite (opp_predZ x).\nrewrite (add_assoc (pos x) (neg 0)); reflexivity.\nreflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nunfold neg at 1 in |- *; rewrite <- opp_neg_neg; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 5171,
                "proof_end_offset": 5905,
                "proof": "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nsimpl in |- *; symmetry in |- *; exact (add_OZ y).\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_IZ_succZ y).\nintros; rewrite (tech_add_pos_succZ n0 y).\nrewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros.\nelim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros; rewrite (tech_add_neg_predZ n0 y).\nrewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros.\nelim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_commutativity : commutativity Z addZ.\n(* quasi-transitive closure *)\n(* In't be the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as *)\n(* the same as the same as the same as the same as the same as the same as the same as *)\n(* the same as the same as the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the same as the *)\n(* the same as the same as the same as the same as the *)\n(* the same as the same as the same as the sameQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold add in |- *; apply opp_neg_pos_neg.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv in |- *.\nunfold Rdiv inQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.\nunfold cancellation at 1 in |- *.Qed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold Zminus in |- *.\nintros.\ncut (neg (S x) = neg 0); intros.\nelim H.\nrewrite (opp_involutive (neg 0)); rewrite (opp_involutive (neg 0)); reflexivity.\nrewrite (opp_involutive (neg 0)); reflexivity.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold computable in |- *.\nsimple induction 1; simpl in |- *; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold Zminus in |- *.\nintros x H'.\ncut (neg (S x) = neg 0); intros. elim H'.\nrewrite (pred_succZ x H').\nrewrite (pred_tech (neg x) (neg x)); reflexivity.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold not in |- *; intros; elim H.\nrewrite (pred_succZ x); rewrite (pred_predZ x); reflexivity.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold IZR, Z, Z.abs, Z.abs, Z.abs, Z.abs.\nintros; elim H.\nrewrite (pred_addZ_r x xd); rewrite (add_neg_predZ x); reflexivity.\nreflexivity.\nrewrite (pred_addZ_r x xd); rewrite (add_comm x xd); reflexivity.\nreflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold Rminus in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "intros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 710,
                "proof_start_offset": 5935,
                "proof_end_offset": 6461,
                "proof": "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nProof.\nsimple induction n2.\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (neg n1 < n2); intros. elim H0.\nrewrite (pred_predZ n1).\nrewrite (pred_succZ n1).\nrewrite (pred_predZ n2).\nrewrite (pred_predZ n2).\nrewrite (pred_IZ_IZ_ IZ (pos n1)).\nrewrite (pred_absf (pos n2)).\nrewrite (pred_predZ n1).\nrewrite (pred_predZ n2).\nrewrite (pred_ (?&?&?pred_predZ n2).\nreflexivity.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_n_O 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_IZ_ Scope nat.\n(* pos n *)\nintros; rewrite (tech_add_pos_neg_pos_posZ n1).\nrewrite (pred_ IZ (pos n)).\nrewrite (pred_predZ (posQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nelim n1; simpl in |- *; reflexivity.\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn 0).\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn 0).\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mRec n2).\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mRec n2).\n(* pos n1 *)\nsimple induction n1.\n(* pos n2 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mRec n1).\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mRec n2).\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (neg (S n1) = neg (n1 - S n2)); intros. elim H.\nrewrite (pred_addZ_r x0 1); reflexivity.\nreflexivity.\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_IZ_ Scope 0.\n(* neg n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ IZ).\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_IZ_ Scope 0.\n(* neg n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_IZ_ Scope 0.\n(* neg n1 *)\nsimple induction n1.\n(* pos n2 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_IZ_ Scope 0.\n(* negQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nrewrite (pred_addZ_r x (neg n1)); rewrite H.\nrewrite (pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_ (?&?&?pred_Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (neg n1 = pos (n1 - S n2)); intros. elim H0.\nrewrite (pred_predZ n1); reflexivity.\nrewrite (pred_ IZ); reflexivity.\n(* neg n *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_n_O 0).\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIs_pos_neg_negZ 0).\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIs_pos_neg_negZ 0).\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIs_pos_neg_negZ 0).\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIs_neg_negZ 0).\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIs_neg_neg_neg_Qed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nsimple induction n1; auto.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (neg (S n1) = pos (S n2)); intros. elim H0.\nrewrite (pred_addZ_r x (neg n1)); rewrite (neg_involutive (neg n2)); reflexivity.\nreflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nProof.\nsimple induction n1.\n(* pos O *)\nsimple induction n1.\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n1 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimple induction n2.\n(* pos n2 *)\nsimpleQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nsimple induction n1; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (neg (neg n1) = pos (S n2)).\nintro. elim H0.\nrewrite (pred_addZ_r (pos n1) (neg n2)).\nrewrite (pred_succZ (neg n2)).\nrewrite (pred_addZ_l (pos n1) (neg n2)).\nrewrite (pred_ (?&?&?).\nreflexivity.\n(* pos n *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_moins_ Scope nat).\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_moins_ Scope nat).\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (add_moins_ Scope nat).\n(* pos n1 *)\nsimple induction n1.\n(* pos n1 *)\nsimpl in |- *; symmetry  in |- *; exact (addQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "reflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 6491,
                "proof_end_offset": 7092,
                "proof": "Theorem addZ_associativity : associativity Z addZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nunfold addZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (succ_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (pred_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_associativity : associativity Z addZ.\nunfoldassoc in |- *; intros; elim x.\n(* pos n *)\nintros; elim (mult_comm x (pos n)) (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O 0).\n(* pos n *)\nintros; elim (mult_comm x (neg n)) (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O 0).\n(* pos n *)\nintros; elim (mult_comm x (neg n)) (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O 0).\n(* pos n *)\nintros; elim (mult_comm x (neg n)) (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O 0).\n(* pos n *)\nintros; elim (mult_commQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Zminus in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_pos_neg_posZ 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_neg_pos_pos_posZ 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_neg_pos_pos_posZ 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_neg_pos_pos_neg_negZ 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_neg_pos_neg_pos_neg_posZ 0).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_neg_neg_neg_neg_negZ 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_neg_neg_pos_posZ 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_negQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfoldassoc in |- *; intros; elim x; trivial.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O n).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O n).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O n).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O n).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O n).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O m).\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_n_O m).\n(* pos n *)Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold))); trivial.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Rminus in |- *; intros; elim x.\n(* neg n *)\nunfold not in |- *; intros; elim x.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_ind.\n(* pos n *)\napply eq_Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfoldassoc in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predn y).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Zminus in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_typeconv n);\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_typeconv n);\n(* pos n *)\nintros; elim (mult_comm (pos n) (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_typeconv n);\n(* neg n *)\nintros; elim (mult_comm (neg n) (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_typeconv n);\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_typeconv n);\n(* pos n *)\nintros; elim (mult_comm (neg n) (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_m'.(N_of_nat n)).\n(* pos n *)\nintros;Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold symmetry in |- *; exact (opp_neg_posZ 1).\n(* pos n *)\nsimple induction n.\n(* m = 0 *)\nintro.\nrewrite tech_add_neg_neg_neg_negZ; rewrite H; reflexivity.\n(* m = 0 *)\nintro.\nrewrite tech_add_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Rminus in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_mIZ_predZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ IZ y).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ Scope nat).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_mIZ_ Scope nat).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ Scope nat).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ Scope nat).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ Scope nat).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ Scope nat).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_ Scope nat).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Zlt in |- *; intros; elim x.\n(* pos n *)\nintro H; elim H; symmetry  in |- *; exact (add_0_pos_neg_pos_posZ H).\n(* pos n *)\nintro H; elim H; symmetry  in |- *; exact (add_0_pos_neg_pos_posZ H).\n(* pos n *)\nintro H; elim H; symmetry  in |- *; exact (add_0_neg_pos_neg_pos_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ".\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\n",
                "context_tokens": 745,
                "proof_start_offset": 7164,
                "proof_end_offset": 7330,
                "proof": "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nProof.\nunfold neutral in |- *; intros.\nsplit.\nexact I.\nintros.\nsplit.\nexact (add_OZ x).\nunfold addZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold absZ in |- *; intros; elim x.\n(* pos n *)\nintro.\nrewrite (tech_add_neg_pos_posZ x y).\nrewrite (tech_add_pos_neg_pos_posZ x y).\nrewrite (tech_add_neg_neg_neg_neg_neg_neg_neg_pos_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold IdZ in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  inQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold absZ in |- *; intros; elim x.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ pacofold (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ (?&?&?).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ Theorems (pred_RN_succ_pos_posZ n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ }\")\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_pos_pos_negZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_)](pred_tech_add_pos_neg_pos_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_neg_posZQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold varZ, oppZ in |- *; intros; apply abs_inj_pos_pos_pos.\n\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n).\n(* pos n *)\nintros.\ncase (neg n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_invol n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n).\n(* pos n *)\nintros.\ncase (neg n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_invol n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_invol n).\n(* pos n *)\nintros.\ncase (neg n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn n).\n(* pos nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold oppZ in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_0_pos_posZ x).\n(* neg n *)\nintros.\ndo 2 rewrite (tech_add_pos_pos_neg n0).\nrewrite (tech_add_neg_neg n0).\nrewrite (add_comm (negb (S n0)) (neg n0)); elim H; reflexivity.\n(* neg n *)\nintros.\ndo 2 rewrite (tech_add_neg_neg n0).\nrewrite (tech_add_neg_neg n0).\nrewrite (add_comm (negb (S n0)) (neg n0)); elim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_neg n0).\nrewrite (tech_add_neg_neg n0).\nrewrite (add_comm (negb (S n0)) (neg n0)); elim H; reflexivity.\n(* neg n *)\nintros.\ndo 2 rewrite (tech_add_neg_neg n0).\nrewrite (tech_add_neg_neg n0).\nrewriteQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold id in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_posZ).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_posZ).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_posZ).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_posZ).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_posZ).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_posZ).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_neg_posZ).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_opp_neg_posZ).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_powers_oppQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold absZ in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_mIZN x).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_mIZN x).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_m.(://.(.(://.('.(\\`)))).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_m.(://.(.(://.(://.('.('.('.(.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.('.(Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold not in |- *; intros; elim x.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (pos O)).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (neg O)).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (neg O)).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (neg O)).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (neg O)).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (neg O)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (neg O)).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetryQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold absZ in |- *; intros; elim x.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ x).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ x).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn x).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ Scope nat_scope.\n(* pos n *)\nintros; elim x.\n(* pos n *)\nsimpl inQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold oppZ in |- *; intros; elim x.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_ (?&?&?is_opp_predZ n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_addZ_neutral y z).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_predZ n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_predZ n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_succZ n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exactQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7528,
                "proof_end_offset": 7725,
                "proof": "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nintros; reflexivity.\nsimple destruct n; intros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nintros; unfold oppZ in |- *; intros; elim x.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_Qed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros; discriminate.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nunfold oppZ in |- *; intros; elim x.\n(* neg n *)\nunfold neg at 2 in |- *; rewrite neg_neg; reflexivity.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (opp_discr (opp_discr (opp_discr (opp_discr (opp_discr (inv_discr (inv_discr (inv_discr (inv_discr (inv_intro H)))))))).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (opp_discr (opp_discr (inv_discr (inv_intro H))) (inv_discr (inv_intro H))).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (opp_discr (inv_discr (inv_discr (inv_discr (inv_discr (inv_discr H)))) (inv_discr (inv_discr (inv_discr (inv_discr (inv_intro H))))) (inv_discr (inv_discr (inv_discr (inv_intro H)))) H)).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr (invQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nsimple induction x.\n(* neg n *)\nintros; elim (opp_involutive x).\n(* neg n *)\nintros; elim (opp_involutive x).\n(* pos n *)\nintros; rewrite (tech_opp_neg_pos_pos (pos n) (neg n)) *)\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (neg_involutive (neg n)).\nrewrite (Qed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\nsplit; [ apply opp_involutive | apply opp_involutive | apply opp_involutive | apply opp_involutive | apply opp_involutive ].\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nintros.\nunfold oppZ in |- *; intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros.\nunfold oppZ in |- *.\nrewrite <- opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutiveQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\n intros.\ncase oppZ; intros.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_Qed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nintro; unfold oppZ; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\n",
                "context_tokens": 733,
                "proof_start_offset": 7743,
                "proof_end_offset": 7940,
                "proof": "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nsimple destruct n; intros; reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive 0).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive 0).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)Qed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exactQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nProof.\nintros; reflexivity.\n(* pos n *)\nsimple destruct x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* posQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_neg_negQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* posQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nsimple destruct n; simpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nunfold neg in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nunfoldQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive n).\n(* neg n *)\nintrosQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivityQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nintros; reflexivity.\n(* neg n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 7966,
                "proof_end_offset": 8159,
                "proof": "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintro; reflexivity.\n(* neg n *)\nelim (tech_add_neg_negZ n).\n(* pos n *)\nintro; reflexivity.\n(* pos n *)\nrewrite (tech_add_neg_neg_negZ n).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (opp_involutive (neg n)).\nrewrite (Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* posQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple induction n; intros; reflexivity.\n(* pos n *)\nsimple induction n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros; elim (le_plus_neg_pos_posZ n).\nelim (le_plus_neg_pos_pos_posZ n).\nelim (le_plus_neg_pos_pos_pos_nat n).\nelim (le_plus_neg_pos_nat n).\nelim (le_plus_neg_pos_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_neg_nat n).\nelim (le_plus_negQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity. \n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity. \n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; introsQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (neg n)).\n(* pos n *)Qed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 8185,
                "proof_end_offset": 8340,
                "proof": "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nProof.\nintros; elim (addZ_commutativity (pos n) (neg n)); exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* m *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* I *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_discr_eq (pos n)).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr_eq (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr_eq (pos n)).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr_eq (pos n)).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_discr_eq (pos n)).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (opp_Qed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n; simpl; auto with arith.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintro; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ tidn 0).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ tidn 0).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ tidn 0).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ tidn 0).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ tidn 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ tidn 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ tidn 0).\n(* pos n *)\nsimpl in |- *; symmetry  inQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; reflexivity.\n(* pos n *)\nreflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)Qed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n).\n(* pos n *)\nsimple induction n.\n(* 0 *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ posnP n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_IZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predn m).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_IZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_IZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_IZQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* m *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Jakubiec_add_negZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_negZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_pos_negZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_negZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (predQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n(* m *)\nunfold oppZ in |- *; intros; elim (le_gt_cases 0 n); intro H.\n(* m = 0 *)\nreflexivity.\n(* m = 0 *)\nintro H; rewrite (tech_add_neg_pos_negZ n).\nelim pred_homographicAcc_r; exact H.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivity.\n(* m = 0 *)\nintros; reflexivityQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nProof.\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple destruct n0; intros; reflexivity.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n1.\n(*Qed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n(* 0 *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_Snm_nSm (neg n) (neg n)).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_Snm_nSm (neg n) (neg n)).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_Snm_nSm (neg n) (neg nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nintro; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Zrem_add_neg_posZ n0).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Zminus_plus_neg_posZ n0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Zminus_plus_neg_posZ n0).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Zminus_plus_neg_posZ n0).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Zminus_plus_neg_posZ n0).\n(* pos n *)\nintros; elim (le_or_lt 0 n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_Zminus_plus_neg_posZ n0).\n(* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8366,
                "proof_end_offset": 8577,
                "proof": "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* m *)\nreflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nintros; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nintros; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimplQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* O *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.Qed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_commutativity (pos n) (neg m));\n exact (tech_add_neg_negZ n).\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n; auto with arith.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* n *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* m *)\nreflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimple induction m.\n(* m *)\nreflexivity.\n(* m *)\nsimple induction m.\n(* m *)\nsimple induction m.\n(* m *)\nreflexivity.\n(* m *)\nreflexivity.\n(* m *)\nintros.\nsimpl in |- *; reflexivity.\n(* m *)\nreflexivity.\n(* m *)\nsimple induction m.\n(* m *)\nreflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nreflexivity.\n(* m *)\nintros.\nsimpl in |- *; reflexivity.\n(* m *)\nsimple induction m.\n(* m *)\nreflexivity.\n(* m *)\nintros.\nsimpl in |- *; reflexivity.\n(* m *)\nsimple induction m.\n(* m *)\nreflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nsimpl in |- *; reflexivity.\n(* m *)\nreflexivity.\n(* m *)\nsimple induction m.\n(* m *)\nreflexivity.\n(* m *)\nsimple induction m.\n(* m *)\nreflexivity.\n(* m *)\nreflexivity.\n(*Qed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_negZ n0).\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_negZ n0).\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_negZ n0).\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_negZ n0).\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_neg_posZ n0).\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_negZ n0).\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_negZ n0).\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nintros; elim (tech_add_neg_negZ n0).\n(* 0 *)\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\n(* 0 *)\nintros; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8603,
                "proof_end_offset": 8818,
                "proof": "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nsimple induction n0.\n(* m0 *)\nintros; rewrite (tech_add_pos_negZ n0).\nrewrite (tech_add_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_neg_posZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewrite (tech_add_neg_neg_negZ n0).\nrewriteQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).\n(* pos n0 *)\nsimpl in |- *; symmetry  in |- *; exact (plus_assoc m n0).Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_negZ (pos n) 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_negZ (neg n) 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_negZ (neg n) 0).\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_negZ (neg n) 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_negZ (neg n) 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_negZ (neg n) 0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_tech_add_neg_posZ (neg nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nsimple induction n.\n(* zero *)\nreflexivity.\n(* zero *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintro; elim n.\n(* m *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim (tech_add_neg_negZ n m); exact H.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim (tech_add_neg_negZ n m).\nrewrite <- (neg_add_neg_negZ n m); rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8843,
                "proof_end_offset": 9198,
                "proof": "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nProof.\nrepeat split; trivial.\ncase x.\nreflexivity.\nintros; exact (tech_add_pos_negZ n).\nintros; exact (tech_add_neg_posZ n).\ncase x.\nreflexivity.\nintros; exact (tech_add_neg_posZ n).\nintros; exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; rewrite (tech_opp_negZ (pos n)); rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; intros.\nrewrite (tech_opp_negZ (neg n) (neg n)); rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimple destruct n.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\n(* N *)\nreflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimple destruct 1.\n(* pos n *)\nintros; rewrite (tech_opp_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_negZ (neg n)); rewrite H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimple destruct x.\n(* M *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (oppZ x));\n rewrite H; simpl in |- *; reflexivity.\n(* M *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (oppZ x));\n rewrite H; simpl in |- *; reflexivity.\n(* M *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (oppZ x));\n rewrite H; simpl in |- *; reflexivity.\n(* M *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (oppZ x));\n rewrite H; simpl in |- *; reflexivity.\n(* M *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (oppZ x));\n rewrite H; simpl in |- *; reflexivity.\n(* M *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (oppZ x));\n rewrite H; simpl in |- *; reflexivity.\n(* M *)\nsimpl in |- *; symmetry  in |- *; exact (opp_involutive (oppZ x));\n rewrite H; simpl in |- *; reflexivity.\n(* M *)\nsimpl in |- *; symmetry  in |-Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimpl in |- *; intros; rewrite (tech_add_neg_negZ); rewrite H; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (plus_comm 0 (neg n));\n (* neg n *)\nsimpl inQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivityQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimple destruct 1; simpl in |- *; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)\nsimpl in |- *; rewrite (tech_add_neg_negZ 0); rewrite H; reflexivity.\n(* 0 *)Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_r_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_r_neg_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_r_neg_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_r_neg_posZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_r_neg_posZ n).\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ_negZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_r_neg_negZ n).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_)\u00f7_r_neg_posZ n.\n(* posQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros.\nelim (tech_opp_negZ (neg n)); intro H.\nelim (tech_opp_negZ (neg n)); intro H'.\nelim H'.\n(* pos n0 *)\nreflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nsimpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\n",
                "context_tokens": 741,
                "proof_start_offset": 9217,
                "proof_end_offset": 9379,
                "proof": "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nexact addZ_associativity.\nsplit.\nexact addZ_neutral.\nexact addZ_opposite.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\napply (BUILD_HOM_MODULE (Z:=Z) (x:=Z) (y:=Z) (x:=Z) (y:=Z) (x:=Z) (y:=Z) (y:=Z) (x:=Z) (y:=Z) (y:=Z) (x:=Z) (y:=Z) (y:=Z) (x':=Z) (y:=Z) (y':=Z) (x':=Z) (y':=Z) (y':=Z) (x':=Z) (x':=Z) (x':=Z) (y':=Z) (y':=Z) (x':=Z) (y':=Z) (x':=Z) (y') := x') (x':=Z) (x':=Z) (y':=Z) (x':=Z) (y':=Z) (x':=Z) (y':=Z) (x':=Z) (x':=Z) (x':=Z) (y':=Z) (x':=Z) (x':=Z) (x':=Z) (x':=Z) (x':=Z) (x':=Z) (y':=Z) (x':=Z) (x':=Z) (yQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |-Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group, is_group; intros; reflexivity.\n(* <- *)\ncase x.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; elim (Z_nat_of_P n).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; apply (tech_add_neg_posZ n).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; apply (tech_add_neg_neg_negZ n).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; apply (tech_add_neg_neg_negZ n).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; apply (tech_add_neg_neg_posZ n).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; apply (tech_add_neg_neg_negZ n).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; apply (tech_add_neg_neg_negZ n).\n(* pos n *)\nintros; apply (tech_add_neg_neg_negZ n).\n(* pos n *)\nreflexivity.\n(* pos nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros; elim (tech_add_neg_posZ n).\n(* neg n *)\nsimpl; intros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\napply (is_group (Z_group (Z_to_nat 1)) (Z_to_nat 1)).\n(* 0 -> *)\nauto.\n(* 0 -> *)\nintros; exact (tech_add_neg_posZ 0).\n(* pos n *)\nintros; exact (tech_add_neg_neg_posZ 1).\n(* pos n *)\napply (H (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_div2 (Z_mod_bound (Z_mod_bound (Z_mod_bound (Z_mod_bound (S (S n))) (neg n)))) 0)) (neg n)).\n(* 0 -> *)\nintros; apply H0.\n(* pos n *)\nintros; apply H0.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* pos n *)\nintros; apply H0.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).Qed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group at 1 in |- *; intros.\napply (tech_add_neg_posZ n).\n(* <- *)\nelim (tech_add_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_pos_posZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nelim (tech_add_neg_neg_negZ n).\n(* <- *)\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nintros; elim Z_group; simpl in |- *.\nexact (tech_add_neg_negZ n).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nunfold is_group, is_group, is_group, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.\nintros H H; apply (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_opp (opp_involutive (opp_involutive (opp_opp (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_opp (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_opp (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutiveQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold is_group at 1 in |- *; simpl in |- *.\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <- *)\nintros; reflexivity.\n(* <-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\n",
                "context_tokens": 725,
                "proof_start_offset": 9404,
                "proof_end_offset": 9518,
                "proof": "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nProof.\nsimple destruct x; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; elim x.\n(* 0 *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* 0 *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; apply (tech_add_neg_neg_negZ); trivial.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; rewrite (tech_opp_neg_negZ); trivial.\n(* pos n *)\nintros; rewrite (tech_opp_negQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintro x.\ncut (oppZ x = - oppZ x).\nintro H'.\napply H'.\napply opp_inj_neg_posZ.\napply opp_inj_neg_posZ.\napply opp_inj_neg_posZ.\napply opp_inj_neg_negZ.\napply opp_inj_neg_neg_negZ.\napply opp_inj_neg_negZ.\napply opp_inj_neg_negZ.\napply opp_inj_neg_negZ.\napply opp_inj_neg_negZ.\napply opp_inj_neg_negZ.\napply opp_inj_neg_negZ.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim (tech_opp_negZ x).\nintros; reflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros; reflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros; reflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros; reflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ x).\nintros;Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_opp_negZ x).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nintros; exact (tech_opp_neg_negZ x).\n(* pos n *)\nexact (tech_opp_neg_negZ x).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_neg_negZ).\n(* pos n *)\nexact (tech_opp_neg_neg_negZ).\n(* pos n *)\nexact (tech_oppQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x; simpl in |- *; auto.\nsplit.\nexact egal_eq.\nelim plus_comm.\nrewrite <- H; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_add_neg_negZ x).\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_add_neg_neg_negZ x).\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(*Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; elim x.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim (mult_comm x).\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim (tech_add_neg_negZ x).\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* pos n *)\nintros; discriminate.\n(* posQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintro; elim x.\n(* zero n *)\nintro; elim x.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\n(* 0 *)\nintros; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\nTheorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\n\nsimple destruct x; auto with arith.\nQed.\n\n(*********************)\n",
                "context_tokens": 722,
                "proof_start_offset": 9544,
                "proof_end_offset": 9675,
                "proof": "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintro.\nrewrite (tech_opp_negZ n).\nelim (neg_negZ n).\nrewrite opp_involutive; auto with arith.\nsplit.\nrewrite opp_involutive; auto with arith.\nrewrite opp_involutive; auto with arith.\napply opp_involutive.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nintro n; elim n.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nintros; ring.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nreflexivity.\n(* x *)\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n; auto with arith.\nintros; elim (tech_opp_neg_negZ n).\n(* pos n *)\nintros; elim (tech_opp_neg_negZ n).\n(* pos n *)\nsimpl in |- *; auto with arith.\nsplit.\n(* pos n *)\nintro; elim (tech_opp_neg_neg_posZ n).\n(* pos n *)\nsimpl in |- *; auto with arith.\nsplit.\n(* pos n *)\nintros; elim (tech_opp_neg_neg_negZ n).\n(* pos n *)\nsimpl in |- *; auto with arith.\nsplit.\n(* pos n *)\nsimpl in |- *; auto with arith.\nsplit.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ n).\n(* pos n *)\nsimpl in |- *; auto with arith.\nsplit.\n(* pos n *)\nintros; elim (tech_opp_neg_negZ n).\n(* pos n *)\nsimpl in |- *; auto with arith.\nsplit.\n(* pos n *)\nsimpl in |- *; auto with arith.\nsplit.\n(* pos n *)\nsimpl inQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintro; elim n; auto with arith.\nintros; rewrite <- (tech_opp_negZ n); rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\n",
                "context_tokens": 316,
                "proof_start_offset": 1992,
                "proof_end_offset": 2126,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nsimple induction 1; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros.\nelim H1; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold not in |- *; intros.\napply Trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))).\napply Trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))).\napply Trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))))));\n auto with arith.\napply Trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))).\napply Trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))));\n auto with arith.\napply Trans with (S (S (S (S (S (Qed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply Trans with (M0 := Inv).\napply TransQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold not in |- *; intros.\nelim (classic (P O /\\ forall x : S, In x S -> P x) 0); intros.\nleft; assumption.\nleft; assumption.\nright; assumption.\nright; assumption.\nright; assumption.\nright; assumption.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nsimple induction 1.\nintros. elim H1; intros.\nrewrite H2; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nunfold not in |- *; intros x y z H0; elim H0; auto.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nsimple induction 1; intros; auto with arith.\napply H with (x := x); auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nsimple induction 1.\nintros.\napply E_0_l.\napply E_1_r.\napply E_1_r.\napply E_1_l.\napply E_1_r.\napply E_1_l.\napply E_1_r.\napply E_1_r.\napply E_1_r.\napply E_1_r.\napply E_2_r.\napply E_1_r.\napply E_2_r.\napply E_1_r.\napply E_1_r.\napply E_1_r.\napply E_1_r.\napply E_2_r.\napply E_2_r.\napply E_1_r.\napply E_2_r.\napply E_1_r.\napply E_1_r.\napply E_2_r.\napply E_1_r.\napply E_2_r.\napply E_1_r.\napply E_2_r.\napply E_2_r.\napply E_2_r.\napply E_2_r.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\nLemma neutral_add : neutral S G Add O -> O = Add O O.\n\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\n(********************)\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n(************)\n",
                "context_tokens": 403,
                "proof_start_offset": 2245,
                "proof_end_offset": 2466,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H0; elim H0; intros; elim H0; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nsimple induction x; auto.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nintros x y H H0; elim H0; auto.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nsimple induction x; simpl in |- *; intros.\nauto.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; intros.\nrewrite (H0 y).\nrewrite (H0 y).\nrewrite (H0 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H0 y).\nrewrite (H1 y).\nrewrite (H0 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H0 y).\nrewrite (H1 y).\nrewrite (H0 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H0 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H0 y).\nrewrite (H0 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H1 y).\nrewrite (H0 y).\nrewrite (HQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; elim H1; intros.\nleft; assumption.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H; elim H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\n",
                "context_tokens": 227,
                "proof_start_offset": 1772,
                "proof_end_offset": 2677,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nsimple induction x.\nintros.\nrewrite plus_n_O.\nrewrite <- plus_n_Sm.\nrewrite <- plus_n_Sm.\nrewrite mult_assoc.\napply mult_reg_l with (S x).\nauto with arith.\nauto with arith.\nauto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x x H.\napply mult_O_l.\napply S_O.\napply S_O.\napply S_O.\napply S_O.\napply S_O.\napply S_O.\napply S_O.\napply S_O.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros x x H; elim H; clear H.\nintros x0 H1; elim H1; clear H1.\nintros x1 H2; elim x2; clear x2.\nintros x2 H3; elim x2; clear x2.\nintros x3 H4; elim H4; clear x4.\nintros x4 H5; elim x5; clear x5.\nintros x6 H6; elim x7; clear x6.\nintros x8 H9; elim x8; clear x8.\nintros x9 H9; elim x9; clear x10.\nintros x11 H12; elim x12; clear x11.\nintros x12 H13; elim x12; clear x12.\nintros x13 H14; elim x13; clear x13.\nintros x15 H16; elim x15; clear H14.\nintros x15 H16; elim x15; clear H15.\nintros x15 H16; elim x15; clear x15.\nintros x15 H16; elim x15; clear x15.\nintros x15 H16; elim x15; clear H15.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction x; intros.\nrewrite H0.\nauto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction x.\nintros.\nelim H2.\nintros.\nrewrite H2 in H2.\nrewrite (mult_comm x0).\napply mult_reg_l with (x := S x0).\nrewrite mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_plus_distr_l.\nrewrite mult_assoc.\nrewrite (mult_comm x0).\nrewrite mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite (mult_comm x0).\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <-Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction x.\nintros x0 H.\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewrite (mult_comm x0).\nrewrite (mult_comm x1).\nrewriteQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction 1; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction x; intros.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite <- H2.\nrewrite <- H0.\nrewrite H2.\nrewrite H1.\nrewrite <- H2.\nrewrite H3.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H3.\nring.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x; elim x; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "              *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 576,
                "proof_start_offset": 2697,
                "proof_end_offset": 3436,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros x y H.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros x y H; elim H; intros; rewrite H; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nunfold is_ring in |- *.\nintros x y H; elim H; intros; elim H; intros; elim H1; intros; elim H2; intros.\nrewrite H2; rewrite H1; rewrite H2; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros; apply mult_opp_r.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros.\nclear H H1 H2; intros.\ngeneralize (plus_O_S x y H H2); intro.\nelim (le_or_lt x y H2); intro.\nrewrite H2.\nrewrite H4.\napply (plus_le_compat_l (S n) (S m) (S n) H2).\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plus_minus_r.\napply le_plusQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim mult_inv_l with (x := S) (y := S) (x := y); auto.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nrewrite mult_opp_r.\nrewrite mult_opp_r.\nrewrite mult_opp_r.\nrewrite mult_opp_r.\nrewrite mult_opp_r.\nrewrite (mult_comm (S x) (S y) (S x))).\nrewrite (mult_comm (S x) (S y)).\nrewrite (mult_comm (S y) (S x)).\nrewrite (mult_comm (S x) (S y)).\nrewrite (mult_comm (S x) (S y)).\nrewrite (mult_comm (S x) (S y))).\nrewrite (mult_comm (S x) (S y)).\nrewrite (mult_comm (S y) (S y)).\nrewrite (mult_comm (S x) (S y)).\nrewrite (mult_comm (S y) (S x)).\nrewrite (mult_comm (S y) (S y)).\nrewrite (mult_comm (S x) (S y)).\nrewrite (mult_comm (S y) (S y)).\nrewrite (mult_comm (S x) (S y)).\nrewrite (mult_comm (S y) (S yQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\napply mult_reg_l with x; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\napply mult_reg_l with y; auto with arith.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nelim H1; intros; elim H2; intros.\nelim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H5; intros; elim H5; intros.\nelim H6; intros; elim H6; intros.\nrewrite H8; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\n",
                "context_tokens": 721,
                "proof_start_offset": 3456,
                "proof_end_offset": 4193,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H1; intros; elim H2; intros; \n elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H6; intros; \n clear H6 H7 H8 H9 H10 H11 H12 HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nunfold is_zero in |- *; intros; elim H; auto.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nunfold is_zero in |- *; intros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; \n elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H2; intros.\nrewrite H3; rewrite H1; rewrite H2; ring.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n intros; elim H6; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H12; intros; elim H12; intros; elim H13; \n intros; elim H12; intros; elim H13; intros; elim H14; intros; \n elim H15; intros; elim H16; intros; elim H15; intros; elim H17; \n intros; elim H14; intros; elim H16; intros; elim H17; intros; \n elim H17; intros; elim H18; intros; elim H17; intros; elim H17; \n intros; elim H17; intros; elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elimQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; elim H7; \n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H6; \n intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; \n intros; elim H12; intros; elim H12; intros; \n elim H13; intros; elim H13; intros; elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nunfold is_symmetric in |- *; unfold is_symmetric in |- *; intros x y H.\nelim (mult_O x y H); intros; rewrite H0; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\n",
                "context_tokens": 720,
                "proof_start_offset": 4215,
                "proof_end_offset": 4702,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim H4; intros; elim H5; intros; elim H5; intros.\nrewrite H5; rewrite H6; rewrite H7; reflexivity.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H4; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H6; intros.\nelim H7; intros; elim H7; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H8; intros; \n elim H9; intros; elim H11; intros; elim H11; intros; \n elim H10; intros; elim H12; intros; elim H11; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; \n elim H13; intros; elim H14; intros; \n elim H13; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; \n elim H7; intros; elim H8; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; elimQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nrewrite H4; rewrite H4; auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim (H3 x H2); intros; elim H3; intros; elim H4; intros.\nelim (H4 x H3); intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H10; \n intros; elim H12; intros; elim H13; intros; elim H13; intros; \n elim H15; intros; elim H13; intros; elim H13; intros; \n elim H15; intros; elim H14; intros; elim H15; intros; \n elim H15; intros; elim H15; intros; elim H15; intros; \n elim H15; intros; elim H15; intros; elim H16; intros; elim H17; \n intros; elim H15; intros; elim H17; intros; elim H17; intros; \n elim H17; intros; elim H16; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim (H4 x y H1); intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; \n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H7; \n intros; elim H7; intros; elim H7; intros; elim H6; intros; \n elim H7; intros; elim HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nsimple induction x; simpl in |- *.\nauto.\nauto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; \n intros; elim H2; intros; elim H3; intros; elim H4; intros.\nrewrite H3; rewrite H4; rewrite H1; reflexivity.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros.\nelim H1; intros; elim H2; intros.\nrewrite H1; rewrite H2; rewrite H2; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\n",
                "context_tokens": 742,
                "proof_start_offset": 5096,
                "proof_end_offset": 5330,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *.\nintros.\nelim (le_gt_dec O O).\nintro.\nelim (le_gt_dec O O).\nintro.\napply le_antisym.\napply lt_le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.\napply le_trans with (m := S n); auto with arith.Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; \n clear H4 H5; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H5 H6; elim H5; intros; elim H5; intros; elim H6; intros; \n clear H5 H6; elim H6; intros; elim H6; intros; elim H6; intros; \n clear H6 H7; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n clear H6 H6; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n clear H6 H7; elim H6; intros; \n elim H6Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H3; intros; \n elim H4; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n clear H6 H7 H8 H9 H10 H11 H12 H12 H13 H14 H15 H16 H17 H17 H18 H19.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *.\nintros a b H' H'0 H'1.\nelim (le_or_lt O O).\nintros H'2 H'3; elim H'3; intros; elim H'3; intros; elim H'3; intros;\n elim H'3; intros; elim H'4; intros; elim H'5; intros; elim H'6;\n intros; elim H'6; intros; elim H'6; intros; elim H'6; intros;\n elim H'6; intros; elim H'7; intros; elim H'7; intros;\n elim H'8; intros; elim H'8; intros; elim H'8; intros; elim H'8; \n intros; elim H'8; intros; elim H'8; intros; elim H'8; \n intros; elim H'8; intros; elim H'8; intros; elim H'8; intros; \n elim H'8; intros; elim H'9; intros; elim H'8; intros; elim H'9; \n intros; elim H'9; intros; elim H'9; intros; elim H'Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *.\nunfold divide in |- *.\nintros a b H.\nelim (le_or_lt 0 a); intro.\nrewrite H0.\nrewrite <- (mult_n_O a b H).\nrewrite <- (mult_n_O a b H).\nrewrite <- (mult_n_O a b H).\nrewrite <- (mult_n_O a b H).\nrewrite (mult_n_O a b H).\nrewrite <- (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O b H).\nrewrite (mult_n_O bQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros; apply le_antisym; apply lt_O_Sn.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_zero_ary in |- *; simpl in |- *.\nintros.\ninversion H0.\ninversion H1.\ninversion H2.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H2.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H6.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H6.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros a b H H'0; elim H'0; intros; elim H'0; intros; elim H'1; intros; elim H'1;\n intros; elim H'2; intros; elim H'2; intros; elim H'2; intros;\n elim H'2; intros; elim H'3; intros; elim H'3; intros; \n elim H'4; intros; elim H'5; intros; elim H'5; intros; \n elim H'5; intros; elim H'6; intros; elim H'6; intros; \n elim H'6; intros; elim H'6; intros; elim H'6; \n intros; elim H'6; intros; elim H'7; intros; elim H'7; intros; \n elim H'8; intros; elim H'7; intros; elim H'6; \n intros; elim H'8; intros; elim H'7; intros; \n elim H'8; intros; elim H'8; intros; \n elim H'8; intros; elim H'8; intros; elim H'8; intros; \n elim H'8; intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": ".\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 5349,
                "proof_end_offset": 6556,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H; intros; elim H0; intros; elim H2; intros; elim H3; intros.\nelim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros.\nsplit. exact H6.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit. exact H9.\nsplit.Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H6; intros; \n intros; elim H7; intros; elim H6; intros; elim H7; \n intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H7; intros; elim H6; intros; elim H7; \n intros; elim H7; intros; elim H7; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H6; \n intros; elim H8; intros; elim H8; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim HQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\napply mod_unique with (b := a); auto with *.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nelim (div_plus_or _ _ _ H); intros.\nsplit.\nexact (div_plus_or _ _ _ H H1).\nsplit.\nexact (div_plus_or _ _ _ H0).\nsplit.\nexact (div_plus_or _ _ _ H1).\nsplit.\nexact (div_plus_or _ _ _ H).\nsplit.\nexact (div_plus_or _ _ _ H1).\nsplit.\nexact (div_plus_or _ _ _ H1).\nsplit.\nexact (div_plus_or _ _ _ H2).\nsplit.\nexact (div_plus_or _ _ _ H2).\nsplit.\nexact (div_plus_or _ _ _ H1).\nsplit.\nexact (div_plus_or _ _ _ H1).\nsplit.\nexact (div_plus_or _ _ _ H0).\nsplit.\nexact (div_plus_or _ _ _ H0).\nsplit.\nexact (div_plus_or _ _ _ H1).\nsplit.\nexact (div_plus_or _ _ _Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H; intros.\nelim H0; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; elim H7; \n intros; elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H7; intros; elim HQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H1; intros.\nsplit. exact H2.\nsplit. exact H3.\nsplit. exact H1.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exact H3.\nsplit. exactQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H11.\nsplit. exact H11.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10.\nsplit. exact H10Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; elim H10; \n intros; elim H9; intros; elim H11; intros; \n elim H12; intros; elim H12; intros; elim H13; intros; \n elim H13; intros; elim H13; intros; elim H13; intros; \n elim H14; intros; elim H14; intros; elim H14; intros; \n elim H13; intros; elim H14; intros; elim H14; intros; \n elim H15; intros; elim H14; intros; \n elim H14; intros; elimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0; elim H; intros; elim H0; intros; elim H1; intros.\nelim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\n\n\nunfold divide in |- *; intros.\nsplit.\n(* A d *)\nelim H0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 727,
                "proof_start_offset": 6576,
                "proof_end_offset": 7261,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1; elim H0; intros; elim H1; intros.\nsplit.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H.\nrewrite H2.\nrewrite H0.\nrewrite H.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H0.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H0.\nrewrite H3.\nrewrite H2.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H2.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H0.\nrewrite H2.\nring.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H12; intros.\nelim H10; intros.\nelim H12; intros.\nelim H12; intros.\nelim H14; intros.\nelim H14; intros.\nelim H15; intros.\nelim H15; intros.\nelim H13; intros.\nelim H15; intros.\nelim H14; intros.\nelim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H1; intros.\nelim (H1 b H2); intros.\nelim (H3 b H4); intros.\nelim (H1 b H4); intros.\nelim (H0 b H4); intros.\nelim (H1 b H4); intros.\nelim (H4 b H5); intros.\nelim (H5 b H6); intros.\nelim (H6 b H6); intros.\nelim (H7 b H7); intros.\nelim (H7 b H7); intros.\nelim (H8 b H8); intros.\nelim (H8 b H9); intros.\nelim (H10 b H9); intros.\nelim (H10 b H9); intros.\nelim (H11 b H11); intros.\nelim (H10 b H11); intros.\nelim (H11 b H12); intros.\nelim (H10 b H11); intros.\nelim (H11 b H12); intros.\nelim (H12 b H13); intros.\nelim (H12 b H13Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult_strong.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult_strong.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros.\ncase H; intros.\nrewrite <- (H0 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H0 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H2 b).\nrewrite (H0 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H0 b).\nrewrite (H2 b).\nrewrite (H0 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H2 b).\nrewrite (H2 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H2 b).\nrewrite (H2 b).\nrewrite (H2 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H1 b).\nrewrite (H2 b).\nrewrite (H2 b).\nrewrite (H1 b).\nrewrite (H1Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nsplit.\nexact H2.\nelim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0 H1 H2; elim H1; intros.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult.\napply mod_mult_compat.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.\napply mod_mult_l.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H0 H1; elim H0; intros; elim H1; intros; elim H2; intros.\nrewrite H0.\nelim (H0 (le_S_n _ _ H1)).\nrewrite <- (plus_n_O _ _ H2).\nrewrite <- (plus_n_O _ _ H1).\nrewrite <- (plus_n_O _ _ H2).\nrewrite <- (plus_n_O _ _ H2).\nrewrite (plus_n_O _ _ H1).\nrewrite (plus_n_O _ _ H2).\nrewrite (plus_n_O _ _ H2).\nrewrite (plus_n_O _ _ H2).\nrewrite (plus_n_O _ _ H1).\nrewrite (plus_n_O _ _ H3).\nrewrite (plus_n_O _ _ H2).\nrewrite (plus_n_O _ _ H2).\nrewrite (plus_n_O _ _ H1).\nrewrite (plus_n_O _ _ H2).\nrewrite (plus_n_O _ _ H2).\nrewrite (plus_Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H.\nelim H; intros; elim H; intros; elim H; intros.\nelim H1; intros; elim H2; intros; elim H3; intros.\nelim H4; intros; elim H4; intros.\nelim (H5 H6); intros.\nelim (H6 H7); intros.\nelim (H7 H7); intros.\nelim (H6 H7); intros.\nelim (H7 H8); intros.\nelim (H8 H9); intros.\nelim (H10 H8); intros.\nelim (H9 H9); intros.\nelim (H10 H9); intros.\nelim (H10 H10); intros.\nelim (H10 H11); intros.\nelim (H10 H11); intros.\nelim (H12 H10); intros.\nelim (H11 H12); intros.\nelim (H12 H13); intros.\nelim (H13 H14); intros.\nelim (H13 H15); intros.\nelim (H14 H15); intros.\nelim (H13 H14); intros.\nelim (H15 H14); intros.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim (H0 d H1); intros.\nrewrite H2.\nelim (H3 (inv_inv_inv_inv a b)); intros.\nrewrite H3.\nelim (H4 (inv_inv_inv_inv a b)); intros.\nrewrite H4.\nelim (H5 (inv_inv_inv_inv a b)); intros.\nrewrite H4.\nelim (H2 (inv_inv_inv_inv a b)); intros.\nrewrite H4.\nelim (H5 (inv_inv_inv_inv_inv a b)); intros.\nrewrite H4.\nelim (H6 (inv_inv_inv_inv a b)); intros.\nrewrite H4.\nelim (H6 (inv_inv_inv_inv a b)); intros.\nrewrite H4.\nelim (H2 (inv_inv_inv_inv a b)); intros.\nrewrite H4.\nelim (H6 (inv_inv_inv_inv a b)); introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 732,
                "proof_start_offset": 7280,
                "proof_end_offset": 8081,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros a d H H0.\ncase (le_gt_dec a d); intros.\nrewrite <- H0.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\napply div_opp.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold divide in |- *; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nelim H; intros.\n(* A d *)\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold is_ring in |- *; intros.\n(* A d *)\nelim H; intros.\nelim H1; intros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nrewrite H4.\nelim H2; intros.\nelim H1; intros.\nrewrite H4.\nelim (H2 (S d)).\nelim H1; intros.\nrewrite H4.\nelim (H0 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H1 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (H2 (S d)).\nelim (Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* A d *)\nelim H; intros.\nrewrite <- (div_mod a d H H0).\nrewrite <- (div_mod a d H0).\nrewrite <- (div_mod a d H0).\nrewrite <- (div_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (div_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (div_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (mod_mod a d H0).\nrewrite <- (modQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros.\nrewrite <- (abs_inv _ _ _ H0).\napply divide_opp_l.\napply divide_opp_l.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold divide in |- *; intros.\nrewrite (div_mult a d).\nrewrite <- (mult_comm (a*d)).\nrewrite <- (mult_comm (a*d)).\nrewrite (mult_comm (a*d)).\nrewrite <- (mult_assoc a d).\nrewrite <- (mult_comm (a*d)).\nrewrite (mult_comm a d).\nrewrite <- (mult_assoc b d).\nrewrite <- (mult_assoc b d).\nrewrite (mult_comm (a*d)).\nrewrite (mult_comm b d).\nrewrite <- (mult_assoc a d).\nrewrite <- (mult_assoc b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm d).\nrewrite (mult_comm (b*d)).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm d).\nrewrite (mult_comm (b*d)).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm d).\nrewrite (mult_comm d).\nrewrite (mult_Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros; apply div_opp.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\napply div_opp_l.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply oppQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold divide in |- *; intros.\ncase (Rle_or_lt a 0).\n(* a <> 0 *)\nintros.\nrewrite <- H.\nelim (mult_O_O (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S N)))))))))) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))))))))).\napply div_add.\napply lt_le_trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros.\nunfold divide in |- *.\nelim H; intros.\nrewrite <- H0.\napply divide_opp_l.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divide_opp_r.\napply divideQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8240,
                "proof_end_offset": 8608,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\n intros.\n case (gcd_eq_bool a b O); auto.\n intros; elim H; intros.\nelim (gcd_eq_bool a b O); auto.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nsimple induction 1; intros.\nelim (gcd_0_l a b H0); intros; elim H; intros.\nelim (gcd_0_l b b H1); intros.\nexists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))))))))))\n    with\n    (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S S))))))))))))))))))\n    (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))))\n       (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\n intros a b H.\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (div_mod a b H).\n rewrite <- (divQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H0.\nelim H0; intros; elim H0; intros.\nsplit.\nexact H1.\nelim H1; intros; elim H2; intros.\nsplit.\nexact H3.\nelim H3; intros; elim H3; intros.\nsplit.\nexact H3.\nelim H3; intros; elim H3; intros.\nsplit.\nexact H5.\nelim H3; intros; elim H5; intros.\nsplit.\nexact H5.\nelim H5; intros; elim H5; intros.\nsplit.\nexact H5.\nelim H5; intros.\nsplit.\nexact H5.\nelim H5; intros.\nsplit.\nexact H5.\nelim H5; intros.\nsplit.\nexact H6.\nelim H5; intros.\nsplit.\nexact H5.\nelim H5; intros.\nsplit.\nexact H5.\nelim H5; intros.\nsplit.\nexact H6.\nelim H5; intros.\nsplit.\nexact H5.\nelim H5; intros.\nsplit.\nexact H5Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\napply gcd_intro; intros.\nrewrite H.\nrewrite <- (mult_0_r a b).\nrewrite <- (mult_0_l b).\nrewrite <- (mult_0_r b).\nrewrite <- (mult_0_r b).\nrewrite <- (mult_assoc b b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (multQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nelim H.\nintros.\nsplit.\nexact (H0 H).\nintros.\nsplit.\nexact (H1 H0).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nsimple induction a; intros; elim H; intros.\nelim (divide_0_l a b H0).\nelim (divide_0_l a b H0 H1).\nelim (divide_0_l a b H0 H1).\nelim (divide_0_l a b H1 H1).\nelim (divide_0_r a b H1 H2).\nelim (divide_0_r b b H2).\nelim (divide_0_l b b H1 H2).\nelim (divide_0_r b H2).\nelim (divide_0_l b H2 H2).\nelim (divide_0_r b H1 H2).\nelim (divide_0_r b H2).\nelim (divide_0_l b H2).\nelim (divide_0_r b H1 H2).\nelim (divide_0_l b H2).\nelim (divide_0_r b H2 H2).\nelim (divide_0_r b H2).\nelim (divide_0_l b H2).\nelim (divide_0_r b H1 HQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H0.\nelim (gcd_opp_r a b); intros.\nrewrite H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite H0.\nrewrite H0.\nrewrite <- H1.\nrewrite H0.\nrewrite H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite H0.\nrewrite <- H1.\nrewrite H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold gcd in |- *; intros.\nelim (is_gcd a b); intros.\nelim (is_gcd a b); intros.\nelim (is_gcd a b); intros.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite H1; assumption.\nelim (is_gcd a b); intros.\nrewrite HQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\n intros a b H.\n case (gcd_eq_bool a b); intros.\n rewrite H.\n rewrite <- H.\n rewrite (divide_0_r a b).\n rewrite (divide_0_r a b).\n rewrite (divide_0_r a b).\n rewrite (divide_0_l a b).\n rewrite (divide_0_r b).\n rewrite (divide_0_r a b).\n rewrite (divide_0_r b).\n rewrite (divide_0_r b).\n rewrite (divide_0_r a b).\n rewrite (divide_0_r b).\n rewrite (divide_1_r a).\n rewrite (divide_1_r b).\n rewrite (divide_1_r b).\n rewrite (divide_1_r b).\n rewrite (divide_0_r b).\n rewrite (divide_1_r b).\n rewrite (divide_1_r b).\n rewrite (divide_1_r b).\n rewrite (divide_1_r b).\n rewrite (divide_1_r b).\n rewrite (divide_1_r b).\n rewrite (divide_1_r bQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8628,
                "proof_end_offset": 8894,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros.\nelim (H0 d H1).\nelim (H0 d H1).\nelim (H0 d H1).\nelim (H0 d H1).\nelim (H2 d H2).\nelim (H0 d H1).\nelim (H0 d H1).\nelim (H1 d H2).\nelim (H1 d H2).\nelim (H2 d H2).\nelim (H0 d H2).\nelim (H1 d H2).\nelim (H2 d H1).\nelim (H2 d H2).\nelim (H2 d H0).\nelim (H2 d H1).\nelim (H1 d H2).\nelim (H2 d H2).\nelim (H4 d H2).\nelim (H4 d H2).\nelim (H4 d H1).\nelim (H5 d H3).\nelim (H2 d H3).\nelim (H0 d H4).\nelim (H2 d H4).\nelim (H4 d HQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\n unfold is_gcd in |- *; intros.\n elim H; intros; elim H; intros.\n elim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H1 (S x)); intros.\nsplit.\n exact (H0 x).\n exact (H x).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintro.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros.\nelim H; intros.\nelim (H1 (S x)); intros.\nelim (H1 (S x)); intros.\nelim (H2 (S x)); intros.\nelim (H2 (S x)); intros.\nelim (H4 (S x)); intros.\nelim H4; intros.\nelim (H1 (S x)); intros.\nelim H6; intros.\nelim (H4 (S x)); intros.\nelim (H6 (S x)); intros.\nelim H6; intros.\nelim H6; intros.\nelim (H6 (S x)); intros.\nelim H6; intros.\nelim H6; intros.\nelim (H6 (S x)); intros.\nelim (H7 (S x)); intros.\nelim H6; intros.\nelim (H7 (S x)); intros.\nelim H7; intros.\nelim H8; intros.\nelim (H9 (S x)); intros.\nelim H7; intros.\nelim H7; intros.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros; elim H; intros; elim H; intros.\nelim H; intros.\nelim (le_not_lt 0 n); intros.\nelim H1; intros.\nelim (H1 n H1); intros.\nsplit.\n exact (H2 n H2).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros.\nelim (H0 d).\nelim (H0 d).\nelim (H0 d).\nelim (H0 d).\nelim (H0 d).\nelim (H1 d).\nelim (H0 d).\nelim (H0 d).\nelim (H0 d).\nelim (H1 d).\nelim (H0 d).\nelim (H0 d).\nelim (H1 d).\nelim (H2 d).\nelim (H1 d).\nelim (H0 d).\nelim (H0 d).\nelim (H2 d).\nelim (H1 d).\nelim (H2 d).\nelim (H4 d).\nelim (H2 d).\nelim (H0 d).\nelim (H2 d).\nelim (H0 d).\nelim (H1 d).\nelim (H0 d).\nelim (H0 d).\nelim (H1 d).\nelim (H2 d).\nelim (H1 d).\nelim (H4 d).\nelim (H1 d).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim (H6 x0 H6).\nelim H5; intros.\nelim (H7 x0 H6).\nelim (H7 x0 H5).\nelim (H7 x0 H5).\nelim (H7 x0 H5).\nelim (H7 x0 H6).\nelim (H7 x0 H7).\nelim (H8 x0 H6).\nelim (H7 x0 H8).\nelim (H8 x0 H6).\nelim (H8 x0 H8).\nelim (H8 x0 H8).\nelim (H8 x0 H9).\nelim (H8 x0 H9).\nelim (H9 x0 H9).\nelim (H10 x).\nelim (H9 x0 H9).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\n unfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim (H0 _ H); intros.\nelim (H0 _ H1); intros.\nelim (H1 _ H2); intros.\nsplit.\nexact (H0 _ H0).\nelim (H2 _ H1); intros.\nsplit.\nexact (H1 _ H2).\nelim (H2 _ H1); intros.\nsplit.\nexact (H _ _ H3).\nelim (H2 _ H2); intros.\nsplit.\nexact (H _ _ H4).\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim (H4 x H2).\nintros.\nelim (H4 x H2).\nintros.\nelim (H4 x H2).\nintros.\nelim (H5 y H2).\nintros.\nelim (H5 y H2).\nintros.\nelim (H5 y H3).\nintros.\nelim (H5 y H4).\nintros.\nelim (H6 y H3).\nintros.\nelim (H7 y H6).\nintros.\nelim (H6 y H5).\nintros.\nelim (H6 y H5).\nintros.\nelim (H6 y H6).\nintros.\nelim (H6 y H6).\nintros.\nelim (H6 y H5).\nintros.\nelim (H6 y H6).\nintros.\nelim (H6 y H7).\nintros.\nelim (H7 y H6).\nintros.\nelim (H7 y H5).\nintros.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros.\nelim (gcd_0_l _ _ H1); intros.\nelim (H0 q); intros.\nexists q.\nexists (S q).\nsplit.\napply H1.\napply H.\napply divide_trans with (1 := H1).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H1).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H5).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1 := H4).\napply divide_trans with (1Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m); intros.\nelim (gcd_not_gcd n m);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\n",
                "context_tokens": 711,
                "proof_start_offset": 8928,
                "proof_end_offset": 9827,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nunfold not in |- *; intros.\nelim H; intros.\nelim (H0 a); intros.\nelim (H0 b H); intros.\nelim (H0 a H0); intros.\nelim (H0 b H1); intros.\nelim (H1 b H2); intros.\nrewrite H2; rewrite H3; reflexivity.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\ngeneralize H1; elim H1; intros; elim H1; intros.\nelim (H2 O (div_O_O H1)); intros; elim H2; intros.\nrewrite H3; rewrite H1; rewrite H2; reflexivity.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nsimple induction a.\nintros.\nelim (H0 O (div_S_O a x H2)); intros.\nelim (H0 O (div_S_O a x H2)).\nelim H2; intros; elim H3; intros.\nelim (H2 (div_S_O a x H2)).\nelim H2; intros.\nrewrite H5; rewrite H6; reflexivity.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I. \n\nintros.\napply eq_ind.\napply H0; apply H1; apply H1; apply H1; trivial.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nsimple induction a; simpl in |- *; intros.\nelim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim (H0 (pred (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S S)))))))))))))))))))).\nintros.\nelim H1; intros.\nrewrite H2.\nrewrite (plus_comm (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S S)))))))))))))))))) H2Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nelim H0; intros; elim H1; intros.\nelim (H2 (S O) (S (S (pred O))); intros; elim H2; intros; elim H2; intros.\nelim (H4 (S (pred O))); intros; elim H4; intros; elim H5; intros; elim H6;\n intros; elim H6; intros.\nelim (H6 (S (pred O))); intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros.\nelim (H8 (S (pred O))); intros; elim H6; intros; elim H7; intros; elim H6; \n intros; elim H6; intros.\nelim (H8 (S (pred O))); intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros;Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros a x H0 H1 H2 H3; apply H1; rewrite <- H2; assumption.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H0; intros.\nelim (H1 a H1); intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nelim H6; intros.\nexists x0.\nelim H6; intros.\nrewrite H6; rewrite H7; reflexivity.\nelim H6; intros.\nexists x1.\nelim H7; intros.\nrewrite H8; rewrite H8; reflexivity.\n\nelim H8; intros.\nexists x2.\nelim H8; intros.\nelim H9; intros.\nrewrite H9; rewrite H9; reflexivity.\n\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nexists x0.\nelim H10; intros.\nelim H10; intros.\nrewrite H10; rewrite H10; reflexivity.\n\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nrewrite H10; rewrite H10; reflexivity.\n\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nsimple induction a; intros.\nelim H0; intros; elim H1; intros.\nelim (H1 (A:=A)).\nintros; elim H2; intros.\nelim H2; intros.\nelim (H2 (A:=A)).\nintros; elim H3; intros.\nelim H3; intros.\nelim (H4 (A:=A)).\nintros; elim H5; intros.\nelim (H5 (A:=A)).\nintros; elim H6; intros.\nelim (H6 (A:=A)).\nintros; elim H6; intros.\nelim (H6 (A:=A)).\nintros; elim H6; intros.\nelim (H6 (A:=A)).\nintros; elim H6; intros.\nelim (H7 (A:=A)).\nintros; elim H6; intros.\nelim (H7 (A:=A)).\nintros; elim H6; intros.\nelim (H7 (A:=A)).\nintros; elim H6; intros.\nelim (H8 (A:=A)).\nintros; elim H6; intros.\nelim (H7 (A:=A)).\nintros;Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nelim H; intros.\nelim H; intros.\nelim (H (A:=fun a : S => a + S a)%nat (S x)).\nelim H0; intros.\nrewrite H1; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\n\n\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\n",
                "context_tokens": 684,
                "proof_start_offset": 9908,
                "proof_end_offset": 11305,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H; intros; elim H0; intros.\nelim (H2 (S x)); intros.\nelim (H0 (S x)); intros.\nelim H1; intros; elim H2; intros.\nelim H3; intros.\nelim (H4 (S x)); intros.\nelim H5; intros.\nelim (H6 (S x)); intros.\nelim H6; intros.\nelim H6; intros.\nelim (H7 (S x)); intros.\nelim H6; intros.\nelim H7; intros.\nelim (H6 (S x)); intros.\nelim H6; intros.\nelim (H7 (S x)); intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim (H6 (SQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros.\nelim (H0 b); intros.\nelim (H0 b); intros.\nelim H1; intros.\nelim (H b); intros.\nelim (H b); intros.\nrewrite <- H1; rewrite <- H2; rewrite <- H0; rewrite <- H1; auto.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_power in |- *.\nintros.\nelim H; intros.\nelim (H (S (S (S n0))) x).\nelim x; elim x.\n elim x0; simpl in |- *; intros; elim H2; intros.\nelim (H0 x0 H2).\nelim (H0 x1).\nelim (H2 (S (S n0)) x2).\nelim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H1; intros.\nelim (H2 n (le_O_Sn n)); intros; elim H2; intros.\nelim (H2 n (le_O_Sn n)); intros; elim H2; intros; elim H3; intros; elim H5;\n intros.\nelim (le_O_Sn n); intros; elim H5; intros.\nelim (le_O_Sn n); intros; elim H5; intros.\nelim (le_O_Sn n); intros; elim H6; intros.\nelim (le_O_Sn n); intros; elim H6; intros.\nrewrite H5; rewrite H6.\nelim (le_O_Sn n); intros; elim H6; intros.\nrewrite H6; rewrite H6.\nrewrite <- (plus_n_O n); simpl in |- *; auto with arith.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\napply gcd_unique with (2 := H).\napply gcd_trans with (2 := H0).\napply gcd_trans with (2 := H1).\napply gcd_trans with (2 := H1).\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_symQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H0; intros; elim H0; intros.\nelim H1; intros; elim H2; intros.\nelim H2; intros.\nelim H4; intros.\nelim (H3 (H4 a0)); intros.\nelim (H4 (H2 b0)); intros.\nelim H4; intros.\nelim (H5 (H6 b0)); intros.\nelim (H6 b0); intros.\nelim (H6 b0); intros.\nelim (H6 b0); intros.\nelim (H6 b0); intros.\nrewrite H6.\nelim (H7 b0); intros.\nelim (H8 b0); intros.\nelim (H8 b0); intros.\nrewrite H8.\nelim (H7 b0); intros.\nelim (H8 b0); intros.\nelim (H8 b0); intros.\nelim (H8 b0); intros.\nelim (H8 b0); intros.\nrewrite H8.\nelim (H8 b0); intros.\nelim (H7 b0); intros.\nelim (H9 b0); introsQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim (H3 b d1 H4).\nelim (H4 b d2 H4).\nelim (H4 b d2 H4).\nelim (H5 b d2 H4).\nelim (H5 b d2 H4 H5).\nelim (H5 b d2 H4).\nelim (H5 b d2 H4).\nelim (H6 b d2 H5).\nelim (H6 b d2 H6).\nelim (H6 b d2 H4).\nelim (H6 b d2 H5).\nelim (H6 b d2 H4).\nelim (H6 b d2 H5).\nelim (H6 b d2 H5).\nelim (H6 b d2 H4).\nelim (H7 b d2 H5).\nelim (H6 b d2 H5).\nelim (H7 b d2 H5).\nelim (H7 b d2 H6).\nelim (H6 b d2 H6).\nelim (H7 b d2 H7).\nelim (H7Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H1; intros.\nelim (H2 n (div_O_O H1)); intros; elim H3; intros.\nelim (H3 n (div_O_O H1)); intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H7; intros.\nelim (H8 n (div_S_O H1)); intros; elim H8; intros; elim H8; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H8; \n intros; elim H9; intros; elim H10; intros; elim H11; \n intros; elim H11; intros; elim H11; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H13; intros; elim H14; intros; \n elim H14; intros; elim H14; intros; elim H15; intros; elim H17; \n intros; elim H16Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros.\nelim (H0 H0).\nelim (H0 H).\nelim (H2 (H2 a0)).\nelim (H0 (H1 a0)).\nelim (H0 (H2 a0)).\nelim (H2 H2).\nelim (H3 (H0 a0)).\nelim (H0 H1).\nelim (H2 H0).\nelim (H2 H1).\nelim (H1 H2).\nelim (H1 H2).\nelim (H3 H2).\nelim (H0 H3).\nelim (H1 H3).\nelim (H3 H0).\nelim (H2 H2).\nelim (H0 H3).\nelim (H1 H3).\nelim (H1 H4).\nelim (H3 H3).\nelim (H4 H3).\nelim (H1 H2).\nelim (H4 H5).\nelim (H5 H3).\nelim (H6 H3).\nelim (H1 H3).\nelim (H4 H5).\nelim (H6 H6).\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros.\nelim (H1 x H2); intros.\nelim (H2 x H3); intros.\nelim H4; intros.\nelim (H4 x H4).\nrewrite (H6 x H4).\nrewrite (H8 x).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H9 y).\nrewrite (H8 y).\nrewrite (H9 y).\nrewrite (H9 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H8 y).\nrewrite (H9 y).\nrewrite (H9 y).\nrewrite (HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\n\n\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* d2 = O *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* d2 <> 0 *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* d1 <> 0 *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n(**********)\n",
                "context_tokens": 731,
                "proof_start_offset": 11320,
                "proof_end_offset": 11524,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros; rewrite opp_O; auto.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nsimple induction x.\nintros.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H2.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H3.\nrewrite H0.\nrewrite H3.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H0.\nrewrite H1.\nrewrite H3.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H0.\nrewrite H1.\nrewrite H1Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; auto.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H; intros; elim H1; intros.\nelim H2; intros; elim H3; intros; elim H4; intros.\nelim (H3 x0 H4); intros.\nexists x1; split.\n apply (opp_O_eq x0 x1 H4); auto.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nsimple induction x.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros.\nsplit.\nelim (H x0); intros.\nsplit.\nelim H4; intros.\nrewrite H5; rewrite H5; auto.\napply in_or_rev with x0; auto.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros; elim x; intros.\nelim H; intros; elim H0; intros; elim H1; intros.\nelim H2; intros.\nelim (H2 x H2).\nelim (H3 x H4).\nelim (H0 x H4).\nelim (H2 x H5).\nelim (H0 x H4).\nelim (H2 x H6).\nelim (H3 x H5).\nelim (H0 x H6).\nelim (H1 x H6).\nelim (H0 x H6).\nelim (H0 x H6).\nelim (H0 x H6).\nelim (H0 x H6).\nelim (H0 x H7).\nelim (H1 x H6).\nelim (H2 x H7).\nelim (H7 x0 H7).\nelim (H1 x H6).\nelim (H2 x H7).\nelim (H0 x H6).\nelim (H0 x H7).\nelim (H0 x H7).\nelim (H0 x H7).\nelim (H2 x H7).\nelim (Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H11; intros.\nelim H10; intros.\nelim H11; intros.\nelim H11; intros.\nelim H10; intros.\nelim H12; intros.\nelim H12; intros.\nelim H11; intros.\nelim H12; intros.\nelim H13; intros.\nelim H11; intros.\nelim H13; intros.\nelim H12Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1;\n intros; elim H2; intros.\nelim H3; intros; elim H4; intros; elim H4; intros.\nelim (H4 (S x) (S x) H4)); intros; elim H5; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim (H6 (S x) (S x) H6); intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros.\nelim (H6 (S x) (S x) H6); intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H6; intros.\nelim (H6 (S x) (S x) H6); intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros.\nelim (H6 (S x) (S x) H6);Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nsimple induction x; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H0; simpl in |- *; intros; elim H1; intros.\nelim (H x0); intros.\nexists x1.\nelim (H x0); intros.\nsplit; [ right; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ right; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ left; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ right; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ left; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ left; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ left; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ right; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ left; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ right; reflexivity | assumption ].\nelim (H x0); intros.\nsplit; [ rightQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros.\nelim (H H1); intros; elim H2; intros.\nelim (H H2); intros.\nelim (H2 (S x)); intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim (H4 (S x)); intros; elim H5; intros; elim H5; intros.\nelim (H5 (S x)); intros; elim H5; intros.\nrewrite H6; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zdiv.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zdiv.v                                  *)\n(****************************************************************************)\nRequire Export Zbase.\nRequire Export Zadd.\nRequire Export Zmult.\nRequire Export Zle.\nRequire Export Euclid.\n\nUnset Standard Proposition Elimination Names.\n\n(********************)\nDefinition is_diveuclZ (a b q r : Z) :=\n  b <> OZ /\\ leZ OZ r /\\ ltZ r (absZ b) /\\ a = addZ (multZ b q) r.\n\n(***************************)\nInductive diveuclZ (a b : Z) : Set :=\n    divexZ : forall q r : Z, is_diveuclZ a b q r -> diveuclZ a b.\n\n(************************)\n",
                "context_tokens": 234,
                "proof_start_offset": 1632,
                "proof_end_offset": 3661,
                "proof": "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nintros a b; case b; intros.\nelim H; reflexivity.\ncase a; intros.\napply (divexZ OZ (pos n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (pos n)).\nreflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)).\nintros.\napply (divexZ (pos n0) (pos n) (posOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r).\nexact (gt_S_le r n g).\nexact (tech_div1 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (pos n) (negOZ q) OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (pos n) (negOZ q))).\napply (tech_div2 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (pos n) (neg q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div3 n0 n q r e g).\ncase a; intros.\napply (divexZ OZ (neg n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (neg n)); reflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\napply (divexZ (pos n0) (neg n) (negOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r); exact (gt_S_le r n g).\nexact (tech_div4 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (neg n) (posOZ q) OZ).\nunfold is_diveuclZ in |- *.\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (neg n) (posOZ q))).\napply (tech_div5 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (neg n) (pos q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div6 n0 n q r e g).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a; simple induction b; simpl in |- *; intros.\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\n(* a = b *)\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a; auto with arith.\nintros.\nelim H1; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction 1; intros; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a; simple induction 1; intros; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a; simple induction b; intros.\nelim H1; intros.\nelim H0; intros.\nelim H1; intros.\napply H; assumption.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a; intros.\n(* divex *)\nsimpl in |- *; auto with arith.\n(* divex *)\nsimpl in |- *; auto with arith.\n(* divey *)\nintros x y z; elim z; intros.\n(* divey *)\nsimpl in |- *; auto with arith.\n(* divey *)\nsimpl in |- *; auto with arith.\n(* divey *)\nintros x y z; elim z; intros.\n(* divey *)\nsimpl in |- *; auto with arith.\n(* divey *)\nintros x y z; elim z; intros.\n(* divey *)\nsimpl in |- *; auto with arith.\n(* divey *)\nintros x y z; elim z; intros.\n(* divey *)\nsimpl in |- *; auto with arith.\n(* divey *)\nintros x y z; elim z; intros.\n(* divey *)\nsimpl in |- *; auto with arith.\n(* divey *)\nintros x y z; elim z; intros.\n(* divey *)\nsimpl in |- *; auto with arith.\n(* divey *)\nintros x y z;Qed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a; intros.\nabsurd (b = 0 :>Z).\ndiscriminate.\nintros.\nabsurd (0 = 0 :>Z).\ndiscriminate.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction 1; auto with arith.\nintros a b q r H H0; elim H0; auto with arith.\nintros a0 q r H H1 H2; elim H2; auto with arith.\nintros a0 q r H H2; elim H2; auto with arith.\nintros a0 q r H H3; elim H3; auto with arith.\nintros a0 q r H3; elim H3; auto with arith.\nintros a0 q r H3; elim H3; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nintros.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply modZ_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply mod_pos.\napply modQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\n",
                "context_tokens": 286,
                "proof_start_offset": 1694,
                "proof_end_offset": 1893,
                "proof": "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nintros n m.\nelim (le_or_lt _ _ H); intro H1.\nleft; assumption.\nright; assumption.\nright; assumption.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n unfold pos in |- *; intros n m H; elim H; auto.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n.\nreflexivity.\nintros; absurd (0 = 0); auto with arith.\nintros; absurd (0 = 0); auto with arith.\nintros; absurd (0 = 0); auto with arith.\nintros; absurd (0 = 0); auto with arith.\nintros; absurd (0 = 0); auto with arith.\nintros; absurd (0 = 0); auto with arith.\nintros; absurd (0 = 0); auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n; simpl in |- *; intros.\nauto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nintros n m; elim n; auto.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n  intros.\n  apply pos_or_pos_not_pos_neg_pos.\n  apply pos_or_neg_neg_pos.\n  apply pos_or_neg_pos.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nintros n m; case n; simpl in |- *; auto with arith.\nintros n m; case m; simpl in |- *; auto with arith.\nintros n0 H; case m; simpl in |- *; auto with arith.\nintros n0 H; case m; simpl in |- *; auto with arith.\nintros n1 H; case m; simpl in |- *; auto with arith.\nintros m1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simpl in |- *; auto with arith.\nintros n1 H; case m1; simplQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n; simpl in |- *; auto with arith.\nintros n H; elim H; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n; intros.\n elim (pos_not_pos _ H).\n intros.\n apply H.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\nLemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\n\n\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H. rewrite H0; simpl in |- *; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 362,
                "proof_start_offset": 1912,
                "proof_end_offset": 2065,
                "proof": "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nintros; elim x.\nleft; reflexivity.\nintros; right; discriminate.\nintros; right; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros x H; elim H; auto.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos (pos n)) = x).\nintro H; elim H.\nauto with arith.\nauto with arith.\nauto with arith.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros; apply (eq_SO_dec x).\napply (eq_SO_dec x).\napply (eq_SO_dec x).\napply (eq_SO_dec x).\napply (eq_SO_dec x).\napply (eq_SO_dec x).\napply (eq_SO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqSO_dec x).\napply (eqQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (is_posn (pos n) (pos n)).\nsimpl in |- *; exact H.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos n)).\nsimpl in |- *; exact H.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros x; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros x; elim x; auto.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos n) = pos (pos (pos n)).\nsimpl in |- *; exact H.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros; elim x; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\n",
                "context_tokens": 156,
                "proof_start_offset": 1347,
                "proof_end_offset": 1460,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition is_empty : Prop := forall x : A, is_empty x.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x -> x = y :>A.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x -> exists y : A, in_empty x.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x /\\ exists y : A, in_empty x /\\ x = y :>A.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x -> is_empty x.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x /\\ exists y : A, in_empty x /\\ y = y :>A.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x /\\ exists y : A, in_empty x /\\ y = y :>A.\n\nDefinition is_empty : Prop :=\n  forall x : A, is_empty x /\\ exists y : A, in_emptyDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\n(* The next two lemmas are defined in the same *)\n\nDefinition not (x : A) := ~ P x.\n\nLemma not_not_in : forall (A : Set) (P : A -> Prop),\n (forall x : A, P x -> P x) -> P x.\nsimple induction 1.\nintros x H0; elim H0; intros.\nsplit; [ assumption | right; auto with arith ].\nintros x0 H1; elim H1; intros.\nsplit; [ assumption | left; auto with arith ].\napply not_not_in; auto with arith.\napply not_not_in; auto with arith.\napply not_not_in; auto with arith.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition not (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, P x -> P x.\n\nDefinition sub (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> x = y :>A.\n\nDefinition rel (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition rel (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition rel (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition rel_choice (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, R x x.\n\nDefinition rel_choice (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, R x x.\n\nDefinition rel_choice (A : Set) (R : A -> A -> Prop) :=\n  forall x yDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition explicit_noetherian (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> explicit_noetherian A R x y.\n\nDefinition explicit_noetherian (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> explicit_noetherian A R x y.\n\nDefinition explicit_noetherian (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> explicit_noetherian A R x y.\n\nDefinition explicit_noetherian (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition explicit_noetherian (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> R x y.\n\nDefinition explicit_noetherian (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R x y.\n\nDefinition explicit_noetherian (A : Set) (R : A -> A -> Prop)Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition no_dup (A : Set) (P : A -> Prop) :=\n  forall x : A, P x -> P x.\n\nLemma no_dup : forall (A : Set) (P : A -> Prop),\n  (forall x : A, P x -> P x) -> P x.\nProof.\nunfold not in |- *; intros A P H x H0; elim H0; intros H1 H2; clear H H2.\ngeneralize H0; clear H0; clear H0; clear H0.\nelim (classic (P x /\\ P x)); intros.\nelim H1; intros.\ngeneralize H2; clear H2; clear H2; clear H2.\ngeneralize H0; clear H2; clear H2; clear H0.\nelim (classic (P x /\\ P x)); intros.\nelim H2; intros.\nclear H2; elim H2; intros.\napply H4; auto with sets.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nsimple induction 1; auto with *.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\n(* We define the following definition of Inductives a predicate that is the image of A. *)\n\nInductive le (A : Set) : A -> A -> Prop :=\n    le_wf_lt_dec : forall x y : A, lt x y -> lt x y.\n\nInductive le_n_Sn : forall n : nat, A n -> Prop :=\n    le_wf_lt_dec : forall n : nat, A n -> n = n :>A.\n\n(* This one is a little part of the part of the part of the part of the part of the part of  *)\n(* in the part of the part of the part of the part of the part of  *)\n(* of the part of the part of the part of the part of the part of the part of the part of     *)\n(* of the part of the part of the part of the part of the part of     *)\n(* of the part of the part of the part of the part of the part of     *)\n(* of the part of the part of the part of the part of the part of    *)\n(* of the part of the part of the part of the part of part of     *)\n(*Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\n(*  Definition of the following definition: *)\n(* The following theorem are used in the proof of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case of the  *)\n(* (resp.v x) of the case of the case of the case of the case of the case ofDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition is_a_in_dom (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> P x y.\n\nLemma is_a_in_dom :\n forall (A : Set) (R : A -> A -> Prop) (x y : A),\n R x y -> exists x : A, R x y /\\ R x y x.\nProof.\nunfold not in |- *; intros A R x y H0; elim H0; intros y0 H1; elim H1; intros y2 H2; elim H2;\n intros y3 H4; elim H4; intros y5 H5; elim H6;\n intros y5 H6; elim H6; intros y7 H7; elim H7;\n intros y8 H9; elim H10; intros y10 H11; elim H10; intros y12 H13;\n elim H12; intros y13 H14; elim H15; intros H15 H16;\n elim H16; intros H17 H17; elim H16; intros H17 H17; elim H16;\n intros H17 H17; elimDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x.\nelim H.\nintros x y H0.\napply (H x y H0).\napply H0.\napply H1.\napply H.\napply H0.\napply H0.\napply H0.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\n",
                "context_tokens": 203,
                "proof_start_offset": 1485,
                "proof_end_offset": 1628,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n simple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n simple induction p.\nintros; auto.\nintros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\n\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\n(*******************)\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n(************)\n",
                "context_tokens": 313,
                "proof_start_offset": 1781,
                "proof_end_offset": 2050,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift; auto.\napply inv_shift;Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold inv_shift in |- *; intros; elim H1; intros; elim H2; intros; \n elim H3; intros; elim H3; intros; elim H4; intros; \n elim H4; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; \n intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; unfold subersible in |- *; intros.\napply (H (invI x)).\nrewrite <- H0.\napply (H (invI x)).\nrewrite <- H0.\napply (H (invI x)).\nrewrite <- H1.\napply (H (invI x)).\nrewrite <- H1.\napply (H (invI x)).\nrewrite <- H1.\napply (H0 (invI x)).\nrewrite <- H1.\napply (H (invI x)).\nrewrite <- H1.\napply (H (invI x)).\nrewrite <- H1.\napply (H (invI x)).\nrewrite <- H0.\napply (H (invI x)).\nrewrite <- H1.\napply (H0 (invI x)).\nrewrite <- H0.\napply (H (invI x)).\nrewrite <- H1.\napply (H0 (invI x)).\nrewrite <- H1.\napply (H0 (invI x)).\nrewrite <- H1.\napply (H (invI x)).\nrewrite <- H1.\napply (H0 (invI x)).Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nelim (plus_comm _ _ H0).\nelim (mult_comm _ _ H1).\nelim (mult_comm _ _ H0).\nelim (mult_comm _ _ H1).\nelim (mult_comm _ _ H2).\nelim (mult_comm _ _ H2).\nelim (mult_comm _ _ H2).\nelim (mult_comm _ _ H3).\nelim (mult_comm _ _ H3).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H5).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H5).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (mult_comm _ _ H4).\nelim (multQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintros; elim (plus_comm (S x) (S x)); auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intro x; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros x; elim x.\n  simpl in |- *; auto with arith.\n  intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n    elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n    intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros;\n    elim H6; intros; elim H8; intros; elim H8; intros; elim H8; intros;\n    elim H8; intros; elim H8; intros; elim H9; intros;\n    elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros;\n    elim H9; intros; elim H8; intros; elim H9; intros;\n      elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n      elim H9; intros; elim H9;Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nunfold upaco, regZ in |- *.\nintros x y; elim y; simpl in |- *; auto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfold upaco1 in |- *; intros x y H; elim H; auto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfold Zlt, sign_opp.\n intros.\n apply Zlt_succ_pred; assumption.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  simple induction x.\n  auto with arith.\n  intros.\n  unfold Zminus in |- *.\n  apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak;\n    assumption.\n  intros.\n  unfold Zminus in |- *.\n  apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak;\n    assumption.\n  intros.\n  unfold Zminus in |- *.\n  apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak;\n    assumption.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.\nunfold Zminus in |- *.\nintros x y.Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n unfold decide in |- *; intros; discriminate.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nunfold])).\nintro; elim x; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n intros; apply zero_pos.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nsimple induction x; simpl in |- *; auto.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nexact (le_lt_pos_abs x).\nexact (le_lt_pos_abs x).\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.Qed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *; intros.\napply le_trans with (pos x); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napply le_trans with (pos y); auto.\napplyQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rlt in |- *; intros x y H; elim H.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rlt in |- *; intros x y H'; elim H'.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nred in |- *; intros x y H'; elim H'.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\napply Rle_lt_pos_abs; auto.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rgt in |- *; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nunfold sym in |- *; auto with arith.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Rlt in |- *; intros; elim H. \nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x y; elim y. \nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold Hnle; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\napply Rlt_le_pos_abs; apply pos_neg_abs; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nunfold lt_absZ in |- *; intros x y; elim x.\n(* (neg n) *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)\nreflexivity.\n(* pos n = 0 *)Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *.\nexact I.\nintros; elim H0; apply H0.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *. exact I. intro; discriminate.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *; intros; elim H.\n(* pos n0 *)\nsimpl in |- *; intros; elim H0.\n(* pos n0 *)\nintros; elim H0.\n(* pos n0 *)\nelim H0.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nsimpl in |- *; intros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nunfold lt_absZ in |- *; intros x y H.\nelim (lt_irrefl x).\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros;Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H1.\n(* (neg n) *)\nintros; elim H2.\n(* (neg n) *)\nintrosQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* pos n0 *)\nintros; elim H.\n(* pos n0 *)\nintros; elim H0.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H0.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.\n(* pos n0 *)\nintros; elim H1.Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\n(* pos n *)\nintros; elim H; apply H.\n(* pos n *)\nintros; elim H0; apply H0.\n(* pos n *)\nintros; elim H0; apply H.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elim H0; apply H1.\n(* pos n *)\nintros; elimQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *; intros; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": " Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 737,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold Zle in |- *;\n unfold Prec_gt in |- *; unfold Prec_gt in |- *;\n unfold Prec_gt in |- *; simpl in |- *;\n unfold Prec_gt in |- *;\n unfold Prec_gt in |- *;\n unfold Prec_gt in |- *;\n unfold Prec_gt in |- *;\n unfold Prec_gt in |- *; simpl in |- *;\n unfold Prec_gt in |- *;\n unfold Prec_gt in |- *;\n unfold Prec_gt in |- *; simpl in |- *;\n unfold Prec_gt_0 in |- *;\n unfold Prec_gt_0 in |- *;\n unfold Prec_gt_0 in |- *;\n unfold Prec_gt_0 in |- *; simpl in |- *;\n unfold Prec_gt_0 in |- *;\n unfold Prec_gt_0 in |- *; simpl in |- *;\n unfold Prec_gt_0 in |- *;\n unfold Prec_gt_0 in |- *;\n unfold Prec_gt_0 in |- *; simpl in |- *;\n unfold Prec_gt_0 in |- *;\n unfold Prec_Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold neqZ in |- *;\n unfold neqZ in |- *; unfold Zminus in |- *;\n unfold Zminus in |- *; unfold Zminus in |- *;\n unfold Zminus in |- *;\n unfold Zminus in |- *; unfold Zminus in |- *;\n unfold Zminus in |- *;\n unfold Zminus in |- *; unfold Zminus in |- *;\n unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *; unfold Zminus in |- *;\n unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *;\n unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; repeat rewrite Zplus_0_r; \n unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; unfold Zminus in |- *; \n unfold Zminus in |- *; \n unfold Zminus in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintro; elim n. \n(* Focus 1 *)\nreflexivity.\n(* Focus 1 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nreflexivity.\n(* Focus 2 *)\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\n(* n *)\nauto.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold posZ in |- *;\n unfold neq in |- *;\n unfold neq in |- *; simpl in |- *; apply neq_O_lt;\n unfold lt_absZ in |- *;\n unfold lt_absZ in |- *; unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *; apply neq_O_lt;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold lt in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold lt in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold eq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold lt in |- *;\n unfold neq in |- *;\n unfold neq in |- *;Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold neqZ in |- *;\n unfold oppZ in |- *; unfold neqZ in |- *;\n unfold decide equality;\n unfold ltZ in |- *;\n unfold neqZ in |- *; unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold neqZ in |- *;\n unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold neqZ in |- *;\n unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold neqZ in |- *;\n unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold ltZ in |- *;\n unfold neqZ in |- *;\n unfold neq in |- *;\n unfold neqZ in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold neq in |- *;\n unfold ltZ in |- *;\n unfold neq in |- *;\n unfold ltZ in |- *;Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold signed in |- *; unfold ltZ in |- *;\n unfold LKSIZE in |- *; unfold ltZ in |- *;\n unfold gt in |- *; unfold neqZ in |- *;\n unfold neqZ in |- *; simpl in |- *; intros.\nelim (le_Sn_O n H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold neqZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; simpl in |- *; intros.\nelim (lt_O_Sn n H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold gt in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; simpl in |- *; intros.\nelim (le_Sn_O n H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold gt in |- *; unfold gt in |- *;\n unfold ltZQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |- *; intros; elim H0.\n(* pos n *)\nsimpl in |-Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* n *)\nreflexivity.\n(* nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* m *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; simpl in |- *; auto with arith.\n(* m *)\nunfold lt_absZ in |- *; unfold Zle in |- *; unfold Zle in |- *; unfold Zle in |- *;\n unfold Zle in |- *; unfold Zle in |- *;\n unfold Zle in |- *; simpl in |- *; auto with arith.\n(* m *)\nunfold lt_absZ in |- *; unfold Zle in |- *; unfold Zle in |- *;\n unfold Zle in |- *; \n unfold Zle in |- *; simpl in |- *; auto with arith.\n(* m *)\nunfold lt_absZ in |- *; unfold Zle in |- *; simpl in |- *; auto with arith.\n(* m *)\nunfold lt_absZ in |- *; unfold Zle in |- *; unfold Zle in |- *;\n unfold Zle in |- *; \n unfold Zle in |- *; simpl in |- *; auto with arith.\n(* m *)\nunfold lt_absZ in |- *; unfold Zle in |- *; simpl in |- *; auto with arith.\n(* m *)\nunfold lt_absZ in |- *; unfold Zle in |- *; auto with arith.\n(* m *)\nunfold lt_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3529,
                "proof_end_offset": 3703,
                "proof": "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\nsimpl in |- *; intros; exact I.\nsimpl in |- *; intros; exact I.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim x.\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold ltZ in |- *;\n unfold tge in |- *; unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *; \n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *;\n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |-Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.\n(* var n *)\nreflexivity.Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* pos n *)\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold ltZ in |- *;\n unfold tge in |- *; unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *; \n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *;\n unfold tge in |- *; \n unfold tge in |- *;\n unfold tge in |- *; \n unfold tge in |- *; \n unfold tge in |- *;\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nintros; elim n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold neqZ in |- *;\n unfold 1024 in |- *; simpl in |- *.\n unfold \"__ \"__ \"__ \"__ lt_O_Sn_O _ H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold \"__ \"__ lt_O_Sn_O _ H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold \"__ \"__ lt_O_Sn_O _ H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold \"__ \"__ lt_O_Sn_O _ H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold \"__ \"__ lt_O_Sn_O _ H).\n(* pos n *)\nunfold lt_absZ in |- *; unfold \"__ lt_O_Sn_O _ H.\n(* pos n *)\nunfold lt_absZ in |- *; unfold \"__ lt_O_Sn_O _ H.\n(* pos n *)\nunfold lt_absZ in |- *; unfold \"__ \"__ lt_O_Sn_O _ H).Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n.  simpl in |- *; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros a0; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros; elim n.\n(* a real *)\nintros a0; elim n.\n(* a real *)\nintros a0; elim n.Qed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x; simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n; simpl in |- *; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nsimple induction x.\n(* a case a case a case a0 *)\nintros; elim H0.\n(* a case a0 case a1 *)\nintros; elim H0.\n(* a0 case a1 *)\nintros; elim H0.\n(* a0 case a1 *)\nintros; elim H0.\n(* a1 case a1 *)\nintros; elim H0.\n(* a1 case a2 *)\nintros; elim H0.\n(* a1 *)\nintros; elim H0.\n(* a1 *)\nintros; elim H1.\n(* a1 case a2 *)\nintros; elim H0.\n(* a1 case a2 *)\nintros; elim H1.\n(* a1 case a2 *)\nintros; elim H1.\n(* a1 *)\nintros; elim H1.\n(* a1 *)\nintros; elim H1.\n(* a1 *)\nintros; elim H1.\n(* a1 *)\nintros; elim H1.\n(* a1 *)\nintros; elim H1.\n(* a1 *)\nintros; elim H1.\n(* a1 *)\nintros; elim H1.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 3722,
                "proof_end_offset": 3902,
                "proof": "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros.\napply (leZ_antisymmetric x OZ).\nrewrite H.\nexact (le_opp_OZ_l y H1).\nexact H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; intros; elim H.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nintros x y H H0; elim H0; auto.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y; elim y; simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\napply le_opp_OZ_l; assumption.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nintros x y H0 H1 H2; elim H1.\nintros; elim H1.\nrewrite <- H2; exact I.\nintros; elim H1.\nrewrite <- H2; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nintros; elim H1.\nrewrite <- H3; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\n(* x = y *)\nunfold lt_absZ in |- *; unfold neqZ in |- *; unfold ltZ in |- *;\n unfold Pminus in |- *; intros.\nelim (le_Sn_O n H).\n(* x = y *)\nreflexivity.\n(* x = y *)\nreflexivity.\n(* x = y *)\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n(* 0 *)\nintros; elim H0; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H0; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewrite H1; reflexivity.\n(* pos n *)\nelim H1; intro; rewriteQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H H0 H1; elim H1; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y; elim y; simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x; intros; elim H; intros; elim H0; intros; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\nLemma le_opp_OZ :\n forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\n\nProof.\nintros. apply (leZ_antisymmetric x OZ). rewrite H. exact (le_opp_OZ_l y H1).\nexact H0.\nQed.\n\n(***************)\n",
                "context_tokens": 725,
                "proof_start_offset": 3922,
                "proof_end_offset": 4176,
                "proof": "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\nrewrite (le_opp_OZ x y H H0 H1).\nrewrite (opp_opp Z IdZ addZ OZ oppZ Z_group y I); elim H.\nrewrite (le_opp_OZ x y H H0 H1); simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nsimple induction x; simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros. apply (le_opp_OZ x y H H0).\nrewrite <- (le_opp_OZ x y H0). exact (le_opp_ PARTICULAR PURPOSE.is_opp_involutive y H0).\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_opp_)!x; apply le_opp_OZ2; assumption.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros. apply (le_opp_)!x; assumption.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros x y; elim x.\nintros; elim y.\nrewrite (pos_eq_bool_correct x y); trivial.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_opp_)!x; trivial.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nintros. apply (le_opp_)!.\napply (le_opp_multKl x y H1).\napply (le_opp_multKl x y H1).\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\nelim (le_lt_eq_dec x y); intro H1; rewrite H1 in H1; rewrite H1 in H1; assumption.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros x y; elim x; simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros; elim x.\nintros; elim H0.\nrewrite (minus_comm x y); rewrite (minus_comm x y); rewrite (minus_comm y);\n rewrite (minus_comm x y); rewrite (minus_comm y);\n rewrite (minus_comm x y); rewrite (minus_comm y);\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\n",
                "context_tokens": 121,
                "proof_start_offset": 1253,
                "proof_end_offset": 1349,
                "proof": "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple destruct n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nintros n; elim n; auto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n intros.\n apply eq_le_incl.\n apply (fun (n m : nat) (a : nat) (b : nat) => b).\n apply eq_le_incl.\n apply (fun (n m : nat) (a : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b : nat) => b).\n apply (fun (n m : nat) (b :Qed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nauto with arith.\nintros.\nright.\nelim minus_n_O.\napply sym_equal.\napply sym_equal.\napply refl_equal.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nauto with arith.\nauto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nauto with arith.\nintro.\nelim (lt_n_O_dec n).\nauto with arith.\nintros.\nelim (lt_irrefl n).\nauto with arith.\nintros.\nelim (le_lt_or_eq n0 n).\nauto with arith.\nintros.\nelim (lt_irrefl n).\nauto with arith.\nintros.\nelim (lt_irrefl n).\nauto with arith.\nintros.\nelim (le_not_lt n n).\nauto with arith.\nintros.\nelim (le_not_le n0 n).\nauto with arith.\nintros.\nelim (le_not_lt n0 n).\nauto with arith.\nintros.\nelim (lt_not_eq n0 n).\nauto with arith.\nintros.\nelim (le_not_lt n0 n).\nauto with arith.\nintros.\nelim (le_not_le n0 n).\nauto with arith.\nintros.\nelim (le_not_lt n0 n).\nauto with arith.\nintros.\nelim (le_not_lt n0 n).\nautoQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n   intros.\n   elim (le_lt_O_eq _ (eq_sym _ H)).\n   elim (le_lt_eq _ _ H).\n   intros.\n   elim (le_n_O_eq _ _ H).\n   intros.\n   elim (le_not_eq _ _ H0).\n   intros.\n   elim (le_not_eq _ _ H1).\n   intros.\n   apply (le_S_n _ _ H2).\n   intros.\n   apply (le_S_n _ _ H1).\n   apply le_S_n.\n   apply le_trans with (m := S n).\n   apply le_n_S.\n   apply le_n_S.\n   apply le_n_S.\n   apply le_trans with (m := S n).\n   apply le_n_S.\n   apply le_n_S.\n   apply le_trans with (m := S n).\n   apply le_n_S.\n   apply le_n_S.\n   apply le_n_S.\n   apply le_trans with (m := S n).\n   apply le_n_S.\n   apply le_n_S.\n   apply leQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nintro n; elim n; auto.\nintros n0 H; elim H; auto.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nauto with arith.\nintros n0 H; inversion H.\nauto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\nintros.\napply (lt_irrefl n).\napply (lt_irrefl n).\napply (lt_irrefl n).\napply (lt_trans (n + S n) (S n) (S n)).\napply lt_O_Sn.\napply (lt_irrefl n).\napply (lt_trans (n + S n) (S n) (S n) (S n)).\napply lt_trans with (n + S n) (S n) (S n)).\napply le_plus_l.\napply le_minus.\napply (lt_trans (n + S n) (S n) (S n) (S n)).\napply lt_le_weak.\napply lt_le_weak.\napply (lt_trans (n + S n) (S n) (S n) (S n) (S n))).\napply lt_le_weak.\napply (lt_trans (n + S n) (S n) (S n) (S n) (S n) (S n)))).\napply lt_le_weak.\napply (le_trans (n + S nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple induction n.\nintros.\nelim (le_gt_O_dec n).\nintro.\nelim (le_gt_O_dec n).\nintro.\nelim (le_gt_O_dec n).\nintro.\nelim (le_gt_O_dec n).\nintro.\nabsurd (n = 0).\napply lt_le_trans with n; auto with arith.\napply lt_le_weak; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\n",
                "context_tokens": 164,
                "proof_start_offset": 1370,
                "proof_end_offset": 1528,
                "proof": "Lemma mult_commut : forall n m : nat, n * m = m * n.\nProof.\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros n m H'; elim H'.\nintros m H'0; elim H'.\nintros m H'1; elim H'0.\nintros m1 H'2; elim H'2.\nintros m1 H'3; elim H'1.\nintros m2 H'3; elim H'3.\nintros m3 H'4; elim H'4.\nintros m3 H'5; elim H'5.\nintros m4 H'6; elim H'6.\nintros m4 H'6; elim H'6.\nintros m4 H'6; elim H'6.\nintros m4 H'6; elim H'6.\nintros m4 H'6; elim H'6.\nintros m5 H'6; elim H'6.\nintros m5 H'6; elim H'6.\nintros m5 H'6; elim H'6.\nintros m5 H'6; elim H'6.\nintros m5 H'6; elim H'6.\nintros m5 H'6; elim H'6.\nintros m5 H'6; elim H'6.\nintros m5Qed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nProof.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nProof.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 224,
                "proof_start_offset": 1548,
                "proof_end_offset": 1637,
                "proof": "Lemma mult_neutr : forall n : nat, 1 * n = n.\nProof.\nunfold mult in |- *; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\n",
                "context_tokens": 261,
                "proof_start_offset": 1662,
                "proof_end_offset": 1875,
                "proof": "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nProof.\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros y m; elim m; auto with arith.\nintros; rewrite H; rewrite <- H; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nProof.\nintros y m; elim m.\nauto with arith.\nintros; rewrite H; rewrite (plus_comm (y + m)) (S y + m)).\nauto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros y m; elim m; simpl in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple induction 1; auto with arith.\nintros; rewrite H; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros.\napply plus_reg_l with (n := y); auto with arith.\napply plus_reg_l with (n := y); auto with arith.\napply plus_reg_l with (n := y); auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim H; simpl in |- *; auto with arith.\nintros; rewrite H; elim H; simpl in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; rewrite H; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\n",
                "context_tokens": 352,
                "proof_start_offset": 1894,
                "proof_end_offset": 2016,
                "proof": "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim (plus_comm m (y + m)); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nintros; rewrite H; elim (plus_comm m n).\nrewrite (plus_comm (x * m) (y + m)).\nrewrite (plus_assoc m (y * m) (y + m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (x * m) (y * m)).\nrewrite (plus_comm (xQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros.\nrewrite (plus_comm (y * m) (y + m)) in |- *.\nrewrite (plus_comm m (y * m) (x + m)); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n.\nintros.\nrewrite (mult_comm m n (y * m + (y + m))).\nrewrite (plus_assoc m n (y * m) (y + m)); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nintros; rewrite H; apply le_n_S; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *; auto with arith.\nintros; rewrite H; elim (plus_comm m n); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; rewrite H0; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *; auto with arith.\nintros; rewrite H; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 400,
                "proof_start_offset": 2036,
                "proof_end_offset": 2173,
                "proof": "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nProof.\nsimple induction n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nProof.\nsimple induction n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; auto with arith.\nintros; rewrite H; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros.\nrewrite minus_n_O; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; simpl in |- *.\nauto with arith.\nintros; elim minus_Sn_m; auto with arith.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\nLemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\n\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(************)\n",
                "context_tokens": 456,
                "proof_start_offset": 2190,
                "proof_end_offset": 2319,
                "proof": "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nintros; elim (le_lt_eq_dec n (S m) H); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction n; simpl in |- *.\nauto with arith.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim minus_Sn_m; auto with arith.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros.\nrewrite <- minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nsimple induction 1; intros; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H.\n  destruct (H a b H) as [n [e [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He [He']]]]]]]]]]]]]]]].\n  exists (n + e)%nat; split; auto.\n  exists (S n); split; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n destruct (H a) as (x,H).\n exists x; auto.\n exists x; auto.\n exists x; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nunfold Zis_gcd; simpl;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm; rewrite Z.mul_comm;\n rewrite Z.mul_assoc;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite Z.mul_comm;\n rewrite ZQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n apply Zis_gcd_refl.\n apply Zis_gcd_trans.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_symQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\ndestruct H.\ndestruct H0.\napply Zis_gcd_for_euclid with (a - b - a).\napply Zis_gcd_for_euclid with (b - b - a).\napply Zis_gcd_for_euclid with (b - b - a).\napply Zis_gcd_for_euclid with (b - b - a).\napply Zis_gcd_for_euclid with (b - b - b).\napply Zis_gcd_for_euclid with (b - b - b).\napply Zis_gcd_for_euclid with (b - b - a).\napply Zis_gcd_for_euclid with (b - b - b).\napply Zis_gcd_for_euclid with (b - b - b).\napply Zis_gcd_for_euclid with (b - b - a).\napply Zis_gcd_for_euclid with (b - b - a).\napply Zis_gcd_for_euclid with (b - b - b).\napply Zis_gcd_for_euclid with (b - b - a).\napply Zis_gcd_for_euclid with (b - b - a).\n apply ZisQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply Zis_gcd; apply Zis_gcd; apply Zis_gcd; apply Zis_gcd_for_euclid1.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n case (H a); intros.\n inversion H.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d.\ngeneralize (gcd_gcd_alt a b d).\ngeneralize (gcd_gcd_alt a b d).\ngeneralize (gcd_gcd_alt a b d).\ngeneralize (gcd_gcd_alt a b d).\ngeneralize (gcd_gcd_alt a b d).\nintros (n,H).\ngeneralize (gcd_gcd_alt a b d).\nintros (n',H).\nrewrite gcd_gcd_alt.\nrewrite <- (gcd_gcd_abs b d).\nrewrite <- (gcd_gcd_abs b d).\nrewrite <- (gcd_gcd_abs b d).\nrewrite <- (gcd_gcd_abs b d).\nrewrite <- (gcd_abs b d).\nrewrite <- (gcd_abs b d).\nrewrite <- (gcd_abs b d).\nrewrite <- (gcd_abs b d).\napply gcd_eq.\nrewrite <- (gcd_abs b d).\nrewrite <- (gcd_abs b d).\napply gcd_eq.\nrewrite <- (gcd_abs b d).\nrewrite <- (gcd_abs b d).\napply gcd_eq.\nrewrite <- (gcd_absQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H; split; intros H1.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H b); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H a); auto.\n - destruct (H aQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym.\n apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply Zis_gcd_sym. apply H.\n apply ZisQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 732,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case (Zneq_bool x y); intros; subst; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros H.\n  apply Z.ge_bool_false; auto with zarith.\n  apply Z.ge_bool_false; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\n  exists y; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z.eq_dec x y); intros H; subst; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros H; case (Zeq_dec x y); intros H; subst; auto with zarith.\n  destruct (H x); auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y; case (Zeq_dec x y); intros.\n  apply Z.neq_bool_true; apply Z.lt_neq_bool_false; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H; case (Zeq_dec x y); intro H; subst.\n destruct (Z.eq_dec x y); auto.\n destruct (Z.eq_dec x y); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?= y)%Z; auto; intros H1 H2; subst; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x==y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y); auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x==y); auto;\n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; case (x==y); auto;\n try (intros; discriminate); auto. \nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\n",
                "context_tokens": 702,
                "proof_start_offset": 4191,
                "proof_end_offset": 4728,
                "proof": "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\nintros x0 y0.\napply PHL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e'=> forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nintuition auto with zarith.\ncutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H; case H; simpl; auto. \n intros (H1,H2).\n exists (fun e => (VX e)); auto.\n intros (H1,H2).\n exists (fun e => (VX e)); auto.\n intros (H2,H2).\n exists (fun e => (VX e)); auto.\n intros (H3,H4).\n exists (fun e => (VX e)); auto.\n intros (H4,H4).\n exists (fun e => (VX e)); auto.\n intros (H5,H6).\n exists (fun e => (VX e)); auto.\n intros (H6,H6).\n exists (fun e => (VX e)); auto.\n intros (H6,H7).\n exists (fun e => (VX e)); auto.\n intros (H6,H8).\n exists (fun e => (VX e)); auto.\n intros (H6,H8).\n exists (fun e => (VX e)); auto.\n intros (H8,H9).\n exists (fun e => (VQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H; apply (gcd_for_gcd_for_gcd_for_gcd_for_gcd_for_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_gcdQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H; apply (gcd_for_gcd_gcd_for_gcd_for_gcd_for_gcd_for_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcd_for_gcd_gcd_gcd_for_gcd_gcd_gcd_gcd_gcdQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0 H; case (Zis_gcd_for_gcd x0 y0); intros; auto;\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\nintros x0 y0 H; generalize (Zeq_dec x0 y0); clear (Zeq_dec x0 y0);\n case (x?= 0)%Z; auto; intros (H1,H2).\ngeneralize (H0 H0); clear H0; unfold Zneq_bool.\n case (x?= 0)%Z; auto; intros (H1,H2).\n generalize (H2 H0); clear H2; unfold Zneq_bool; case (x?= 0)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H H0; case (constructive_gcd_for_gcd x0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 y0 H0); auto.\n intros; case (constructive_gcd_for_gcd y0 yQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H.\n generalize (gcd_is_gcd x0 y0 H); clear H.\n destruct (divide_bool x0 y) as [H0|H0].\n rewrite H; clear H.\n apply Zis_gcd_for_euclid with (x:=0); auto.\n generalize (gcd_is_gcd x0 y0 H); clear H.\n destruct (divide_bool x0 y) as [H|H0].\n rewrite H; clear H.\n apply Zis_gcd_for_euclid with (x:=0); auto.\n generalize (gcd_is_gcd x0 y H); clear H.\n destruct (divide_bool x0 y) as [H0|H0].\n rewrite H; clear H.\n apply Zis_gcd_for_euclid with (x:=0); auto.\n generalize (gcd_is_gcd x0 y0 H); clear H.\n destruct (divide_bool x0 y) as [H0|H0].\n rewrite H; clear H.\n apply Zis_gcd_for_euclid with (x:=0); auto.\n generalize (gcd_is_gcd x0 yQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0 H; case (gcd_spec x0 y0); intros H1 H2; subst; auto;\n  try (intros; discriminate); auto. \nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H; case (Zcompare_spec x0 y0); auto; intros H1; subst; auto.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0 H; case H; intros H1 H2.\n exists (VX e); exists (VX e); exists (VX e); exists (VX e); exists (VX e); exists (VX e); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "var A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\nLemma gcd_partial_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) \n   |= gcd  {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\n",
                "context_tokens": 693,
                "proof_start_offset": 4775,
                "proof_end_offset": 6000,
                "proof": "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\nintros x0 y0.\napply THL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\ forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nconstructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\nconstructor 1.\napply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\nauto with datatypes.\nunfold Zwf; simpl; (intuition auto with zarith).\ncutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\ncut ((fst e')<=(snd e')); auto with zarith.\ncut ((fst e')<>(snd e')); auto with zarith.\ncut (~(fst e')<=(snd e')); auto with zarith.\nintros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H1; case H1; intros; subst; auto with zarith.\n apply gcd_refl.\n apply gcd_refl.\n apply gcd_sym.\n apply gcd_refl.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_Qed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H; split; intros.\n - intros (H1,H2).\n   exists (fun e => (VX e)); split; auto.\n   intros d H2; destruct (H1 d H2).\n   destruct (H2 d H2).\n   destruct (H0 d H2).\n   destruct (H2 d H2).\n   destruct (H4 d H2).\n   destruct (H2 d H4).\n   destruct (H4 d H4).\n   destruct (H5 d H4).\n   destruct (H5 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H7 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (H6 d H4).\n   destruct (HQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H; apply PHL. revert x0 y0 H.\n induction x0; intros; simpl in *; try discriminate.\n apply (H (S x0)).\n assert (H': (exists y, (fun e => (VX e)) = (VX e)).\n  intro H; apply H'. clear H.\n  destruct H' as [y H].\n  exists y; exists y; exists y; auto.\n intros; exists y; exists y; auto.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H.\n unfold gcd in H.\n destruct H as (e,H).\n destruct H as (e'',H).\n destruct (H e'' (DY e'')) as (e'',H1).\n destruct (H e'' (DY e'')) as (e'',H2).\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists (2* e).\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n split; auto with zarith.\n exists e''.\n splitQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H; case (Z_eq_dec x0 y0); intros H; subst.\n rewrite <- H; simpl in *; auto with zarith.\n rewrite <- H; simpl in *; auto with zarith.\n rewrite <- H; simpl in *; auto with zarith.\n rewrite <- H; simpl in *; auto with zarith.\n rewrite <- H; simpl in *; auto with zarith.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n destruct (gcd_total_order_dec x0 y0) as [H|H].\n (* even even *)\n destruct (gcd_total_order_dec y0 y) as [H|H].\n (* even even *)\n exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) x0))) y0)) y0)) y0) ); \n [ now auto with zarith | apply gcd_refl ].\n exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (Qed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply PHL. intros e; exists (VX e); auto with zarith.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H1; split; intros H2 H3; apply H3; clear H3; unfold Z.lt in H1;\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX e)); auto with zarith.\n apply Zis_gcd_for_euclid with (x:=fun e => (VX eQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H; split; intros H; constructor; auto.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0 H; split; intro H; [omega | omega ].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "un e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\nLemma gcd_total_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0)\n  |= gcd  [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply THL.soundness.\n simpl.\n intros e; intuition subst.\n (** after simplification, I provide the invariant and then the variant *) \n constructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\\n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n constructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\n (** - proof that my variant is a well_founded relation *) \n constructor 1.\n apply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\n auto with datatypes.\n (** - other goals *)\n  unfold Zwf; simpl; (intuition auto with zarith).\n (** -- invariant => postcondition \n      --- gcd part like in partial correctness proof \n *)\n  cutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\n  (** --- new VY in branch \"then\" is positive *)\n  cut ((fst e')<=(snd e')); auto with zarith.\n  cut ((fst e')<>(snd e')); auto with zarith.\n  (** --- new VX in branch \"else\" is positive *)\n  cut (~(fst e')<=(snd e')); auto with zarith.\n  intros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\n  discriminate.\nQed.\n\n(** ** Another example: infinite loops in partial correctness.\n\nBasic Hoare logic is not well-suited for reasoning about non-terminating programs.\nIn total correctness, postconditions of non-terminating programs are not provable.\nIn partial correctness, a non-terminating program satisfies any (unsatisfiable) postcondition.\n\nFor example, in an informal \"meaning\", the program below enumerates all multiples of 3. But this meaning \ncan not be expressed here (even in partial correctness).\n*)\n\nDefinition enum_3N := \n  (Iseq (Iset VX (const 0))\n        (Iwhile (const true)\n                (Iset VX (PLUS VX (const 3))))).\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6625,
                "proof_end_offset": 6819,
                "proof": "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\napply PHL.soundness.\nsimpl.\nconstructor 1 with (x:=fun _:Env => True).\nintuition (discriminate || auto).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros.\n destruct (nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_to_eq_dec nat_Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros e; intuition congruence.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n  intros e; unfold enum_3N.\n  destruct e as (e, e); simpl; auto.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\nunfold enum_3N.\ndestruct e.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THL.\napply THLQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\nassert (forall (d : list (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * A))))))) d)) (co_members c))) ->\n  (forall (d : list (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * A)))) d))) (co_members c))) ->\n  forall (d0 : list (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * A))))) d)) (co_members c))) d0)\n->\n  forall (d0 : list (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * (ident * A))))) d0)) (co_members c0)) d1)\n->\n  forall (d1 : list (ident * (ident * (ident * (ident * (ident * (ident * (ident * A))))) d0) (Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintro.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napply THL. intros e.\napplyQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\ndestruct e; auto with datatypes.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros e; intuition auto with datatypes.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros e;\n unfold enum_3N.\n rewrite Iseq_eq.\n rewrite (Iseq_eq (fun e => True) e); simpl.\n intros e; intuition subst.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n apply Iseq_eq; simpl; auto.\n applyQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\n intros.\n apply THL. intros e; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "(** * Generation of Hoare proof obligations in total correctness\n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file gives a syntactic definition of the weakest precondition [wp]\n introduced in #<a href=hoarelogicsemantics.html>#[hoarelogicsemantics]#</a>#.\n We refine here the approach of  #<a href=partialhoarelogic.html>#[partialhoarelogic]#</a>#.\n*)\n\nGlobal Set Asymmetric Patterns.\nSet Implicit Arguments.\nRequire Export hoarelogicsemantics.\nRequire Wf.\n\nModule TotalHoareLogic (HD: HoareLogicDefs).\n\nExport HD.\nModule HLD:=HD.\n\nDefinition sem_wp := wp.\n\nExport Wf.\n\n(** * Syntactic definition of the weakest precondition.\n\n In the following, we show that this definition is logically\n equivalent to [wp].\n *)\nFixpoint synt_wp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n          ((E.eval cond e)=true -> (synt_wp p1 post e))\n       /\\ ((E.eval cond e)=false -> (synt_wp p2 post e))\n  | (Iseq p1 p2) => synt_wp p1 (synt_wp p2 post) e\n  | (Iwhile cond p) =>  \n        exists inv:Pred,\n        exists R:E.Env -> E.Env -> Prop,\n             (well_founded R)\n          /\\ (inv e)\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=false -> post e')\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=true -> synt_wp p inv e')\n          /\\ (forall e0, (inv e0)\n                  -> (E.eval cond e0)=true -> synt_wp p (fun e1 => R e1 e0) e0)\n  end.\n\n(** * Soundness *)\n\n(** Monotonicity is also trivially satisfied by [wp].\n    We need it here to prove the soundness.\n*)\n",
                "context_tokens": 530,
                "proof_start_offset": 1747,
                "proof_end_offset": 1962,
                "proof": "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\ninduction p; simpl; firstorder eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st st st st st' st' st' st' st' st'.\n  unfold synt_wp.\n  intros st st st' st' st' st' st' st' st'.\n  unfold synt_wp.\n  intros st st st' st' st' st' st' st' st'.\n  induction st' as [st st' st' st' st'' st'' st'' st''.\n  - (* nil *)\n    apply IHst with st st'' st'' st'' st'' st'' st''.\n    + (* nil *)\n      apply IHst with st st'' st'' st'' st''.\n      * (* nil *)\n        apply IHst with st st'' st''.\n        * (* cons *)\n          apply IHst with st st'' st''.\n          * (* cons *)\n          apply IHst with st st'' st''.\n          * (* cons *)\n          apply IHst with st'' st'' st''.\n          * (* cons *)\n            apply IHst with st'' st''.\n            * (* cons *)\n            apply IHst with st'' st''.\n            * (* cons *)\n            apply IHst with st'' st''.\n            * (* cons *)\n            apply IHst with st'' st'' st''.\n            *Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p post1 post2 e H.\n  eapply H; eauto.\n  eapply H; eauto.\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros ppost1 ppost2.\n  destruct ppost1 as [e' [H1 H2]].\n  destruct ppost2 as [e' [H1 H2]].\n  destruct ppost1 as [e'' [H1 H3]].\n  destruct ppost2 as [e'' [H3 H4]].\n  destruct ppost1 as [e'' [H4 H5]].\n  destruct ppost2 as [e'' [H4 H5]].\n  destruct ppost2 as [e'' [H5 H6]].\n  destruct ppost2 as [e'' [H5 H6]].\n  destruct ppost2 as [e'' [H6 H7]].\n  destruct ppost2 as [e''' [H5 H6]].\n  destruct ppost2 as [e''' [H7 H8]].\n  destruct ppost2 as [e''' [H8 H9]].\n  destruct ppost2 as [e''' [H9 H10]].\n  destruct ppost2 as [e''' [H11 H12]].\n  destruct ppost2 as [e''' [H11 H12]].\n  destruct ppost2 as [e''' [H11 H12]].\n  destruct ppostQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p post1 post2 e.\n  induction p.\n  - simpl. auto.\n  - simpl. auto.\n  - simpl. auto.\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros.\n  destruct st2.\n  - (* The following case is used as [wp_wp]. *)\n    destruct st2.\n    + (* the following case is not used in this case, which case it is no need to apply *)\n      destruct st3.\n      * (* the case is not used in this case, which case it is not true. *)\n        destruct st4.\n        * (* the case is not true in this case, it is not true. *)\n        * (* the case is true in this case, it is not true. *)\n          exists inv:forall; auto.\n          * (* the case is true in this case, it is not true. *)\n          exists inv:forall; auto.\n          * (* the case is true in this case, it is true. *)\n          exists inv:forall; auto.\n          * (* the case is true in the case, it is true. *)\n          exists inv:forall; auto.\n          * (* the case is true in the case, it is true. *)\n          exists inv:forall; auto.\n          * (* the case is true in the case, it is true. *)\n          exists inv:forall; auto.\n          * (* the case is true in theQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros ppost1 post2 e.\n  induction ppost1.\n  + intros H.\n    apply H.\n    inversion H0.\n    inversion H0.\n  + intros H.\n    inversion H0.\n  + intros H.\n    inversion H0.\n    inversion H0.\n  + intros H0.\n    inversion H0.\n  + intros H0.\n    inversion H0.\n  + intros H0.\n    inversion H0.\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p st st st st st st' st' st' st' st'.\n  generalize st st st' st' st' st' st' st' st'.\n  generalize st st st' st' st' st'.\n  induction st'.\n  - (* E_IfTrue *)\n    destruct st' as [| st' st'].\n    + (* E_IfTrue *)\n      destruct st' as [| st'' st'].\n      + (* E_IfFalse *)\n        destruct st'' as [| st'' st'].\n        * (* E_IfFalse *)\n          destruct st'' as [| st'' st'].\n          * (* E_IfFalse *)\n          destruct st'' as [| st'' st'].\n          * (* E_IfFalse *)\n          destruct st'' as [| st'' st'].\n          * (* E_IfFalse *)\n          destruct st'' as [| st'' st'].\n          * (* E_IfFalse *)\n          destruct st'' as [| st'' st'].\n          * (* E_IfFalse *)\n          destruct st'' as [| st'' st'''].\n          * (* E_IfFalse *)\n          destruct st'' as [| st'' st'''].\n          * (* E_IfFalse *)\n          destruct st'' as [| st'' st'''].\n          * (* E_WhileTrue *)\n          destruct stQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p post1 post2 e H1.\n  induction sigma1; simpl; intros.\n  + (* We can use the following proof.  We can use a case where we don't know that\n(e) and we need to define the form of the form\n(e) and that the form of the form\n(e) and that this is not. *)\n  assert (e = e) by (inversion e; subst; auto).\n  subst e; auto.\n  + (* We can use the following proof.  It is a case where we can use the\n(e) and prove that the form\n(e) and that the form (e) and (e)\n(e) and (e) and (e)\n(e) and (e) are not as [e]. *)\n  assert (e = e) by (inversion e; subst).\n  subst e; auto.\n  + (* we can use the following proof.  It is a case where the lemma\n(e) and (e) are also in the case where the\n(e) and (e) are not in the form of the form\n(e) and (e)\n(e) andQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros.\n  remember (p, pre1 e) as p.\n  remember (p, pre2 e) as p.\n  remember (p, pre2 e) as p.\n  remember (p, pre2 e) as p.\n  generalize dependent p.\n  induction p.\n  intros st' e.\n  destruct st' as [st'' e'].\n  simpl in *.\n  destruct st'' as [st'' e'].\n  simpl in *.\n  destruct st'' as [st'' e'].\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H0.\n  subst st''.\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H0.\n  subst st''.\n  simpl in *.\n  inversion H0.\n  subst st''.\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H.\n  subst st''.\n  simpl in *.\n  inversion H0.\n  subst st''.\n Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p post1 post2 e H1 H2.\n  generalize dependent p.\n  induction p; intros st1 st2 H1.\n  - (* restore *)\n    apply IHst2 in H1. inversion H1.\n    destruct (H1 st2) as [st1' st2'].\n    destruct (H2 st2) as [st2' st2'].\n    destruct (H3 st2) as [st3' st3'].\n    destruct (H1 st3) as [st4' st4'].\n    destruct (H2 st4') as [st5'' st6'].\n    destruct (H2 st4') as [st6'' st7'].\n    destruct (H3 st4') as [st6'' st6'].\n    destruct (H4 st6'') as [st6'' st7'].\n    destruct (H5 st6'' st7') as [st6'' st7'].\n    destruct (H6 st7'' st7') as [st6'' st7'].\n    destruct (H7 st7'' st7'') as [st6'' st7'].\n    destruct (H8 st8'' st8') as [st6'' st7'].Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "dec2 H2 H.\n generalize Hinv.\n pattern e.\n (* -- here the proof proceeds by induction on the well-founded relation *)\n eapply well_founded_ind; eauto.\n clear Hinv e.\n intros e' X H'.\n set (b:=E.eval cond e').\n cut (E.eval cond e'=b); auto.\n case b; [ idtac | firstorder eauto with hoare ].\n intros H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\n",
                "context_tokens": 707,
                "proof_start_offset": 5789,
                "proof_end_offset": 5976,
                "proof": "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction 1; simpl; try ((firstorder eauto with hoare); fail).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nunfold e; induction prog; intros.\n inv H.\n destruct a as [ | a' e'].\n destruct H.\n exists a'.\n exists e'.\n simpl.\n destruct (H a').\n exists (S a).\n simpl.\n destruct (H a').\n simpl.\n destruct (H a').\n destruct H.\n subst.\n simpl.\n destruct (H a').\n subst.\n simpl.\n destruct (H0 a').\n destruct H.\n destruct H0.\n subst.\n simpl.\n destruct (H a').\n destruct H0.\n simpl.\n destruct (H0 a').\n simpl.\n destruct (H a').\n destruct H0.\n subst.\n simpl.\n destruct (H a').\n destruct H0.\n simpl.\n destruct (H0 a').\n destruct H0.\n simpl.\n destruct (H0 a').\n simpl.\n destruct (H a').\n destruct H0.\n simpl.\n destruct (H0 a').\n simpl.\n destruct (H0 a').\n simpl.\n destruct H0.\n simpl.\n destruct (H0 a').\n destruct H0.\n simpl.\n destruct (HQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n induction 1; simpl; intros.\n auto.\n destruct a.\n destruct H.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H.\n destruct H.\n destruct H0.\n destruct H.\n destruct H.\n destruct H.\n destruct H.\n destruct H0.\n destruct H.\n destruct H0.\n destruct H.\n destruct H.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H.\n destruct H0.\n destruct H.\n destruct H.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H.\n destruct H0.\n destruct H1.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H.\n destruct H0.\n destruct H0.\n destruct H.\n destruct H.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H0.\n destruct H.\n destructQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ninduction sigma; intros; simpl in *; auto.\ndestruct (exec_inversion H); subst.\napply step_intro; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  intros until e.\n  induction H.\n  simpl.\n  auto.\n  simpl.\n  destruct p.\n  auto.\n  simpl.\n  destruct p.\n  auto.\n  simpl.\n  auto.\n  auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction e; intros; simpl; auto.\n  destruct a.\n  apply IHst_acc.\n  apply (no_path_no_path_no_path_no_path_no_path_no_path_no_path_no_path_no_path_no_path_no_path_no_path_no_path_path_no_path_no_path_no_path_path_no_path_no_path_no_path_path_no_path_no_path_path_no_path_no_path_no_path_path_no_path_no_path_path_no_path_path_no_path_path_no_path_path_no_path_no_path_no_path_path_no_path_path_no_path_no_path_path_no_path_path_no_path_sym_path_no_path_path_no_path_no_path_no_path_path_no_path_path_no_path_path_no_path_path_no_path_no_path_path_no_pathQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n induction 1.\n simpl; auto.\n simpl; intros.\n apply H0.\n apply H0.\n simpl; intros.\n apply H.\n simpl; intros.\n apply H; simpl; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n induction 1; intros.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H0.\n inversion H0.\n inversion H.\n inversion H0.\n inversion H1.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n intros.\n apply (exec_inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H).\n simpl; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction e; intros; simpl; auto.\ndestruct a.\ninversion H.\ninversion H.\ninversion H0.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n intros.\n destruct H0 as [st' [H1 H2]; destruct H2 as [st' [H1 H2]].\n exists st'.\n exists st'.\n exists (st'0 ++ (mu_ (mu_ (mu_ (mu_ mu_ j))) ++ (mu_ (mu_ mu_ j))).\n split.\n simpl.\n apply mu_equiv_1.\n simpl.\n apply mu_equiv_2.\n simpl.\n apply mu_equiv_2.\n simpl.\n apply mu_equiv_2.\n simpl.\n apply mu_equiv_2.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_2.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_3.\n simpl.\n apply mu_equiv_4.\n simpl.\n apply mu_equiv_3.\n simplQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\n",
                "context_tokens": 696,
                "proof_start_offset": 6074,
                "proof_end_offset": 6404,
                "proof": "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\nintros A x expr e e' H.\npattern e'; apply (exec_inversion H); simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  destruct (exec_inversion _ _ _ H) as [e'' [H1 H2]].\n  destruct (exec_inversion _ _ _ H) as [e'' [H1 H3]].\n  subst e''.\n  rewrite <- H1 in H1.\n  rewrite <- H2 in H1.\n  rewrite e'' in H1.\n  rewrite e'' in H1.\n  rewrite e'' in H1.\n  rewrite e''.\n  auto.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  inv H0.\n  inv H0.\n  inv H1.\n  inv H1.\n  inv H1.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H3.\n  inv H3.\n  inv H2.\n  inv H2.\n  inv H3.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H3.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H3.\n  inv H2.\n  inv H2.\n  inv H2.\n  inv H3.\n  inv H2.\n  inv H3.\n  inv H3.\n  inv H2.\n  inv H3.\n  inv H2.\n  inv H3.\n  inv H3.\n  inv H2.\n  inv H3.\n  inv H3.\n  inv H2.\n  inv H2.\n  inv H3.\n  inv H2.\n  inv H3.\n  inv H3.\n  inv H3.\n  inv H3.Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  destruct (exec_inversion x e) as [[a b] [e' EQ]].\n  destruct (exec_inversion x e) as [[b' EQ]].\n  destruct (exec_inversion x e) as [[b' EQ]].\n  rewrite EQ in EQ.\n  inversion EQ.\n  simpl in EQ.\n  case_eq (F.eval (if E.eval e' then b else b') e');\n  intros.\n  apply H.\n  apply exec_test_inversion.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction e; simpl; intros; auto.\n  Case \"typing_case_ip\".\n    destruct (e' x); destruct (e' x); destruct (e'' x); simpl; auto.\n    Case \"typing_case_ip\".\n      destruct (e'' x); destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".\n      destruct (e'' x); destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".\n      destruct (e'' x); destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".\n      destruct (e'' x); destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".\n      destruct (e'' x); destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".\n      destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".\n      destruct (e'' x); destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".\n      destruct (e'' x); destruct (e'' x); simpl; auto.\n      SCase \"typing_case_ip\".Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros; eapply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\n  apply exec_test_inversion.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x expr e e' H.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functionalQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  induction e; simpl;\n  try (monadInv H; subst; try reflexivity).\n  Case \"typing_case_same\".\n    simpl; apply IH; auto.\n  Case \"typing_case_same\".\n    simpl; apply IH; auto.\n    simpl; apply IH; auto.\n  Case \"typing_case_same\".\n    simpl; apply IH; auto.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  destruct (exec_inversion x e) as [[v v] e'] eqn:?.\n  auto.\n  destruct (exec_inversion x e) as [[v' v'] e'].\n  auto.\n  destruct (exec_inversion x e') as [[v'' v'] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x e) as [[v'' v''] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x e'') as [[v'' v''''] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x e'') as [[v'' v''].\n  auto.\n  destruct (exec_inversion x e'') as [[v'' v'''] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x e'') as [[v'' v'''] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x e'') as [[v'' v''] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x e'') as [[v'' v'''] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x e'') as [[v'' v''] e''] eqn:?.\n  auto.\n  destruct (exec_inversion x eQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  induction 1; simpl; intros.\n  auto.\n  destruct e; simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (e a); simpl; auto.\n  destruct (eQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ct the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\nLemma exec_test_inversion:\n  forall A (x:E.Var A) expr e e',\n     (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x expr e e' H.\n  (** Here, try \"[inversion H]\" instead the tactic below. \n      The generated goal is not directly provable. *)\n  pattern e'; apply (exec_inversion H); simpl; auto.\nQed.\n \n(** Below, a little tactic to helps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\n",
                "context_tokens": 712,
                "proof_start_offset": 6917,
                "proof_end_offset": 7168,
                "proof": "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\ninduction 1; intros ef' X; exec_inversion X; eauto.\nintros e1 e2 X1 X2; assert (X3: e'=e1); auto.\nsubst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n intros; subst; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply exec_deterministic.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; simpl; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; apply exec_step_inversion; intros.\n  apply exec_deterministic in H1; destruct H1 as [e1 H2].\n  apply exec_deterministic in H1; destruct H1 as [e2 H3].\n  apply exec_deterministic in H1; destruct H1 as [e3 H4].\n  apply exec_deterministic in H1; destruct H1 as [e4 H5].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 as [e5 H6].\n  apply exec_deterministic in H1; destruct H1 asQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros ei p ef H.\n  unfold e; intros; apply exec_deterministic; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; apply exec_deterministic.\n  intros; apply exec_deterministic.\n  intros; apply exec_deterministic.\n  intros; apply exec_deterministic.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros.\n  apply exec_deterministic.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; apply exec_deterministic.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until e.\n  induction sigma; intros.\n  simpl in H.\n  inversion H.\n  subst.\n  inversion H.\n  subst.\n  inversion H2.\n  subst.\n  inversion H3.\n  subst.\n  inversion H0.\n  subst.\n  inversion H2.\n  subst.\n  inversion H2.\n  subst.\n  inversion H4.\n  subst.\n  inversion H2.\n  subst.\n  inversion H2.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H2.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H5.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H5.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  subst.\n  inversion H4.\n  substQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8653,
                "proof_end_offset": 8793,
                "proof": "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\ninduction 1; firstorder (eauto with hoare).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; intros; try solve [inversion H]; intros.\n  inversion H.\n  apply execn_Iskip in H1; destruct H1 as [n1 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1; destruct H1 as [n2 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1; destruct H1 as [n2 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1; destruct H1 as [n2 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1; destruct H1 as [n2 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1; destruct H1 as [n2 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1; destruct H1 as [n2 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1; destruct H1 as [n2 H1]; subst.\n  inversion H1.\n  apply execn_Iskip in H1;Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction ei; intros; auto.\n  destruct a.\n  simpl in H.\n  inversion H.\n  destruct (sem_cast e (Icall op p) i) as [n'|] eqn:?; auto.\n  destruct i; try contradiction.\n  simpl in H.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n  destruct i; try contradiction.\n Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros.\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p (Iseq p e)) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p (Iseq p e)) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p (Iseq p e)) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p e) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p (Iseq p e)) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p (Iseq p e)) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p e) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p e) e).\n  apply execn_Iseq with (f := fun n => exec n e (Iseq p e) e).\n  apply execn_Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros; apply execn_Iseq with (e := exec n e nil); trivial.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n intros.\n destruct op; simpl in *; trivial.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros.\n  apply execn_Iif.\n  destruct op; simpl; intros; auto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n intros.\n apply execn_Iseq with (e := exec n e (Iseq p (Iseq p (Iseq p e) e)) (Iseq p e)).\n apply execn_Iseq with (e := exec (Oseq p e) (Iseq p e)).\n apply execn_Iseq with (e := exec (Oseq p e) (Iseq p e)).\n apply execn_Iseq with (e := exec (Oseq p e) (Iseq p e)).\n apply execn_Iseq with (e := exec (Oseq p e) e).\n assumption.\n apply execn_Iseq with (e := exec (Oseq p e) e).\n assumption.\n apply execn_Iseq with (e := exec (Oseq p e) e).\n assumption.\n apply execn_Iseq with (e := exec (Oseq p e) e).\n assumption.\n apply execn_Iseq with (e := exec (Oseq p e) e).\n assumption.\n apply execn_Iseq with (e := exec (Oseq p e) e).\n assumption.\n apply execnQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n intros.\n destruct e.\n destruct (is_int_or_or_or_app e e).\n auto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n intros.\n destruct op; simpl; intros; auto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n intros.\n destruct op; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\n",
                "context_tokens": 739,
                "proof_start_offset": 9000,
                "proof_end_offset": 9914,
                "proof": "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\nunfold well_founded.\nintros cond p e0; apply Acc_intro.\nintros e1 H; unfold reduces in H.\ndecompose [ex and] H; clear H.\nclear H2 H0 e0.\ncase (exec_execn H1).\nintros n.\ngeneralize cond p e1 x; clear cond p e1 x H1.\nelim n.\nintros cond p e0 e1 H; inversion_clear H.\nclear n; intros n HR cond p e0 e1 H.\ninversion_clear H.\ninversion_clear H0.\nset (b:=E.eval cond e0) in * |-.\ncut (E.eval cond e0=b); auto.\ngeneralize H; clear H; case b; simpl.\nintros H; inversion_clear H.\nintros; apply Acc_intro.\nintros e2 H3; unfold reduces in H3.\nintuition.\nrewrite (exec_deterministic H3 H0); eauto.\nintros H H0; apply Acc_intro.\nunfold reduces; rewrite H0.\nintuition.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros; apply (well_founded_induction_wf _ _ H).\n  intros.\n  destruct H as [n H].\n  destruct H as [n' H'].\n  destruct H0 as [n' H'].\n  destruct H0 as [n' H'].\n  destruct H0 as [n'' H']].\n  destruct H0 as [n'' H']].\n  destruct H1 as [n'' H']].\n  destruct H0 as [n'' H''].\n  destruct H0 as [n'' H''].\n  destruct H' as [n'' H''].\n  destruct H0 as [n'' H''].\n  destruct H1 as [n'' H''].\n  destruct H'' as [n'' H''].\n  destruct H'' as [n''' H''].\n  destruct H'' as [n''' H''].\n  destruct H''.\n  destruct H'' as [n'' H''].\n  destruct H'' as [n''' H''].\n  destruct H''.\n  destruct H'' as [n''' H''].\n  destruct H''.\n  destruct H''.\n  destruct H'' as [n''' H''].\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct HQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold is_conv, rev; intros; apply step_wf; auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  destruct (classic (e0 = e1)).\n  auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold is_founded.\n  intros.\n  unfold is_founded.\n  destruct (classic (forall e, is_equiv (for_iff (for_iff (for_iff (for_iff (for_iff (for_iff (iff (iff P)))) ef)) e)) e)).\n  intros.\n  destruct (classic (forall e, is_equiv (for_iff (for_iff (for_iff (for_iff (iff (for_iff (iff P))) ef)) e)) e)).\n  intros.\n  destruct H0 as [e' [e' [H1 H2]].\n  exists e'.\n  split; auto.\n  exists e'.\n  split; auto.\n  exists e'.\n  split; auto.\n  right.\n  auto.\n  auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\n  destruct p; firstorder.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder; simpl; intros.\n  destruct p; firstorder.\n  destruct (H0 e0).\n  destruct (H0 e).\n  destruct (H0 e0).\n  destruct (H1 e).\n  destruct (H1 e).\n  destruct H2.\n  destruct (H2 e).\n  destruct H4.\n  destruct (H1 e).\n  destruct (H2 e).\n  destruct H4.\n  destruct H4.\n  destruct (H4 e).\n  destruct H4.\n  destruct (H5 e).\n  destruct H5.\n  destruct H5.\n  destruct (H6 e).\n  destruct H4.\n  destruct H5.\n  destruct H6.\n  destruct H6.\n  destruct H6.\n  destruct (H7 e).\n  destruct H7.\n  destruct H7.\n  destruct H8.\n  destruct H8.\n  destruct H9.\n  destruct H10.\n  destruct H9.\n  destruct H8.\n  destruct H9.\n  destruct H9.\n  destruct H9.\n  destruct H9.\n  destruct H9.\n  destruct H9.\n  destruct H9.\n  destruct H9.\n  destruct H10.\n  destruct H10.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "Prog -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\n",
                "context_tokens": 734,
                "proof_start_offset": 10044,
                "proof_end_offset": 11057,
                "proof": "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\nunfold wp.\nintros prog post e H; case H; clear H.\nintros e' H; case H; clear H.\ngeneralize post e e'; clear post e e'; elim prog; clear prog; simpl.\nintros post e e' H; exec_inversion H; auto.\nintros A v expr post e e' H; exec_inversion H; auto.\nintros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\ncase (E.eval cond e); simpl; firstorder auto || discriminate.\nintros p1 Hp1 p2 Hp2 post e e' H.\nexec_inversion H.\neauto.\nintros cond p Hp post e e' H H0.\nconstructor 1 with (x:=wp (Iwhile cond p) post).\nconstructor 1 with (x:=reduces cond p).\nunfold wp; (intuition eauto with hoare); dec2 e1 H1; case H1; clear H1; intros H1; exec_inversion H1; intros e2 H1; exec_inversion H1; rewrite H2; intros e3 H1; exec_inversion H1; unfold reduces; eauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  destruct H as [n H].\n  destruct H as [n' H].\n  destruct H as [n'' H'].\n  destruct H as [n'' H'].\n  destruct H' as [n'' H'].\n  destruct H' as [n'' H'].\n  destruct H'' as [n'' H''].\n  destruct H'' as [n'' H''].\n  destruct H'' as [n'' H''].\n  destruct H''.\n  destruct H'' as [n'' H''].\n  destruct H''.\n  destruct H''.\n  destruct H'' as [n'' H''].\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  induction 1; auto.\n  exists nil; auto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  destruct st as [n st].\n  destruct st as [n st'].\n  destruct st' as [st'' st'].\n  destruct st'' as [st'' st'].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st''' st''].\n  destruct st'' as [st''' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''.\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st''' st''].\n  destruct st'' as [st''' st''.\n  destruct st'' as [st'' st''].\n  destruct st'' as [st'' st''].\n  destruct st'' as [st''' st''].\n  destruct st''Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; unfold sigma, sigma, sigma, sigma, sigma, sigma, sigma, sigma, sigma, sigma, sigma, sigma, sigma.\n  induction sigma; intros;\n    inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma; inversion_clear H.\n  destruct sigma;Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  unfold hereditary; intros TT post H.\n  destruct (classic (exists p, proj1_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig H)))\n         (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig H)))))\n         (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig H)))))\n         (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig H)))))\n         (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig H)))))\n         (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig H)))))Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros sigma post; induction H; intros; simpl in *; try discriminate.\n  destruct (step_det _ _ H) as [n [H1 H2]].\n  destruct (step_det _ _ H) as [n' [H3 H4]].\n  destruct (step_det _ _ H4) as [n'' [H4 H5]].\n  destruct (step_det _ _ H5) as [n'' [H5 H6]].\n  destruct (step_det _ _ H6) as [n'' [H5 H6]].\n  destruct (step_det _ _ H5) as [n'' [H5 H6]].\n  destruct (step_det _ _ H5) as [n''' [H5 H6]].\n  destruct (step_det _ _ H6) as [n''' [H6 H7]].\n  destruct (step_det _ _ H6) as [n''' [H7 H8]].\n  destruct (step_det _ _ _ H7) as [n''' [H8 H9]].\n  destruct (step_det _ _ H8) as [n''' [H9 H9]].\n  destruct (step_det _ _Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  destruct (classic (exists n, typing n (Ocall_well_founded (fun n => n <> 0))).\n  destruct (classic (exists n, typing n (Ocall_well_founded (fun n => n <> 0))).\n  destruct (classic (exists n, typing n (Ocall_well_founded (fun n => n <> 0))).\n  intro H.\n  apply (H n).\n  apply (H n).\n  apply (H n).\n  apply (H0 n).\n  apply (H n).\n  apply (H0 n).\n  apply (H0 n).\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  induction 1; firstorder (auto with hoare).\n  destruct (H0 _ _ H0 H1).\n  destruct H as [n' [H0 H2]].\n  exists n'.\n  split; auto.\n  simpl in H1.\n  destruct H1 as [n'' [H2 H3]].\n  destruct H2 as [n'' [H4 H5]].\n  exists n''.\n  split; auto.\n  simpl in H1.\n  destruct H1 as [n'' [H4 H5]].\n  destruct H3 as [n''' [H5 H6]].\n  exists n''.\n  split; auto.\n  simpl in H1.\n  destruct H1 as [n'' [H4 H6]].\n  exists n''.\n  split; auto.\n  simpl in H1.\n  destruct H1 as [n'' [H4 H6]].\n  destruct H3 as [n''' [H5 H6]].\n  exists n''.\n  split; auto.\n  simpl in H1.\n  destruct H1 as [n'' [H4 H6]].\n  exists n''.\n  split; auto.\n  simpl in H1.\n  destruct H1 as [n''' [H5 H6]].\n  existsQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; unfold wp; intros.\n  destruct st.\n  destruct st.\n  destruct st.\n  destruct st.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'. destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'.\n  destruct st'. destruct stQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  inv H.\n  inv H0.\n  inv H.\n  simpl.\n  apply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  simpl.\n  apply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  apply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  eapply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  eapply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  eapply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  apply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  eapply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  eapply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  apply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  apply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  apply step_deterministic.\n  unfold no_path; intros.\n  inv H.\n  apply step_deterministic.\n  unfold no_path; intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold post; intros; split; intros H;\n    inversion H; subst; auto.\n  repeat intro; apply H; auto.\n  repeat intro; apply H; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p.\n  + intros H; apply H; auto.\n  + intros H; apply H; auto.\n  + intros.\n    apply H; auto.\n  + intros.\n    apply H; auto.\n  + intros.\n    apply H; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p.\n  apply hoare_call with (Q:=fun _ => True);\n    [ | apply hoare_call with (Q:=fun _ => True);\n      [ | apply hoare_call with (Q:=fun _ => True);\n        [ | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=fun _ => True);\n            [ | apply hoare_call with (Q:=Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; split; intros.\n  spec H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply HQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; split; intros H1 H2;\n  destruct H2 as [e' H1];\n  destruct H3 as [e' H3];\n  destruct H4 as [e'' H4];\n  destruct H6 as [e'' H4];\n  destruct H6 as [e'' H4];\n  destruct H6 as [e'' H6];\n  destruct H6 as [e'' H6];\n  destruct H7 as [e'' H6];\n  destruct H7 as [e'' H6];\n  destruct H7 as [e'' H7];\n  destruct H7 as [e''' H8];\n  destruct H8 as [e'' H9];\n  destruct H9 as [e'' H9];\n  destruct H9 as [e''' H10];\n  destruct H11 as [e'' H11];\n  destruct H12 as [e''' H11];\n  destruct H13 as [e'' H13];\n  destruct H13 as [e''' H13];\n  destruct H14 as [e''' H14];\n  destruct H14 as [e''' H15];\n  destruct H15 as [e''' H15];\n  destruct H15 as [e''' H14];Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros pre p post; split; auto.\n  intros st st st' H H;\n  apply boxy_derives; auto.\n  intros st st st' H;\n  apply boxy_derives; auto.\n  intros st st st' H H;\n  apply boxy_derives; auto.\n  intros st st' st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  apply boxy_derives; auto.\n  intros st st' H;\n  applyQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  split; intros.\n  eapply H; eauto.\n  eapply H; eauto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  split.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p as [p [H1 H2]].\n  destruct p as [p' [H3 H4]].\n  destruct p' as [p' [H4 H5]].\n  destruct H6 as [p'' [H5 H6]].\n  destruct H6 as [p'' [H7 H8]].\n  destruct H6 as [p''' [H8 H9]].\n  destruct H6 as [p'' [H8 H9]].\n  destruct H6 as [p''' [H9 H9]].\n  destruct H7 as [p''' [H10 H11]].\n  destruct H6 as [p''' [H11 H12]].\n  destruct H7 as [p''' [H11 H13]].\n  destruct H6 as [p''' [H13 H14]].\n  destruct H8 as [p''' [H14 H14]].\n  destruct H15 as [p''' [H15 H15]].\n  destruct H15 as [p''' [H15 H15]].\n  destruct H15 as [p''' [H15 H15]].\n  destruct H15 as [p''' [H15 H15]].\n  destruct H15 as [p''' [H16 H15]].\n Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply H.\n  apply H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros; split.\n  apply H; auto with hoare.\n  unfold reif; simpl; intros;\n    repeat intro;\n    repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n      end.\n  repeat intro;\n    match goal with\n      | H: _ |- _ => rewrite <- H; clear H\n     Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  unfold hereditary; intros.\n  apply H.\n  unfold hereditary; intuition.\n  intros e' H; case H; clear H.\n  destruct H as [e' H].\n  destruct H as [e' H].\n  destruct H as [e' H].\n  destruct H0 as [e'' H'].\n  destruct H' as [e'' H'].\n  inversion_clear H.\n  destruct H as [e'' H'].\n  destruct H' as [e'' H'].\n  destruct H' as [e'' H'].\n  inversion_clear H'.\n  destruct H' as [e'' H'].\n  destruct H' as [e'' H''].\n  inversion_clear H.\n  destruct H' as [e'' H''].\n  destruct H'' as [e'' H''].\n  inversion_clear H''.\n  destruct H''.\n  destruct H'' as [e'' H''].\n  destruct H'' as [e'' H''].\n  destruct H''.\n  destruct H'' as [e'' H''].\n  inversion_clear H''.\n  destruct H''.\n  destruct H'' as [e'' H''].\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct H''.\n  destruct HQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros p post e H; apply H; auto with hoare; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold post, -->, pqr.\n intros s p post e H; case H; clear H.\n  intros e' H; apply H; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold pre, pre, pre, -->, p POST; simpl; intros;\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct H as [P1 P2 Q1 Q2].\ndestruct H as [P1 P2 Q2].\ndestruct H as [P1 P2 Q2].\ndestruct H as [P1 P2 Q1].\ndestruct H as [P2 P3 Q2].\ndestruct H as [Q3 Q3].\ndestruct H as [P1 P3 Q3].\ndestruct H as [Q3 Q4].\ndestruct H as [P1 Q3].\ndestruct H as [Q3 P4].\ndestruct H as [Q4 Q5].\ndestruct H as [Q5 Q6].\ndestruct H as [Q7 Q8].\ndestruct H as [Q9 Q9].\ndestruct H as [Q9 Q11].\ndestruct H as [Q10 Q11].\ndestruct H as [Q11 Q12].\ndestruct H as [Q11 Q11].\ndestruct H as [Q11 Q12].\ndestruct H as [Q11 Q12].\ndestruct H as [Q12 Q23].\ndestruct H as [Q12 Q13].\ndestruct H as [Q12 Q22].\ndestruct H as [QQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct H.\n destruct H0 as [e' H].\n destruct H0 as [e' H0].\n destruct H0 as [e'' H1].\n destruct H1 as [e'' H2].\n destruct H2 as [e'' H3].\n exists e''; auto.\n inversion_clear H2; subst.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold hereditary; intros.\ninversion H; subst; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\n",
                "context_tokens": 556,
                "proof_start_offset": 1603,
                "proof_end_offset": 1825,
                "proof": "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n apply exec_Iif_true in H0.\n rewrite H0 in H0.\n destruct cond eqn:?; simpl in *.\n apply exec_Iseq with (m := exec e (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec e (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).\n apply exec_Iseq with (m := exec (Iseq p1 p2) e0).Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\napply exec_Iif_true; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iwhile_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_false; auto.\n apply exec_Iif_falseQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 e' H.\ndestruct (exec_Icall cond p e' H).\nreflexivity.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros e cond p1 e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply exec_Iif_false.\n intros e' H.\n apply execQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_false; eauto.\n eapply exec_Iif_falseQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n destruct (exec_Iwhile cond p e e').\n assumption.\n apply exec_Iif_false.\n apply exec_Iif_false.\n assumption.\n assumption.\n apply exec_Iif_false.\n assumption.\n apply exec_Iwhile_false.\n assumption.\n assumption.\n assumption.\n apply exec_Iwhile_false.\n assumption.\n assumption.\n apply exec_Iif_false.\n assumption.\n assumption.\n assumption.\n apply exec_Iwhile_false.\n assumption.\n assumption.\n assumption.\n assumption.\n apply exec_Icase_false.\n assumption.\n apply exec_Iwhile_false.\n assumption.\n assumption.\n assumption.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros e cond p e' H.\n destruct (exec_Iif cond p e' H) as [e'' [e'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'']]]]]]]]]]]]]]]]]]]]]]]] ];\n destruct (exec_Iif cond p1 (Iif cond p1 p2) e'')\n as [e'' [e'' [e'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He'']]]]]]]]]]]]]]]] ];\n destruct (exec_Iif cond p1 (Iif cond p1 p2) e'')\n as [e'' [e'' [He'' [He'' [He'' [He'' [He'' [He'' [He'' [He''Qed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros e cond p1 e'.\n induction cond; simpl; intros; auto.\n destruct (H0 (seq (sif cond (Iseq p1 p2) e)) Iskip e); auto.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\n contradiction.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros e cond p1 e' H.\n functional induction (exec e (Iif cond (Iseq p1 p2)) e).\n intros e' H.\n functional induction (exec (Iif cond (Iseq p1 p2)) e').\n intros e' H.\n functional induction (exec (Iif cond (Iseq p1 p2)) e).\n intros.\n functional induction (exec (Iif cond p2 (Iseq p1 p2)) e').\n intros.\n functional induction (exec (Iif cond (Iseq p1 p2)) e').\n intros.\n functional induction (exec (Iif cond p2 (Iseq p2)) e').\n intros.\n functional induction (exec (Iif cond (Iseq p1 p2)) e').\n intros.\n functional induction (exec (Iif cond p1 (Iseq p2)) e').\n intros.\n functional induction (exec (Iif cond p2 (Iseq p1 p2)) e').\n intros.\n functional induction (exec (Iif cond p2 (Iseq p2)) e').\n intros.\n functional induction (exec (Iif cond (IseqQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\n",
                "context_tokens": 646,
                "proof_start_offset": 1829,
                "proof_end_offset": 2053,
                "proof": "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1.\n  apply exec_Iif.\n  rewrite <- H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1.\n  apply exec_Iif_false.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1 H2.\n  apply exec_Iif_false.\n  rewrite H2; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 e' H1.\n  apply exec_Iif_false.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1 H2.\n  apply exec_Iif_false.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1 H2.\n  apply exec_Iif_false.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1.\n  apply exec_Iif_false.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1.\n  apply exec_Iif_true.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 e' H1.\n  apply exec_Iif_false.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 cond p2 e' H1 H2.\n  apply exec_Iif_false.\n  rewrite H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": " E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nLemma exec_Iif_false:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=false\n      -> (exec e p2 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nDefinition Pred := E.Env -> Prop.\n\nDefinition wlp: ImpProg -> Pred -> Pred\n := fun prog post e => (forall e', (exec e prog e') -> (post e')).\n\nDefinition wp: ImpProg -> Pred -> Pred\n := fun prog post e => exists e', (exec e prog e') /\\ (post e').\n\n\nNotation \"p |= q\" := (forall e, (p e) -> (q e)) (at level 80, no associativity).\nNotation \"p {= post =}\" := (wlp p post) (at level 70).\nNotation \"p [= post =]\" := (wp p post) (at level 70).\n\nEnd HLD.\n\nExport HLD.\n\nModule PHL<: HoareProofSystem := PartialHoareLogic(HLD). \nModule THL<: HoareProofSystem := TotalHoareLogic(HLD). \n\nImport THL.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 2648,
                "proof_end_offset": 2853,
                "proof": "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\nunfold wp, wlp.\nintros prog post e H e' H'.\ndec2 e0 H.\ndec2 H0 H.\nrewrite (exec_deterministic H' H0).\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n intros.\n destruct s; auto.\n destruct H0 as [s1 s2].\n destruct s1 as [s2 s3].\n destruct s1 as [s3 s4].\n destruct s4 as [s4 s5].\n destruct s4 as [s6 s7].\n destruct s6 as [s6 s7].\n destruct s7 as [s8 s8].\n destruct s8 as [s7 s8].\n destruct s8 as [s8 s9].\n destruct s8 as [s9 s10].\n destruct s9 as [s8 s9].\n destruct s9 as [s9 s10].\n destruct s10 as [s10 s11].\n destruct s12 as [s11 s12].\n destruct s12 as [s11 s12].\n destruct s12 as [s12 s22].\n destruct s12 as [s12 s22].\n destruct s23 as [s22 s22].\n destruct s23 as [s22 s22].\n destruct s23 as [s22 s22].\n destruct s22 as [s22 s22].\n destruct s22 as [s22 s22].\n destructQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\nintros.\ndestruct H.\neapply star_trans.\napply H0.\neapply star_trans.\napply H1.\neapply star_trans.\napply H2.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_trans.\napply H2.\neapply star_trans.\napply H2.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_trans.\napply H1.\neapply star_step; eauto.\neapply star_trans.\napply H2.\neapply star_step; eauto.\neapply star_step; eauto.\neapply star_trans.\napply H3.\neapply star_trans.\napply H2.\neapply star_step; eauto.\neapply star_step; eauto.\neapply starQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  destruct (H0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3 H4)\n  as (e' & e' & e' & e' & e' & e' & e' & e' & e' & e' & e'' & e'' & e'' & e'' & e'' & e'' & e'' & e'' & e'' & e''' & e'' & e'' & e''').\n  exists e''; split; auto.\n  exists e''. split; auto.\n  exists e''. split; auto.\n  exists e''. split; auto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  split.\n  + intros H.\n    inversion H; subst.\n    + intros H.\n      inversion H; subst.\n      * intros.\n        inversion H; subst.\n        * apply H0.\n        * intros.\n        inversion H; subst.\n        * intros.\n        inversion H; subst.\n        * apply H0.\n        * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion H; subst.\n          * apply H0.\n          * intros.\n          inversion HQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  destruct (H _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\n  destruct (H0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H H0).\n  destruct (H _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H2).\n  destruct (H1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H2).\n  destruct (H2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H H H0).\n  destruct (H3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  induction H; auto.\n  destruct H0; auto.\n  destruct H0; auto.\n  destruct H0; auto.\n  destruct H0; auto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n intros.\n destruct H as [e' [H1 H2]].\n destruct (H2 e').\n apply H1.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\nintros.\ndestruct H as [n].\nsimpl.\nrewrite H.\nrewrite H.\nauto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  destruct p; simpl in *.\n  destruct p0; try discriminate; subst; simpl in *.\n  destruct (H0 _ _ _ _ H1).\n  destruct (H0 _ _ _ _ H1).\n  destruct (H1 _ _ _ _ H0).\n  destruct (H2 _ _ _ _ H0).\n  destruct (H3 _ _ _ _ H1).\n  destruct (H4 _ _ _ _ H2).\n  destruct (H4 _ _ _ _ H1).\n  destruct (H5 _ _ _ _ H2).\n  destruct (H6 _ _ _ _ H1).\n  destruct (H6 _ _ _ H2).\n  destruct (H7 _ _ _ H1).\n  destruct (H7 _ _ _ _ H2).\n  destruct (H9 _ _ _ _ _ H H3).\n  destruct (H8 _ _ _ H1).\n  destruct (H9 _ _ _ _ H2).\n  destruct (H7 _ _ _ H2).\n  destruct (H9 _ _ _ _ H H0).\n  destruct (H7 _ _ _ H3).\n  destruct (H9 _ _ _ H2).\n  destruct (H9Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; exists (fun i => fun s => forall s, step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s => step s (fun s)))) s))) s))).\n  apply step_while; intros.\n  apply H0.\n  apply star_refl.\nQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto.\nintros n H; elim H; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction 1; auto with arith.\nintros n H; elim H; auto with arith.\nintros n H; elim H; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; auto with arith.\nintros n0 H; elim H; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (O_Sn n).\nelim (OSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction 1; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto.\nintros.\ncut (n = 0).\nintro.\nrewrite H.\nauto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n; elim n; simpl in |- *; auto.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with *.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nintros; elim (plus_comm m n); auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 2; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nsimple induction 1; auto with core.\nsimple induction 1; auto with core.\nsimple induction 1; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nintros; apply plus_n_O.\nauto with *.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n m p H; elim H; simpl in |- *; auto with arith.\nintros n0 H; elim H; simpl in |- *; auto with arith.\nintros n1 H; elim H; simpl in |- *; auto with arith.\nintros n1 H; elim H; simpl in |- *; auto with arith.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nintros; apply Plus_plus_r.\nauto with arith.\napply Plus_plus_r.\nauto with arith.\nauto with arith.\nauto with arith.\n\nauto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nsimple induction n; simpl in |- *; auto with arith.\nintros.\napply plus_n_Sm.\nrewrite <- plus_n_Sm; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nintros n m p; elim p; simpl in |- *; auto with core.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nintros; rewrite plus_n_O; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nintros; rewrite plus_n_Sm; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nintros; discriminate.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nintros n m p.\nelim (plus_assoc (Plus n m) (Plus n p)); simpl in |- *; auto with *.\nsimple induction 1; auto with *.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nintros n m p; elim p; simpl in |- *; auto with core.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with core.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; elim t; simpl in |- *; auto with arith.\nintros; elim (le_not_eq _ _ H0).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H2).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H2).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H1).\nauto with arith.\nintros; elim (le_not_eq _ _ H2).\nauto with arith.\nintrosSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\ncut (forall t u : tree, size t = size t -> size t = size t).\nsimple induction t; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nintros; elim H0; auto with arith.\nintros; elim H0; auto with arith.\nintros; elim H0; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\npattern (size u) at 2 in |- *; replace (size t) with (size (size t)); auto.\nrewrite (double_double_plus _ _ _ H0).\nauto.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; apply (H t).\nauto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\nchange (size t = S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S S (S S (S S (S S)))))))));))))))))\n   (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S S))))))))))))))) v))\n   (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (SSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; apply tip; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nSave size_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\n",
                "context_tokens": 379,
                "proof_start_offset": 1699,
                "proof_end_offset": 1769,
                "proof": "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros A B C D H H0 H1.\nelim H1; intros A B C D H2; elim H2; intros B C D H3; elim H3;\n auto.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros.\nintro.\napply H.\nintro.\napply H0.\nintros.\napply H2.\nintro.\napply H2.\nintro.\napply H0.\nintro.\napply H1.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H1.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H1.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.\napply H2.\nintro.Qed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintros A B C.\nsplit.\nelim H; auto.\nintros H1 H2 H3 H4.\nelim H3; auto.\nintros H1 H2 H3 H4.\nelim H3; auto.\nintros H1 H3 H4.\nelim H3; auto.\nintros H1 H3 H4.\nelim H4; auto.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\nred in |- *.\nsplit; intros.\nunfold B in H2.\nelim H2.\napply (H0 H2).\napply (H2 H3).\napply (H3 H4).\napply (H0 H2).\napply (H1 H3).\napply (H2 H4).\napply (H0 H3).\napply (H H4).\napply (H H4).\napply (H1 H4).\napply (H H4).\napply (H H4).\napply (H1 H4).\napply (H0 H5).\napply (H0 H4).\napply (H1 H4).\napply (H H4).\napply (H1 H4).\napply (H1 H4).\napply (H2 H4).\napply (H1 H4).\napply (H0 H5).\napply (H1 H4).\napply (H H4 H2).\napply (H0 H4).\napply (H0 H5).\napply (H1 H4).\napply (H1 H4).\napply (H0 H4).\napply (Qed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\nunfold B in |- *.\nunfold A in |- *.\nsplit.\nintro; apply H0.\nintro; apply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H2.\napply H2.\napply H1.\napply H2.\napply H2.\napply H1.\napply H0.\napply H1.\napply H0.\napply H2.\napply H2.\napply H0.\napply H1.\napply H2.\napply H3.\napply H4.\napply H3.\napply H3.\napply H4.\napply H2.\napply H3.\napply H1.\napply H0.\napply H2.\napply H0.\napply H3.\napply H3.\napply H0.\napply H3.\napply H0.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H4Qed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nunfold A in |- *.\nintros A B C H.\nelim H; clear H.\nintros x y H1.\nexact (even_non_zero_non_zero A).\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nunfold A, B, C in |- *.\nintros.\napply H.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\n\n(* End of the formal definition of a non-empty-empty-emptynus *)\n\n(* We define a type of a set of the inductive predicate *)\n\nInductive A : nat -> Prop :=\n  | A_S : forall n : nat, A n\n  | A_S : forall n : nat, A n -> A (S n).\n\n(* Non-empty-empty-nus *)\n\nInductive A : nat -> Prop :=\n  | A_S : forall n : nat, A n -> A (S n).\n\n(* A is a good version of a decidable equality *)\n\nInductive A : nat -> Prop :=\n  | A_S : forall n : nat, A n -> A (S n).\n\n(* A is a good version of a decidable equality *)\n\nInductive A_dec : forall n : nat, A n -> Prop :=\n  | A_dec : forall n : nat, A n -> A_dec n (A_dec n).\n\nInductive A_dec : forall n : nat, A n -> Prop :=\n  | A_dec : forall n : nat, A n -> A_dec n (A_dec n).\n\n(* AQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros A B C H.\ngeneralize (H A B C H).\nintros A B C H.\nsplit; auto.\n\napply H0; auto.\n\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\napply P.\nintros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 1771,
                "proof_end_offset": 1818,
                "proof": "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \n",
                "context_tokens": 448,
                "proof_start_offset": 1867,
                "proof_end_offset": 1948,
                "proof": "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nProof.\nintro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\n",
                "context_tokens": 499,
                "proof_start_offset": 2006,
                "proof_end_offset": 2102,
                "proof": "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\nintro.\nintro.\napply H.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H2.\napply H0.\napply H1.\napply H2.\napply H1.\napply H2.\napply H2.\napply H1.\napply H1.\napply H2.\napply H1.\napply H2.\napply H2.\napply H0.\napply H2.\napply H2.\napply H2.\napply H3.\napply H2.\napply H2.\napply H0.\napply H3.\napply H0.\napply H0.\napply H2.\napply H0.\napply H2.\napply H0.\napply H0.\napply H3.\napply H2.\napply H0.\napply H3.\napply H0.\napply H0.\napply H3.\napply H0.\napply H3.\napply H1.\napply H0.\napply HQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\nintro.\nintro.\nintro.\nassert (n = S (even n)).\nrewrite <- H0.\napply H.\nassumption.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\nintro.\nelim (even_odd n).\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_even.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_even.\nintros.\napply abs_even.\nintros.\napply abs_even.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_odd.\nintros.\napply abs_oddQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro n.\nintro.\nintro.\napply P_Sn.\nintro.\napply P_Sn.\nintro.\napply P_Sn.\nintro.\napply P_Sn.\nintro.\napply P_Sn.\nintro.\napply P_Sn.\nintro.\napply P_Sn.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro n.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro n.\nintro.\nintro.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_S.\napply P_n_Qed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\nintro.\napply Ex_Klenne''.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\nintro.\nred in |- *.\nintro.\napply H0.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply P_S.\napply PQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\n",
                "context_tokens": 582,
                "proof_start_offset": 2243,
                "proof_end_offset": 2346,
                "proof": "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintros.\napply P in H0.\nassumption.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintro x.\ngeneralize (P_ind (P:=P) (Q:=P) (Q:=P) (Q:=P) (B:=P) (B:=P) (B:=P) (H0:=P) (H1:=P) (H0:=P) (H0:=P) (H1:=P) (H2:=P) (H2:=P) (H3:=P) (H3:=P) (H4:=P) (H4:=P) (H5:=P) (H6:=P) (H6:=P) (H7:=P) (H8:=P) (H9:=P) (H8:=P) (H9:=P) (H8:=P) (H9:=P) (H9:=P) (H10:=P) (H10:=P) (H11:=P) (H12:=P) (H13:=P) (H12:=P) (H13:=P) (H13:=P) (H13:=P) (H13:=P) (H13:=P) (H14:=P) (H15:=P) (Qed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintro.\napply H.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H0.\napply H2.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H0.\napply H1.\napply H2.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0Qed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintro.\nintro.\napply H.\napply H0.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintros.\nsplit.\nintro.\napply H.\napply H0.\napply H.\napply H0.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintro.\nintro.\nintro.\nelim H.\nintro.\napply H0.\napply H.\napply H0.\napply H1.\napply H1.\napply H2.\napply H0.\napply H1.\napply H2.\napply H2.\napply H1.\napply H3.\napply H1.\napply H3.\napply H1.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintro.\nintro.\napply H.\napply H0.\napply H1.\napply H0.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintro.\nintro.\napply H0.\napply H1.\napply H0.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintros.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintro x.\napply H0.\napply H1.\napply H0.\napply H1.\napply H2.\napply H1.\napply H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\n",
                "context_tokens": 750,
                "proof_start_offset": 3167,
                "proof_end_offset": 3202,
                "proof": "Lemma NoMember : False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma NoMember : False.\nauto.\nQed.",
                    "Lemma NoMember : False.\napply A.\napply B.\napply A.\napply B.\nQed.",
                    "Lemma NoMember : False.\nProof.\nintro.\napply H0.\nQed.",
                    "Lemma NoMember : False.\nintuition.\nQed.",
                    "Lemma NoMember : False.\nassumption.\nQed.",
                    "Lemma NoMember : False.\nunfold not in |- *.\ntauto.\nQed.",
                    "Lemma NoMember : False.\nProof.\nsplit.\napply (is_true_or_introl (is_true_or_intror (is_true_or_intror (is_true_or_intror (is_true_or_intror (is_true_or_intror (is_true_or_introl (is_true_or_intror (is_true_or_intror (is_true_or_intror (is_true_or_intror (is_true_or_introl (is_true_or_introl (is_false_intror (is_true_or_introl (is_true_intror (is_false_introl (proj1_true_iff I)))) I))) I))) I))) I)))\n .\nQed.",
                    "Lemma NoMember : False.\ntauto.\nQed.",
                    "Lemma NoMember : False.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.\nunfold not in |- *; intros.Qed.",
                    "Lemma NoMember : False.\nintro.\napply rule5.\napply rule5.\napply rule5.\napply rule6.\napply H0.\napply rule5.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3215,
                "proof_end_offset": 3288,
                "proof": "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros x H; elim H.\nintros y H; elim H.\nintros y H1; elim H1.\nintros y H1; elim H1.\nintros y H1; elim H1; intros y H2; elim H2.\nintros y H1; elim H1.\nintros y H1; elim H1.\nintros y H1; elim H1.\nintros y H2; elim H2.\nintros y H1; elim H1.\nintros y H2; elim H2.\nintros y H2; elim H1.\nintros y H2; elim H2.\nintros y H2; elim H2.\nintros y H3; elim H3.\nintros y H3; elim H4.\nintros y H4; elim H5.\nintros y H4; elim H4.\nintros y H5; elim H5.\nintros y H5; elim H5.\nintros y H5; elim H5.\nintros y H5; elim H6.\nintros y H6; elim H5.\nintros y H6; elim H6.\nintros y H7; elim HQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros.\nunfold P.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros x y H; elim H; auto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintro x.\nintros x y H1 y H2.\napply H1 with y; auto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintro x.\nintro x.\nintro y.\napply H.\napply H.\napply H0.\napply H1.\napply H1.\napply H1.\napply H2.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros.\napply (H y).\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros x y H; elim H; auto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros.\nexact (or_intror (or_introl (or_intror (or_introl (or_introl (or_introl (or_introl (or_introl (or_intror (or_intror (or_introl (or_introl (or_intror (or_introl not_introl (or_introl (or_introl (or_introl not_intror (P Q) H))))) _))))))\n                                        (P (or_intror (or_intror (or_intror (or_intror (or_intror (or_introl (or_intror (or_intror (or_intror (or_introl not_introl (or_introl (or_intror (or_introl not_introl not_introl (or_introl (or_introl (P or_introl not_intror not_intror (or_intror not_intror (or_intror not_intror (or_intror not_intror (or_intror (or_introl not_introl (or_introl not_intror (or_introl not_intror not_intror not_intror (or_introl not_intror not_intror (or_intror not_intror not_intror not_introl (or_intror not_intror not_intror notQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintro x; intro y; apply (H x y); auto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros x y H.\ninversion H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3290,
                "proof_end_offset": 3326,
                "proof": "Theorem tauto1 : A -> A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ulus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 3328,
                "proof_end_offset": 3393,
                "proof": "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "bolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3395,
                "proof_end_offset": 3462,
                "proof": "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\nintro.\napply H.\napply H1.\napply H1.\napply H1.\napply H2.\napply H0.\napply H0.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\nintros x x0 x1 x2.\napply H.\napply H.\napply H0.\napply H0.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3464,
                "proof_end_offset": 3527,
                "proof": "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 3529,
                "proof_end_offset": 3565,
                "proof": "Theorem a4 : ~ A -> ~ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\n",
                "context_tokens": 745,
                "proof_start_offset": 3567,
                "proof_end_offset": 3607,
                "proof": "Theorem e2 : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "amathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3609,
                "proof_end_offset": 3657,
                "proof": "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 3659,
                "proof_end_offset": 3767,
                "proof": "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3769,
                "proof_end_offset": 3823,
                "proof": "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ".\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3825,
                "proof_end_offset": 3883,
                "proof": "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3885,
                "proof_end_offset": 3937,
                "proof": "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "s red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\nTheorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4257,
                "proof_end_offset": 4323,
                "proof": "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "s of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\n",
                "context_tokens": 377,
                "proof_start_offset": 2468,
                "proof_end_offset": 2722,
                "proof": "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.",
                "end_command": "Save Ackermann.",
                "generated_proofs": [
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\napply (le_lt_trans _ _ (S m)).\napply plus_reg_l with (S p).\napply gt_trans with (S m).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S q).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S q).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S q).\napply gt_mult_reg_l with (S p).\napply gt_mult_reg_l with (S p).\napply gt_Save Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p; elim p; simpl in |- *; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\nelim p.\nintros n0 p.\nunfold mkT in |- *.\napply sym_equal.\napply H1.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.Save Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\nunfold zerad in |- *.\nintros n m.\npattern m in |- *.\npattern n in |- *.\napply sym_equal.\napply le_plus_l.\napply le_plus_l.\napply le_plus_r.\napply le_plus_r.\napply le_plus_l.\napply le_plus_r.\napply le_plus_l.\napply le_plus_l.\napply le_plus_l.\napply le_plus_r.\napply le_plus_r.\napply le_plus_l.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_r.\napply le_plus_l.\napply le_plus_l.\napply le_plus_r.\napply le_plus_r.\napply le_plus_l.\napply le_plus_r.\napply le_plus_l.\napply le_Save Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros.\nelim (le_or_eq _ _ H).\nintro.\nelim H.\nauto with arith.\nintro.\nelim H.\nauto with arith.\nauto with arith.\nauto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nintros.\nelim p.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p q.\nelim q.\nintros n m.\nelim q.\nintros n1 m1.\nelim q.\nintros n2 m2.\nelim q.\nintros n1 m2.\nelim q.\nintros n2 m3.\nelim q.\nintros n3 m3.\nelim q.\nintros q1 m3.\nelim q1.\nintros m4.\nelim q1.\nintros n3 m4.\nelim q1.\nintros n4 m4.\nelim q1.\nintros m4 q2.\nelim q1.\nintros m4 q3.\nelim q1.\nintros n4 m5.\nelim q1.\nintros n5 q2.\nelim q2.\nintros n6 q2.\nelim q2.\nintros n6 q3.\nelim q1.\nintros m4 q5.\nelim q2.\nintros n6 q6.\nelim q1.\nintros n6 q6.\nelim q6.\nintros n6 q7.\nelim q5.\nintros m5 q6.\nelim q5.\nintros nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\npattern n in |- *.\napply Zplus_reg_l with (m := p).\nauto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\nelim p.\nintros n m.\nelim (mult_comm (S n) (S m)); auto with arith.\nintros p H'.\nelim (mult_comm (S n) (S m)); auto with arith.\nintros p q H'.\nelim (mult_comm (S n) (S q) q); auto with arith.\nintros p q H'.\nelim (mult_comm (S p) (S q) q); auto with arith.\nintros p q H'.\nelim (mult_comm (S p) (S q) q); auto with arith.\nintros p q H'.\nelim (mult_comm (S q) (S q) q); auto with arith.\nintros p q H'.\nelim (mult_comm (S p) q); auto with arith.\nintros p q H'.\nelim (mult_comm (S q) q); auto with arith.\nintros p q H'.\nelim (mult_comm (S q) q); auto with arith.\nintros p q H'.\nelim (mult_comm (S p) q); auto with arith.\nintros p q H'.\nelimSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p; elim p.\nintros n0 p0 H; elim H.\nintros H0 H1; elim H1; intros H2 H3; elim H3; intros H4 H5; clear H3.\nelim (mult_comm n0 (S p0) (S q0)); auto with arith.\nintros n0 p0 H H1 H2; elim H1; intros H3 H4; elim H4; intros H5 H6; clear H5.\nelim (mult_comm n0 (S p0) (S q0)); auto with arith.\nintros n0 p0 H H1 H2; elim H1; intros H3 H5; elim H5; intros H6 H7; clear H5.\nelim (mult_comm n0 (S p0) (S q0)); auto with arith.\nintros n0 p0 H1 H2; elim H1; intros H4 H5; elim H5; intros H6 H7; clear H5.\nelim (mult_comm n0 (S q0) (S q0)); auto with arith.\nintros n0 p0 H1 H2Save Ackermann."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": " not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\n",
                "context_tokens": 519,
                "proof_start_offset": 3199,
                "proof_end_offset": 3373,
                "proof": "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.",
                "end_command": "Save ack_Ack.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p; elim p; simpl in |- *; auto.\nintros n0 H; elim H; simpl in |- *; auto.\nintros n0 H; elim H; simpl in |- *; auto.\nintros n0 H; elim H; simpl in |- *; auto.\nintros n0 H; elim H; simpl in |- *; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p; elim p; simpl in |- *.\nintros.\nrewrite H; auto.\nrewrite H; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n; simpl in |- *.\nintros.\napply sym_equal.\napply H0.\napply H.\napply H1.\napply H.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.Save ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H H1.\nelim H1; intros.\nelim H1; intros.\nrewrite H2; auto.\n\nintros m' H'; elim H'; intros.\nrewrite H2; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H.\nelim H; intros.\nauto.\nintros m' H'0 H'1.\nelim H'0.\nintro H'2; elim H'2; intros.\nauto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros.\nrewrite H.\nelim H; auto.\nintros m' H'; elim H'; auto.\nintros.\nexists x; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p.\nelim p.\nintro.\napply sym_equal.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H0.\napply H1.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H2.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0Save ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H0; elim H0; intros.\nexists (S m); auto.\nexists (S m); auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n; simpl in |- *; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H2; intros.\nexists x; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nintros n m p H.\nelim H.\nintros.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nauto.\nSave ack_Ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "               *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\nGoal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.\n\n",
                "context_tokens": 554,
                "proof_start_offset": 3375,
                "proof_end_offset": 3606,
                "proof": "Goal forall n m : nat, Ack n m (ack n m).\nProof.\nsimple induction n.\nsimpl in |- *; auto.\nintros n' H; simple induction m.\nsimpl in |- *; auto.\nintros m' H'; apply AckSS with (ack (S n') m'); auto.\napply (H (ack (S n') m')).\nSave Ack_ack.",
                "end_command": "Save Ack_ack.",
                "generated_proofs": [
                    "Goal forall n m : nat, Ack n m (ack n m).\nintros n m p.\nsimple induction 1; simpl in |- *; trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1; elim p1; elim p1; elim p1; elim p2; elim p2; elim p2; elim p2; elim p2; elim p2; elim p1; elim p2; elim p2;\n elim p2; elim p2; elim p3; elim p4; elim p4; elim p4; elim p5;\n elim p5; elim p5; elim p5; elim p5; elim p6; elim p5; elim p6; \n intros.\nauto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n.\nintros n m p.\nauto.\nintros n m p.\nauto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nintros n m p; elim (H n); intros.\nrewrite H; rewrite H; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nintros n m p.\napply (H n); simpl in |- *; trivial.\nintros n0 m p1 ASn Eq; elim Eq; trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m p1 ASn Eq; elim Eq; trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1; elim (H0 1); intros.\nexists (S n1); simpl in |- *; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 ASn Eq1; elim Eq1; trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n1 m1; elim (H 1); intros.\nexists x1; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nintros n m p.\napply (H n); apply H; auto.\nSave Ack_ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\n",
                "context_tokens": 307,
                "proof_start_offset": 1329,
                "proof_end_offset": 1418,
                "proof": "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nautorewrite with base0 using try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ResAck0 : Ack 3 2 = 29.\nrewrite <- (plus_comm (S n) 1).\nrewrite <- plus_assoc.\nrewrite plus_assoc.\nrewrite <- (mult_comm (S n) 1).\nrewrite <- plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite <- plus_assoc.\nrewrite <- plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite <- plus_assoc.\nrewrite plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite (mult_comm (S n) 1).\nrewrite plus_assoc.\nrewrite (mult_comm (S n) 1).\nrewrite (Qed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nreflexivity.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\n\nHint Rewrite ResAck0 : base0.\n\nHint Rewrite lem1 : base0.\n\nLemma lem1 : forall n : nat, ZL2 n = 0.\nintros.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nintros.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\n reflexivity.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nintros.\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nreflexivity.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nintros; apply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S (S n0))).\napply Trans with (S (S (S n0))).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S (S n0))).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S (S n0))).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\napply Trans with (S (S n0)).\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\n\nHint Rewrite ResAck0 : base0.\n\nHint Rewrite <- mult_assoc : base0.\n\nHint Rewrite (mult_comm (Ack0 _ _ _ _ _ _ _ _ _ _ _ _) (mult_comm (Ack0 _ _ _ _ _ _ _) _) (mult_comm (Ack0 _ _ _ _ _) _) (mult_comm (Ack0 _ _ _ _ _) _) _) (mult_comm (Ack0 _ _ _ _) _) (mult_comm (Ack0 _ _ _ _) _) (mult_comm (Ack0 _ _ _ _) _) (mult_comm (Ack0 _ _ _) _) _) (mult_comm (Ack0 _ _ _) _) (mult_comm (Ack0 _ _ _) _) (mult_comm (Ack0 _ _ _) _) (mult_comm (Ack0 _ _) _) (mult_comm (Ack0 _ _ _) _) (mult_comm (Ack0 _ _ _) _) (mult_comm (Ack0 _ _) (mult_comm (Ack0 _ _ _) _)) (mult_comm (Ack0 _ _ _) (mult_comm _ _) (Qed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\n",
                "context_tokens": 462,
                "proof_start_offset": 1725,
                "proof_end_offset": 1826,
                "proof": "Lemma Resg0 : g 1 110 = 100.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  auto.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  simpl; auto with arith.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  intros n; induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  auto with arith.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  rewrite g0.\n  reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1 using try reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\nLemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1828,
                "proof_end_offset": 1927,
                "proof": "Lemma Resg1 : g 1 95 = 91.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "ense, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\n",
                "context_tokens": 352,
                "proof_start_offset": 2584,
                "proof_end_offset": 2664,
                "proof": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nsimple induction b.\nunfold si in |- *.\nauto.\nunfold si in |- *.\nauto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros.\nelim H; intros.\nrewrite H0; auto with arith.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nintro; elim H; reflexivity.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros.\napply (f_equal (fun y : X => y = x)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => y = y)).\napply (f_equal (fun y : Y => yQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\napply b.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n intros X x y.\n case b; auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nintros X x y.\nelim (X_eq x y); auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros.\nunfold si in |- *.\nelim (le_or_lt X (pred y)).\nelim (le_or_lt X (pred y)).\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nauto.\nautoQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction b.\nintros.\napply H.\napply H.\napply H0.\napply H0.\napply H.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H2.\napply H0.\napply H1.\napply H0.\napply H1.\napply H2.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nunfold si; intros X.\nelim X; elim X; elim X; elim X; elim X; elim X; elim X; elim X; elim X; elim X; elim X; elim X; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "                                                *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 373,
                "proof_start_offset": 2666,
                "proof_end_offset": 2747,
                "proof": "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "eceived a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\n",
                "context_tokens": 475,
                "proof_start_offset": 3105,
                "proof_end_offset": 3181,
                "proof": "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n unfold inf_egal in |- *.\n intros m H.\n rewrite H.\n rewrite H.\n apply inf_conv_inv_l with (n := S m); auto with arith.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "rogram; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 3183,
                "proof_end_offset": 3264,
                "proof": "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\n",
                "context_tokens": 501,
                "proof_start_offset": 3267,
                "proof_end_offset": 3361,
                "proof": "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "n                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4026,
                "proof_end_offset": 4088,
                "proof": "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n simple induction l.\n simpl in |- *. split.\n trivial.\n simpl in |- *. split.\n trivial.\n simpl in |- *. split.\n trivial.\n intros. elim H.\n intros. elim H1.\n intros. elim H2.\n intros. elim H2.\n intros. elim H2.\n intros. elim H2.\n intros. elim H2.\n intros. elim H3.\n intros. elim H3.\n intros. elim H3.\n intros. elim H4.\n intros. elim H4.\n intros. elim H5.\n intros. elim H5.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H7.\n intros. elim H7.\n intros. elim H6.\n intros. elim H6.\n intros. elim H6.\n intros. elim H7.\n intros. elim H7.\n introsQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n intro.\n case l.\n intros.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "        *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4090,
                "proof_end_offset": 4181,
                "proof": "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 4183,
                "proof_end_offset": 4343,
                "proof": "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n apply sorted_eq.\n rewrite H.\n reflexivity.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n elim m.\n trivial.\n intros.\n elim m.\n trivial.\n intro.\n elim m.\n trivial.\n intro.\n elim m.\n trivial.\n intro.\n elim m.\n trivial.\n intro.\n elim m.\n trivial.\n intro.\n rewrite H.\n intro.\n elim m.\n trivial.\n intro.\n rewrite H.\n intro.\n rewrite H.\n intro.\n rewrite H0.\n intro.\n rewrite H.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.\n intro.\n rewrite H0.Qed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4504,
                "proof_end_offset": 4577,
                "proof": "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 4579,
                "proof_end_offset": 4724,
                "proof": "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\n",
                "context_tokens": 746,
                "proof_start_offset": 4780,
                "proof_end_offset": 4846,
                "proof": "Theorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nchange (true <> true) with (true <> true); auto with bool.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n unfold not in |- *; auto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\n intro.\n case H.\nintros m H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewriteQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nintros; discriminate.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nunfold not in |- *; intros; discriminate.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\n",
                "context_tokens": 698,
                "proof_start_offset": 4879,
                "proof_end_offset": 5155,
                "proof": "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\nintros.\nrewrite si_eq1.\napply H.\ntrivial.\nintros.\nrewrite si_eq2.\napply H0.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros X P x y b.\ncase (b = false); [ intro H; clear H | idtac ].\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H.\nrewrite H.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0Qed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintro X P.\nelim X.\nintros.\nrewrite (H1 x y b).\nrewrite (H2 x y b).\nrewrite (H2 y b).\nrewrite (H2 y b).\ntrivial.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b.\ncase b; auto.\nintros x0 y0 H1 H2.\ncase b; auto.\nintros x0 y0 H2.\ncase b; auto.\nintros x0 y0 H1 H2.\ncase b; auto.\nintros x0 y0 H1 H2.\ncase b; auto.\nintros x0 y0 H2.\ncase b; auto.\nintros x0 y0 H2.\ncase b; auto.\nintros x1 y0 H2.\ncase b; auto.\nintros x0 y0 H1.\ncase b; auto.\nintros x1 y0 H2.\ncase b; auto.\nintros x0 y0 H2.\ncase b; auto.\nintros x0 y0 H2.\ncase b; auto.\nintros x0 y0 H1 H2.\ncase b; auto.\nintros x1 y0 H2.\ncase b; auto.\nintros x0 y0 H1 H2.\ncase b; auto.\nintros x1 y0 H2.\ncase b; auto.\nintros x1Qed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b.\napply (diff_true_false b); auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b.\ncase (X _ _ _ H); auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b.\ncase (dec b x).\nintro.\ncase (dec b x).\nintro.\nrewrite H1.\ntrivial.\nintros.\ncase (dec b x).\nintro.\nrewrite H1.\ntrivial.\nintros.\nrewrite H1.\ntrivial.\nintros.\nrewrite H1.\ntrivial.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b H.\ncase H.\nintros H1 H2.\nrewrite <- H1 in H1.\nrewrite H2 in H1.\ndiscriminate.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\nrewrite H1.\nrewrite H2.\nrewrite <- H0.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y b.\napply (H (P x y) b).\napply (H (P y b) b).\napply (H (P y b) b).\napply (H (P y b) b).\napply (H (P y b) b).\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite <- H3.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H2.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\n",
                "context_tokens": 728,
                "proof_start_offset": 5197,
                "proof_end_offset": 5481,
                "proof": "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\nintros.\napply False_ind.\napply diff_true_false.\nassumption.\nsimple induction m.\nintro.\ntrivial.\nintros.\nrewrite inf_egal_eq3.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction m.\ntrivial.\nintros.\nrewrite H1.\ntrivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\nintros.\nrewrite H0.\ntrivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\nsimple induction m.\nsimple induction m.\nsimple induction m.\nsimpl in |- *.\nintros.\nrewrite H0.\napply IH.\napply IH.\napply H.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintro n.\ncase (inf_ Resolve inf_true_false_false_false).\nintros.\nrewrite si_intro.\napply le_lt_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans with (m := n); trivial.\nrewrite H1.\napply le_trans withQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n; simpl in |- *; trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintro n.\ncase n; simpl; intros; trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\nintros.\nrewrite H.\napply le_antisym.\napply le_refl.\napply le_refl.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction m.\n simpl in |- *. intros.\nelim H.\n simpl in |- *. intros.\nelim H.\n simpl in |- *. intros.\nelim H0.\n simpl in |- *. intros.\nelim H1.\n simpl in |- *. intros.\nelim H1.\n simpl in |- *. intros.\nelim H1.\n simpl in |- *. intros.\nelim H1.\n simpl in |- *. intros.\nelim H1.\n simpl in |- *. intros.\nelim H2.\n simpl in |- *. intros.\nelim H3.\n simpl in |- *. intros.\nelim H3.\n simpl in |- *. intros.\nelim H3.\n simpl in |- *. intros.\nelim H4.\n simpl in |- *. intros.\nelim H4.\n simpl in |- *. intros.\nelim H4.\n simpl in |- *. intros.\nelim H4.\n simpl in |- *. intros.\nelim H4.\n simpl in |- *. intros.\nelim H4.\n simpl in |- *. intros.\nelim H4.\n simpl in |- *. intros.\nelim H5.\n simpl in |- *. intros.\nelim HQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintros n m H.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; auto.\nintros m IH.\ncase H; autoQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nintro n.\ncase n; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ") (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 5518,
                "proof_end_offset": 5731,
                "proof": "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\nintro.\nunfold sorted in |- *.\ntrivial.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\nintros.\nelim H.\nintros.\nelim H.\nintros.\nrewrite <- H0.\napply H.\napply H0.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n apply nil_ind.\n intros.\n apply H.\n apply H.\n apply H.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\nintro.\napply (H (Cons nat n x)).\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n rewrite H.\n apply lt_irrefl.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\nintro.\napply (H (S x)).\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\nintros.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n apply (H (S n)).\n apply sorted_trans with (Nil nat) (Nil nat) (Nil nat) (Nil nat)).\napply sorted_trans with (Cons nat (Cons nat n x) (Cons nat m x)).\napply sorted_trans with (Cons nat m x).\napply H.\napply H.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\nsimple induction n.\nintros.\nrewrite H0.\napply H.\napply H0.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n intros.\n apply le_trans with (S (S (n + S n))).\n apply sorted_lt.\n apply lt_trans with (S (S (n + S n))) (S (S (n + S n))).\n apply sorted_lt.\n apply lt_trans with (S (n + S n))).\n apply lt_trans with (S (n + S n)).\n apply lt_trans with (S (n + S n)).\n apply lt_le_weak.\n apply lt_trans with (S (n + S n)).\n apply lt_n_S.\n apply lt_n_S.\n apply lt_trans with (S (n + S n)).\n apply lt_O_Sn.\n apply lt_n_S.\n apply lt_trans with (S (n + S n)).\n apply lt_n_S.\n apply lt_trans with (S (n + S n)).\n apply lt_n_S.\n apply lt_le_weak.\n apply lt_le_weak.\n apply lt_trans with (S (n + S n)).\n apply lt_n_SQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\nintros.\ninversion H.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H1.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H.\nintro.\ninversion H0.\nintro.\ninversion H.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H.\nintro.\ninversion H.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H.\nintro.\ninversion H0.\nintro.\ninversion H0.\nintro.\ninversion H.\nintro.\ninversion H.\nintro.\ninversion H.\ninversion H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \n",
                "context_tokens": 719,
                "proof_start_offset": 5734,
                "proof_end_offset": 5910,
                "proof": "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n rewrite app_nil_r.\n apply (H (Cons nat m x)).\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\nintros.\nunfold rev in |- *. trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n rewrite <- H.\n apply (nocc_inf_r x m).\n assumption.\n intro.\ncut (n = m).\n auto.\n case (le_gt_dec n m); auto.\n simple induction m.\n intros.\n rewrite H0.\n apply lt_le_trans with (m := S n).\n assumption.\n apply le_n_S.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\nintros.\nchange (inf_egal n m = true) in |- *.\ndiscriminate.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\n apply H.\n assumption.\nintros.\napply H.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n intros.\napply sorted_trans with (Cons nat (Cons nat m x) (Cons nat m x)).\napply sorted_le; auto.\nsimple induction m.\nintros.\napply H.\n assumption.\nintros.\napply H.\n assumption.\nintros.\napply H.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\nintro.\napply sorted_lt with (Cons nat m x).\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_lt.\napply H.\napply sorted_ltQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\nintros.\napply sorted_lt.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H1.\napply H.\napply H0.\napply H0.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\nintro.\nrewrite sorted_eq.\napply sorted_sym.\napply sorted_trans with (Cons nat m x).\napply sorted_lt.\napply sorted_lt.\napply H.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nsimple induction n.\n simpl in |- *. intros.\nrewrite H0.\napply (le_S_n _ _ H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 6171,
                "proof_end_offset": 6267,
                "proof": "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintros.\napply ins_eq1.\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).\nrewrite <- (nil_ind n).Qed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *. reflexivity.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintros.\nelim n.\nintro.\nrewrite H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.Qed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintro.\nrewrite H.\nrewrite (plus_n_O (Nil nat) 0).\ntrivial.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\nintros.\nrewrite H.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintros n.\nrewrite ins_eq1.\napply ins_eq1.\napply ins_eq1.\napply ins_eq1.\napply ins_eq2.\napply ins_eq2.\napply ins_eq1.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq1.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq1.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_eq2.\napply ins_Qed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n trivial.\nintro.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq2.\nrewrite H.\napply ins_eq2.\nrewrite H.\napply ins_eq2.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq2.\nrewrite H.\napply ins_eq1.\nrewrite H.\napply ins_eq2.\nrewrite H.\napply ins_eq2.\nrewrite H.\napply ins_eq2.\nrewrite H.\napply insQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nintro n.\n intro.\n apply (IH (Nil nat)).\n discriminate.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\n simpl in |- *. trivial.\nintros.\nrewrite H.\napply le_n_S.\napply le_trans with (S (S n0)).\napply le_S_n.\napply le_trans with (S (S (S n0))).\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S (S n0))).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S n0)).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S (S n0))).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S (S n0))).\napply le_n_S.\napply le_n_S.\napply le_trans with (S (S (S n0))).\napply le_n_S.\napply le_trans with (S (S (S n0))).\napply le_n_Qed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nsimple induction n.\nintro.\nrewrite H.\nrewrite (plus_n_O 0).\ntrivial.\nrewrite (plus_n_O 0).\ntrivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 6269,
                "proof_end_offset": 6448,
                "proof": "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite ins_eq1.\n rewrite <- plus_n_Sm.\n rewrite <- plus_n_Sm.\n rewrite <- plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite <- plus_n_Sm.\n rewrite plus_n_Sm.\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n simple induction m.\n simpl in |- *. intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\n intro. discriminate H.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 6573,
                "proof_end_offset": 6640,
                "proof": "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6642,
                "proof_end_offset": 6758,
                "proof": "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\n",
                "context_tokens": 711,
                "proof_start_offset": 6851,
                "proof_end_offset": 7541,
                "proof": "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\nintros.\nrewrite ins_eq1.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\nintro.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\nrewrite sorted_eq3.\nsplit.\napply H2.\napply (sorted_cdr m).\nassumption.\nintro.\nrewrite sorted_eq3.\nsplit.\napply (sorted_inf m x0 l).\nassumption.\napply H.\nassumption.\napply (sorted_cdr m).\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros x n m.\n case m.\n intros.\n rewrite H.\n rewrite H.\n reflexivity.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite H0.\napply H.\napply H.\napply H.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H2.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H0.\napply H0.\napply H1.\napply H2.\napply H2.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H2.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H1.\napply H0.\napply HQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\nelim (lt_or_eq (S m) 0).\nintro.\nelim H1.\nintro.\nrewrite H1.\nrewrite H2.\nrewrite H0.\nrewrite H1.\napply H0.\napply H.\napply H0.\napply H0.\napply H1.\napply H.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H0.\napply H1.\napply H.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\nintros.\nrewrite H0; auto.\nintros.\nrewrite H; auto.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n.\n simpl in |- *.\nintro.\napply le_antisym.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0Qed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n simple induction m.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros x n m H.\nelim (lt_eq_dec n m).\nintros.\napply lt_trans with (S m).\nrewrite <- H.\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nrewrite (plus_comm m).\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintro x; elim x.\nintros.\nrewrite H.\napply (IH (x::m)); auto.\nintros.\nrewrite H.\napply (IH (x::m)); auto.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros.\ncase (le_or_lt n m).\nintro.\nrewrite H.\napply (H (S x)).\nrewrite H.\napply H0.\napply H.\napply H0.\napply H1.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 7543,
                "proof_end_offset": 7836,
                "proof": "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply si_intro.\nintros.\nrewrite sorted_eq3.\nsplit.\nassumption.\nassumption.\nintro.\napply sorted_ins_Cons.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n simpl in |- *.\n   intros.\n   rewrite <- H.\n   apply sorted_ins_lt with (1 := H).\n   simpl in |- *.\n   apply (sorted_sup (Some x)).\n   rewrite sorted_lt_trans.\n   apply H.\n   apply (sorted_sorted_node H).\n   apply H.\n   apply (sorted_sorted_sorted_sorted H).\n   apply H.\n   apply (sorted_sorted_sorted H).\n   apply H.\n   apply (sorted_sorted_sorted H).\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite (sorted_cons (Cons nat m x) x).\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewrite sorted_cons.\n rewriteQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\nintros.\nrewrite ins_eq1.\n rewrite sorted_ord_eq1.\n simpl.\napply sorted_ins_Eq_or with (1 := H).\napply sorted_ins_Eq_or with (1 := H).\napply sorted_ins_Eq_or with (1 := H).\napply sorted_ins_Eq_or with (1 := H).\napply H.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nintro.\nunfold sorted in |- *.\napply sorted_ins_lt with (x := x).\napply sorted_ins_lt with (x := x).\napply sorted_ins_lt with (x := x).\napply (sorted_more_x x).\napply (sorted_more_x x).\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nintros.\ngeneralize x.\ninduction n.\nintro.\nrewrite (IH sorted_lt n m x).\nrewrite (IH sorted_lt n m x).\nintros.\nrewrite (IH sorted_lt n m x).\nintros.\nrewrite (IH sorted_lt n m x).\nrewrite (IH sorted_lt n m x).\nintros.\nrewrite (IH sorted_lt n m x).\nintros.\nrewrite sorted_lt with (S m).\nrewrite sorted_lt with (S m).\nrewrite (IH sorted_lt n m x).\nintros.\nrewrite (IH sorted_lt n m x).\nintros.\nrewrite (IH sorted_lt n m x).\nintros.\nrewrite sorted_lt with (S m).\nrewrite sorted_lt with (S m).\nrewrite (IH sorted_lt n m).\nrewrite (IH sorted_lt n m).\nrewrite (IH sorted_lt n m).\nrewrite (IH sorted_lt n m).\nintros.\nrewrite sorted_lt with (S m).\nrewrite sorted_lt with (S m).\nrewrite (IH sorted_lt n m).\nintros.\nrewrite (Qed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\nintros.\nrewrite sorted_eq3.\nrewrite sorted_eq3.\nrewrite sorted_lt3.\nsplit.\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).\napply sorted_ins_lt with (1 := H).Qed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\nintro.\nrewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq2.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq2.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq2.\n rewrite <- insert_eq1.\n rewrite <- insert_eq2.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq2.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq2.\n rewrite <- insert_eq1.\n rewrite <- insert_eq2.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_eq1.\n rewrite <- insert_Qed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n simpl in |- *.\nintro.\nrewrite <- H.\napply sorted_ins_eq1.\nrewrite sorted_eq3.\nrewrite sorted_lt0.\nrewrite sorted_lt0.\napply H.\napply sorted_ins_eq2.\nrewrite sorted_lt0.\napply (sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted).\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n; auto.\nintros.\nrewrite <- H.\napply sorted_ins_nil.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction n.\n intro.\nunfold sorted in |- *.\n case (le_gt_dec n 0).\n intro.\n rewrite H.\n apply sorted_more_nil.\n assumption.\n intro.\n rewrite H.\n apply sorted_more_nil.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7983,
                "proof_end_offset": 8871,
                "proof": "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\nintro.\nrewrite nocc_eq2.\napply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite (nocc_eq2 n m x).\napply si_intro.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n intros.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewriteQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\nintro.\nrewrite (le_S_n _ _ H1).\napply le_n_S.\napply le_trans with (m := p).\napply le_trans with (m := p).\napply le_n_S.\napply le_trans with (m := p).\napply le_n_S.\napply le_trans with (m := p).\napply le_trans with (m := p).\napply le_plus_le_compat_l.\napply le_trans with (m := p).\napply le_plus_le_compat_l.\napply le_trans with (m := p).\napply le_plus_le_compat_l.\napply le_trans with (m := p).\napply le_plus_le_compat_l.\napply le_trans with (m := p).\napply le_plus_le_compat_l.\napply le_trans with (m := p).\napply le_plus_le_compat_l.\napply le_trans with (m := p).\napply le_plus_le_compat_r.\napply leQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n simple induction n.\n intros.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite H0.\n rewrite HQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\nintro.\nrewrite <- H.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.\napply inv_intro.Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\nauto.\nintros.\nrewrite <- H0.\nrewrite <- H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H1.Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\nintros.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\nintro.\nrewrite H.\napply lt_irrefl with (S (Cons nat m x)).\napply lt_trans with (pred (Cons nat m x)).\napply lt_trans with (pred (Cons nat m x)).\napply lt_plus_l.\napply lt_trans with (pred (Cons nat m x)).\napply lt_n_S.\napply lt_trans with (pred (Cons nat m x)).\napply le_n_S.\napply lt_trans with (pred (Cons nat m x)).\napply lt_S_n.\napply le_trans with (pred (Cons nat m x)).\napply lt_n_S.\napply lt_trans with (pred (Cons nat m x)).\napply lt_n_S.\napply lt_trans with (pred (Cons nat m x)).\napply lt_n_S.\napply lt_trans with (pred (Cons nat m x)).\napply lt_n_S.\napply lt_trans with (pred (Cons nat m x)).\napply lt_n_S.\napply lt_trans with (pred (Cons nat m x)).\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\nintro.\nrewrite H0.\napply lt_n_S.\napply le_n_S.\napply le_trans with (S p).\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_trans with (S p).\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_plus_n_Sm.\napply le_Qed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\nintros.\nrewrite H.\napply Cons_Cons.\napply H.\napply (H0 (Cons nat m x)).\napply H0.\napply H0.\napply Cons_Cons.\napply H0.\napply H.\napply Cons_Cons.\napply H0.\napply (H0 (Cons nat m x)).\napply H0.\napply H0.\napply H0.\napply Cons_Cons.\napply H0.\napply Cons_Cons.\napply H0.\napply H0.\napply Cons_Cons.\napply H0.\napply H0.\napply Cons_Cons.\napply H0.\napply (H0 (Cons nat m x)).\napply H0.\napply Cons_Cons.\napply H0.\napply Cons_Cons.\napply H0.\napply Cons_Cons.\napply H0.\napply H0.\napply Cons_Cons.\napply H0.\napply Cons_Cons.\napply H0.\napply H0.\napply H0.\napply Cons_Cons.\napply H0.\napplyQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nsimple induction n.\n simpl in |- *.\nauto.\nintros.\nrewrite index_eq3.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq2.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1.\nrewrite index_eq1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 8873,
                "proof_end_offset": 9171,
                "proof": "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\nassumption.\nintro.\nrewrite H0.\nsimpl in |- *.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction x.\nintros.\nrewrite (nocc_eq2 n p x).\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.Qed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\nintros.\nrewrite (nocc_eq1 n p x).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq1 n p y).\nrewrite (nocc_eq2 n p y).\napply refl_equal.\napply (H0 (x := nocc_eq1 n p y)).\nrewrite (nocc_eq1 n p y).\napply refl_equal.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\nintro n.\nrewrite (nocc_eq1 n p x).\nrewrite (nocc_eq1 n p x).\nrewrite (nocc_eq2 n p x).\nrewrite (nocc_eq2 n p x).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p x).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nocc_eq2 n p y).\nrewrite (nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq2 n m x).\napply nocc_Cons_Cons_Cons. assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq2 n m x).\napply bin_intro.\nintro.\nrewrite nocc_eq2.\nrewrite (nocc_eq2 n m x).\napply bin_intro.\nrewrite nocc_eq2.\napply (pp_intro n m x).\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq n p (Cons nat m x)).\napply nocc_Cons_Cons_Cons.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq n m x).\napply le_trans with (n := x).\napply le_trans with (n := x).\napply le_trans with (m := x).\napply le_trans with (m := x).\napply le_trans with (m := x).\napply le_trans with (m := y).\napply le_trans with (m := x).\napply le_trans with (m := x).\napply le_trans with (m := y).\napply le_trans with (m := x).\napply le_trans with (m := x).\napply le_trans with (m := y).\napply le_trans with (m := y).\napply le_trans with (m := y).\napply le_trans with (m := y).\napply le_trans with (m := y).\napply le_trans with (m := x).\napply le_trans with (m := y).\napply le_trans with (m := x).\napply le_trans with (m := y).\napply le_trans with (m := y).\napply le_trans with (mQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\nintros.\nrewrite (nocc_eq1 n p x).\nrewrite (nocc_eq1 n p y).\napply Hrec; assumption.\nintro.\nrewrite (nocc_eq2 n p y).\napply Hrec; assumption.\nintro.\nrewrite nocc_eq2.\nrewrite nocc_eq1.\nrewrite H0.\nrewrite H0.\nrewrite (nocc_eq2 n p y).\nrewrite <- (nocc_eq2 n p y).\napply Hrec; assumption.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite H.\nrewrite (nocc_eq2 n p y).\napply Hrec; assumption.\nintro.\nrewrite nocc_eq1.\nrewrite nocc_eq2.\nrewrite H0.\napply sym_equal.\napply H.\napply H.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nocc_eq2 n p y).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (Cons nat m x).\napply (IH (Cons nat m x)).\napply (IH (Cons nat m x)).\napply (Cons nat m x).\napplyQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nsimple induction n.\nintro.\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\napply bin_intro.\nrewrite nocc_eq2.\nrewrite <- H.\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_eq n p).\nrewrite (nocc_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 9173,
                "proof_end_offset": 9520,
                "proof": "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\ntrivial.\nintro.\nrewrite nocc_Cons_Cons.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nocc_eq2 n m x).\napply (nocc_eq2 n m x).\nintro.\nrewrite nocc_eq2.\napply (IH (x + m) n x).\nintro.\nrewrite nocc_eq2.\napply (IH (x + m) n x).\nintro.\nrewrite H0.\n simpl in |- *.\napply eq_S.\napply (IH (x + m) n x).\nintro.\nrewrite H.\nsimpl in |- *.\napply eq_S.\napply (IH (x + m) n x).\nintro.\nrewrite H.\nsimpl in |- *.\napply eq_S.\napply (IH (x + m) n x).\nintro.\nrewrite nocc_eq2.\napply (IH (x + m) n x).\nintro.\nrewrite nocc_eq2.\napply (IH (x + m) n x).\nintro.\nrewrite nocc_eq2.\napply (IH (x + m) n x).\nintro.\nrewrite nocc_eq2.\napply (IH (x + m)Qed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply (H (S n)).\nintro.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\napply H0.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_Cons_Cons.\napply (H (Cons nat m x)).\nintro.\nrewrite <- (nocc_eq2 n m x).\napply (H (Cons nat m x)).\nintro.\nrewrite <- (nocc_eq2 n m x).\nrewrite <- H.\nrewrite (nocc_eq2 n m x).\nrewrite <- H.\nrewrite (nocc_eq2 n m x).\nrewrite H.\napply refl_equal.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply le_lt.\nintro.\nrewrite H0.\nsimpl in |- *.\napply le_n_S.\nintro.\nrewrite nocc_eq1.\napply le_n_S.\nintro.\nrewrite nocc_eq1.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite nocc_eq2.\napply le_n_S.\nintro.\nrewrite noccQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply (nocc_In_cons_Cons_Cons nat m x n).\nintro.\nrewrite H0.\nrewrite H1.\ntrivial.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_cons_Cons.\napply H.\napply (H (Cons nat m x)).\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nocc_eq2 n m x).\nrewrite (nocc_eq2 n m x).\nrewrite (nocc_eq2 n m x).\nrewrite (nocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n m x).\nrewrite (mocc_eq2 n mQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply (nocc_cons_Cons_Cons_Cons_Cons_Cons nat m x).\nintro.\nrewrite nocc_eq1.\nrewrite (nocc_eq2 n m x).\napply refl_equal.\nintro.\nrewrite nocc_eq1.\nrewrite (nocc_eq2 n m x).\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite (nocc_eq2 n m x).\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite (nocc_eq2 n m x).\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite (nocc_eq2 n m x).\napply refl_equal.\nintro.\nrewrite nocc_eq1.\nrewrite (nocc_eq2 n m x).\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite (nocc_eq2 n m x).\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite (nocc_eq2Qed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_Cons_Cons_Cons.\napply (H0 (Cons nat m x)).\nintro.\nrewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nocc_eq2 n m x).\napply (nocc_cons_Cons_Cons_Cons A x (Cons nat m x)) with (n := (Cons nat m x)).\nintro.\nrewrite (nocc_eq2 n m x).\napply (nocc_cons_Cons_Cons A x (Cons nat m x)) with (n := (Cons nat m x)).\nintro.\nrewrite (nocc_eq2 n m x).\napply (mocc_cons_Cons A x (Cons nat m x)) with (n := (Cons nat m x)).\nintro.\nrewrite (nocc_eq2 n m x).\napply (mocc_cons_Cons A x (Cons nat m x) m x).\napply (mocc_cons_Cons A x (Cons nat m x) m x).\nassumption.\napply (mocc_cons_Cons A x (Cons nat m x) m y).\nassumption.\napply nocc_cons_Cons_Cons_Cons A x (Cons nat m x) with (n := (Cons nat m x)).\nintro.\nrewrite (nocc_eqQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 9522,
                "proof_end_offset": 9729,
                "proof": "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite tri_ins_eq2.\nrewrite nocc_ins.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintro.\nrewrite nocc_Cons.\n apply nocc_Cons.\n apply nocc_tl_ins.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\nrewrite (nocc_cons n x).\n trivial.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite H.\n simpl in |- *.\n apply eq_S.\n apply H.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\nrewrite (nocc_eq1 n p (Cons nat m x)).\nrewrite (nocc_eq2 n p (Cons nat m x)).\nrewrite (nocc_eq1 n p (Cons nat m x)).\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply le_trans with (Cons nat m x); trivial.\nrewrite (nocc_eq1 n p (Cons nat m x)).\napply le_trans with (Cons nat m x); trivial.\nrewrite (nocc_eq1 n p (Cons nat m x)).\napply le_trans with (Cons nat m x); trivial.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply le_trans with (Cons nat m x); trivial.\nrewrite (nocc_eq1 n p (Cons nat m x)).\napply le_trans with (Cons nat m x); trivial.\nrewrite (nocc_eq1 n p (Cons nat m x)).\napply le_trans with (Cons nat m x); trivial.\nrewrite (nocc_eq1 n p (Cons nat mQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_cons_nil n).\nintro.\nrewrite (nocc_consQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_Cons_append.\napply nocc_Cons.\napply (H0 (n:=n) H).\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nintros.\nrewrite (nocc_eq n p (Cons nat p x)).\nrewrite (nocc_eq n p (Cons nat p x)).\napply nocc_Cons.\napply nocc_Cons.\napply H.\napply H.\napply (H0 H).\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\nrewrite (nocc_Cons_Cons_Cons x n0 p x).\napply nocc_Cons.\napply nocc_Cons_Cons.\napply H.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\nsimpl in |- *.\napply eq_S.\n apply (pp_intro n (cons n x)).\nintro.\nrewrite nocc_Cons_Cons.\napply nocc_Cons.\napply H.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\nintros.\nrewrite H.\nsimpl in |- *.\napply eq_S.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 10123,
                "proof_end_offset": 10190,
                "proof": "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nintros x.\nrewrite bub)++equation_aux_aux.\napply bub qlist.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bubextensionnalite.\nelim (dec_eq_nat b n).\nintro.\nrewrite H.\nrewrite H.\nrewrite H0.\nsimpl.\nrewrite H.\ntrivial.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nintro.\ncase bub paired_aux with (n := 0).\ntrivial.\nintros.\nrewrite <- H.\nrewrite <- H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.Qed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nintros.\nrewrite bub qlist.\ntrivial.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nintro.\nelim bubseg.\n intro.\n rewrite aubseg_eq1.\n rewrite H.\n simpl in |- *.\n apply lt_O_Sn.\n intro.\n rewrite aubseg_eq1.\n simpl in |- *.\n apply le_S.\n apply le_trans with (a + bubseg_aux l n).\n apply le_S_n.\n apply le_n_S.\n apply le_trans with (a + bubseg_aux l n).\n apply le_S_n.\n apply le_trans with (a + bubseg_aux l n).\n apply le_n_S.\n apply le_n_S.\n apply le_trans with (a + bubseg_aux l n).\n apply le_n_S.\n apply le_trans with (a + bubseg_aux l n).\n apply le_n_S.\n apply le_trans with (a + bubseg_aux l n).\n apply le_n_S.\n apply le_trans with (b + bubseg_aux l n).\n apply le_n_S.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nintro.\nrewrite bupequation.\nrewrite aupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupequation.\nrewrite bupQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction 1.\n trivial.\nintro.\nrewrite <- H.\napply Cons_Cons.\n apply Nil_eq.\napply Nil_eq.\napply Cons_Cons.\napply Cons_Cons.\napply Nil_eq.\napply Cons_Cons.\napply Nil_eq.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply Cons_Cons.\napply ConsQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\ntrivial.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction x.\ntrivial.\nintro.\nrewrite <- H.\ntrivial.\nintros.\nrewrite Cons_eq1.\napply (IH (Cons nat n) l).\nintro.\nrewrite H.\ntrivial.\nintros.\nrewrite Cons_eq2.\napply (IH (Cons nat n) l).\nintro.\nrewrite H.\ntrivial.\nintros.\nrewrite Cons_eq1.\napply (IH (Cons nat n) l).\nintro.\nrewrite H.\ntrivial.\nintros.\nrewrite Cons_eq1.\napply (IH (Cons nat n) l).\nintro.\nrewrite H.\ntrivial.\nintros.\nrewrite Cons_eq2.\napply (IH (Cons nat n) l).\nintro.\nrewrite H.\ntrivial.\nintros.\nrewrite Cons_eq1.\napply (IH (Cons nat n) l).\nintro.\nrewrite H.\ntrivial.\nintros.\nrewrite Cons_eq2.\napply (IH (Cons nat n) l).\nintro.\nrewrite H.\ntrivial.\nintros.\nrewrite Cons_eq1.\napply (IH (Cons natQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nunfold bub casetype.\nintros.\ndestruct x.\napply bubseg.\napply bubseg.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 10192,
                "proof_end_offset": 10301,
                "proof": "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\nintros n.\ncase (bub ZLc_dec n (Nil nat)) as [n| n].\nintro.\nrewrite H.\nsimpl.\nrewrite Cons_Cons.\napply H.\napply (nbsique_ind_aux_aux_aux_aux_aux n 0 n0 (Nil nat) (Cons nat n0 (Cons nat n0 l))).\nsimpl.\nrewrite <- H.\nsimpl.\napply (nbsique_ind_aux_aux_aux n 0 n0 (Cons nat n0 (Cons nat n0 l))).\nsimpl.\nrewrite <- H.\nsimpl.\napply (nbsique_ind_aux_aux_aux n 0 (Cons nat n0 l))).\nsimpl.\nrewrite <- H.\nsimpl.\napply (nbsique_ind_aux_aux_aux n 0 (Cons nat n0 l)).\nsimpl.\nrewrite <- H.\nsimpl.\napply (nbsique_ind_aux_aux n 0 (Cons nat n0 l)).\nsimpl.\nrewrite <- H.\nsimpl.\napply (nbsique_ind_aux_aux n 0 (Cons nat n0 lQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\nintros.\nunfold bubextensionnalite.\nrewrite <- bubextensionnalite.\nelim (dec_eq n b).\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H.\ntrivial.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  apply bubextensionnalite.\n  intro.\n  case (Compare_dec (Nil nat) 0).\n  intros.\n  rewrite H0 in H.\n  discriminate.\n  intro.\n  rewrite H0 in H.\n  discriminate.\n  intro.\n  rewrite H.\n  simpl in |- *.\n  apply le_n_S.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ".\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\n",
                "context_tokens": 682,
                "proof_start_offset": 10302,
                "proof_end_offset": 10522,
                "proof": "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  unfold bubloeb.\n  case (bub Distributed (Cons nat m x)).\n  intros.\n  rewrite (IH (Cons nat m x)).\n  apply bub Hvalidmc_ind with\n    (fun t : list nat => n = m).\n  apply bub)))] with\n    (fun t : list nat => n = m).\n  exact (bub ga) with (n := n).\n  apply bub copyse with (n := n) (b := n).\n  apply bub copyse with (n := m) (a := n) (b := n).\n  apply bub copyse with (n := m) (b := n) (b := n).\n  apply bub copyse with (n := n) (b := n) (b := n) (b := n).\n  apply bub copyse with (n := n) (b := n) (b := n) (b := n) (b := n).\n  apply bub copyse with (n := n) (b := n) (b := n) (b := n).\n  apply bub copyse with (n := n) (b := n) (b := nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nintros.\nunfold bubextensionnalite.\nrewrite bub agre_eq1.\nrewrite bubdistributedcompare2.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubseg.\nrewrite bubQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nintros.\ncase (bub)|(a1|a2|a3]; trivial.\nrewrite b2spnP_eq1.\nrewrite b2spnP_eq2.\napply (bub2016qu) with (a1 := b2).\nrewrite b2spnP_eq1.\napply (bub2016qu) with (b1 := b2).\nrewrite b2spnP_eq2.\napply (bub2016qu) with (b := b2).\nrewrite b2spnP_eq2.\napply (bub2016qu) with (b := b2).\nrewrite b2spnP_eq2.\napply (b2ub2016qu) with (b := b2).\nrewrite b2spnP_eq2.\napply (b2ub2016qu) with (b := b2).\nrewrite b2spnP_eq2.\napply (b2ub2016qu) with (b := b2).\nrewrite b2spnP_eq2.\napply (b2ub2016qu) with (b := b2).\nrewrite b2spnP_eq2.\napply (b2ub2016Qed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nintro n.\ncase (bub Distributed_eq (bub Distributed_eq (bub Distributed (bub Distributed)).\nRequire Import mathcomp.ssreflect.\nFrom mathcomp\nRequire Import ssrfun ssrbool eqtype ssrnat seq div fintype.\nFrom mathcomp\nRequire Import bigop finset prime fingroup morphism perm automorphism quotient action.\nFrom mathcomp\nRequire Import fingroup morphism perm automorphism quotient action zmodp.\nFrom mathcomp\nRequire Import gfunctor gproduct cyclic commutator gseries nilpotent.\nFrom mathcomp\nRequire Import matrix mxalgebra mxrepresentation mxabelem.\nFrom odd_order\nRequire Import BGsection10 BGsection12 BGsection15 BGsection15.\nFrom odd_order\nRequire Import BGsection14 BGsection15 BGsection15 BGsection16 BGsection16.\nFrom odd_order\nRequire Import BGsection15 BGsection16 BGsection15 BGsection16 BGsection16.\n\n(******************************************************************************)\n(*   The order of the Odd Order Theorem, section 3.6, we can use a      *)\n(*   two parts of the Odd Order Theorem, section 5.8.3 (the  *)\n(*   two parts of odd order, the odd order is not used in the      *)\n(*   p-order, p-order (or for odd order). *)\n(*   We now prove that the order of the order of oddQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nintros.\nrewrite bubseg.\nrewrite H.\nrewrite (H (S n)).\nrewrite (H0 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H0 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H2 (S m)).\nrewrite (H1 (S m)).\nrewrite (H2 (S m)).\nrewrite (H1 (S m)).\nrewrite (H2 (S m)).\nrewrite (H2 (S m)).\nrewrite (H0 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H2 (S m)).\nrewrite (H2 (S m)).\nrewrite (H1 (S m)).\nrewrite (H1 (S m)).\nrewrite (H2 (S m)).\nrewrite (H1 (SQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 11196,
                "proof_end_offset": 11281,
                "proof": "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  rewrite fTl_eq1.\n  rewrite fTl_eq1.\n  rewrite (plus_comm (list nat) (fun x : list nat => x)).\n  rewrite (plus_comm (list nat) (fun x : list nat => x)).\n  apply fission_eq1.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros; simpl.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  rewrite <- fusion_eq1.\n  apply fission_eq1.\n  apply H.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  rewrite (fliftGen2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  rewrite <- minus_n_O.\n  apply fTl_eq1.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros; reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  rewrite <- (plus_n_O _ (Nil nat) (Nil nat)).\n  simpl.\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite <- (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).\n  rewrite (plus_n_O _ (Nil nat)).Qed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  destruct ms.\n  reflexivity.\n  simpl.\n  rewrite <- plus_n_O.\n  rewrite <- plus_n_O.\n  simpl.\n  rewrite <- plus_n_O.\n  rewrite <- plus_n_O.\n  rewrite <- plus_n_O.\n  rewrite <- plus_n_O.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nintros.\napply f USA                                                    \nunfold fusion_r; auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nintros.\ninduction ms; simpl; auto.\nintros.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite HQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 11283,
                "proof_end_offset": 11406,
                "proof": "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n intros.\n rewrite (fTl_eq1 (Cons nat n) (Cons nat n (Cons nat n (Cons nat n ns))))\n   with (f:= fun x : list nat => x).\n rewrite (fTl_eq1 (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n n))))))\n   with (f:= fun x : list nat => x).\n rewrite (fTl_eq2 (Cons nat n) (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n)))))\n   (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat n))))))))\n   with (f:= fun x : list nat => x).\nrewrite (fTl_eq1 (Cons nat n) (Cons nat n (Cons nat n (Cons nat n (Cons nat n (Cons nat nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\nLemma fusion_eq2 :\n forall (n : nat) (ns : list nat),\n fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 11408,
                "proof_end_offset": 11665,
                "proof": "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 753,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\n  apply: solvable_trans with (p := 1); auto.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\nintros H1 H2 H3.\neapply H2.\nrewrite <- H2.\nrewrite (andp_comm (local _)).\nrewrite (andp_comm (local _)).\napply andp_left1.\napply andp_left2.\napply andp_left1.\napply andp_left2.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_left1.\napply andp_leftSave solution'_b.",
                    "Goal solvable b.\n\n\nLtac n_le :=\n  apply STC with (Q := n) (Q := n) (Q := n) ; auto with arith.\n\nLtac n_le :=\n  eapply STC with (Q := n) (Q := n) (Q := n) ; auto with arith.\n\nLtac n_le :=\n  match goal with\n  | |- context [ (S?X) ] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X with X\n  | |- context [ (S?X)] => replace X withSave solution'_b.",
                    "Goal solvable b.\nintro H0.\napply: (iffP idP) => [H1 | H1].\napply: (iffP idP) => [H2 | H2].\napply: (iffP idP) => [H3 | H3].\napply: (iffP idP) => [H3 | H4].\napply: (iffP idP) => [H3 | H4].\napply: (iffP idP) => [H4 | H4].\napply: (iffP idP) => [H4 | H4].\napply: (iffP idP) => [H5 | H5].\napply: (iffP idP) => [H5 | H6].\napply: (iffP idP) => [H6 | H6].\napply: (iffP idP) => [H6 | H7].\napply: (iffP idP) => [H7 | H8].\napply: (iffP idP) => [H8 | H9].\napply: (iffP idP) => [H8 | H9].\nby apply: (iffP idP) => [/H8 | H9].\nSave solution'_b.",
                    "Goal solvable b.\nProof.\nintros H1 H2.\npattern b at 1 in |- *.\napply H1.\nsplit.\napply H2.\nsplit.\napply H2.\nsplit.\napply H2.\nsplit.\napply H1.\nsplit.\napply H1.\nsplit.\napply H2.\nsplit.\napply H.\nsplit.\napply H2.\nsplit.\napply H2.\nsplit.\napply H1.\nsplit.\napply H2.\nsplit.\napply H3.\nsplit.\napply H0.\nsplit.\napply H2.\nsplit.\napply H2.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H0.\nsplit.\napply H2.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplit.\napply H3.\nsplitSave solution'_b.",
                    "Goal solvable b.\nProof.\nintros H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H.\napply H0.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\n(* The following: we need to do the use of the following proof, to show that the *)\n(* at least one of the case of the context *)\n\nLemma test_in_range:\n  forall (P : Prop) (b : nat),\n  P b ->\n  ~ P b ->\n  ~ P b.\nProof.\nintros P b H.\n(* The following lemma is done here *)\nassert (H := H0); pose proof (H0 b).\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\nassert (H := H1); pose proof (H2 b).\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(* as H1, H2 *)\n(*Save solution'_b.",
                    "Goal solvable b.\n  apply: (iffP idP) => [nSa |nSa |nSa];\n  apply: (iffP idP) => [nSa |nSa];\n  apply: (iffP idP) => [nSa |nSa];\n  apply: (iffP idP) => [nSa |nSa];\n  apply: (iffP idP) => [[IHa | IHa];\n  apply: (iffP idP) => [[IHa | IHa]];\n  apply: (iffP (IHa _)) => [[IHa] | IHa];\n  apply: (iffP (IHa _)) => [[IHa]];\n  apply: (iffP (IHa _)) => [[IHa] | IHa]];\n  apply: (iffP (IHa _)) => [[IHa] | IHa]];\n  apply: (iffP (IHa _)) => [[IHa]];\n  apply: (iffP (IHa _)) => [[IHa]];\n  apply: (iffP (IHa _)) => [[IHa]];\n  apply: (iffP (IHa _)) => [[IHa]];\n  apply: IHa; apply: IHa; apply: IHa; apply: IHa; apply: IHa; apply: IHa; apply: IHa; apply: IHSave solution'_b.",
                    "Goal solvable b.\nProof.\nintros.\napply: (GREAM (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L := L) (L :=Save solution'_b.",
                    "Goal solvable b.\n\nFail (apply N || apply (H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H || apply H.\n\n(* Check that the second lemma to be given in H and H and H is\n   so that it's also contains the same as the same thing in the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof of the proof ofSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 748,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nintros mic)))))%type.\nassert (is_even_odd_odd micLKSIZE_odd_odd_odd_odd_odd_even_odd_even_odd_even_odd_odd_odd_odd_even_even_even_even_odd_even_odd_even_even_even_even_odd_even_odd_even_odd_even_even_even_odd_odd_odd_even_even_odd_even_even_even_even_even_even_even_even_odd_even_odd_even_even_even_even_even_even_even_even_even_odd_even_even_even_odd_even_odd_even_even_even_odd_even_even_even_odd_even_even_even_even_even_even_even_even_even_odd_even_even_even_even_even_even_even_even_even_even_odd_even_even_odd_even_even_even_odd_even_even_even_even_odd_even_even_even_odd_even_even_even_odd_even_even_evenSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic _))%MSan_2,\n  ~ micularity_1, micinlock_2.\n\n(* The main step is used in the main proof. *)\n(*\nGoal forall G : nat,\n  ~ G \\subset 'N(G) -> G \\subset 'N(G) -> G \\subset 'N(G) -> G \\subset 'N(G) -> G \\subset 'N(G) ->\n  G \\subset 'N(G) -> G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) -> G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subset 'N(G) ->\n  G \\subsetSave microban_1_solution.",
                    "Goal solvable microban_1.\n\nunfold mic pacomult to go mic Prost.\nintros madusing madusing madusing madusing madusing madusing madusing madusing macusing mac.\n\n(* <Warning> : *)\n\nGoal (forall a, In a (madapted to a) -> a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ b = mad \\/ a = mad \\/ b = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ b = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a = mad \\/ a =ad \\/ a =ad \\/ a =ad \\/ a =ad \\/ a = ad.\n\n(* This example was wrong, but the last exampleSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold nia eqn:nia eqn:nia eqn:H.\nmove=> nia; move: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia; move: (nia ltac:(auto)) => nia.\nmove: (nia ltac:(auto)) => nia; move: (niaSave microban_1_solution.",
                    "Goal solvable microban_1.\nintros mic Rabs.\nunfold nicLKSIZE in |- *.\nintros n.\napply STEP with (n:=n); auto.\nintros micRabs.\napply STEP with (n:=n); auto.\nintros micRabs.\napply STEP with (n:=n); auto.\nintros micRabs.\napply STEP with (n:=micRabs) (n:=n); auto.\nintros micRabs.\napply STEP with (n:=nicRabs); auto.\nintros micRabs.\napply STEP with (n:=micRabs).\nsimpl in |- *.\napply Rabs_pos; auto.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic pregan_2 in |- *.\nintros mic'))); simpl in |- *.\napply STEP with (micdexpr); auto.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micinlock_1, mic Prost, mic Prost, mic Prost, mic Prost.\n\n\n(* In this case, we can show that we have a locally closed and then it is not *)\n(* which we need to show that the \"mic\" value!  *)\n\nLtac n :=\n  match goal with\n  | H: context [ mac [<=] _] |- _ =>\n      replace (mac [<=] dom) with (mac [<=] dom) by apply H\n  | H: context [ mac [<=] dom] |- _ =>\n      replace (mac [<=] dom) with (mac [<=] dom) by apply H\n  | H: context [ mac [<=] dom] |- _ =>\n      replace (mac [<=] dom) with (mac [<=] dom) by apply H\n  end.\n\n(*\n\n(* A more general lemma -- the form of the form of the form of the form of the form of the form of the form of the form of the form of the form. *)\nLtac n :=\n  match goal with\n  | H: context [ mac [<=] dom] |- _ =>\n      replace (mac [<=] dom) with (mac [<=] dom) by apply H\n  | HSave microban_1_solution.",
                    "Goal solvable microban_1.\n\nGoal (forall n, n > 0 -> forall m, n > 0 -> exists N, n > 0 /\\ M = 0) ->\n  forall m, n > 0 -> exists N, n > 0 /\\ M = 0.\nProof.\nintros n H0.\napply H.\nintros.\nassert (H1: forall n, n > 0 -> exists N : nat, n > 0 /\\ M = 0).\nintros.\nassert (H2: forall n, n > 0 -> M = 0).\nintros.\napply H1.\nintros.\nassert (H3: forall n, n > 0 -> M = 0).\nintro.\napply H2.\nintros.\nassert (H4: forall n, n > 0 -> M = 0).\nintro.\napply H1.\nintros.\nassert (H4: forall n, n > 0 -> M = 0).\nintro.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic Prost_1, mic tret in |- *.\nintros.\napply H.\n(* Test that the following lemma is not used in the goal. *)\n(* TODO: can be used in this case: *)\napply STEP with (C := M); unfold C in |- *.\napply: (H y); auto.\n(* Test that the following lemma is not used in the goal *)\napply STEP with (C := M); unfold C in |- *.\napply (H y); auto.\n(* Test that the following lemma is used in the goal *)\napply STEP with (C := M); unfold C in |- *.\napply (H y); auto.\n(* Test that the following lemma is used in the goal *)\napply STEP with (C := M); unfold C in |- *.\napply (H y); auto.\n(* Test that the following lemma is used in the goal *)\napply STEP with (C := M); unfold C in |- *.\napply (H y); auto.\n(* Test that the following lemma is used in the goal *)\napply STEP with (C := M); unfold C in |- *.\napply (H y); auto.\n(* Test that the goal is in theSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold nic filtered_leq in |- *.\nsimpl in |- *.\napply: (GisValue_char_on_the_1) (normal_ret_assert FF)).\napply: (GisValue_char_on_the_1).\napply: (GisValue_char_on_the_1).\napply: (GisValue_char_on_the_2).\napply: (GisValue_char_on_the_1).\napply: (GisValue_char_on_the_2).\napply: (GisValue_char_on_the_2).\napply: (GisValue_char_on_the_2).\napply: (GisValue_char_on_the_2).\napply: (GisValue_char_on_the_3).\napply: (GisValue_char_on_the_3).\napply: (GisValue_char_on_the_2).\napply: (GisValue_char_on_the_1).\napply: (GisValue_char_on_the_2).\napply: (GisValue_charSave microban_1_solution."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\n",
                "context_tokens": 356,
                "proof_start_offset": 1314,
                "proof_end_offset": 1504,
                "proof": "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs.\nsimpl.\napply head_insertion.\nsimpl.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n induction xs; simpl; auto.\n intros.\n apply H.\n apply incl_cons with x0; auto.\n apply incl_cons with x0; auto.\n apply incl_cons with x0; auto.\n apply incl_cons with x0; auto.\n apply incl_cons with x0; auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros A x xs.\ninduction xs as [| y xs IHxs].\nsimpl.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\napply cons_app.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\napply cons_app.\nrewrite <- app_ass.\nrewrite <- app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\napply cons_app.\nrewrite <- app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_ass.\nrewrite app_Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n induction xs as [ | x xs IHxs ]; simpl.\n auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n induction xs; simpl; auto.\n inversion_clear H.\n inversion_clear H.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H1.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H0.\ninversion_clear H.\ninversion_clear H0.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n induction xs as [ | x xs IHxs ]; simpl; auto.\n intros.\n inversion_clear H; subst; auto.\n inversion_clear H.\n inversion_clear H0.\n inversion_clear H0.\n inversion_clear H0.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear H1.\ninversion_clear HQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros A x xs.\ninduction xs as [ | a l' IH]; simpl; auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros A x xs.\ninduction xs.\nintro.\nunfold insertion_left.\napply (IH (x::l) (y::l)).\napply (IH (x::l) (y::l)); auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n  intros A x xs.\n  induction xs; simpl; auto with arith.\n  inversion_clear 1.\n  inversion_clear 1.\n  inversion_clear H1.\n  inversion_clear H1.\n  inversion_clear H2.\n  inversion_clear H2.\n  inversion_clear H2.\n  inversion_clear H1.\n  inversion_clear H0.\n  inversion_clear H2.\n  inversion_clear H.\n  inversion_clear H2.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H2.\n  inversion_clear H2.\n  inversion_clear H2.\n  inversion_clear H0.\n  inversion_clear H2.\n  inversion_clear H2.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_Qed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros A x xs.\ninduction xs as [ | y l Hrec x l Hrec y l Hrec y l Hrec y l Hrec y l Hrec y l Hrec y l Hrec x l Hrec x l Hrec x l Hrec y l Hrec y l.\nintros x y l Hrec y l Hrec y l Hrec y Hrec x Hrec y Hrec x l Hrec y Hrec x Hrec y Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y.\nintros x y l Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec x Hrec y Hrec x Hrec y Hrec y Hrec y.\nintros x y Hrec y Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec y Hrec y Hrec y Hrec y.\nintros x y Hrec y Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec y Hrec.\nintros x y Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec y Hrec x Hrec y Hrec y Hrec yQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nintros A x xs H; red in H.\ninversion_clear H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\n",
                "context_tokens": 435,
                "proof_start_offset": 1551,
                "proof_end_offset": 1679,
                "proof": "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\nintros.\ninduction H;simpl;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  induction l.\n  simpl.\n  apply sorted_nil.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sorted_cons.\n  simpl.\n  apply sortedQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros A x l l' H.\n  apply (head_lex_inv A x l' H).\n  apply (head_insertion_in A x l' H).\n  apply (insert_uniq A x l' H).\n  apply (insert_uniq A x l' H).\n  apply (insert_uniq A x l' H).\n  apply (insert_uniq A x l' H).\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  apply (head_insertion_in (x::l) l l' H0).\n  apply (head_insertion_in (x::l') l' H0).\n  apply (head_insertion_in (x::l) l' H0).\n  apply (head_insertion_in (x::l) l' H0).\n  apply (head_insertion_in (x::l') l' H0).\n  apply (head_insertion_in (x::l') l' H1).\n  apply (head_insertion_in (x::l') l' H2).\n  apply (head_insertion_in (x::l) l' H1).\n  apply (head_insertion_in (x::l') l' H2).\n  apply (head_insertion_in (x::l') l' H2).\n  apply (head_insertion_in (x::l') l' H2).\n  apply (head_insertion_in (x::l') l' H2).\n  apply (head_insertion_in (x::l') l' H2).\n  apply (head_insertion_in (x::l) l' H2).Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  induction l.\n  simpl.\n  apply (inf_lex_trans _ _ _ _ _ (lt_irrefl _ l) (x::l')) in H1.\n  apply (inf_lex_trans _ _ _ _ _ (lt_irrefl _ l) (x::l')) in H1.\n  apply (inf_lex_trans _ _ _ _ _ (lt_irrefl _ l) H1).\n  apply (inf_lex_trans _ _ _ _ _ H1).\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  induction l.\n  simpl.\n  apply sorted_nil.\n  simpl.\n  apply sorted_nil.\n  apply sorted_cons.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  Proof.\n    induction l.\n    simpl.\n    apply insert_real.\n    simpl.\n    apply insert_nonnil.\n    simpl.\n    apply insert_nonnil.\n  Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  Proof.\n    induction l.\n    simpl.\n    intros.\n    apply (nil_inv H).\n    simpl.\n    apply (cons_inv H).\n  Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  destruct (greater_dec x l'); auto.\n  destruct (greater_dec x l'); auto.\n  destruct (greater_dec x l'); auto.\n  contradiction.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  apply (inf_']].\n  simpl.\n  apply (inf_)|].\n  simpl.\n  apply (inf_lex x l l' H0).\n  apply (inf_lex x l l' H0).\n  apply (inf_lex x l l' H0).\n  apply (inf_lex x l l' H0).\n  apply (inf_lex x l l' H1).\n  apply (inf_lex x l l' H0 H1).\n  apply (inf_lex x l l' H1).\n  apply (inf_lex x l l' H0 H1).\n  apply (inf_lex x l l' H1 H2).\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  induction l.\n  simpl.\n  auto.\n  intros.\n  destruct (IH l l') as [l' [l'' [H1 H2]].\n  destruct (IH l'' l'' l''' H1 H2) as [l'' [H3 H4]].\n  destruct (IH l'' l''' H4) as [l'' [H4 H5]].\n  exists l''.\n  left.\n  auto.\n  right.\n  auto.\n  right.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\n",
                "context_tokens": 500,
                "proof_start_offset": 1735,
                "proof_end_offset": 1960,
                "proof": "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;simpl;try tauto.\ncase H0;try tauto.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  destruct ( <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=? <=?.\n(** For useful boolean or, right boolean or, right- if and right- if and right- if- <=? <=? <=? <=? <=? <=? <=? <=? <=? <=?.\n\n(** The boolean comparison of boolean comparison (and) are defined in boolean comparison. *)\n\n(** If [x] is defined in a boolean comparison (or) or) or (or) if the comparison) *)\n\n(** IfQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros A x l l' H; induction H.\n  simpl; auto.\n  destruct H; subst.\n  apply (H (y::l')); auto.\n  inversion_clear H; auto.\n  inversion_clear H; auto.\n  inversion_clear H; auto.\n  inversion_clear H; auto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl; firstorder.\n  inversion_clear H.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros A x l l l' H.\n  induction H;simpl;intros; inversion_clear H.\n  destruct (IHlist _ _ H0); auto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl in *.\n  inversion_clear H.\n  destruct (greater_list_dec (x::l')) as [H|H].\n  inversion_clear H.\n  destruct (greater_list_dec (x::l')) as [H|H].\n  inversion_clear H.\n  destruct (greater_list_dec (x::l')) as [H|H].\n  inversion_clear H.\n  destruct (greater_list_dec (x::l')) as [H|H].\n  inversion_clear H.\n  destruct (greater_list_dec (x::l')) as [H|H].\n  inversion_clear H.\n  destruct (greater_list_dec (x::l')) as [H|H].\n  inversion_clear H.\n  destruct (greater_list_dec (x::l')) as [H'|H'].\n  inversion_clear H'.\n  subst.\n  destruct (greater_list_dec (x::l')) as [H'|H'].\n  inversion_clear H'.\n  subst.\n  destruct (greater_list_dec (x::l')) as [H'|H'].\n  inversion_clear H'.\n  subst.\n  destruct (greater_listQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl; tauto.\n  destruct (InA_dec l l'); simpl in *; tauto.\n  destruct (InA_dec l l'); simpl in *; tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H.\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H1 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H1 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H1 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H1 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 y).\n  simpl.\n  apply (H0 yQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl;auto.\n  simpl.\n  apply (IHlist x l l' H0 H2).\n  simpl.\n  apply (IHlist x l' H2).\n  simpl.\n  apply (IHlist x l' H2).\n  simpl.\n  apply (IHlist x l' H2 H0 H1 H2).\n  simpl.\n  apply (IHlist x l' H2 H3 H4).\n  simpl.\n  apply (IHlist x l' H2 H2 H4).\n  simpl.\n  apply (IHlist x l' H4 H2).\n  simpl.\n  apply (IHlist x l' H4 H2 H4).\n  simpl.\n  apply (IHlist x l' H2 H2 H4 H5).\n  simpl.\n  apply (IHlist x l' H4 H5 H1 H4).\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction l.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compare_lex.\n  simpl.\n  apply compareQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros A x l l l' H0; induction H0; simpl in *.\n  apply (inf_lex_dec x l l' H1 H0).\n  apply (inf_lex_dec x l' H1 H1).\n  apply (inf_lex_dec x l' H1).\n  apply (inf_lex_dec x l' H1 H0).\n  apply (inf_lex_dec x l' H1 H2).\n  apply (inf_lex_dec y l' H2).\n  apply (inf_lex_dec x l' H1).\n  apply (inf_lex_dec x l' H1 H2).\n  apply (inf_lex_dec x l' H1 H2).\n  apply (inf_lex_dec x l' H2).\n  apply (inf_lex_dec x l' H2 H1).\n  apply (inf_lex_dec x l' H1 H2).\n  apply (inf_lex_dec x l' H2 H1).\n  apply (inf_lex_dec x l' H1 H2).\n  apply (inf_lex_dec x l' H1 H2).\n  apply (inf_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\n",
                "context_tokens": 603,
                "proof_start_offset": 2029,
                "proof_end_offset": 2310,
                "proof": "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\ninduction l;simpl;try tauto;intros.\ncase H;intro.\nrewrite H0;exists l;apply head_insertion.\nelim (IHl H0);intro l';intro.\nexists (a::l');apply tail_insertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\n  intros; destruct H; simpl in *; tauto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;auto.\n  inversion H; auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;intros.\n  inversion H.\n  inversion H; simpl;try tauto.\n  destruct H0.\n  inversion H; simpl;try tauto.\n  case H0;try tauto.\n  left;auto.\n  inversion H; simpl;try tauto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l.\n  simpl.\n  destruct (Sort_dec A x l'); simpl; tauto.\n  destruct (Sort_dec A x l'); simpl; tauto.\n  right;auto.\n  destruct H0;inversion H0;inversion H1;inversion H2;inversion H2;inversion H3;inversion H3;inversion H4;inversion H3;inversion H4;inversion H4;inversion H4;inversion H4;inversion H4;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5; inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5; inversion H5;inversion H5Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\n  induction l;simpl;intros;simpl;auto.\ndestruct (insert_nonnil_nonnil_nonnil_nonnil_nonnil_nonnil);\nintros;simpl;inversion H;simpl;inversion H0.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\n intros A x l l' H; induction H.\n simpl.\n apply (in_insert_round A x l l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply in_or_app.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H1).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' H0).\n simpl.\n apply (in_insert_round A x l' HQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto.\n  case H;intros;inversion H; simpl;try tauto.\n  case H0;try tauto.\n  left;auto.\n  right;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;intros.\n  inversion H; simpl;auto.\n  inversion H0; simpl;auto.\n  inversion H; simpl;auto.\n  inversion H0; simpl;auto.\n  inversion H0; simpl;auto.\n  inversion H0; simpl;auto.\n  inversion H0; simpl;auto.\n  inversion H0; simpl;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros; apply List.in_map_inv in H; destruct H.\n  destruct H0.\n  exists x;simpl;auto.\n  right;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\n  induction l;simpl;intros.\n  inversion H; simpl; tauto.\n  inversion H; simpl; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "riais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\n",
                "context_tokens": 694,
                "proof_start_offset": 2378,
                "proof_end_offset": 2605,
                "proof": "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\nProof.\nintros.\ninduction H;simpl in H0.\ncase H0;intro H1;try (symmetry in H1);tauto.\ncase H0;simpl;intro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\ninduction l;simpl;try tauto;intros.\ninversion H;clear H;inversion H0;auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\nProof.\n  induction l;simpl;try tauto.\n  case H;intro.\n  rewrite H0;exists l';apply in_cons.\n  rewrite H0;exists l';apply in_or_app;assumption.\n  case H1;intro.\n  rewrite H1;exists l';apply in_or_app;assumption.\n  case H1;intro.\n  rewrite H1;exists l';apply in_or_app;assumption.\n  rewrite H1;exists l';apply in_or_app;assumption.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H1.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H2;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H2;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_or_app.\n  rewrite H2;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_or_app.\n  rewrite H1;exists l';apply in_or_app.\n  rewrite H1;exists l';apply in_or_app.\n  rewrite H2;exists l';apply in_or_app.\n  rewrite H1;exists l';apply in_or_app.\n  rewrite H1;existsQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H0;intros.\n  case H0;intro.\n  rewrite H1;exists l';apply in_cons_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_or_app;apply in_orQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\nProof.\n  induction l.\n  simpl.\n  apply NoDup_nil.\n  intros.\n  apply H0.\n  intros.\n  apply H0.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H0.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H0.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.\n  intros.\n  apply H1.Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l';apply H0;auto.\n  case H0;intro.\n  rewrite H1;exists l';apply H0;auto.\n  rewrite H0;exists l';apply H1;auto.\n  case H0;intro.\n  rewrite H1;exists l';apply H0;auto.\n  rewrite H1;exists l';apply H0;auto.\n  rewrite H1;exists l';apply H1;auto.\n  rewrite H1;exists l';apply H0;auto.\n  rewrite H1;exists l';apply H0;auto.\n  rewrite H0;exists l';apply H1;auto.\n  rewrite H1;exists l';apply H0;auto.\n  rewrite H1;exists l';apply H0;auto.\n  rewrite H0;exists l';apply H0;auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\nProof.\n induction l;simpl;try tauto;intros.\ninversion H; simpl; auto.\ninversion H0; simpl; auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto.\n  case H;intro.\n  rewrite H1;exists l';apply in_cons.\n  destruct H1.\n  rewrite H0;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  rewrite H1;exists l';apply in_cons.\n  apply in_or_app; auto.\n  destruct H1.\n  rewrite H1;exists l';apply in_or_app; auto.\n  destruct H1.\n  rewrite H1;exists l';apply in_or_app; auto.\n  destruct H1.\n  rewrite H1;exists l';apply in_or_app; auto.\n  rewrite H1;exists l';apply in_or_app; auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto.\n  inversion H.\n  destruct H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H2.\n  apply H2.\n  apply H0.\n  apply H2.\n  apply H3.\n  apply H0.\n  apply H0.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H3.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2890,
                "proof_end_offset": 3177,
                "proof": "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\ninduction 1;intros.\ninversion H;trivial.\ninversion H0.\napply cons_is_set.\napply IHinsertion;trivial.\nintro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto.\n  elim (IH l l');intro.\n  rewrite (IH l' H0).\n  elim (IH l');intro H1;inversion H1;intros.\n  rewrite H0;exists l';apply H;apply H;apply H1;apply H1;apply H1;apply H1; auto.\n  rewrite (IH l' H0).\n  elim (IH l');intro H1;inversion H1;intros.\n  rewrite (IH l' H0).\n  elim (IH l');intro H1;inversion H1;intros.\n  rewrite (IH l' H1).\n  elim (IH l');intro H2;inversion H2;intros.\n  rewrite (IH l' H1).\n  elim (IH l');intro H3;inversion H4;intros.\n  rewrite (IH l' H1).\n  elim (IH l');intro H4;inversion H4;intros.\n  rewrite (IH l' H5).\n  elim (IH l');intro H5;inversion H5;intros.\n  rewrite (IH l' H5).\n  elim (IH l');intro H5;inversion H5;intros.\n  rewrite (IH l'Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\ninduction l;simpl;try tauto;intros.\ndestruct H;destruct H0;split;try tauto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\n induction l; simpl; intuition.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H0;intros).\n  rewrite H1;intro.\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H0;intros).\n  rewrite H1;intro.\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H0;intros).\n  rewrite H1;intro.\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H1;intros).\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H1;intros).\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H1;intros).\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H1;intros).\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H1;intros).\n  rewrite H1;intro.\n  inversion H1;clear H1;try (elim H1;intros).\n  rewriteQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\n  induction l; simpl;try tauto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\n induction l;simpl;try tauto;intros;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntry tauto;\ntryQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction l;simpl;try tauto;intros.\n  elim (in_dec (order_non_zero A l));intro H1;intro.\n  rewrite H1;exists (x::l');apply H;apply H0; auto.\n  rewrite H1;exists (y::l');apply H0; auto.\n  rewrite H1;exists (y::l');apply H; auto.\n  rewrite H1;exists (y::l');apply H0; auto.\n  rewrite H2;exists (y::l');apply H0; auto.\n  rewrite H1;exists (y::l');apply H0; auto.\n  rewrite H1;exists (y::l');apply H1; auto.\n  rewrite H1;exists (y::l');apply H0; auto.\n  rewrite H1;exists (y::l');apply H0; auto.\n  rewrite H1; exists (y::l');apply H0; auto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl in H;intros.\n  apply H;apply H0; auto.\n  apply H0; auto.\n  apply H0; auto.\n  apply H0; auto.\n  apply H0; auto.\n  Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction l;simpl;intros.\n  inversion H; simpl in H0;try tauto.\n  case H0;intro H1;try (split;intro;fail);intro H2;inversion H2;inversion H1;trivial).\n  destruct H0;inversion H2;inversion H3;trivial.\n  inversion H0;trivial.\n  destruct H0;inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\ninduction l;simpl;try tauto;\ntry tauto;\n (apply (is_set_ Existential A l l' l');auto).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\n",
                "context_tokens": 713,
                "proof_start_offset": 3243,
                "proof_end_offset": 3575,
                "proof": "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;rewrite <- H3 in H0;inversion H0.\nsimpl in H7;trivial.\nintro.\ncase H10;intro.\napply H9;rewrite H11;eapply insertion_in;apply H5.\nelim (IHl l'0 x H5 H8 H11).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.Qed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  inversion H; auto.\n  inversion H0; auto.\n  inversion H0; auto.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;try tauto;try tauto;try tauto.\n  elim H;intro.\n  apply H0;auto.\n  inversion H;trivial.\n  apply IHl';auto.\n  apply (merge_sorted A l l l');trivial.\n  apply (merge_sorted A l l l');trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\nProof.\n induction l; simpl; intuition.\n inversion H; auto.\n inversion H0.\n inversion H0.\n inversion H1.\n inversion H0.\n inversion H1.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H.\n inversion H0.\n inversion H0.\n inversion H.\n inversion H0.\n inversion H0.\n inversion H.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion HQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction 1;intros.\n  inversion H; auto.\n  inversion H0; auto.\n  inversion H0; auto.\n  inversion H0; auto.\n  inversion H0; auto.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;intros.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H1;trivial.\n  inversion H1;trivial.\n  inversion H1;trivial.\n  inversion H2;trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;intros;try tauto;intros.\n  inversion H;trivial.\n  inversion H0;trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction 1;intros;inversion H;trivial.\n  inversion H0.\n  apply IH sorted;trivial.\n  inversion H0;trivial.\n  apply IH sorted;trivial.\n  inversion H1.\n  apply IH sorted;trivial.\n  inversion H0.\n  apply IH sorted;trivial.\n  apply IH sorted;trivial.\n  apply IHsorted;trivial.\n  apply IHsorted;trivial.\n  apply IHsorted;trivial.\n  apply IHsorted;trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;inversion 1;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.\n  inversion H0;trivial.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\nLemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;rewrite <- H3 in H0;inversion H0.\n  simpl in H7;trivial.\n  intro.\n  case H10;intro.\n  apply H9;rewrite H11;eapply insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\n",
                "context_tokens": 697,
                "proof_start_offset": 4672,
                "proof_end_offset": 5534,
                "proof": "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros;simpl in H.\ndestruct l'.\napply nil_is_permutation.\nelim (H a);intros.\nelim H3;simpl;tauto.\ninversion H0.\nsymmetry in H2;rewrite H2 in H;elim (H a);intros.\nrewrite H2 in H6;rewrite H2.\nassert (In x l');auto.\nelim (in_insertion A x l' H8).\nintro l'';intro.\napply cons_is_permutation with l'';trivial.\napply IHl;trivial.\nsplit;intro.\nelim (H x0);intros.\nelim (in_insertion_inv A x0 x l'' l');auto.\nintro;rewrite H13 in H10;rewrite H2 in H5;tauto.\nelim (H x0);intros.\ncase H12;try tauto.\napply (insertion_inclusion A x l'' l');trivial.\nintro;rewrite <- H13 in H10.\nelim (is_set_insertion_in A l'' l' x);trivial.\neapply is_set_insertion;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros.\ninversion H; auto.\ninversion H; auto.\ninversion H0; auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\ninduction l';simpl;try tauto;try tauto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros.\ninversion H; auto.\ninversion H0.\napply H.\napply H0; auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\ninduction l;intros;simpl in *.\ninversion H; auto.\ninversion H0; auto.\ninversion H0; auto.\ninversion H0; auto.\ninversion H0; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H0; auto.\ninversion H0; auto.\ninversion H0; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H0; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion H1; auto.\ninversion HQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n induction l; intros.\n inversion H; auto.\n inversion H0; auto.\n inversion H0; auto.\n inversion H0; auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros A l l' H.\n  apply (is_set_eq_impl_permutation _ _ _ H).\n  apply is_set_eq_impl_permutation with l.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction l; simpl;intros.\n  inversion_clear H; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0; auto.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  induction l; simpl;intros.\n  inversion H.\n  apply IHis_empty.\n  apply H.\n  apply H.\n  simpl; auto.\n  simpl; auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n induction l; intros.\n inversion H0.\n inversion H0; clear H0; subst.\n inversion H0; clear H0; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H2; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.\n inversion H1; clear H1; subst.Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l; simpl;try tauto.\ndestruct l';inversion H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\n",
                "context_tokens": 732,
                "proof_start_offset": 5571,
                "proof_end_offset": 5760,
                "proof": "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\ninduction l.\napply nil_is_permutation.\neapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros; apply is_permutation_intro; apply is_set_eq_impl_permutation; auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\nintro A;unfold is_permutation; auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros.\n  destruct l.\n  apply nil_is_nil.\n  elim (is_empty_not_empty A l); auto.\n  elim (is_empty_not_empty A l); auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros A l; induction l;intros;simpl in *.\n  apply is_set_eq_impl_sym; auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l;intros;simpl in H.\n  apply (is_empty_not_empty l);trivial.\n  apply (is_empty_not_empty l);trivial.\n  apply (is_empty_not_empty l);trivial.\n  apply (is_empty_not_empty l);trivial.\n  apply (is_empty_not_empty l);trivial.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  induction l;simpl;auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros.\n  apply (is_empty_is_empty A l); trivial.\n  apply is_set_eq_impl_permutation.\n  apply H.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  intros; apply is_set_eq_impl_permutation; apply H.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\nintros A l.\ninduction l;intros;simpl;apply is_equal_impl_permutation;apply H.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\n  unfold is_permutation; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\n",
                "context_tokens": 716,
                "proof_start_offset": 5839,
                "proof_end_offset": 6163,
                "proof": "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\nProof.\ninduction 1.\napply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\napply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H;auto.\n  apply H; auto.\n  apply H0; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H0; auto.\n  apply H0; auto.\n  apply H0; auto.\n  apply H0; auto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H;inversion H;trivial.\n  destruct l'0.\n  apply H0;trivial.\n  apply H1;trivial.\n  apply H1;trivial.\n  apply H0;trivial.\n  apply H1;trivial.\n  apply H1;trivial.\n  apply H1;trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;simpl in *; intros.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0Qed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  intros.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H.\n  simpl.\n  apply H.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H.Qed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  intros.\n  apply (is_permutation_elim (list A) l l');trivial.\n  apply (is_true_or_not_permutation (list A) l l');trivial.\n  apply (is_true_or_not_permutation (list A) l l');trivial.\n  apply (is_true_or_not_permutation (list A) l l');trivial.\n  apply (is_true_or_not_permutation (list A) l l');trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l'.\n  simpl.\n  intros.\n  destruct l'.\n  apply nil_is_permutation.\n  destruct H.\n  apply (H a); trivial.\n  apply (H a); trivial.\n  apply (H0 a); trivial.\n  apply (H a); trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l'.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n Qed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;trivial.\n  inversion H; clear H.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H1; clear H1.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H1; clear H1.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H1; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H1; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear H0.\n  inversion H0; clear HQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  simpl.\n  auto.\n  simpl.\n  intros.\n  destruct (is_split A l l') as [H|H].\n  right;auto.\n  left;auto.\n right;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ".\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\n",
                "context_tokens": 682,
                "proof_start_offset": 6350,
                "proof_end_offset": 6985,
                "proof": "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\nProof.\ninduction 1;intros.\ninversion H.\nexists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\nexists l';split;[trivial | apply head_insertion].\ninversion H0.\nexists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\nelim (IHinsertion l'0 y0 H5);intro l3;intro.\nelim H6;intros.\nexists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  simpl in H.\n  destruct l1.\n  destruct l2.\n  simpl in *.\n  destruct l2.\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct l2.\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l4).\n  simpl in *.\n  destruct l3.\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l3).\n  simpl in *.\n  destruct (is_ass l2 l4).\n  simpl in *.\n  destruct (is_ass l2 l4).\n  simpl in *.\n  destruct (is_ass l2 l4).\n  simpl in *.\n  destruct (is_ass l2 l4Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  simpl in H.\n  destruct l1.\n  simpl in H.\n  destruct l2.\n  destruct l2.\n  simpl in H.\n  destruct l2.\n  simpl in H.\n  destruct H.\n  subst.\n  apply H.\n  simpl in H.\n  assert (In x l).\n  apply (H0 l2).\n  apply (H0 l2).\n  apply (H0 l2).\n  apply (H0 l2).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l1).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l0).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ l2).\n  apply (list_forall _ _ lQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;apply (H a);auto.\n  apply (H a);auto.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  simpl.\n  destruct l1.\n  simpl.\n  destruct l2.\n  simpl.\n  inversion_clear H1.\n  simpl.\n  destruct l2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H1.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl in H2.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl in *.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.\n  inversion_clear H2.\n  simpl.Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  simpl.\n  destruct l1.\n  simpl.\n  destruct l2.\n  apply (IHl1 H0).\n  apply (IHl2 H1).\n  apply (IHl2 H1).\n  apply (IHl2 H1).\n  apply (IHl2 H2).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H;inversion H.\n  destruct l2.\n  simpl.\n  apply (H x).\n  simpl.\n  apply (H0 x).\n  simpl.\n  apply (H x).\n  simpl.\n  apply (H0 x).\n  simpl.\n  apply (H0 x).\n  simpl.\n  apply (H1 x).\n  simpl.\n  apply (H1 x).\n  simpl.\n  apply (H0 x).\n  simpl.\n  apply (H0 x).\n  simpl.\n  apply (H0 x).\n  simpl.\n  apply (H0 x).\n  simpl.\n  apply (H0 x).\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0;intros;simpl in H; inversion_clear H.\n  apply (IH l1 H0 H1).\n  destruct (IH l2 H0).\n  destruct (IH l2 H1).\n  destruct (IH l2 H2).\n  destruct (IH l2 H0).\n  destruct (IH l2 H2).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IH l2 H3).\n  destruct (IHQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0;intros;simpl in H;inversion H.\n  inversion H; clear H; subst.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion HQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0;intros;simpl in H.\n  destruct l0.\n  apply (H l2); auto.\n  apply (H0 l2); auto.\n  apply (H l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H l2); auto.\n  apply (H l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H0 l2); auto.\n  apply (H1 l2); auto.\n  apply (HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\n",
                "context_tokens": 690,
                "proof_start_offset": 7110,
                "proof_end_offset": 7644,
                "proof": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\nProof.\ninduction 1;intros.\ninversion H;inversion H0;apply is_permutation_refl.\ninversion H1.\napply cons_is_permutation with l'';trivial.\napply cons_is_permutation with l';trivial.\nelim (insertion_trans A l' l'' x H0 l3 x0 H2).\nintro l4;intro.\nelim H8;intros.\napply cons_is_permutation with l4;trivial.\neapply IHis_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l1.\n inversion 1.\n inversion 1.\n inversion 1.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l0;intros.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H1.\n inversion H1.\n inversion H1.\n inversion H1.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H1.\n inversion H1.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H1.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0.\n inversion H0Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l0;intros;\n inversion H; inversion H0.\ninversion H0.\ninversion H.\napply (H0 l1 H0).\ninversion H.\ninversion H1.\napply (H0 l2 H0).\ninversion H1.\napply (H0 l2 H1).\ninversion H1.\ninversion H1.\napply (H0 l2 H0).\ninversion H1.\napply (H0 l2 H0).\ninversion H1.\napply (H0 l2 H1).\ninversion H1.\napply (H0 l2 H1).\ninversion H1.\napply (H0 l2 H2).\ninversion H1.\napply (H0 l2 H2).\ninversion H1.\napply (H0 l2 H2).\ninversion H1.\napply (H0 l2 H0).\ninversion H1.\napply (H0 l2 H2).\ninversion H2.\napply (H0 l2 H1).\ninversion H1.\napply (H0 l2 H2).\ninversion H1.\napply (H0 l2 H2).\ninversion HQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l0;intros.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l1;intros.\ninversion H.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H0.\ninversion H.\ninversion H2.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H0.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H3.\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\nProof.\ninduction l1;intros;\ndestruct l1.\ndestruct l2.\napply (IHForall2 H0 l1 H H0).\napply (IHForall2 H0 l2 H0 H1).\napply (IHForall2 H0 l2 H1 H0).\napply (IHForall2 H0 l1 H1 H0).\napply (IHForall2 H0 l2 H1 H1).\napply (IHForall2 H0 l2 H1 H1).\napply (IHForall2 H0 l2 H2 H2).\napply (IHForall2 H0 l1 H2).\napply (IHForall2 H0 l1 H2).\napply (IHForall2 H0 l2 H2 H1).\napply (IHForall2 H0 l2 H2 H2).\napply (IHForall2 H0 l1 H2).\napply (IHForall2 H0 l2 H2 H2).\napply (IHForall2 H0 l2 H2 H2).\napply (IHForall2 H0 l2 H2 H2).\napply (IHForall2 H0 l2 H2 H2 H2).\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l0;intros; inversion H.\ninversion H0; inversion H0; inversion H2; inversion H2; inversion H2; inversion H3; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H6; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversionQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l0;intros;simpl in H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H.\ninversion H0.\ninversion H.\ninversion H0.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H0.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H.\ninversion H0.\ninversion H0Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l0;intros.\ninversion H.\ninversion H0.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H2.\ninversion H3.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H3.\ninversion H4.\ninversion H3.\ninversion H3.\ninversion H4.\ninversion H4.Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l0;intros.\n inversion H.\ninversion H0.\ndestruct l1 as [x0 l1]; destruct l2 as [x2 l2]; simpl in *.\ninversion H.\ninversion H0.\ndestruct l2 as [x2 l2]; simpl in *.\ninversion H.\ninversion H.\ndestruct l1 as [x3 l3]; simpl in *.\ninversion H.\ninversion H0.\ndestruct l1 as [x3 l4]; simpl in *.\ninversion H.\ndestruct l3 as [x4 l4]; simpl in *.\ninversion H0.\ninversion H.\ndestruct l4 as [x5 l5]; simpl in *.\ninversion H0.\ndestruct l4 as [x5 l6]; simpl in *.\ninversion H0.\ninversion H.\ninversion H0.\ndestruct l4 as [x5 l6]; simpl in *.\ninversion H0.\ndestruct l4 as [x5 l6]; simpl in *.\ninversion H0.\ndestruct l4 as [x5 l6]; simpl in *.\ninversion H0.\ninversion H0.\ndestruct l4 as [x5 l6]; simplQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\n",
                "context_tokens": 722,
                "proof_start_offset": 7681,
                "proof_end_offset": 7890,
                "proof": "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\ninduction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\n  induction 1;intros.\n  inversion H;apply is_permutation_trans with l';trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\ninduction 1;intros.\ninversion H;apply is_permutation_refl.\napply H.\napply H0.\napply H1.\napply H1.\napply H0.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\n  induction l;intros.\n  inversion H;clear H.\n  inversion H0;apply is_permutation_trans with l'';assumption.\n  inversion H0;apply is_permutation_trans with l';assumption.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\nunfold is_permutation;intros.\ndestruct (is_permutation_dec A l l'); auto.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction l';intros;auto.\ninversion H;apply is_true_equal;apply is_permutation_sym;trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l;intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  apply (IHal l H0 H0).\n  inversion H0;apply (IHal l H0 H1).\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction 1.\ndestruct l';inversion 1;apply is_permutation_trans with l';trivial.\ndestruct l';inversion 1.\napply (is_permutation_sym l l0 H1).\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\ninduction l;intros.\ninversion H.\napply is_permutation_trans with l';assumption.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H0.\napply H1.\napply H1.\napply H0.\napply H1.\napply H0.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H2.\napply H0.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\napply H0.\napply H0.\napply H0.\napply H0.\napply H1.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\n  induction l;intros.\n  inversion H;apply is_permutation_sym.\n  inversion H0;apply is_permutation_sym.\n  inversion H0;apply is_permutation_sym;apply is_permutation_sym.\n  inversion H1;apply is_permutation_sym;apply is_permutation_sym.\n  inversion H1;apply is_permutation_sym;apply is_permutation_sym;apply is_permutation_sym;apply is_permutation_sym;apply is_permutation_sym; apply H; assumption.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\n  induction l;intros;auto.\n  inversion H;apply is_permutation_trans with l';assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 7892,
                "proof_end_offset": 8346,
                "proof": "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\nProof.\ninduction l;simpl;intros.\ninversion H;simpl;tauto.\ninversion H;simpl.\nsplit;intro.\ncase H5;intro.\neapply insertion_in;rewrite H6 in H4;apply H4.\nelim (IHl l'0 H2 x);intros.\neapply insertion_inclusion;eauto.\ncase (in_insertion_inv A x a l'0 l' H4 H5);intro.\nrewrite H6;tauto.\nelim (IHl l'0 H2 x);intros.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intro.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0;apply is_permutation_trans with l';trivial.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1;apply is_permutation_sym;trivial.\n  inversion H1.\n  inversion H1.\n  inversion H1;apply is_permutation_sym;trivial.\n  inversion H2;apply is_permutation_trans with l';trivial.\n  inversion H2.\n  inversion H1;apply is_permutation_sym;trivial.\n  inversion H1;apply is_permutation_sym;trivial.\n  inversion H2;apply is_permutation_trans with l';trivial.\n  inversion H2;apply is_permutation_sym;trivial.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H;apply H1;apply H2;apply H1;apply H2;apply H1;apply H2;apply H1;apply H2;apply H2;apply H2;apply H1; apply H2;apply H2; apply H1; apply H1; apply H2; apply H1; apply H2; apply H1; apply H2; apply H2; apply H2; apply H2; apply H1; apply H1; apply H2; apply H1; apply H1; apply H2; apply H2; apply H2; apply H1; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H1; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply H2; apply HQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;intros.\n  inversion H;apply is_permutation_sym;apply H0.\n  inversion H0;apply H0.\n  inversion H0;apply H1;apply H1;apply H2;apply H1;apply H1;apply H2;apply H1;apply H2;apply H1;apply H2;apply H2;apply H1;apply H2;apply H2;apply H2;apply H2;apply H2;apply H1;apply H2;apply H2;apply H2;apply H0;apply H1;apply H1;apply H2;apply H2;apply H2; apply H1;apply H1; apply H2;apply H2;apply H0;apply H0;apply H2; apply H2;apply H2; apply H1;apply H0; apply H1; apply H2; apply H1; apply H1; apply H2; apply H2; apply H2; apply H2; apply H2; apply H1; apply H2; apply H2.\n  inversion H0;apply H0;apply H0;apply H0; apply H1;Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H2.\n  inversion H3.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H3.\n  inversion H0.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H3.\n  inversion H0.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H2.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros;apply NoDup_nil;apply is_permutation_sym;apply is_permutation_sym;apply NoDup_nil.\n  apply NoDup_cons_or with l';trivial.\n  apply NoDup_cons_or with l';trivial.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros;apply list_forall;simpl;apply NoDup_nil].\n  apply IHis_permutation with l';trivial.\n  apply IHis_permutation with l';trivial.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H.\n  inversion H0;apply is_permutation_trans with l';trivial.\n  inversion H0.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H0.\n  inversion H0.\n  inversion H1;apply is_permutation_trans with l';trivial.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H3.\n  inversion H4.\n  inversion H0.\n  inversion H4.\n  inversion H0;apply is_permutation_trans with l';trivial.\n  inversion H2.\n  inversion H2.\n  inversion H4.\n  inversion H4.\n  inversion H2.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion HQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H.\n  inversion H;apply is_permutation_trans with l';trivial.\n  inversion H;apply is_permutation_sym.\n  inversion H0.\n  apply IHl;auto.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros;apply is_permutation_trans with l';trivial.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1;intros.\n  inversion H;apply is_permutation_sym;apply (H a);trivial.\n  apply cons_is_permutation with l';trivial.\n  apply (H a);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 8348,
                "proof_end_offset": 8572,
                "proof": "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\nProof.\nintros.\neapply permutation_insertion;eauto.\napply is_permutation_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\n  inversion H; auto.\n  inversion H; simpl; tauto.\n  inversion H0; simpl; tauto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H; inversion H0;apply is_permutation_trans with l';assumption.\n  inversion H0;clear H0;apply is_permutation_trans with l'';assumption.\n  inversion H0;clear H0;apply is_permutation_trans with l'';assumption.\n  inversion H0;clear H0;apply is_permutation_trans with l'';assumption.\n  inversion H0;clear H0;apply is_permutation_trans with l'';assumption.\n  inversion H0;clear H0;apply is_permutation_trans with l'';assumption.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\ninversion H;clear H.\ninversion H0.\napply (IHPermutation H).\ndestruct l' as [l'' H].\neapply list_eq_trans; eauto.\napply H0; auto.\napply (IHPermutation H).\ndestruct l' as [l'' H].\neapply list_eq_trans; eauto.\napply H0; auto.\napply (IHPermutation H0).\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H;auto.\n  inversion H;clear H;auto.\n  inversion H0;clear H;auto.\n  inversion H0;clear H0;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0;auto.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros;try tauto; try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tauto.\n  inversion H0;simpl;try tautoQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\ninduction l;simpl;intros.\n  inversion H;apply is_permutation_sym;assumption.\n  inversion H0;apply is_permutation_sym;assumption.\n  inversion H0;apply is_permutation_sym;assumption.\n  inversion H0;apply is_permutation_trans with l';assumption.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H;auto.\n  inversion H0;clear H0;apply is_permutation_sym;apply is_permutation_sym;apply is_permutation_sym;apply is_permutation_sym;apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply is_permutation_sym; apply H; apply is_permutation_sym; apply H; apply is_permutation_sym; apply is_permutation_sym; apply H; apply is_permutation_sym; apply is_permutation_sym; apply H; apply H; assumption.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H;inversion H;clear H0;apply is_permutation_trans with l';assumption.\n  inversion H;clear H0;apply is_permutation_trans with l';assumption.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H; auto.\n  inversion H0; auto.\n  inversion H0; auto.\n  inversion H0; auto.\n  inversion H0; auto.\n  inversion H0; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 8574,
                "proof_end_offset": 8857,
                "proof": "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\nProof.\nintros.\napply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H.\n  inversion H0;clear H0.\n  inversion H1.\n  inversion H0;clear H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1.\n  inversion H1; clear H1.\n  inversion H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1.\n  inversion H1; clear H1Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction l;simpl;intros.\n  inversion H;clear H0;inversion H0;apply is_permutation_refl.\n  inversion H;clear H0.\n  inversion H0.\n  inversion H0;clear H0;apply is_permutation_refl.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0;apply is_permutation_refl.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\nProof.\n  induction l;simpl;intros.\n  inversion H;clear H.\n  inversion H0;clear H0.\n  inversion H0;clear H0;apply is_permutation_refl.\n  inversion H1;clear H1;apply is_permutation_refl.\n  inversion H1;clear H1;apply is_permutation_refl.\n  inversion H1;clear H1;apply is_permutation_refl.\n  inversion H2;clear H1;apply is_permutation_refl.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n induction l;simpl;intros.\ninversion H.\n inversion H;clear H.\ninversion H.\ninversion H.\napply (IHl H2 H0 H1).\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction l;intros.\n  inversion H;clear H.\n  inversion H0;clear H0;apply is_permutation_sym;trivial.\n  destruct H.\n  exists (a::l');split;[trivial | apply perm_swap].\n  inversion H0;clear H0;apply is_permutation_sym;trivial.\n  eapply list_util.NoDup_cons;apply is_permutation_refl.\n  inversion H0;clear H0;apply is_permutation_refl.\n  inversion H0;clear H0;apply is_permutation_trans with l';assumption.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction l;simpl;intros.\n  inversion H.\n  inversion H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0;apply is_true_not_in;trivial.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion H0;clear H0.\n  inversion HQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H0.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H3.\n  inversion H3.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H3.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversionQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction 1;intros.\n  inversion H;apply is_true_nil in H0;apply H0.\n  inversion H0;apply is_true_nil in H0;apply H0.\n  inversion H1;apply is_true_nil in H0;apply H0.\n  apply H1;apply H0.\n  apply H1;apply H1.\n  apply H1;apply H1;apply H2.\n  apply H1;apply H2.\n  apply H2;apply H1;apply H1.\n  apply H2;apply H2.\n  apply H1;apply H2;apply H1.\n  apply H2;apply H2;apply H2.\n  apply H1;apply H3;apply H1.\n  apply H3;apply H3.\n  apply H3;apply H3.\n  apply H3;apply H3;apply H1.\n  apply H3;apply H3.\n  apply H3;apply H3;apply H4.\n  apply H3;apply H1.\n  apply H4;apply H3.\n  apply H4;apply H3.\n  apply H3;apply H3.\n  apply H3Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction l;intros;inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversionQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction l;simpl;intros.\n  inversion H;clear H.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l'';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l'';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l'';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l'';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n  inversion H0;clear H0;apply is_permutation_trans with l';trivial.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 8859,
                "proof_end_offset": 9031,
                "proof": "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\nProof.\ninduction 1;simpl;trivial.\nrewrite IHinsertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\nProof.\n  induction l;simpl;intros.\n  inversion H; auto.\n  inversion H; auto.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;intros.\n  inversion H.\n  inversion H0;clear H0.\n  inversion H0.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1; clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1; clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversion H1;clear H1.\n  inversionQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;intros.\n  inversion H.\n  inversion H.\n  apply H; clear H.\n  inversion H.\n  apply H.\n  inversion H.\n  apply H0; clear H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  apply H; clear H0.\n  inversion H0; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  inversion H0.\n  apply H; clear H0; apply H; clear H0.\n  apply H; clear H; apply H; clear H; apply H; clear H; apply H; clear H; apply H; clear H; auto.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H;clear H; auto.\n  inversion H0;clear H0; auto.\n  inversion H0;clear H0; auto.\n  inversion H0;clear H0; auto.\n  inversion H0;clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l <= length l') (length l')).\n  intros.\n  inversion H; clear H; subst.\n  inversion H0; clear H0; subst.\n  inversion H; clear H; subst.\n  inversion H0.\n  inversion H; clear H; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear H0; subst.\n  inversion H0; clear HQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H; auto.\n  inversion H; auto.\n  inversion H; auto.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H;clear H;trivial.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H2.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\nProof.\n induction l;intros;unfold elements in *;simpl;auto.\ninversion H;clear H.\ninversion H;clear H.\ninversion H;clear H.\ninversion H0.\ninversion H1.\ninversion H1;clear H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H3Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\nProof.\n  induction l;intros.\n  inversion H; inversion H; apply is_true_ind;auto.\n  inversion H0; clear H0; subst; inversion H0; apply is_true_ind;auto.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;intros.\n  inversion H;clear H; auto.\n  inversion H0;clear H0; auto.\n  inversion H0;clear H0; auto.\n  inversion H0;clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; auto.\n  inversion H0; clear H0; autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 9033,
                "proof_end_offset": 9234,
                "proof": "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\nProof.\ninduction 1;simpl;trivial.\ngeneralize (insertion_length A l' l'' x H0);intro;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (Permutation_length H (length l)).\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H0.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply H0.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Permutation.\n  apply H.\n  apply NoDup_Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;intros;inversion H; auto.\ninversion H; auto.\ninversion H; auto.\ninversion H; auto.\ninversion H; auto.\ninversion H; auto.\ninversion H; auto.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  destruct l;inversion H;clear H.\n  destruct l';inversion H0.\n  destruct l';inversion H0.\n  destruct l';inversion H.\n  destruct l';inversion H1.\n  inversion H1.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H3.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H2.\n  destruct l';inversion H3.\n  destruct l';inversion H2.\n  destruct l';inversion H3.\n  destruct l';inversion H4Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IHStrong;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l';simpl;intros.\n  destruct (is_permutation_prf H).\n  destruct (is_permutation_prf H).\n  destruct (is_permutation_prf H).\n  destruct (is_permutation_prf H).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H1).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H1).\n  destruct (is_permutation_prf H1).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H0).\n  destruct (is_permutation_prf H1).\n  destruct (is_permutation_prf H2Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;intros.\n  rewrite <- H;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IH <=?;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  destruct H;subst;trivial.\n  destruct H;subst;trivial.\n  destruct H;subst;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IH ->]: (length l = length l') by trivial.\n  apply (Permutation_length l).\n  apply Permutation_length.\n  apply (Permutation_length (length l) H0).\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply (Permutation_length l).\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n  apply Permutation_length.\n Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  rewrite IH insertion_length.\n  destruct (is_permutation_iff A l l' H0);intro.\n  apply (IHgreater A l H0 H1);intro.\n  apply (IHgreater A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H0 H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H1);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.\n  apply (IHlist A l' H2);intro.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\nLemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  generalize (insertion_length A l' l'' x H0);intro;congruence.\nQed.\n\n",
                "context_tokens": 705,
                "proof_start_offset": 9236,
                "proof_end_offset": 10306,
                "proof": "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\nProof.\ninduction l;intros;inversion H.\ninversion H0.\napply is_permutation_refl.\nrewrite <- H4;destruct l.\ninversion H8.\ngeneralize (head_insertion A a0 l);intro.\nassert (In x (a0::l)).\neapply insertion_in;apply H8.\ncase (in_insertion_inv A x a0 l (a0::l) H10 H11);intro.\nrewrite H12;rewrite <- H12 in H10;rewrite <- H12 in H8;rewrite <- H12 in IHl.\nassert (is_permutation A l l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nelim (in_insertion A x l H12);intro l2;intro.\ngeneralize (tail_insertion A x a0 l2 l H13);intro.\nassert (is_permutation A (a0::l2) l1).\neapply IHl;eauto.\napply is_permutation_sym;auto.\neapply cons_is_permutation;eauto.\nrewrite H1 in H3.\ninversion H0.\nrewrite <- H9;apply insertion_is_permutation;trivial.\nassert (is_permutation A l0 l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (H l' l'' x H0 H1 H2).\n  apply (H0 l' l'' x H2 H0 H1).\n  Qed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H; auto.\n  inversion H0;clear H0;auto.\n  apply (IHlseg _ _ _ _ H0 l' H2);auto.\n  rewrite (IHlseg _ _ _ _ _ H0);auto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  destruct (IHPermutation _ _ H0 H1 H2);inversion H1.\n  right;apply (IHPermutation _ _ H0 H2 H1).\n  right;apply (IHPermutation _ _ H2 H2 H2).\n  apply (IHPermutation _ _ H1 H2 H2).\n  apply (IHPermutation _ _ H2 H2 H3 H4).\n  apply (IHPermutation _ _ H1 H1 H2 H3 H4).\n  apply (IHPermutation _ _ H1 H2 H4 H0).\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H;clear H; auto.\n  inversion H0;clear H0.\n  inversion H;clear H; auto.\n  inversion H0;clear H0.\n  apply (H x);auto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l;simpl;intros;trivial.\n  simpl;intro.\n  apply (H a H0);intros.\n  apply (H0 a H1);intros.\n  apply (H0 a H1);intros.\n  apply (H a H1);intros.\n  apply (H0 a H2);intros.\n  apply (H1 a H1);intros.\n  apply (H0 a H2);intros.\n  apply (H1 a H1);intros.\n  apply (H a H2);intros.\n  apply (H0 a H2);intros.\n  apply (H1 a H2);intros.\n  apply (H1 a H1);intros.\n  apply (H1 a H1);intros.\n  apply (H0 a H2);intros.\n  apply (H0 a H1);intros.\n  apply (H1 a H2);intros.\n  apply (H0 a H1);intros.\n  apply (H0 a H1);intros.\n  apply (H0 a H1);intros.\n  apply (H1 a H1);intros.\n  apply (H0 a H1);intros.\n  apply (H1 a H1);intros.\n  applyQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;intros;trivial.\n  rewrite IHcal.\n  inversion H0.\n  apply (H0 (list A));auto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;intros.\n  inversion H; inversion H0;clear H0;apply is_permutation_refl.\n  destruct (list_eq_dec l l'); auto.\n  destruct (list_eq_dec l l'); auto.\n  apply (H (list_eq_dec l l')); auto.\n  apply (H (list_eq_dec l l')); auto.\n  apply (H (list_eq_dec l l')); auto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l';simpl;intros.\n  inversion H;clear H;apply (H l');trivial.\n  generalize (H l'' H0);intro;congruence.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H0;clear H0;apply is_permutation_trans with l''; auto.\n  apply (H (list_split _ _ H0) (list_split _ _ _ H1) (list_split _ _ H1));trivial.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l';simpl;intros.\n  inversion H;clear H;intros.\n  inversion H;clear H0;intros.\n  inversion H;clear H0;intros.\n  inversion H;clear H;intros.\n  inversion H;clear H;intros.\n  inversion H;clear H;intros.\n  inversion H;clear H;intros.\n  inversion H;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H;clear H0;intros.\n  inversion H;clear H0;intros.\n  inversion H;clear H0;intros.\n  inversion H;clear H0;intros.\n  inversion H;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion H;clear H0;intros.\n  inversion H0;clear H0;intros.\n  inversion HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "1 l2.\n  generalize l1;clear l1.\n  induction l2;intros.\n  inversion H.\n  inversion H.\n  subst a.\n  subst x0.\n  subst l.\n  subst l2.\n  inversion H0.\n  subst x0.\n  subst l.\n  subst l''.\n  exists l'.\n  tauto.\n  subst x0.\n  subst l'.\n  subst a.\n  subst l1.\n  inversion H0.\n  subst x0.\n  subst l''.\n  subst l0.\n  elim (IHl2 l x H4 l' H3).\n  intro l3;intros.\n  elim H1;clear H1;intros.\n  elim (insertion_trans A l3 l' x H2 l4 y H6).\n  intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 12697,
                "proof_end_offset": 12967,
                "proof": "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\nProof.\nintros.\napply is_permutation_reverse_impl_is_permutation.\nrewrite rev_involutive.\nrewrite rev_involutive.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  inversion H.\n  rewrite <- H2 in H0.\n  apply (IHl l l' l' H0).\n  assumption.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply (is_permutation_or_not_in A l l' H H0).\n  trivial.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  trivial.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_trans.\n  apply H.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_or_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_in_not_not_in_not_in_not_in_not_in_not_in_not_in_not_not_in_not_in_not_not_in_not_in_not_in_not_in_not_not_in_not_not_in_not_not_in_not_not_in_not_not_in_not_not_in_not_not_not_in_not_not_in_not_not_in_not_not_in_not_not_in_not_not_in_not_not_not_in_not_in_not_not_in_not_not_in_not_not_not_in_not_not_in_not_not_not_not_in_not_in_not_not_in_not_notQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  induction l; intros.\n  inversion H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply (is_permutation_elim _ _ _ _ H).\n  apply (is_permutation_elim _ _ _ H0).\n  apply H0.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  induction l.\n  simpl.\n  intros.\n  inversion H.\n  rewrite <- H2.\n  trivial.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.Qed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply (is_permutation_or_not_in A l l' H H H).\n  apply is_permutation_intro.\n  eapply H.\n  apply H0.\n  apply in_or_app_or_not_in_not_in in H0.\n  destruct H0.\n  apply H0.\n  apply in_or_app_or in H0.\n  destruct H.\n  apply H0.\n  eapply in_or_app_or_not_in_not_in in H0.\n  destruct H0.\n  apply H1.\n  eapply H0.\n  eapply in_or_app_or_not_in in H0.\n  destruct H0.\n  apply H0.\n  eapply in_or_app_or_not_in in H0.\n  destruct H0.\n  apply H1.\n  eapply H0.\n  eapply in_or_app_or_not_in in H0.\n  destruct H0.\n  eapply H0.\n  eapply in_or_app_or_not_in in H0.\n  destruct H0.\n  eapply H0.\n  eapply in_or_app_not_in in H0Qed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply (is_permutation_nil_not_in A l l' H).\n  apply (is_permutation_cons A l l' H0).\n  apply (is_permutation_cons A l l' H0).\n  apply (is_permutation_cons A l l' H0).\n  apply (is_permutation_cons A l l' H1).\n  apply (is_permutation_cons A l l' H1).\n  apply (is_permutation_cons A l l' H1).\n  apply (is_permutation_cons A l l' H2).\n  apply (is_permutation_cons A l l' H2).\n  apply (is_permutation_cons A l l' H2).\n  apply (is_permutation_cons A l l' H1).\n  apply (is_permutation_cons A l l' H2).\n  apply (is_permutation_cons A l l' H2).\n  apply (is_permutation_cons A l l' H2).\n  apply (is_permutation_cons A l l' H1).\n  apply (is_permutation_cons A l l' H2).\n  apply (is_permutation_cons A lQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 13186,
                "proof_end_offset": 13460,
                "proof": "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\nProof.\ninduction 1.\nsimpl.\nintros.\napply head_insertion.\nintros.\nsimpl.\napply tail_insertion.\napply IHinsertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (list_append_is_permutation_in (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutation (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutation_in (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutation_in (A:=A) x ss yss).\n  apply (list_append_is_permutation_in (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutation_in (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutation_in (A:=A) x ss yss).\n  intros.\n  apply (list_append_not_is_permutation (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutation (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutation_in (A:=A) x ss yss).\n  intros.\n  apply (list_append_is_permutationQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (list_app_or _ _ _ _ H _ H).\n  apply (list_app_or _ _ _ H).\n  apply (list_app_or _ _ _ H).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (list_app_or_inv_not_in _ _ _ _ _ _ H).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  eapply (is_permutation_or_app_or _ _ _ _ H).\n  apply (is_permutation_reverse_not_in _ _ _ _ H).\n  apply (is_permutation_reverse_not_in _ _ _ H).\n  apply (is_permutation_reverse_not_in _ _ _ H).\n  apply (is_permutation_cons_cons_right _ _ H0).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (list_app_not_notin_or_not_in_left _ _ _ _ _ _ H).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_nil (list (A:=A)) (rev xs ++ rev ys ++ rev ys)).\n  apply (is_permutation_app (list (A:=A)) (rev xs ++ rev ys ++ rev ys)).\n  apply (is_permutation_cons_right (list (A:=A)) (rev xs ++ rev ys ++ rev ys)).\n  apply (is_permutation_cons_right (list (A:=A)) (rev xs ++ rev ys ++ rev ys)).\n  apply (is_permutation_cons_right (list (A:=A)) (rev xs ++ rev ys ++ rev ys)).\n  apply (is_permutation_cons_right (list (A:=A)) (rev xs ++ rev ys ++ rev ys)).\n  apply (is_permutation_cons_right (list (A:=A)) (rev xs ++ rev ys ++ rev ys)).\n  apply (is_permutation_cons_right (list (A:=A)) (rev ys ++ rev ys ++ rev ys ++ rev ys)).\n  apply (is_permutation_app (list (A:=A)) (rev xs ++ rev ys ++ rev ys ++ rev ys)).\n  apply (is_permutation_app_rightQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (list_app_not_is_permutation_l (y::ss)); trivial.\n  apply (list_app_not_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  apply (list_app_not_in_app (y::ss)); trivial.\n  applyQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (H xss xss).\n  apply (H0 xss).\n  apply (H0 yss).\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_right (list:=A)).\n  apply is_permutation_swap.\n  apply (is_permutation_reverse (list:=A)).\n  apply (is_permutation_reverse (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=A)).\n  apply (is_permutation_right (list:=Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_or_is_permutation_l (x::ss) (y::ss))).\n  apply (is_permutation_or_not_in (x::ss) (y::ss)).\n  apply (is_permutation_not_in (x::ss)); assumption.\n  apply (is_permutation_not_in (x::ss)); assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\n",
                "context_tokens": 672,
                "proof_start_offset": 13801,
                "proof_end_offset": 14387,
                "proof": "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\nProof.\ninduction 1;intros.\nexists (cons x0 xs).\nsimpl.\nsplit.\nsubst x;subst l;auto.\napply head_insertion.\ndestruct xs.\ndiscriminate H1.\nsimpl in H1.\ninjection H1;clear H1;intros.\nelim (IHinsertion _ _ _ H0 _ H1).\nintro xss;intros.\nelim H3;clear H3;intros.\nexists (cons a xss).\nsimpl.\nsplit.\nsubst y;subst l';auto.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 3;intros.\n  inversion H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; simpl; intuition.\n  destruct xs.\n  simpl in *.\n  apply H1.\n  inversion H1; clear H1; subst.\n  simpl.\n  eapply H1.\n  inversion H; clear H1; subst.\n  simpl.\n  apply H1.\n  inversion H1; clear H1; subst.\n  apply H1.\n  inversion H1; clear H1; subst.\n  simpl.\n  apply H2.\n  inversion H2; clear H2; subst.\n  simpl.\n  eapply H1.\n  inversion H2; clear H2; subst.\n  simpl.\n  eapply H1.\n  inversion H2; clear H2; subst.\n  simpl.\n  eapply H0.\n  inversion H4; clear H3; subst.\n  simpl.\n  eapply H1.\n  inversion H1; clear H3; subst.\n  simpl.\n  eapply H1.\n  inversion H3; clear H3; subst.\n  simpl.\n  eapply H1.\n  inversion H3; clear H3; subst.\n  simpl.\n  eapply H1.\n  inversion H3; clear H3; subst.\n  simpl.\n  eapply H1.\n  inversion H2; clear H3; subst.Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  apply (H _ H).\n  destruct H.\n  destruct H.\n  destruct H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 2;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  destruct H.\n  inversion H.\n  destruct H.\n  destruct H.\n  simpl.\n  apply H.\n  simpl.\n  apply H0.\n  simpl.\n  apply H.\n  simpl.\n  apply H0.\n  simpl.\n  apply H.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n  simpl.\n  apply H0.\n Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros; inversion H; auto.\n  inversion H1; auto.\n  inversion H2; auto.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros B.\n  induction xs; intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros B.\n  induction xs; intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H3.\n  inversion H2.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H3.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H3.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H3.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4.\n  inversion H4Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros B y ys yss.\n  generalize dependent ys.\n  induction ys; intros.\n  inversion H.\n  inversion H.\n  eapply (IHlseg _ _ _ _ _ _ H H H0).\n  apply H0.\n  inversion H0.\n  eapply (IHlseg _ _ _ _ _ H H0).\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  eapply (IHlseg _ _ _ _ _ H H0).\n  inversion H0.\n  inversion H0.\n  eapply (IHlseg _ _ _ _ _ H0 H0).\n  inversion H0.\n  inversion H0.\n  apply (IHlseg _ _ _ _ H0).\n  inversion H0.\n  inversion H0.\n  apply (IHlseg _ _ _ _ H H0).\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  apply (IHlseg _ _ _ _ H0 H0).\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  apply (IHlseg _ _ _ _ H0 H).\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  apply (IHlseg _ _ _ _ _ H0 HQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1.\n  simpl.\n  intros.\n  inversion H.\n  apply (H (f x)).\n  simpl.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H2.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply HQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 2.\n  simpl.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  destruct H.\n  apply (H xss H0).\n  destruct H0.\n  inversion H0.\n  inversion H0.\n  destruct H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\nLemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\n",
                "context_tokens": 677,
                "proof_start_offset": 14389,
                "proof_end_offset": 15125,
                "proof": "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\nProof.\ninduction 1.\nintros.\ndestruct xs1;try (discriminate H).\nexists (nil (A:=A)).\nsplit.\napply nil_is_permutation.\nreflexivity.\nintros.\ndestruct xs1;try (discriminate H1).\nsimpl in H1.\ninjection H1;clear H1;intros.\nsubst x.\nelim (IHis_permutation _ _ _ H1).\nintro xs2.\nintros.\nelim H2;clear H2;intros.\nsubst l'.\nelim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\nintros.\nelim H3;clear H3;intros.\nexists x.\nsplit;auto.\neapply cons_is_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  assert (H := is_permutation_or_is_permutation B (rev ys1) (rev ys2)).\n  destruct H as [l' [H1 H2]].\n  exists l'.\n  split; auto.\n  destruct (IHl' _ _ _ H2 H2).\n  destruct H as [l'' [H1 H2]].\n  exists l''.\n  split.\n  destruct (IHl' _ _ _ _ H2).\n  destruct H as [l'' [H1 H2]].\n  exists l''.\n  split; auto.\n  destruct (IHl' _ _ _ H2).\n  destruct H as [l'' [H1 H2]].\n  exists l''.\n  split.\n  destruct (IHl' _ _ _ _ H2).\n  destruct H1 as [l'' [H1 H2]].\n  exists l''; split; auto.\n  destruct (IHl' _ _ _ _ H2).\n  destruct H1 as [l''' [H1 H2]].\n  exists l''.\n  split; auto.\n  destruct (IHl' _ _ _ _ H2).\n  destruct H2.\n  exists l''.\n  split.\n  destruct (IHl' _ _ _ H2).\n  destruct H2Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction ys1;intros.\n  destruct ys2.\n  destruct ys1.\n  destruct ys2.\n  destruct ys2.\n  destruct ys2.\n  destruct ys2.\n  destruct ys2.\n  destruct ys3.\n  destruct ys2.\n  simpl.\n  apply (IHlseg_cons_inv _ _ _ _ H2).\n  auto.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction ys1;intros.\n  simpl in *.\n  destruct ys1.\n  destruct ys2.\n  destruct ys2.\n  destruct ys1.\n  destruct ys2.\n  destruct ys2.\n  simpl in *.\n  inversion_clear H3.\n  rewrite <- H0.\n  destruct ys1.\n  destruct ys2.\n  destruct ys2.\n  destruct ys2.\n  simpl in *.\n  inversion_clear H3.\n  rewrite <- H0.\n  destruct ys2.\n  destruct ys1.\n  destruct ys2.\n  inversion_clear H3.\n  rewrite <- H2.\n  destruct ys2.\n  inversion_clear H3.\n  rewrite <- H3.\n  destruct ys2.\n  destruct ys2.\n  simpl in *.\n  inversion_clear H3.\n  rewrite <- H3.\n  rewrite <- H1.\n  destruct ys2.\n  inversion_clear H3.\n  rewrite <- H0.\n  destruct ys2.\n  inversion_clear H3.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite <- H3.\n  simpl.\n  eapply is_permutation_cons.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply HQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros Bxs1 ys2.\n  induction ys1;intros.\n  inversion_clear 1; auto.\n  inversion_clear 1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H0; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H1; auto.\n  inversion_clear H0; auto.\n  inversion_clear H1; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H1; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.\n  inversion_clear H0; auto.Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_app.\n  apply (H (f (xs1 ++ ys2))).\n  apply is_permutation_cons.\n  apply (H (f (xs2 ++ ys2))).\n  apply (H (f (xs2 ++ ys2))).\n  apply (H (f (xs2 ++ ys2))).\n  apply (H0 (f (xs2 ++ ys2))).\n  apply (H1 (f (xs2 ++ ys2)).\n  apply (H0 (f (xs2 ++ ys2))).\n  apply (H0 (f (xs2 ++ ys2)).\n  apply (H0 (f (xs2 ++ ys2)).\n  apply (H0 (f (xs2 ++ ys2)).\n  apply (H0 (f (xs2 ++ ys2))).\n  apply (H1 (f (xs2 ++ ys2)).\n  apply (H0 (f (xs2 ++ ys2))).\n  apply (H1 (f (xs2 ++ ys2)).\n  apply (H1 (f (xs2 ++ ys2)).\n  apply (H0 (f (xs2 ++ ys2))).\n  apply (H0 (f (xs2 ++ ys2))).\n  apply (Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  destruct ys1 as [xs2 ys2].\n  destruct ys2 as [xs3 ys3].\n  destruct ys2 as [ys3 ys3].\n  destruct ys3 as [ys4 ys5].\n  destruct ys3 as [ys4 ys6].\n  destruct ys3 as [ys5 ys6].\n  destruct ys3 as [ys4 ys6].\n  destruct ys3 as [ys5 ys6].\n  destruct ys3 as [ys5 ys7].\n  destruct ys3 as [ys6 ys7].\n  destruct ys4 as [ys8 ys9].\n  destruct ys7 as [ys8 ys9].\n  destruct ys6 as [ys8 ys9].\n  destruct ys7 as [ys8 ys9].\n  destruct ys7 as [ys9 ys9].\n  destruct ys9 as [ys8 ys9].\n  destruct ys9 as [ys9 ys9].\n  destruct ys12 as [ys9 ys12].\n  destruct ys12 as [ys8 ys9].\n  destruct ys12 as [ys8 ys9].\n  destruct ys12 as [ys8 ys9].\n  destruct ys12 as [ys8 ys9].\n  destruct ys9 as [ys8 ys9].Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  destruct ys1.\n  destruct ys2.\n  destruct ys2.\n  destruct ys1.\n  destruct ys2.\n  simpl.\n  split;auto.\n  split;auto.\n  apply incl_nil_l; auto.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  destruct ys1 as [xs2 ys2].\n  destruct ys2 as [ys3 ys3].\n  destruct ys3 as [ys4 ys4].\n  destruct ys4 as [ys5 ys5].\n  destruct ys5 as [ys5 ys6].\n  destruct ys7 as [ys6 ys7].\n  simpl.\n  assert (ys2 = ys2).\n    apply not_true_is_false.\n    apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1;intros.\n  simpl.\n  auto.\n  apply is_permutation_cons_app_nil.\n  apply elements_preserves_permutation_cons.\n  apply H.\n  apply list_app_ass.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  induction ys1;intros.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ")(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 15959,
                "proof_end_offset": 16380,
                "proof": "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\nProof.\ninduction 1.\nexists (nil (A:=A)).\nexists l.\nsplit;try reflexivity.\nelim IHinsertion.\nintro l1.\nintro.\nelim H0.\nintro l2;intros.\nelim H1;clear H1;intros.\nexists (cons y l1).\nexists l2.\nsubst l;subst l'.\nsplit;try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  auto.\n  simpl.\n  intros.\n  destruct l1; try (discriminate H0).\n  right; apply H0.\n  right; apply H0.\n  left; apply H.\n  right; apply H0.\n  apply H1.\n  right; apply H0.\n  right; apply H0.\n  right; apply H0.\n  apply H1.\n  right; apply H0.\n  apply H0.\n  right; apply H0.\n  apply H0.\n  left; apply H1.\n  right; apply H0.\n  right; apply H0.\n  apply H0.\n  right; apply H0.\n  apply H0.\n  right; apply H0.\n  apply H0.\n  left; apply H0.\n  right; apply H0.\n  right; apply H0.\n  right; apply H0.\n  apply H0.\n  right; apply H0.\n  right; apply H0.\n  apply H0.\n  right; apply H0.\n  apply H0.\n  right; apply H0.\n  right; apply H0.\n  apply H0.\n  right; apply H0.\n  apply H0.\n  right; apply HQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1;intros;inversion 1; subst; auto.\n  inversion H0; subst.\n  apply (H a); auto.\n  inversion H0; subst; auto.\n  apply (H a); auto.\n  inversion H0; subst; auto.\n  apply (H a); auto.\n  inversion H0; subst; auto.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  simpl; auto.\n  induction 1.\n  simpl.\n  exists x.\n  exists (cons x l2).\n  simpl; auto.\n  apply IHis_permutation_set.\n  apply H1.\n  apply H1.\n  apply (H x).\n  apply H2.\n  apply H2.\n  apply (H x).\n  apply H2.\n  apply H2.\n  apply (H x).\n  apply H2.\n  apply H2.\n  apply (H x).\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply (H x).\n  apply H0.\n  apply (H x).\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply (H x).\n  apply H3.\n  apply H3.\n  apply H3.\n  apply (H x).\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply (H x).\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply (H xQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  auto.\n  intros.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H1.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear HQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists l'.\n  exists (l1 ++ l2).\n  exists l'.\n  split.\n  apply list_length_is_permutation.\n  apply H.\n  destruct (list_length_is_not_in _ _ _ H0).\n  apply H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  applyQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1;intros.\n  inversion H.\n  inversion H.\n  subst x;\n  inversion H0.\n  exists x;\n  split; auto.\n  inversion H.\n  inversion H0.\n  eapply insertion_app; eauto.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  apply nil_is_permutation_set.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H2.\n  apply H1.\n  apply H0.\n  apply H2.\n  apply H3.\n  apply H0.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H0.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1; auto.\n  destruct l'.\n  inversion H1; subst.\n  apply (IHis_permutation_set (x:=A)).\n  apply H.\n  apply IHl'.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  intros; apply (H x); apply H; auto.\n  apply H0; auto.\nQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  simpl.\n  destruct l1.\n  exists l2.\n  destruct l2.\n  destruct l1.\n  destruct l2.\n  destruct l2.\n  simpl.\n  apply (IHis_not_nil (x::l2)).\n  simpl.\n  apply is_permutation_set.\n  apply H1.\n  apply H3.\n  apply H3.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\nLemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists (nil (A:=A)).\n  exists l.\n  split;try reflexivity.\n  elim IHinsertion.\n  intro l1.\n  intro.\n  elim H0.\n  intro l2;intros.\n  elim H1;clear H1;intros.\n  exists (cons y l1).\n  exists l2.\n  subst l;subst l'.\n  split;try reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 16382,
                "proof_end_offset": 16713,
                "proof": "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\nProof.\ninduction 1.\napply perm_nil.\nelim (insertion_append_decompose _ _ _ _ H0).\nintro l1;intros.\nelim H1.\nintro l2;intros.\nelim H2;clear H2;intros.\nsubst l';subst l''.\napply Permutation_cons_app.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists (l::l').\n  split;try assumption.\n  exists l;try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  inversion 1.\n  exists l;try assumption.\n  inversion 1.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversion 1.\n  exists l';try assumption.\n  exists l';try assumption.\n  inversionQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  auto.\n  destruct l' as [l1 l2].\n  exists l2.\n  split;auto.\n  destruct H.\n  destruct l' as [l1 l2].\n  exists l2.\n  split;auto.\n  destruct H.\n  destruct H.\n  destruct l' as [l1' l2].\n  exists l1'.\n  split;auto.\n  destruct (IHl1 _ H0).\n  exists l1'.\n  split;auto.\n  destruct H.\n  destruct H.\n  destruct H.\n  destruct H0.\n  destruct H0.\n  split;auto.\n  destruct H0.\n  destruct H1.\n  split;auto.\n  right.\n  apply H3.\n  auto.\n  destruct H0.\n  split;auto.\n  destruct H0.\n  destruct H0.\n  split;auto.\n  destruct H0.\n  destruct H0.\n  split;auto.\n  destruct H0.\n  split;auto.\n  destruct H0.\n  destruct H1.\n  split;auto.\n  destruct H1.\n  split;auto.\n  apply H3.\n  auto.\n  apply H3.\n  auto.\n  auto.\n  apply H3.\nQedQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists (l::l').\n  exists (l::l').\n  split;try reflexivity.\n  elim IHwp.\n  intro l2.\n  elim (in_or_app l2 l2); intros.\n  elim H1;clear H1;intros.\n  exists (l::l2).\n  split;try reflexivity.\n  elim IHwp.\n  intro l2.\n  elim H1;clear H1;intros.\n  exists l2.\n  split;try reflexivity.\n  elim (in_or_app l2 l1); intros.\n  elim (in_or_app l2 l2); intros.\n  elim H1;clear H1;intros.\n  exists (l::l2).\n  split;try reflexivity.\n  elim IHwp.\n  intro l2.\n  elim H1;clear H1;intros.\n  exists (l::l2).\n  split;try reflexivity.\n  elim (in_or_app l2 l1); intros.\n  elim H1;clear H1;intros.\n  exists (l::l1).\n  split;try reflexivity.\n  elim (in_or_app l2 l2); intros.\n  elim (in_Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  intro l'.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists (l++l').\n  split.\n  exists (l++l').\n  split;try reflexivity.\n  exists l';apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_not_nil.\n  apply permut_cons_Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists l'.\n  split;try reflexivity.\n  exists l.\n  exists l'.\n  split;try reflexivity.\n  exists l.\n  split;try reflexivity.\n  destruct l'0;try reflexivity.\n  exists l.\n  split;try reflexivity.\n  destruct l'0;try reflexivity.\n  destruct l'0;try reflexivity.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists (l' ++ l').\n  split;try reflexivity.\n  elim IHStrict.\n  intro l'.\n  elim (IHl l' H0 H1).\n  intro l2.\n  elim (IHl l' H1).\n  intro l2.\n  elim (IHl l2 H2).\n  intro l3.\n  apply H3.\n  apply H3.\n  apply Permutation_app_not_nil.\n  apply H3.\n  apply Permutation_app_not_nil.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.\n  apply Permutation_app_not_cons.\n  apply Permutation_sym.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  destruct l' as [l' l'].\n  exists l'.\n  split;try reflexivity.\n  elim IHStrong.\n  intro l'.\n  elim (IHStrong l l'); intros.\n  elim (IHStrong l l'); intros.\n  elim (IHStrong l l'); intros.\n  elim (IHStrong l l'); intros.\n  elim (IHStrong l l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elim (IHStrong l'); intros.\n  elimQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply (permut_not_Permutation l l l'); trivial.\n  destruct 1.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  apply Permutation_app_comm.\n  applyQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  auto.\n  intros.\n  exists (list A).\n  exists l'.\n  split.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_appQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_lemma1; auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nintros.\napply mult_integral_l with (n := n) (n := n) (n := n) (n := n) (n := n); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_le_compat_l.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nsimple induction n.\nintro.\napply mult_lemma1.\nauto with arith.\nintros.\napply mult_lemma1.\nauto with arith.\nintros.\napply mult_lemma1.\nauto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n rewrite mult_comm.\n rewrite mult_1_r.\n rewrite mult_1_l.\n rewrite mult_1_r.\n reflexivity.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nintros n m H.\nelim (mult_integral _ _ _ H).\nintros m H.\nelim (mult_integral _ _ _ H).\nintros m H1.\nelim (mult_integral _ _ _ H1).\nintros m H2.\nrewrite mult_comm.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\nrewrite <- mult_plus_distr_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\napply mult_le_compat_r.\nrewrite <- mult_plus_distr_r.\napply mult_Qed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros n m.\n rewrite mult_comm.\n apply mult_le_compat_l.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nsimple induction n; simple induction m; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nintros.\ngeneralize (mult_comm n m).\nelim n.\nintro.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\napply mult_comm.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n apply mult_lemma1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite mult_assoc.\n  rewrite plus_comm.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m) (n * m)).\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m) (n * m)).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m) (n * m)).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m) (n * m)).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m) (n * m)).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m) (n * m)).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m)).\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_commQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewriteQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_l.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_commQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (n * m) (n * m)).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite <- mult_plus_distr_r.\n  rewrite (mult_comm n m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite mult_assoc.\n  rewrite <- mult_plus_distr_r.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply multlemma2.\n  apply multQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n intros.\n rewrite mult_comm.\n reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  rewrite <- plus_comm.\n  rewrite plus_assoc.\n  rewrite <- plus_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite <- plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite <- mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma3.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma2.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma1.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply multlemma3.\n  apply mult_lemma3.\n  apply multQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma3; auto with arith.\n  apply mult_lemma1; auto with arith.\n  apply mult_lemma3; auto with arith.Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply multlemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply multlemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemmaQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  elim H.\n  simpl in |- *.\n  intros.\n  elim H0.\n  simpl in |- *.\n  intros.\n  inversion H0.\n  simpl in |- *.\n  intros.\n  inversion H.\n  simpl in |- *.\n  intros.\n  inversion H1.\n  simpl in |- *.\n  apply mult_lemma1.\n  apply H.\n  apply H.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  apply mult_lemma3.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  destruct n;simpl in H.\n  left.\n  apply mult_lemma1.\n  elim H1;intro.\n  right;trivial.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma1.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma1.\n  apply mult_lemma2.\n  apply mult_lemma3.\n  apply mult_lemma1.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply multlemma3.\n  apply mult_lemma3.\n  apply multlemma3.\n  apply multlemma3.\n  apply mult_lemma3.\n  apply multlemma3.\n  apply multlemma3.\n  apply multlemma3.\n  apply multlemma3.\n  apply multlemma3.\n  applyQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  elim H; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  right; left.\n  assumption.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma3.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\n",
                "context_tokens": 502,
                "proof_start_offset": 1721,
                "proof_end_offset": 2052,
                "proof": "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\nProof.\nintros n m.\ncase n.\nleft;trivial.\nintros.\nright.\ndestruct m.\nrewrite mult_comm in H.\ndiscriminate.\ndestruct m;trivial.\nassert ((S n0)<(S n0)*(S (S m))).\napply mult_lemma3;intros;auto with arith.\nrewrite <- H in H0.\nelim (lt_irrefl (S n0) H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  destruct m.\n  left.\n  apply mult_lemma1.\n  left.\n  apply mult_lemma1.\n  apply mult_lemma4.\n  apply mult_lemma4.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma3.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  omega.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm in H.\n  apply mult_lemma4.\n  assumption.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\nProof.\n  intros.\n  rewrite mult_comm.\n  destruct m.\n  simpl in H.\n  elim H0.\n  left; auto.\n  right.\n  assert (m = 0);try omega.\n  destruct m.\n  simpl in H.\n  elim H.\n  right.\n  split.\n  simpl.\n  trivial.\n  rewrite <- H0.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  inversion H.\n  simpl in H0.\n  assert (m = m).\n  auto with arith.\n  inversion H0.\n  simpl in H.\n  rewrite mult_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl in H.\n  left.\n  apply mult_lemma1;auto.\n  apply mult_lemma2;auto.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\n",
                "context_tokens": 628,
                "proof_start_offset": 2054,
                "proof_end_offset": 2503,
                "proof": "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\nProof.\ninduction n;simpl;intros;try discriminate.\ninduction m.\nrewrite mult_comm in H.\nsimpl in H;discriminate.\nassert ((S n)<=((S n)*(S m))).\napply mult_lemma1;discriminate.\nassert (((S n)*(S m))=((S m)+n*(S m))).\nreflexivity.\nrewrite H1 in H0.\nrewrite H in H0.\nassert ((S n)=1).\nomega.\nsplit;trivial.\ninversion H2.\nrewrite H4 in H.\nsimpl in H.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  apply mult_lemma1;intros;auto with arith.\n  apply mult_lemma1;intros;auto with arith.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  trivial.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  trivial.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  trivial.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm in H.\n  rewrite mult_comm in H.\n  apply mult_lemma4;intros;auto with arith.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm in H.\n  rewrite mult_comm in H0.\n  apply mult_lemma4;intros;auto with arith.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  trivial.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm in H.\n  apply mult_lemma3;intros;auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2505,
                "proof_end_offset": 2662,
                "proof": "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\ninduction y;intros;rewrite plus_comm;simpl.\nauto with arith.\nrewrite plus_comm.\napply IHy.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite plus_comm in H.\n  apply plus_minus_lemma1;assumption.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite plus_comm in H.\n rewrite <- plus_comm in H.\n rewrite <- plus_comm in H.Qed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite mult_comm in H.\n  destruct (plus_eq_dec y x).\n  left;trivial.\n  right;apply mult_integral_zero_pos;trivial.\n  right;apply mult_integral_zero_pos;trivial.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n rewrite plus_comm.\n trivial.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  apply plus_minus_lemma3;assumption.\n  auto with arith.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  destruct (plus_lemma1 y x) as (y,Hy).\n  destruct (plus_lemma1 y y) as (y',Hy').\n  destruct (plus_lemma1 y y') as (y'',Hy').\n  destruct (plus_lemma2 y'' y'') as (y'',Hy'').\n  destruct (plus_lemma1 y'' y'') as (y'',Hy'').\n  rewrite Hy''''.\n  rewrite Hy''.\n  rewrite Hy''.\n  rewrite Hy''.\n  auto with arith.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n rewrite plus_comm.\n replace (S x)*(S y)*(S x)*(S y)*(S x)).\n apply plus_le_compat_r.\n assumption.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n destruct y; simpl;intros.\nrewrite plus_comm in H.\nsimpl in H.\n discriminate.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n  intros.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_Qed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n intros.\n  rewrite plus_comm in H.\n  apply plus_minus_lemma2;assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2664,
                "proof_end_offset": 2918,
                "proof": "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\nintros.\ninduction a.\nsimpl.\ntrivial.\nreplace (S a*n) with (n+a*n);try (auto with arith).\nrewrite plus_comm.\nrewrite plus_minus_lemma1.\nsimpl.\nrewrite <- minus_n_O;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite plus_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\n  intros.\n  replace (a*n) with (a+1).\n  replace (a*n) with (a+1).\n  rewrite plus_comm.\n  trivial.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\n  simple induction n.\n  trivial.\n  simpl in H.\n  intros.\n  rewrite plus_comm in H.\n  simpl in H.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  auto with arith.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\n  intros.\n  case (plus_minus_lemma1 a n).\n  auto with arith.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm b).\n  rewrite (mult_comm a).\n  rewrite (mult_comm b).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm aQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros;rewrite plus_comm;simpl;reflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nintros.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 2920,
                "proof_end_offset": 3619,
                "proof": "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\nProof.\ninduction a.\nintros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\nintros b n H.\nrewrite mult_comm;simpl;rewrite mult_comm;intro.\nassert (n*a = n*b-n).\napply plus_minus;auto.\nassert (a*n=(b-1)*n).\nrewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\nassert (a=(b-1)).\napply (IHa (b-1) n);trivial.\nrewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\ndestruct b;simpl in H3.\nrewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\nrewrite <- minus_n_O in H3;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_lemma1;trivial.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite <- minus_n_O;trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  apply le_plus_minus_lemma1.\n  apply le_minus_lemma1.\n  apply le_minus_lemma2.\n  apply le_minus_lemma2.\n  apply le_minus_lemma2.\n  apply le_minus_lemma3.\n  apply le_minus_lemma1.\n  apply le_minus_lemma3.\n  apply le_minus_lemma2.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n  apply le_minus_lemma3.\n Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  rewrite mult_comm.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  destruct a, b.\n  simpl.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  destruct a.\n  simpl.\n  trivial.\n  destruct a.\n  simpl.\n  trivial.\n  destruct n.\n  simpl.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a;simpl;auto with arith.\n  rewrite mult_comm;auto with arith.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  destruct a.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl in H.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl in H.\n  replace (S a) with (S a + S n); try (auto with arith).\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  destruct x.\n  destruct y.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  destruct z.\n  simpl.\n  omega.\n  destruct z0.\n  simpl.\n  omega.\n  destruct z0.\n  destruct z.\n  destruct z0.\n  destruct z0.\n  simpl.\n  omega.\n  destruct z0.\n  simpl.\n  omega.\n  destruct z0.\n  destruct z1.\n  simpl.\n  omega.\n  destruct z1.\n  destruct z0.\n  simpl.\n  omega.\n  destruct z1.\n  destruct z0.\n  simpl.\n  omega.\n  destruct z0.\n  destruct z1.\n  simpl.\n  omega.\n  destruct z1.\n  destruct z1.\n  simpl.\n  omega.\n  destruct z1.\n  simpl.\n  omega.\n  destruct z1.\n  destruct z1.\n  simpl.\n  omega.\n  destruct z2.\n  destruct z2.\n  simpl.\n  omega.\n  destruct z2.\n  simpl.\n  omega.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x.\n  simpl.\n  trivial.\n  simpl.\n  trivial.\n  simpl.\n  trivial.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  replace (y*z*t) with (z*t).\n  replace (z*t) with (z*t).\n  reflexivity.\n  replace (z*t) with (z*t).\n  reflexivity.\n  symmetry  in |- *; apply mult_plus_distr_l.\n  assumption.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros;\ninduction x;intros;rewrite mult_comm;simpl;reflexivity.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros;symmetry;apply mult_lemma1;assumption.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction y;intros;rewrite plus_comm in H;rewrite plus_comm in H;rewrite plus_comm in H;trivial.\n  simpl in H;rewrite (mult_comm x y) in H;rewrite (mult_comm y x) in H;rewrite (mult_comm y x) in H; rewrite (mult_comm y x) in H;\n    rewrite (mult_comm y x) in H; rewrite (mult_comm y x) in H; rewrite (mult_comm x y) in H;\n    rewrite (mult_comm y x) in H; rewrite (mult_comm y x) in H; rewrite (mult_comm y x) in H;\n    rewrite (mult_comm y x) in H; rewrite (mult_comm y x) in H; rewrite (mult_comm x y) in H;\n    rewrite (mult_comm y x) in H; rewrite (mult_comm y x) in H; rewrite (mult_comm y x) in H;\n    rewrite (mult_comm y x) in H; rewrite (mult_comm x y) in H; rewrite (mult_comm y x) in H;\n    rewrite (mult_Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply mult_lemma3;auto with arith.\n  replace (x*y*t) with (x*z*t).\n  rewrite mult_minus_distr_r;auto with arith.\n  rewrite mult_comm;rewrite mult_comm;assumption.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n intros.\n rewrite (mult_comm x y z t).\n rewrite (mult_comm y z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm x z).\n rewrite (mult_comm y z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm y z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm (z*t)).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (mult_comm z t).\n rewrite (Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n intros.\n apply mult_lemma3;assumption.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros x y z t.\nelim (mult_integral _ _ _ _ _ t); intros l Hl1 Hl2; elim Hl2; intros; elim Hl1; intros; elim Hl1; intros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply mult_lemma1;trivial.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\n  intros.\n  apply plus_lt_compat_l.\n  apply plus_le_compat_l.\n  apply le_plus_minus_le;auto.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  case (mult_lemma1 a b);intro H.\n  case (mult_lemma1 b b);intro H.\n  rewrite (mult_comm a b); auto with arith.\n  rewrite (mult_comm a b); auto with arith.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply plus_le_compat;auto.\n  apply mult_le_compat;auto.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  unfold S.\n  apply plus_lt_compat_l.\n  auto with arith.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  inversion H; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H1; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversion H0; auto with arith.\n  inversionQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  rewrite <- minus_n_O in H.\n  generalize (mult_lemma1 n a b); intros Hl1.\n  elim (mult_lemma1 n a b); intros Hl2.\n  elim (mult_lemma2 n a b); intros Hl2.\n  elim (mult_lemma1 n a b); intros Hl3.\n  elim (mult_lemma1 n a b); intros Hl3.\n  elim (mult_lemma1 n a b); intros Hl3.\n  elim (mult_lemma1 n a b); intros Hl3.\n  elim (mult_lemma2 n a b); intros Hl3.\n  elim (mult_lemma1 n a b); intros Hl3.\n  elim (mult_lemma1 n a b); intros Hl3.\n  elim (mult_lemma1 n a b); intros Hl4.\n  elim (mult_lemma1 n a b); intros Hl4.\n  elim (mult_lemma2 n a b); intros Hl4.\n  elim (mult_lemma1 n a b); intros Hl4.\n  elim (mult_lemma1 n a b); intros Hl4.\n  elim (mult_lemma2 n a b); intros Hl5.\n  elimQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply mult_lemma1;trivial.\n  unfold S in |- *; simpl in |- *.\n  intros.\n  rewrite mult_comm.\n  rewrite (mult_comm a).\n  rewrite (mult_comm a).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm a).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n  rewrite (mult_comm b).\n Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply plus_le_reg_l with b; auto with arith.\n  replace (S a) with (S b + S a); auto with arith.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plusQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (plus_comm x y z);rewrite (plus_comm y z);trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2;trivial.\n  apply plus_minus_lemma2;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n apply plus_minus_lemma2.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n intros.\n omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  apply plus_minus_lemma2.\n  trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ";rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y z);rewrite mult_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  apply plus_minus_lemma2.\n  trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (plus_minus_lemma1 y z l);rewrite plus_comm;rewrite plus_comm;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;auto with arith.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (plus_minus_lemma2 y z l);rewrite mult_minus_lemma2;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (plus_comm x y z);try (auto with arith).\n  rewrite (plus_comm x y z);try (auto with arith).\n  rewrite (plus_comm y z);try (auto with arith).\n  rewrite plus_comm;rewrite (mult_comm y z);try (auto with arith).\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (plus_minus_lemma1 y z l);rewrite plus_comm;rewrite (mult_comm x (y-z));simpl;rewrite plus_comm;ring.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n intros.\n generalize (plus_minus_lemma1 x y z H);intros.\n rewrite (minus_minus_lemma1 y z l);rewrite (plus_comm y z);trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (minus_minus_lemma2 y z l);rewrite mult_plus_distr_l;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite (minus_minus_lemma1 y z);trivial.\n  rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma1.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma1.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma1.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma1.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply (plus_minus_lemma2 y z x y z).\n  apply (plus_minus_lemma2 y z x z y).\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y z);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;auto.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y z).\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma1.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma2.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemma3.\n  apply minus_minus_lemmaQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (minus_minus z y);trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (plus_comm z x);auto.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  apply minus_minus_lemma1; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\n  apply minus_le_eq; trivial.\n  apply minus_le_eq; trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  apply minus_lt_lemma2; trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;simpl;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;trivial.\n  intros; simpl.\n  case b;Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\n",
                "context_tokens": 375,
                "proof_start_offset": 1374,
                "proof_end_offset": 1542,
                "proof": "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nunfold is_gcd.\nintros.\nelim H;elim H0;intros.\napply divides_antisym;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d a b.\nunfold is_gcd in |- *.\nunfold is_gcd in |- *.\nunfold is_rel in |- *.\nunfold rel in |- *.\nunfold rel in |- *.\nunfold rel in |- *.\nunfold rel in |- *.\nunfold rel in |- *.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.\nunfold rel in H.Qed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nintros.\ngeneralize (gcd_unique (gcd d a) (gcd d' a)).\nunfold gcd in |- *.\nunfold gcd in |- *.\nunfold gcd in |- *.\nunfold gcd in |- *.\nunfold divide in |- *.\nintros.\ngeneralize (gcd_unique (gcd d a) (gcd d' a)).\nunfold gcd in |- *.\nunfold gcd in |- *.\nunfold gcd in |- *.\nunfold gcd in |- *.\nunfold gcd in |- *.\nintros.\nelim H1; intros.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H4.\nrewrite <- H4.\nrewrite H1.\nrewrite <- H4.\nrewrite <- H2.\nrewrite H2.\nrewrite H4.\napply gcd_refl.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\napply gcd_unique with (gcd d a b).\napply gcd_unique with (gcd d a); auto.\napply gcd_unique with (gcd d a); auto.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H'.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H''.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H''.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H''.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H''.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H''.\ngeneralize (gcd_unique (d' a) (d' a)).\nintro H''.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H''.\ngeneralize (gcd_unique (d' a) (d' a) (d' a)).\nintro H''.\ngeneralize (gcdQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\napply gcd_unique with (a*b) (a*b) (a*b) (c*a) (b*c) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*a) (d*aQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintro d; apply (gcd_unique (is_gcd d a b) (is_gcd d' a b)).\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\nrewrite <- gcd_unique with (d' := a); auto with *.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nintros.\napply gcd_unique with (a*b); auto with *.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n intros.\n destruct (gcd_unique d a b); auto.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\napply (gcd_unique_rev d a b H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\n",
                "context_tokens": 457,
                "proof_start_offset": 1571,
                "proof_end_offset": 1763,
                "proof": "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros.\nelim H;intros.\nsplit.\nred;red in H0;tauto.\nintros.\napply H1.\nred;red in H2;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply divide_antisym;auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H0;elim H0;intros.\n  apply until_ind with (2:=H0).\n  apply until_ind with (2:=H1).\n  apply until_ind with (2:=H2).\n  apply until_ind with (2:=H3).\n  apply until_ind with (2:=H1).\n  apply until_ind with (2:=H2).\n  apply until_ind with (2:=H3).\n  apply until_ind with (2:=H3).\n  apply until_ind with (2:=H3).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2:=H3).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2:=H3).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2:=H4).\n  apply until_ind with (2Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H.\n  apply gcd_antisym.\n  apply gcd_refl.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcdQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H.\n  intros.\n  rewrite <- H0.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divideQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H.\n  intros.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_rel.\n  unfold is_rel.\n  unfold is_rel.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  apply eqm_trans with (m := a); auto with *.\n  apply eqm_trans with (m := a); auto.\n  apply eqm_trans with (m := a); auto.\n  apply eqm_trans with (m := a); auto.\n  apply eqm_trans with (m := a); auto.\n  apply eqm_mult; auto.\n  apply eqm_mult; auto.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold gcd.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold common_gcd in |- *.\n  intros.\n  elim H; intros.\n  apply H0.\n  apply gcd_sym.\n  apply gcd_refl.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\n  unfold gcd.\n  intros.\n  elim H;intros.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.\n  apply divide_antisym.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\n",
                "context_tokens": 545,
                "proof_start_offset": 1783,
                "proof_end_offset": 1947,
                "proof": "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\nunfold is_gcd.\nintro.\nsplit.\nred;split;[apply zero_max_div | apply divides_refl].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply (is_gcd_divide a a).\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_sym.\n  apply gcd_refl.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_sym.\n  applyQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_rel.\n  unfold is_rel.\n  unfold pred, pred, pred in |- *.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H4.\n  apply H4.\nQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  elim H;intros.\n  apply H0.\n  red; simpl; intros.\n  apply H2.\n  apply H1.\n  red; simpl; intros.\n  apply H2.\n  red; simpl; intros.\n  apply H3.\n  red; simpl; intros.\n  apply H3.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H4.\n  red; simpl; intros.\n  apply H5.\n  red; simpl; intros.\n  apply H4.\n  red;Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\nQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  unfold is_gcd.\n  intros.\n  elim (gcd_intro a 1).\n  intro.\n  elim H1;intros.\n  apply H2.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  apply H4.\n  red; intro.\n  applyQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H.\n  apply gcd_refl.\n  red; intro.\n  rewrite H0 in H.\n  destruct (is_gcd a a H1) as (g,H1).\n  apply H1.\n  apply gcd_refl.\n  red; intro.\n  rewrite H0 in H.\n  destruct (is_gcd a a H1) as (g,H2).\n  apply H2.\n  apply gcd_refl.\n  apply gcd_sym.\n  red; intro.\n  rewrite H0 in H.\n  destruct (is_gcd a a H1) as (g,H3).\n  apply H2.\n  apply gcd_refl.\n  apply gcd_sym.\n  red; intro.\n  rewrite H0 in H.\n  destruct (is_gcd a a H1) as (g,H3).\n  apply H3.\n  apply gcd_refl.\n  apply gcd_sym.\n  red; intro.\n  rewrite H0 in H.\n  destruct (is_gcd a a H1) as (g,H4).\n  apply H2.\n  apply gcd_refl.\n  red; intro.\n  rewrite H0 in H.\n  destructQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\n  apply (is_gcd_intro _ _ H).\nQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply (is_gcd_0_l (b,a) (b,a)).\n  apply gcd_sym;auto.\n  red; intro.\n  apply (is_gcd_0_l (b,a) (b,a)).\n  apply gcd_comm;auto.\n  apply gcd_comm.\nQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red; red in H0; tauto.\n  red in H0; tauto.\n  red in H0; tauto.\nQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd; intros.\n  elim H;intros.\n  elim H;intros.\n  apply H2; auto with arith.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  redQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\n",
                "context_tokens": 615,
                "proof_start_offset": 1967,
                "proof_end_offset": 2130,
                "proof": "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\nunfold is_gcd.\nintros.\nsplit.\nred;split;[apply divides_refl | apply one_min_div].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  elim H.\n  intros.\n  apply H1.\n  split.\n  red; intro.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H1.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H4.\n  intros.\n  elim H4.\n  intros.\n  elim H5.\n  intros.\n  apply H1.\n  split.\n  red; intro.\n  elim H5.\n  intros.\n  apply H1.\n  split.\n  red; intro.\n  elim H5.\n  intros.\n  apply H3.\n  split.\n  red; intro.\n  elim H5.\n  intros.\n  apply H4.\n  split.\n  red; intro.\n  elim H5.\n  intros.\n  apply H5.\n  red; intro.\n  elim H5.\n  intros.\n  apply H1.\n  split.\n  red; intro.\n  elim H5.\n  intros.\n  apply H5.\n  split.\n  red; intro.\n  elim H6.\n  intros.\n  apply H4.\n  split.\n  red; intro.\n  elim H6Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_nan; tauto.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_rel, is_rel, is_rel, is_rel, is_rel, is_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_rel, le_Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_nan; tauto.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_rel.\n  intro.\n  elim H;intros.\n  elim H0;intros.\n  apply H1.\n  red; intro.\n  elim H0;intros.\n  apply H1.\n  red; intro.\n  elim H0;intros.\n  apply H1.\n  red; intro.\n  elim H1;intros.\n  apply H1.\n  red; intro.\n  elim H1;intros.\n  apply H1.\n  red; intro.\n  elim H1;intros.\n  apply H1.\n  red; intro.\n  elim H1;intros.\n  apply H1.\n  red; intro.\n  elim H1;intros.\n  apply H1.\n  red; intro.\n  elim H1;intros.\n  apply H1.\n  red; intro.\n  elim H1; intros.\n  apply H1.\n  red; intro.\n  elim H1; intros.\n  apply H1.\n  red; intro.\n  elim H1; intros.\n  apply H1.\n  red; intro.\n  elim H1; intros.\n  apply H1.\n  red; intro.\n  elim H1; intros.\n  apply H1.\n  red; intro.\n  apply HQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_d.\n  intros.\n  elim H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H. red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H. red; intro.\n  apply H. red; intro.\n  apply H.\n  red; intro.\n  apply H. red; intro.\n  apply H. red; intro.Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  unfold is_gcd.\n  intros.\n  elim H.\n  elim H0; intros.\n  elim H0; intros.\n  elim H1; intros.\n  rewrite H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H2.\n  apply H4.\n  apply H4.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold gcd.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in |- *.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_a, is_a, is_a, is_a, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d.\n  unfold no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d, no_d.\n  unfold no_d, no_d, no_d, no_d, no_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\n",
                "context_tokens": 697,
                "proof_start_offset": 2174,
                "proof_end_offset": 2759,
                "proof": "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\nintros.\nunfold is_gcd.\nsplit;intro.\nelim H0;intros.\nsplit.\nred in H1;red.\nelim H1;intros.\nsplit;try tauto.\napply divides_minus;trivial.\nunfold is_cd;intros.\napply H2;red;elim H3;intros.\nsplit;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nelim H0;unfold is_cd;intros.\nsplit.\nsplit;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nintros.\nelim H3;intros;apply H2.\nsplit;try (apply divides_minus);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  generalize (is_gcd_abs d a b H H0); tauto.\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  apply H2.\n  red; unfold is_gcd in |- *; tauto.\n  unfold is_rel in |- *; tauto.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  apply (gcd_trans _ _ _ _ _ _ H0).\n  apply (gcd_trans _ _ _ _ _ H1).\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply H1.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\n  apply divide_antisym;auto.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply H2.\n  apply divide_refl.\n  apply divide_refl.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold gcd in |- *.\n  unfold gcd in |- *.\n  unfold divide in |- *.\n  unfold b, a, b, a, b, b, a, b, b, d, b.\n  split.\n  split.\n  red; unfold gcd in |- *.\n  unfold b, a, b, b, a, b, b, b, a, b, b, b.\n  split.\n  red; unfold b, a, b, a, b, b, a, b, b, b, a.\n  split.\n  red; unfold b, a, b, a, b, b, a, b.\n  split.\n  red; unfold b, b, a, b, a, b, a, b, b, a.\n  split; unfold b, b, b, a, a, b, b.\n  split; unfold b, b, aQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  unfold gcd.\n  intros.\n  elim H;intros.\n  apply H0.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  unfold is_gcd.\n  intros.\n  generalize (gcd_minus_r a b); intro.\n  generalize (gcd_minus_r a b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b); intro.\n  generalize (gcd_minus_r b b);Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; elim H;intros.\n  apply H1.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H1.\n  red; intro.\n Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  apply H1.\n  red; red in H0; tauto.\n  unfold is_rel in H0.\n  unfold is_rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H1.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H0.\n  unfold rel in H1.\n  unfold rel in H1.\n  unfold rel in H.\n  unfold rel in H1.\n  unfold rel in H.\n  unfold rel in H0.\n  unfold rel in H1.\n  unfold rel in H1.\n  unfold rel in H1.\n  unfold rel in H1.\n  unfold rel in H.\n  unfold rel in H1.\n  unfold rel in H.\n  unfold rel in H1.\n  unfoldQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\n",
                "context_tokens": 739,
                "proof_start_offset": 2781,
                "proof_end_offset": 2923,
                "proof": "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nunfold is_gcd.\nintros.\nunfold is_cd.\nsplit;try tauto.\nsplit;apply divides_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd; tauto.\n  unfold is_gcd; tauto.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red in |- *.\n  elim H1;intros.\n  split.\n  red in |- *.\n  elim H1;intros.\n  split;try tauto.\n  red in |- *.\n  elim H1;intros.\n  split.\n  red in |- *; intro.\n  elim H1;intros.\n  split; try tauto.\n  red in |- *; intro.\n  elim H1;intros.\n  split; try tauto.\n  red in |- *; intro.\n  elim H1;intros.\n  split; try tauto.\n  red in H3; red in H3; simpl in H3; tauto.\n  red in H3; red in H3; simpl in H3; tauto.\n  red in H3; simpl in H3; tauto.\n  red in H3; simpl in H3; tauto.\n  red in H3; simpl in H3; tauto.\n  red in H3; simpl in H3; tauto.\n  red in H3; simpl in H3; tauto.\n  red in H3; simpl in H3; tauto.\n  red in H3; simpl in H3; tauto.\n  red inQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  split.\n  red; split;intro.\n  elim H1;intros.\n  split.\n  red in H0;tauto.\n  apply H1; red in H0;tauto.\n  apply H1; red in H0;tauto.\n  apply H1; red in H0; tauto.\n  apply H1; red in H0;tauto.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  unfold is_gcd.\n  intro.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  elim H0;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H2;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H.\n  apply gcd_sym.\n  red; intro.\n  elim H1;intros.\n  split.\n  red; intro.\n  elim H1;intros.\n  apply H1.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H1.\n  red; intro.\n  apply H2.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.\n  apply H3.\n  red; intro.Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H.\n  red; intros.\n  split.\n  red in H0.\n  apply H0.\n  red in H0;tauto.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red in H0.\n  apply H0.\n  red.\n  redQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd; intros.\n  case (is_gcd a a); auto.\n  unfold is_gcd; intros.\n  rewrite <- H1; rewrite <- H2; rewrite <- H1; simpl; trivial.\n  apply gcd_refl.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  split; intro.\n  elim H0;intros.\n  split.\n  red in H.\n  elim H0;intros.\n  split;intro.\n  red in H1.\n  elim H1;intros.\n  split;intro.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1.\n  elimQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intro.\n  elim H;intros.\n  split.\n  red in H0;intro.\n  elim H1;intros.\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H2 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H2 b).\n  split;try tauto.\n  apply (H2 b).\n  split;try tauto.\n  apply (H2 b).\n  split;try tauto.\n  apply (H2 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H2 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H2 b).\n  split;try tauto.\n  apply (H1 b).\n  split;try tauto.\n  apply (H1 b).\n  splitQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red in H.\n  elim H;intros.\n  split.\n  red in H.\n  elim H;intros.\n  split.\n  red in H.\n  elim H;intros.\n  split; try tauto.\n  red in H.\n  elim H;intros.\n  split.\n  red in H.\n  elim H;intros.\n  split.\n  red in H.\n  elim H;intros.\n  split.\n  red in H0.\n  elim H0;intros.\n  split.\n  red in H0.\n  elim H0;intros.\n  split.\n  red in H0.\n  elim H0;intros.\n  split.\n  red in H0.\n  elim H0;intros.\n  split.\n  red in H1.\n  elim H1; intros.\n  split.\n  red in H1.\n  elim H1; intros.\n  split.\n  red in H1.\n  elim H1; intros.\n  split.\n  red in H1.\n  elim H1; intros.\n  split.\n  red in H1.\n  elim H1; intros.\n  split.\n  red in H1.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 2965,
                "proof_end_offset": 3080,
                "proof": "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H.\n  intros.\n  elim H.\n  intros.\n  split.\n  apply H1.\n  split.\n  red in |- *.\n  elim H1;intros.\n  apply H2; generalize (H1 H1); intro.\n  split.\n  red in |- *.\n  elim H1; intros.\n  elim H2; intros.\n  split.\n  red in H3.\n  elim H3; intros.\n  apply H2; generalize (H3 H4); intro.\n  split.\n  red in |- *.\n  elim H3; intros.\n  elim H3; intros.\n  split.\n  red in |- *.\n  elim H3; intros.\n  apply H3; generalize (H4 H4); intro.\n  split.\n  red in |- *; intro.\n  elim H3; intros.\n  split.\n  red in |- *.\n  elim H3; intros.\n  split.\n  red in |- *.\n  elim H3; intros.\n  apply H3; generalize (H5 H3); intro.\n  split.\n  red in |- *; intro.\n  elim H3; intros.\n  apply H4; generalize (H4 H4); intro.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  apply (is_gcd_1_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_1_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  split.\n  apply (is_gcd_2_r a b).\n  splitQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red in |- *.\n  elim H.\n  intros.\n  apply H1.\n  split.\n  red in |- *.\n  elim H1.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H1.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H2.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H2.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H3.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H3.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H3.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H3.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H3.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H3.\n  split.\n  red in |- *.\n  elim H1.\n  intros.\n  apply H3.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H.\n  split.\n  red in H.\n  red in H.\n  elim H.\n  intros.\n  split.\n  red in H.\n  elim H.\n  intros.\n  split.\n  red in H.\n  elim H.\n  intros.\n  split.\n  red in H.\n  elim H.\n  intros.\n  split.\n  red in H.\n  elim H0.\n  red in H.\n  elim H.\n  intros.\n  split.\n  red in H.\n  elim H.\n  intros.\n  split.\n  red in H.\n  elim H0.\n  intros.\n  split.\n  red in H.\n  elim H0.\n  intros.\n  split.\n  red in H0.\n  elim H0.\n  intros.\n  split.\n  red in H0.\n  elim H0.\n  intros.\n  split.\n  red in H0.\n  elim H0.\n  intros.\n  split.\n  red in H.\n  elim H0.\n  intros.\n  split.\n  red in H0.\n  elim H0.\n  intros.\n  split.\n  red in H0.\n  elim H0.\n  intros.\n  split.\n  redQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H.\n  intro.\n  split;try tauto.\n  intro.\n  elim H.\n  intros.\n  split.\n  red in H0.\n  elim H0;intros.\n  split.\n  red in H0.\n  elim H0;intros.\n  split.\n  red in H0.\n  elim H0;intros.\n  split.\n  red in H1; red in H1;tauto.\n  split.\n  red in H1; red in H1; tauto.\n  apply H1; red in H1; tauto.\n  apply H; red in H1; tauto.\n  apply H; red in H1; tauto.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  split.\n  red;intro.\n  elim H0;intros.\n  split;try tauto.\n  apply H.\n  red;intro.\n  elim H0;intros.\n  split;try tauto.\n  apply H.\n  red;intro.\n  elim H0;intros.\n  split;try tauto.\n  apply H.\n  red;intro.\n  elim H0;intros.\n  split;try tauto.\n  apply H.\n  red;intro.\n  elim H0;intros.\n  split;try tauto.\n  apply H0.\n  red;intro.\n  elim H1;intros.\n  split;try tauto.\n  red;intro.\n  elim H1;intros.\n  split;try tauto.\n  apply H1.\n  red;intro.\n  elim H1;intros.\n  split;try tauto.\n  apply H0.\n  red;intro.\n  elim H1;intros.\n  split;try tauto.\n  apply H1.\n  red;intro.\n  elim H1;intros.\n  split;try tauto.\n  apply H0.\n  red;intro.\n  elim H1;Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n  apply gcd_divide.\n Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  generalize (is_gcd_pos d a).\n  generalize (is_gcd_pos d a).\n  generalize (is_gcd_pos d a).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  split.\n  red in H0;red in H0;tauto.\n  unfold is_gcd in H0;tauto.\n  unfold is_gcd in H0; tauto.\n  unfold is_gcd in H0; tauto.\n  unfold is_gcd in H0; tauto.\n  unfold is_gcd in H0; tauto.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red in H0;red in H0;tauto.\n  split.\n  red in H0;intros.\n  apply H1.\n  red in H0;tauto.\n  apply H1.\n  red in H0;tauto.\n  red in H0;tauto.\n  unfold is_gcd; intros.\n  apply H1.\n  red in H0; tauto.\n  red in H0; tauto.\n  unfold is_gcd; intros.\n  apply H2.\n  red in H0; tauto.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split;try tauto.\n  elim H1;intros.\n  split.\n  apply H;auto.\n  red in H1.\n  elim H1;intros.\n  split.\n  red in H1;red in H1.\n  elim H1;intros.\n  split.\n  apply H1;auto.\n  apply H2;auto.\n  apply H1;auto.\n  apply H;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\n",
                "context_tokens": 731,
                "proof_start_offset": 3102,
                "proof_end_offset": 3217,
                "proof": "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;simpl;intros;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;intro.\n  split;try tauto.\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    case (is_gcd a a);\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd;\n    unfoldQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H1;try tautoQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;intros; tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\nunfold is_gcd;unfold is_gcd;\n unfold is_gcd; unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold isQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;simpl; tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;intros;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd; tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;intro; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3393,
                "proof_end_offset": 3478,
                "proof": "Lemma Rwf : well_founded R.\nProof.\nunfold R.\napply (well_founded_ltof (nat*nat) f).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Rwf : well_founded R.\nProof.\n unfold well_founded.\n intros.\n destruct (f x); destruct (f x); simpl; trivial.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded.\n  unfold well_founded.\n  unfold well_founded.\n  unfold well_founded.\n  unfold well_founded.\n  intros.\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:= fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:= fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => x).\n  apply Acc_intro with (P:=fun x => xQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded.\n  unfold well_founded.\n  intros.\n  unfold well_founded.\n  case (well_founded_induction_type_ind (P:=P) (P:=P) (P:=P)).\n  intro.\n  apply H.\n  red.\n  red; intro.\n  apply H.\n  red; intro.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded.\n  intros.\n  apply (H x).\n  apply (H0 y).\n  apply (H0 y).\n  apply (H0 y).\nQed.",
                    "Lemma Rwf : well_founded R.\n  apply well_founded_induction_type_ind_type_ind_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_type_eq_dec.\n  apply well_founded_induction_type_ind_Qed.",
                    "Lemma Rwf : well_founded R.\nProof.\n unfold well_founded; intros.\n apply (H (fun x y:nat => x+y+y)); trivial.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded; intros; tauto.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded.\n  unfold well_founded.\n  intros.\n  apply Acc_intro with (R:=fun x y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  apply Acc_intro with (R:=fun y:nat => f y).\n  applyQed.",
                    "Lemma Rwf : well_founded R.\nProof.\n  unfold well_founded, f; intros.\n  apply (well_founded_induction_type_ind (fun (a b:nat)(H:P a b)->(a=b)) H).\n  apply (well_founded_induction_type_ind (fun (a b:nat)(H:P a b)->(a=b))).\n  apply (well_founded_induction_type_ind (fun (a b:P a b)->(a=b))).\n  apply (well_founded_induction_type_ind (fun (a b:P a b)->(a=b))).\n  apply (well_founded_induction_type_ind (fun (a b:P a b) H => H0)).\n  apply (well_founded_induction_type_ind (fun (a b:P a b)->(a=b)) H).\n  apply (wellfounded_induction_type_ind (fun (a b:P a b) H => H0).\n  apply (wellfounded_induction_type_ind (fun (a b:P a b)->(a=b))).\n  apply (wellfounded_induction_type_ind (fun (a b:P a b) H =>Qed.",
                    "Lemma Rwf : well_founded R.\nProof.\n unfold well_founded.\n intros.\n unfold well_founded.\n apply well_founded_induction_wf; intros.\n apply (well_founded_induction_wf _ H0).\n apply (well_founded_induction_wf _ H0).\n apply (well_founded_induction_wf _ H0).\n apply (well_founded_induction_wf _ H1).\n apply (well_founded_induction_wf _ H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ".\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\n",
                "context_tokens": 724,
                "proof_start_offset": 3573,
                "proof_end_offset": 4309,
                "proof": "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nexists (snd x);apply gcd_zero.\nelim (H (S n,snd x-S n)).\nsimpl;intro d;intro.\nexists d.\nelim (gcd_minus d (S n) (snd x));try (auto with arith).\nsimpl.\nomega.\nrewrite e;exists (snd x);apply gcd_refl.\ndestruct (snd x).\nexists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n)).\nsimpl;intro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_minus d (S n) (fst x));try (auto with arith).\nsimpl.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;simpl; tauto.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros; unfold R.\n  apply (is_gcd_exists_prod (fun a b => a=b) (fst x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => b=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (snd x)).\n  apply (is_gcd_exists_prod (fun a b => a=b) (Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold f; unfold f; destruct x; destruct y; simpl; f_equal; auto.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold R.\n  destruct x; simpl.\n  split;intros.\n  apply (is_gcd_intro (fst x) (snd x0)).\n  apply (is_gcd_intro (snd x) (snd x0)).\n apply (is_gcd_intro (snd x) (snd x0)).\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;simpl; tauto.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros x d. unfold D, D.\n  apply (well_founded_ltof _ (nat*nat) (fun x => (fst x) (snd x))).\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros; unfold is_gcd;destruct x; destruct y; simpl;\n  rewrite?H; auto.\n  destruct (is_gcd_spec a (fst x) (snd y)); simpl; trivial.\n  destruct (is_gcd_spec a (snd y)); simpl; trivial.\n  destruct (is_gcd_spec a (fst x) (snd y)); simpl; trivial.\n  destruct (is_gcd_spec a (fst y) (snd y)); simpl; trivial.\n  destruct (is_gcd_spec a (snd x) (snd y)); simpl; trivial.\n  destruct (is_gcd_spec a (snd y)); simpl; trivial.\n  destruct (is_gcd_spec a (snd x) (snd y)); simpl; trivial.\n  destruct (is_gcd_spec a (snd y)); simpl; trivial.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\n  apply (is_gcd_exists_prod x).\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold R.\n  destruct (is_gcd (fst x) (snd x)).\n  exists (is_gcd (fst x) (snd x)).\n  exists (is_gcd (fst x) (snd x)).\n  intros.\n  exists (is_gcd (fst x) (snd x)).\n  split; trivial.\n  split; trivial.\n  apply (is_gcd_divide_r (fst x) (snd x)).\n  split; trivial.\n  apply (is_gcd_divide_r (fst x) (snd x))).\n  split; trivial.\n  apply (is_gcd_divide_r (snd x) (snd x)).\n  split; trivial.\n  apply (is_gcd_divide_r (fst x) (snd x)).\n  split; trivial.\n  apply (is_gcd_divide_r (fst x) (snd x))).\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  apply (well_founded_ltof (nat*nat)); auto with arith.\n  apply (well_founded_ltof (nat*nat)); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4346,
                "proof_end_offset": 4496,
                "proof": "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod (a,b)).\nsimpl;intro d;intro;exists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd.\n  destruct a.\n  exists (is_gcd a (is_gcd a b) (is_gcd b (snd a)) /\\ a=b}.\n  exists (is_gcd a (is_gcd b (snd a))).\n  exists (is_gcd b (snd a)).\n  split.\n  exists (is_gcd b (fst a)).\n  exists (is_gcd b (snd b)).\n  split.\n  split.\n  split.\n  apply gcd_mult_l.\n  split.\n  apply gcd_refl.\n  split.\n  apply gcd_refl.\n  split.\n  apply gcd_refl.\n  split.\n  apply gcd_refl.\n  split.\n  generalize (gcd_divide_r b (fst a) (snd b));try (auto with arith).\n  intros.\n  exists (fst x).\n  apply gcd_refl.\n  split.\n  split.\n  apply gcd_refl.\n  split.\n  apply gcd_refl.\n  split.\n  generalize (gcd_divide_r b (fst a) (snd b));try (auto with arith).\n  intros.\n  exists (snd x).\n  apply gcd_refl.\n  split.\n  generalize (gcd_divide_r bQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd; unfold is_gcd;simpl;intros;auto.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd.\n  exists (fun x:nat => a=x \\/ a=b /\\ b=c /\\ b=c /\\ b=c /\\ a=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ a=d /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\ b=c /\\Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  case (gcd_spec a b); intro.\n  case (gcd_spec a b); intro.\n  exists (snd x);apply gcd_mult; try tauto.\n  exists (fst y); apply gcd_sym.\n  exists (snd x); apply gcd_refl.\n  exists (snd y); apply gcd_refl.\n  exists (snd x); apply gcd_refl.\n  exists (snd y); apply gcd_sym.\n  exists (snd x); apply gcd_refl.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd; intros.\n  case (gcd_spec a b);intros.\n  case (gcd_spec a b);intros.\n  destruct (gcd_spec a b);destruct (gcd_spec a b);auto.\n  exists b;split.\n  destruct (gcd_spec a b);destruct (gcd_spec a b);auto.\n  exists b;split.\n  rewrite gcd_comm; apply gcd_0_l.\n  apply gcd_0_l.\n  exists b;split.\n  rewrite gcd_comm; apply gcd_0_l.\n  split; trivial.\n  rewrite gcd_comm; apply gcd_0_l.\n  exists b;split.\n  rewrite gcd_comm; apply gcd_0_l.\n  exists b;split.\n  rewrite gcd_comm; apply gcd_0_l.\n  exists b;split.\n  rewrite gcd_comm; apply gcd_0_l.\n  exists b;split.\n  rewrite gcd_comm; apply gcd_0_l.\n  exists b;split.\n  rewrite gcd_comm; apply gcd_comm.\n  exists b; split; trivial.\n  rewrite gcd_comm; apply gcd_comm.\n  exists b; split; trivial.Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd;unfold is_gcd;intros;tauto.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros a b.\n  unfold gcd.\n  case (gcd_spec a b);intro.\n  exists (fst x);apply gcd_intro.\n  exists (snd x);auto with arith.\n  destruct (gcd_spec a b);auto with arith.\n  exists (snd x);auto with arith.\n  exists (snd x);auto with arith.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd; unfold is_gcd; intros.\n  case (le_lt_dec a b); intro.\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_r _ _ H).\n  generalize (gcd_0_r _ _ H).\n  generalize (gcd_0_l _ _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_r _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n  generalize (gcd_0_l _ _ H).\n Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros; apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_prod.\n  apply gcd_exists_Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd; intros; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4634,
                "proof_end_offset": 4785,
                "proof": "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\nintros.\nunfold gcd.\ngeneralize (gcd_exists a b).\nintro;elim s;intro d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd.\n  intros.\n  case (gcd_spec (gcd a b) (gcd a b));intro.\n  elim (gcd_spec a b);intro.\n  elim (gcd_spec a b);intro.\n  intros.\n  destruct (gcd_spec a b) as [H|H].\n  rewrite H in H.\n  elim (gcd_spec a b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec a b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);intro.\n  rewrite (gcd_spec b b);Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  destruct (gcd_is_gcd a b) as [H|H].\n  elim (gcd_is_gcd a b).\n  destruct (gcd_spec a b) as [H|H].\n  destruct (gcd_spec a b) as [H'|H'].\n  left. apply gcd_abs.\n  destruct (gcd_spec a b) as [H'|H'].\n  right. apply gcd_abs.\n  apply gcd_abs.\n  right. apply gcd_abs.\n  split.\n  apply gcd_abs.\n  right. apply gcd_abs.\n  split.\n  apply gcd_abs.\n  apply gcd_abs.\n  right. apply gcd_abs.\n  split.\n  apply gcd_abs.\n  exists 1; apply gcd_abs.\n  split.\n  apply gcd_abs.\n  exists 1; apply gcd_abs.\n  split.\n  apply gcd_abs.\n  split.\n  apply gcd_abs.\n  split.\n  apply gcd_abs.\n  split.\n  apply gcd_abs.\n  generalize (gcd_is_gcd a b).\n  generalize (gcd_is_gcd a b).\n  generalize (gcd_is_gcd b b).\n  generalize (gcd_Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd;simpl;intros;auto.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd.\n  intros.\n  destruct (le_gt_dec a b) as [H|H].\n  elim (gcd_is_gcd a b); trivial.\n  destruct (gcd_is_gcd a b) as [H|H].\n  elim (gcd_is_gcd a b); trivial.\n  destruct (gcd_is_gcd b b) as [H|H].\n  elim (gcd_is_gcd b b); trivial.\n  exists (gcd a b); split; trivial.\n  exists (gcd a b); split; trivial.\n  apply gcd_is_gcd.\n  elim (gcd_is_gcd b b); trivial.\n  exists (gcd a b); split; trivial.\n  apply gcd_is_gcd.\n  elim (gcd_is_gcd a b); trivial.\n  exists (gcd a b); split; trivial.\n  apply gcd_is_gcd.\n  elim (gcd_is_gcd b b); trivial.\n  exists (gcd a b); split; trivial.\n  apply gcd_is_gcd.\n  elim (gcd_is_gcd b b); trivial.\n  exists (gcd a b); split; trivial.\n  apply gcd_is_gcd.\n Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  elim (gcd_is_gcd a b).\n  simpl;intro.\n  rewrite <- H; apply gcd_is_gcd; trivial.\n  apply gcd_is_gcd; trivial.\n  apply gcd_is_gcd; trivial.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  apply gcd_is_gcd; auto.\n  apply gcd_is_gcd; auto.\n  apply gcd_is_gcd; auto.\n  apply gcd_is_gcd; auto.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd; unfold is_gcd; intros.\n  apply gcd_is_gcd; try tauto.\n  apply gcd_is_gcd; try tauto.\n  apply gcd_is_gcd; try tauto.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  destruct (gcd_exists_prod (gcd a b) (gcd a b)); tauto.\n  exists (a,(b,b)).\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd; simpl;intro; split; trivial.\n  split; try (apply gcd_is_gcd; trivial).\n  intros.\n  exists (gcd a b); exists (gcd a b); split; trivial.\n  split; try (apply gcd_is_gcd; trivial).\n  split; try (apply gcd_is_gcd; trivial).\n  intros.\n  exists (gcd a b); exists (gcd a b); split; trivial.\n  split; try (apply gcd_is_gcd; trivial).\n  split; try (apply gcd_is_gcd; trivial).\n  intros.\n  exists (gcd a b); exists (gcd a b); split; trivial.\n  split; try (apply gcd_is_gcd; trivial).\n  split; try (apply gcd_is_gcd; trivial).\n  split; try (apply gcd_is_gcd; trivial).\n  intros.\n  exists (gcd a b); exists (gcd a b); split; trivial.\n  split; try (apply gcd_is_gcd; trivial).\n  split; try (apply gcd_is_gcd; trivial).\n  split; try (apply gcd_is_gcd; trivial).\n  intros.\n  exists (gcd a b);Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd; unfold is_gcd; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 4948,
                "proof_end_offset": 5077,
                "proof": "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  elim (gcd_intro a b);intro.\n  left; apply gcd_intro; split; trivial.\n  right; apply gcd_intro; split; trivial.\n  right; apply gcd_intro; split; trivial.\n  right; apply gcd_intro; split; trivial.\n  right; apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  right; apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (gcd_divide_l a b).\n  intro; elim (gcd_divide_r b a);intros.\n  generalize (gcd_divide_l b b);intro.\n  elim (gcd_divide_r b b);intros.\n  generalize (gcd_divide_r b a);intro.\n  generalize (gcd_divide_r b a);intro.\n  elim (gcd_divide_r b a);intros.\n  generalize (gcd_divide_l b a);intro.\n  destruct (gcd_divide_r b a);intros.\n  generalize (gcd_divide_r b b);intro.\n  destruct H1 as [H2|H2].\n  generalize (gcd_divide_r b a);intro.\n  destruct H2 as [H3|H3].\n  generalize (gcd_divide_r b a);intro.\n  generalize (gcd_divide_r b a);intro.\n  destruct H3 as [H4|H4].\n  generalize (gcd_divide_r b a);intro.\n  destruct H4 as [H5|H5].\n  generalize (gcd_divide_r b b);intro.\n  destruct H5 as [H5|HQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (rel_prime_sym a b).\n  generalize (rel_prime_sym a b).\n  intro;elim a;intro q; inversion q; clear q; intros q r.\n  generalize (rel_prime_sym b).\n  rewrite <- (rel_prime_sym a b).\n  destruct (rel_prime_sym a b); destruct (rel_prime_sym a b);\n    simpl; intro; inversion q; clear q; intros q r.\n  generalize (rel_prime_sym a b).\n  rewrite <- (rel_prime_sym a b).\n  destruct (rel_prime_sym a b); destruct (rel_prime_sym a b);\n    simpl; intro; inversion q; clear q; intros q r.\n  generalize (rel_prime_sym a b); destruct (rel_prime_sym a b);\n    simpl; intro; inversion q; clear q; intros q r.\n  generalize (rel_prime_sym a b).\n  rewrite <- (rel_prime_sym a b); destruct (rel_prime_sym a b);\n    simpl; intro; inversion q; clear q; intros q r.\n  generalize (rel_prime_sym a b).Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  unfold rel_prime.\n  case (divide_dec (rel_prime a b) (rel_prime b a)); intro.\n  case (divide_dec (rel_prime a b) (rel_prime b a)); intro.\n  case (divide_dec (rel_prime a b) (rel_prime b a)); intro.\n  rewrite H0; trivial.\n  rewrite H1; trivial.\n  rewrite H0; trivial.\n  rewrite H1; trivial.\n  rewrite H1; trivial.\n  rewrite H2; trivial.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (rel_prime_sym a b).\n  intro; elim (rel_prime_sym a b);intro.\n  apply (rel_prime_sym a b); auto.\n  apply rel_prime_sym; apply rel_prime_sym; apply gcd_sym.\n  apply rel_prime_sym; apply rel_prime_sym.\n  apply rel_prime_sym; apply rel_prime_sym; apply gcd_sym.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  apply (rel_prime_sym a b); trivial.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  destruct (rel_prime_intro a b H H0).\n  destruct (rel_prime_intro a b H0).\n  destruct (rel_prime_intro b b H0).\n  destruct (rel_prime_intro a b H0).\n  destruct (rel_prime_intro a b H0).\n  destruct (rel_prime_intro a b H0).\n  destruct (rel_prime_intro b b H0).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_prime_intro b H1).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_prime_intro b H1).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_prime_intro b H1).\n  destruct (rel_prime_intro b H1).\n  destruct (rel_prime_intro b H1).\n  destruct (rel_prime_intro b H0).\n  destruct (rel_Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  elim (rel_prime_sym a b).\n  intros; apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym b b).\n  apply (rel_prime_sym b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym b b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym b b).\n  apply (rel_prime_sym a b).\n  apply (rel_prime_sym b).\n  apply (rel_prime_sym b b).\n  apply (rel_prime_sym b b).\n  apply (rel_prime_sym a b).\n Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  generalize (rel_prime_intro a b).\n  intro;elim (rel_prime_intro a b).\n  intro;elim (rel_prime_intro b a).\n  intro; elim (rel_prime_intro a b).\n  intro; elim (rel_prime_intro a b).\n  intro; elim (rel_prime_intro b a).\n  intro; elim (rel_prime_intro a b).\n  intro; elim (rel_prime_intro a b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b a).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_prime_intro b b).\n  intro; elim (rel_primeQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime, rel_prime, rel_prime; intros;\n  case (prime_dec a b); intros.\n  destruct (H _ H0); exists (b * b); auto.\n  destruct (H _ H0).\n  destruct (H _ H0).\n  destruct (H _ H0).\n  destruct (H _ H1).\n  destruct (H _ H1).\n  destruct (H _ H0).\n  destruct (H _ H0).\n  split; auto.\n  destruct (H _ H1).\n  destruct (H _ H2).\n  destruct (H _ H1).\n  destruct (H _ H0).\n  destruct (H _ H1).\n  destruct (H _ H2).\n  destruct (H _ H2).\n  destruct (H _ H0).\n  destruct (H _ H1).\n  destruct (H _ H0).\n  destruct (H _ H1).\n  destruct (H _ H2).\n  destruct (H _ H3).\n  destruct (H _ H3).\n  destruct (H _ H1).\n  destruct (H _ H0).\n  destruct (H _ H0).\n  destruct (H _ H1).\n  destruct (H _ H1).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\n",
                "context_tokens": 738,
                "proof_start_offset": 5126,
                "proof_end_offset": 5240,
                "proof": "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;apply gcd_one.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; apply gcd_intro; trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime; intros; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcdQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  apply (well_founded_ltof (nat*nat)).\n  apply (well_ltof (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (well_ltof _ (nat*nat)).\n  apply (well_founded_ltof _ (nat*nat)).\n  apply (wellQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  apply prime_gt1; apply prime_gt1.\n  unfold rel_prime.\n  apply prime_gt1; apply prime_gt1.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; apply gcd_intro_l.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime; intros; elim (rel_prime_1 a).\n  simpl; intro.\n  case (dec_eq_lt_dec 1 a); intro.\n  elim (dec_eq_lt_dec 1 a); intro.\n  elim (dec_eq_lt_dec 1 a); intro.\n  left; assumption.\n  right; assumption.\n  right; assumption.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  unfold rel_prime.\n  intros.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n Qed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; apply gcd_intro; split; assumption.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\n  apply gcd_intro; split; trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intro.\n  case (dec_prime a 1);intro.\n  generalize (H1 (gcd_is_gcd a 1)); intro; elim H; intro.\n  rewrite <- H1 in H1.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H1; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H1; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H1; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion HQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros; apply gcd_intro; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\n",
                "context_tokens": 696,
                "proof_start_offset": 5309,
                "proof_end_offset": 6031,
                "proof": "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (quo_is_quo a d (gcd_div_l d a b H));intro.\ngeneralize (quo_is_quo b d (gcd_div_r d a b H));intro.\nunfold is_gcd;split;unfold is_cd.\nsplit;apply one_min_div.\nintros.\nelim H3;intros.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H6 in H1.\nrewrite H7 in H2.\nassert (divides d (d*d')).\nred in H;elim H;intros.\napply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\nelim H8;intros.\nexists x.\napply mult_lemma6 with d;trivial.\nrewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_is_gcd_sym; apply gcd_refl.\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_is_gcd_l; apply gcd_refl.\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_is_gcd_r; apply gcd_refl.\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_is_gcd_l; apply gcd_refl.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_intro; apply gcd_intro; apply gcd_intro.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  applyQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_sym.\n  rewrite <- H0.\n  apply gcd_div_exact; trivial.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_comm; apply gcd_comm; apply gcd_comm.\n  apply gcd_comm; apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_refl.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_refl.\nQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_sym; apply gcd_sym; apply gcd_sym.\n  unfold rel_prime.\n  apply gcd_sym; apply gcd_symQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime; intros.\n  apply gcd_sym; apply gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_intro.\n  rewrite <- gcd_intro; apply gcd_Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_intro; apply gcd_intro; apply gcd_intro.\n  apply gcd_intro; apply gcd_intro.\n  apply gcd_intro; apply gcd_intro; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro; apply gcd_intro; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro; apply gcd_intro.\n  apply gcd_intro; apply gcd_intro.\n  apply gcd_intro; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro; apply gcd_intro.\n  apply gcd_intro; apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 6065,
                "proof_end_offset": 6268,
                "proof": "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nunfold is_gcd.\nintros.\nelim H0;intros.\nintro.\nelim H1;intros.\nelim H5;intros.\nrewrite H3 in H6;simpl in H6;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  unfold is_gcd; intros.\n  generalize (gcd_is_gcd_l d (gcd_comm d p) (gcd_div_r d p));intro.\n  generalize (gcd_is_gcd_l d (gcd_comm d p) (gcd_div_r d p));intro.\n  generalize (gcd_is_gcd_l d (gcd_comm d p) (gcd_div_r d p));intro.\n  generalize (gcd_is_gcd_l d (gcd_comm d p) (gcd_div_r d p));intro.\n  generalize (gcd_is_gcd_r d (gcd_comm d p) (gcd_div_r d p));intro.\n  unfold is_gcd;split; unfold is_gcd;\n  split; apply one_min_div; auto.\n  apply gcd_sym.\n  unfold gcd; split; apply gcd_sym; trivial.\n  unfold gcd; split; apply gcd_sym; trivial.\n  unfold gcd; split; apply gcd_sym; trivial.\n  apply gcd_sym.\n  unfold gcd; split; apply gcd_sym; trivial.\n  unfold gcd; split; apply gcd_sym;Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (gcd_is_gcd (gcd_is_gcd d p q) (gcd_is_gcd d p q)).\n  unfold gcd.\n  case (gcd_is_gcd (gcd d p q) (gcd_is_gcd d p q));intro.\n  generalize (gcd_is_gcd (gcd_is_gcd d p q) (gcd_is_gcd d p q));intro.\n  unfold gcd in H.\n  generalize (gcd_is_gcd (gcd_is_gcd d p q) (gcd_is_gcd d p q));intro.\n  unfold gcd in H.\n  generalize (gcd_is_gcd (gcd_is_gcd (gcd_is_gcd d p q) (gcd_is_gcd d p q));intro.\n  generalize (gcd_is_gcd (gcd_is_gcd d p q) (gcd_is_gcd d p q));intro.\n  unfold gcd in H.\n  generalize (gcd_is_gcd (gcd_is_gcd (gcd_is_gcd d p q) (gcd_is_gcd d p q));intro.\n  unfold gcd in H.\n  generalize (gcd_is_gcd (Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold gcd in |- *; intros.\n  unfold gcd in |- *.\n  apply gcd_is_gcd_l.\n  split; apply gcd_is_gcd; auto.\n  intros.\n  elim H; intro.\n  elim H; intro.\n  apply H; intro.\n  apply H0.\n  apply gcd_sym; apply gcd_is_gcd; auto.\n  intros.\n  elim H; intro.\n  apply H1.\n  apply H0.\n  apply gcd_sym; apply gcd_is_gcd; auto.\n  intros.\n  elim H; intro.\n  apply H0.\n  apply gcd_sym; apply gcd_is_gcd; auto.\n  intros.\n  elim H1; intro.\n  apply H0.\n  apply gcd_sym; apply gcd_is_gcd; auto.\n  intros.\n  elim H1; intro.\n  apply H0.\n  apply gcd_sym; apply gcd_is_gcd; auto.\n  intros.\n  elim H1; intro.\n  apply H1.\n  apply H0.\n  apply gcd_sym; apply gcd_is_gcd; auto.\n  intros.\n  elim H1; intro.\n  apply H1.\n  apply H1.\n Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  generalize (gcd_0_l (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_l (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_l (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_l (d*q) (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_l (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_r (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_l (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_r (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_r (d*q) (d*q) (d*q)).\n  intro; elim (gcd_0_l (d*q) (d*q) (d*q)).Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  generalize (gcd_is_gcd_l d (gcd_divide_l d p) (gcd_div_l d p));intro.\n  generalize (gcd_is_gcd_r d (gcd_divide_l d p));intro.\n  destruct (gcd_is_gcd_r d (gcd_divide_r d p) (gcd_gcd_gcd_r d p));\n  destruct (gcd_is_gcd_r d (gcd_gcd_gcd_l d p) (gcd_gcd_gcd_l d p));\n  destruct (gcd_is_gcd_r d (gcd_gcd_gcd_l d p) (gcd_gcd_gcd_l d p));\n  destruct (gcd_is_gcd_l d p) as (q,r).\n  rewrite H1.\n  destruct (gcd_is_gcd_l d p) as (q,r).\n  rewrite H2.\n  rewrite <- H1.\n  destruct (gcd_is_gcd_r d p) as (q,r).\n  rewrite H2.\n  destruct (gcd_is_gcd_l d p) as (q,r).Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold gcd; intros.\n  case (gcd_is_gcd (gcd_is_gcd d p) (gcd_is_gcd (gcd_is_gcd d p) q)); intros.\n  generalize (gcd_is_gcd (gcd_is_gcd d p) (gcd_is_gcd (gcd_is_gcd d p) q)); intro.\n  generalize (gcd_is_gcd (gcd_is_gcd (gcd_is_gcd d p) q)); intro.\n  rewrite H0 in H2.\n  assert (forall x, x<gcd (gcd_is_gcd (gcd_is_gcd d p) (gcd_is_gcd (gcd_is_gcd d p) q)) (gcd_is_gcd (gcd_is_gcd d p) q));\n   intro.\n   apply H4;red;split; [exists q; rewrite H3;ring | exists q'; rewrite H3;ring ].\n   rewrite H3; rewrite H4; ring.\n   apply H4; simpl; auto with arith.\n   apply H4; simpl; auto with arith.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd;intro.\n  generalize (gcd_divide_l (gcd_divide_l d p) (gcd_divide_r d p)); intro.\n  generalize (gcd_divide_r (gcd_divide_r d p) (gcd_divide_l d p)); intro.\n  rewrite H; auto with arith.\n  apply gcd_divide_r.\n  intros.\n  elim H1; intro.\n  rewrite H2 in H3.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in H2.\n  rewrite H3 in HQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  unfold gcd; intros.\n  generalize (gcd_is_gcd_l (gcd_divide_r d p) (gcd_divide_l d p H));intro.\n  generalize (gcd_is_gcd_l (gcd_divide_r d p) (gcd_divide_l d p H));intro.\n  generalize (gcd_is_gcd_l (gcd_divide_r d p) (gcd_divide_r d p H));intro.\n  generalize (gcd_is_gcd_r (gcd_divide_r d p) (gcd_divide_r d p H));intro.\n  generalize (gcd_is_gcd_r (gcd_divide_r d p) (gcd_divide_r d p H));intro.\n  generalize (gcd_is_gcd_l (gcd_divide_r d p) (gcd_divide_r d p H));intro.\n  generalize (gcd_is_gcd_r (gcd_divide_r d p) (gcd_divide_r d p H));intro.\n  generalize (gcd_is_gcd_l (gcd_divide_r d p) (gcd_divide_r d p H));introQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  generalize (spec_eq q);intro; elim p;intro q;unfold is_gcd;\n    unfold is_gcd;\n    unfold is_gcd; intros; elim (gcd_spec_divisors q q); intro.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x; apply gcd_refl.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x; apply gcd_refl.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x; apply gcd_refl.\n  exists x; apply gcd_refl.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x; apply gcd_refl.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x; apply gcd_refl.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x; apply gcd_refl.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x; apply gcd_refl.\n  generalize (spec_eq q);intro; elim q;intro.\n  exists x0; apply gcd_Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_intro (gcd_gcd_l d p) (gcd_gcd_l d p));intro.\n  elim (gcd_intro (gcd_gcd_l d p) (gcd_gcd_l d p));intro.\n  apply H; red; tauto.\n  apply H; red; tauto.\n  apply H; red; tauto.\n  apply H; red; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\n",
                "context_tokens": 700,
                "proof_start_offset": 6472,
                "proof_end_offset": 6772,
                "proof": "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros.\nelim (gcd_minus ((u+v)*x-v*y) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  unfold is_gcd; intros.\n  elim H0;intros.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;auto.\n  elim H1;intros.\n  rewrite H3 in H1; simpl in H1;autoQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros x y u v H.\n  generalize (is_gcd_pos x y u H).\n  intro H'.\n  elim H' as [| a b| b| b| b| ]; intro H; simpl in H';\n  rewrite H' in H'; elim H'; clear H'; intro H';\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'; intro H'.\n  rewrite H' in H'; elim H'; clear H'.Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros x y u v H.\n  generalize (spec_div_mod a u v H);intro.\n  generalize (spec_div_mod a u v H);intro.\n  generalize (spec_div_mod a u v H);intro.\n  generalize (spec_div_mod a u v H);intro.\n  generalize (spec_div_mod a u v H);intro.\n  generalize (spec_div_mod a u v H);intro.\n  generalize (spec_mod_eq u v H);intro.\n  generalize (spec_mod_eq u v H);intro.\n  generalize (spec_mod_eq u v H);intro.\n  generalize (spec_mod_eq u v H);intro.\n  generalize (spec_mod_eq u v H);intro.\n  rewrite H2 in H1;simpl in H1;auto.\n  rewrite H2 in H1;simpl in H1;auto.\n  rewrite H3 in H1;simpl in H1;auto.\n  rewrite H3 in H1;simpl in H1;auto.\n  rewrite H3 in H1;simpl in H1;auto.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n intros x y u v; unfold is_gcd.\n intros x y u v H; unfold is_gcd.\n destruct (is_gcd x y) as [H|H].\n apply H; trivial.\n apply H; trivial.\n apply H; trivial.\n apply H; trivial.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  generalize (is_gcd_divide a (u*x) (y-x) (z-x));intro.\n  generalize (is_gcd_divide a (u*y));intro.\n  generalize (is_gcd_divide a (u*x) (z-y));intro.\n  generalize (is_gcd_divide a (u*x) (z-y));intro.\n  generalize (is_gcd_divide b (u*x) (z-y));intro.\n  generalize (is_gcd_divide a (u*y));intro.\n  unfold is_gcd in H.\n  unfold is_gcd;intro.\n  rewrite H in H.\n  generalize (is_gcd_divide b (u*x) (z-x));intro.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H in H.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H in H.\n  rewrite H.\n  apply gcd_divide.\n  generalize (is_gcd_divide b (u*y));intro.\n  rewrite H in H.\n  rewrite H0 in H.\n  rewrite H0 in HQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  unfold is_gcd.\n  intros.\n  generalize (is_gcd_equiv x y u v H H0);intro.\n  generalize (is_gcd_divide a y v H H0);intro.\n  unfold is_gcd;split; unfold is_gcd;\n    split; apply one_min_div.\n  intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  rewrite H7 in H3; simpl in H3;auto.\n  elim H3;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  apply H9; red; split; auto.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; introsQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  unfold is_gcd.\n  intros.\n  generalize (gcd_is_gcd a b x y);intro.\n  generalize (gcd_is_gcd a b y);intro.\n  rewrite H1 in H.\n  generalize (gcd_is_gcd a b y);intro.\n  rewrite H1 in H.\n  rewrite <- H0 in H.\n  rewrite <- H.\n  apply gcd_is_gcd_r with b; trivial.\n  apply gcd_is_gcd.\n  intros.\n  elim H3;intros.\n  elim H5;intro q';intro.\n  rewrite H5 in H3;simpl in H3;auto.\n  rewrite <- H3 in H3;simpl in H3;auto.\n  rewrite <- H3 in H3;simpl in H3;auto.\n  rewrite <- H3 in H3;simpl in H3;auto.\n  rewrite <- H3 in H3;simpl in H3;auto.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  unfold is_gcd; intros.\n  generalize (is_gcd_pos x y u v H);intro.\n  generalize (is_gcd_pos x y u v H);intro.\n  generalize (is_gcd_pos x y u v H);intro.\n  generalize (is_gcd_pos x y u v H);intro.\n  unfold is_gcd;split;unfold is_gcd;intro.\n  split;apply one_min_div.\n  intros.\n  elim H1;intros.\n  rewrite H3 in H1;simpl in H1;auto.\n  rewrite H3 in H1;simpl in H1;auto.\n  rewrite H3 in H1;simpl in H1;auto.\n  rewrite H3 in H1;simpl in H1;auto.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n intros.\n unfold is_gcd.\n  destruct (is_gcd_spec (u*x/v) y) as (q,r).\n  destruct (is_gcd_spec (u*x/v) y) as (r,Hr).\n  destruct (is_gcd_spec (u*x/v) y) as (r',Hr').\n  rewrite Hr in Hr'.\n  destruct (is_gcd_spec (u*x/v) y) as (r',Hr').\n  destruct (is_gcd_spec (u*x/v) y) as (r',Hr').\n  rewrite Hr in Hr'.\n  destruct Hr' as (r'', Hr').\n  split.\n  rewrite Hr' in Hr''.\n  rewrite Hr' in Hr''.\n  apply Hr'; auto.\n  rewrite Hr''.\n  apply Hr''; auto.\n  apply Hr'; auto.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros x y u v H.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intro.\n  rewrite H3 in H3;simpl in H3;auto.\n  rewrite H3 in H3;simpl in H3;auto.\n  rewrite H4 in H3;simpl in H3;auto.\n  rewrite H4 in H3;simpl in H3;auto.\n  rewrite H4 in H3;simpl in H3;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n",
                "context_tokens": 700,
                "proof_start_offset": 6774,
                "proof_end_offset": 7070,
                "proof": "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\nProof.\nintros.\nelim (gcd_minus (v*y-(u+v)*x) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_mult_strong (u+v*x) y (y-x) y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x+v) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x H);intros.\n  elim H0;intro.\n  rewrite H1.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\n  rewrite mult_comm;rewrite mult_minus_lemma2;assumption.\n  rewrite mult_comm;rewrite mult_minus_lemma2;assumption.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_mult_strong_strong_strong_strong_strong_strong_strong_strong (u*x+v) x y u v H);intros.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (u*y) x y z H);intros.\n  elim H1;intro.\n  elim H2;intro.\n  apply H2;red;split;[exists q;rewrite H1;ring | exists q;rewrite H2;ring].\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_mult_strong (v*x-v) x y u H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;try (auto with arith);rewrite mult_minus_distr_r;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x) y (z-y) x (z-x));intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;try (auto with arith);rewrite mult_minus_distr_r;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_mult_div_l u x y u v H);intros.\n  rewrite H1; rewrite mult_minus_distr_r; rewrite <- minus_minus_lemma2;assumption.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\n  apply H3.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\n  apply H3.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\n  apply H3.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\n  apply H3.\n  rewrite mult_plus_distr_l;rewrite <- minus_minus_lemma2;assumption.\n  apply H3.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;assumption.\n Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x+v) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma2;try (auto with arith);rewrite <- mult_minus_lemma1;auto.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_r;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_r;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_l;auto with arith.\n  apply mult_le_compat_rQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x (y-x));intros.\n  rewrite mult_plus_distr_r;rewrite <- H1;ring.\n  apply H1.\n  rewrite mult_plus_distr_r;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_l;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_l;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_l;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_r;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_l;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_l;rewrite <- H1;ring.\n  apply H0.\n  rewrite mult_plus_distr_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\n",
                "context_tokens": 677,
                "proof_start_offset": 7098,
                "proof_end_offset": 8538,
                "proof": "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nright;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\nelim (H (S n,snd x-S n));try (intro;simpl).\nelim a;intro y;intro.\nleft;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nright;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nrewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\ndestruct (snd x).\nleft;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n));try (intro;simpl).\nelim a;intro y;intro.\nright;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nleft;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (is_gcd (fst y) (snd x)); intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  rewrite H3 in H1;simpl in H1;auto.\n  rewrite <- H3; auto.\n  rewrite mult_plus_distr_r; rewrite <- minus_minus_lemma1;trivial.\n  rewrite mult_plus_distr_r; rewrite <- minus_minus_lemma2;trivial.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (is_gcd_prime x y H); intros.\n  rewrite <- H in H0.\n  rewrite <- H0 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 in H1.\n  rewrite <- H1 inQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\nProof.\n  intros.\n  generalize (is_gcd_prime x (is_gcd (fst x));intro.\n  elim (is_gcd (fst x) (snd x));intro.\n  elim (is_gcd (fst x) (snd y));intro.\n  elim (is_gcd (fst x) (snd y));intro.\n  elim (is_gcd (snd x) (snd x));intro.\n  elim (is_gcd (fst x) (snd y));intro.\n  elim (is_gcd (fst x) (snd x));intro.\n  elim (is_gcd (snd x) (snd x));intro.\n  elim (is_gcd (fst x) (snd y));intro.\n  elim (is_gcd (snd x) (snd x));intro.\n  elim (is_gcd (snd x) (snd y));intro.\n  elim (is_gcd (fst x) (snd x));intro.\n  elim (is_gcd (fst x) (snd x));intro.\n  elim (is_gcd (fst x) (snd y));intro.\n  elim (is_gcd (fst x) (snd y));intro.\n  elim (is_gcd (Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  rewrite H2 in H2; simpl in H2; auto.\n  elim H2; intros.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 in H2; simpl in H2; auto.\n  elim H2; intros.\n  rewrite H3 inQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\nProof.\nintros x y u v H.\nelim (gcd_minus_r x y u H);intros.\nelim H.\nrewrite mult_plus_distr_r;rewrite <- mult_plus_distr_r;rewrite <- mult_plus_distr_r;\nrewrite <- mult_plus_distr_r;rewrite <- mult_plus_distr_r;\nrewrite <- mult_plus_distr_l; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_distr_r; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_distr_r; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_distr_r; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_distr_r; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_distr_r; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_distr_r; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_distr_r; rewrite <- mult_plus_distr_r;\n rewrite <- mult_plus_Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\nProof.\n  intros.\n  elim H.\n  intro.\n  elim H0.\n  intros.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H2 in H1;simpl in H1;auto.\n  rewrite H2 in H1;simpl in H1;auto.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (is_gcd_spec (is_gcd (snd x) (snd y) (snd x))).\n  intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;ring.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_minus ((snd x),(snd y))(snd x)); intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  rewrite H4 in H2; simpl in H2; auto.\n  apply H3.\n  rewrite mult_plus_distr_r; rewrite <- minus_minus_lemma2;trivial.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  rewrite H0 in H.\n  assert (H0:=is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (is_gcd_pos x).\n  apply (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\nLemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\n",
                "context_tokens": 690,
                "proof_start_offset": 8563,
                "proof_end_offset": 8967,
                "proof": "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros.\nelim (bezout_exists_prod (a,b));intro.\nelim a0;destruct x;simpl;intros.\nleft;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\nelim b0;destruct x;simpl;intros.\nright;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  apply beometric_gcd.\n  intros.\n  unfold is_gcd.\n  case (is_gcd (a*u) a b H); intros.\n  case (is_gcd (a*u) a b H); intros.\n  apply H.\n  rewrite H1; rewrite H2; rewrite <- H3; rewrite <- H1; auto.\n  apply H.\n  rewrite H1; rewrite H2; rewrite <- H1; rewrite <- H2; auto.\n  apply H.\n  rewrite H1; rewrite H2; rewrite <- H1; auto.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros.\n  case (is_gcd a b).\n  case (is_gcd a b).\n  intros.\n  right;exists 0%nat;exists 0%nat;exists 0%nat;exists 0%nat;exists 0%nat;exists 0%nat;exists 0%nat;\n    rewrite <- plus_n_O; rewrite <- plus_n_O; reflexivity.\n  left; exists 0%nat; exists 0%nat; exists 0%nat; exists 0%nat;\n    rewrite <- plus_n_O; rewrite <- plus_n_O; rewrite plus_comm;\n    apply gcd_refl.\n  elim a;intro.\n  right; exists 0%nat; exists 0%nat; exists 0%nat; exists 0%nat;\n    rewrite <- plus_n_O; rewrite <- plus_n_O; reflexivity.\n  right; exists 0%nat; exists 0%nat; exists 0%nat;\n    rewrite <- plus_n_O; rewrite <- plus_n_O; rewrite <- plus_n_O;\n    apply gcd_refl.\n  exists 0%nat; exists 0%nat; exists 0%nat; exists 0%nat;\n    rewrite <-Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  case (well_founded_induction_ind a b); intros.\n  rewrite H.\n  elim (is_gcd_spec a b); intros.\n  rewrite H0; apply is_gcd_intro; trivial.\n  rewrite H0; apply is_gcd_intro; trivial.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  elim (is_gcd_bound a b); intros.\n  elim (is_gcd_bound a b); intros.\n  elim (is_gcd_bound a b); intros.\n  elim (is_gcd_bound a b); intros.\n  elim (is_gcd_bound a b); intros.\n  elim (is_gcd_bound b q); intros.\n  apply H2.\n  rewrite <- H2; apply gcd_refl.\n  simpl; apply gcd_refl.\n  simpl; apply gcd_refl.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros a b.\ndestruct a as [|a|a].\n(* a = 0 *)\ndestruct a as [|a|a].\n(* a = 0 *)\ndestruct a as [|a].\nrewrite a' in H.\nrewrite plus_0_r in H.\nelim (le_Sn_O _ H).\n(* a = 0 *)\ndestruct a as [|a].\nrewrite a' in H.\nrewrite plus_0_r in H.\nelim (le_Sn_O _ H).\nrewrite <- plus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros.\n  unfold is_gcd.\n  simple induction a;intros; simpl in |- *; auto with arith.\n  intros; elim (H a);intros; simpl in |- *; auto with arith.\n  intros; elim (H0 a); intros; simpl in |- *; auto with arith.\n  intros; elim (H a); intros; simpl in |- *; auto with arith.\n  intros; elim (H0 a); intros; simpl in |- *; auto with arith.\n  intros; elim (H0 a); intros; simpl in |- *; auto with arith.\n  intros; elim (H a); intros; simpl in |- *; auto with arith.\n  intros; elim (H0 a); intros; simpl in |- *; auto with arith.\n  intros; elim (H0 a); intros; simpl in |- *; auto with arith.\n  intros; elim (H0 a); intros; simpl in |- *; auto with arith.\n  intros; elim (H0 a); intros; simpl in |- *; auto with arith.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros a b.\ndestruct a as [|a|a].\nsimpl;intros.\nelim (is_gcd_prime a b); intros.\nelim (is_gcd_prime a b); intros.\nexists (r-a); split; auto with arith.\nelim (is_gcd_prime a b); intros.\nexists (r+1); split; auto with arith.\nelim (is_gcd_prime a b); intros.\nexists r; split; auto with arith.\nelim (is_gcd_prime b a); intros.\nexists r; split; auto with arith.\nelim (is_gcd_prime a b); intros.\nexists (r+1); split; auto with arith.\nelim (is_gcd_prime a b); intros.\nexists r; split; auto with arith.\nelim (is_gcd_prime a b); intros.\nexists r; split; auto with arith.\nelim (is_gcd_prime a b); intros.\nexists r; split; auto with arith.\nelim (is_gcd_prime b a); intros.\nexists r; split; auto with arith.\nelim (is_Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintro a; elim a; intros.\nelim (is_gcd a b); intros.\nleft; exists (a/u).\nsimpl;apply gcd_refl.\nelim a;intro.\nexists (is_gcd a b).\nsimpl;apply gcd_refl.\nelim a;intro.\nexists (is_gcd a b).\nsimpl;apply gcd_refl.\nelim a;intro.\nexists (is_gcd a b).\nsimpl;apply gcd_refl.\nelim a;intro.\nexists (is_gcd a b).\nsimpl;apply gcd_refl.\nelim b;intro.\nexists (is_gcd a b).\nsimpl;apply gcd_refl.\nelim a;intro.\nexists (is_gcd a b).\nsimpl;apply gcd_refl.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  destruct a.\n  destruct b.\n  right;exists 1.\n  right;exists 0.\n  apply is_gcd_1;auto.\n  right;exists 0.\n  apply is_gcd_2;auto.\n  right;exists 0.\n  apply is_gcd_2;auto.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b.\n  case (lt_eq_lt_dec 0 a);intro.\n  elim (le_gt_dec 0 a);intro.\n  left; exists (2*a);simpl;auto.\n  right;exists (2*a);simpl;auto.\n  right;exists (2*a);simpl;auto.\n  right;exists (2*a);simpl;auto.\n  right;exists (2*a);simpl;auto.\n  right;exists (2*a);simpl;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\n",
                "context_tokens": 708,
                "proof_start_offset": 9005,
                "proof_end_offset": 9380,
                "proof": "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\nelim (bezout_exists a b);intro.\nelim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\nelim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  exists (fun x => (u+1) x).\n  exists (fun x => (u+1) x).\n  exists (fun x => (u+1) x).\n  intros.\n  exists (fun x => (u+1) x).\n  intros.\n  elim a0;destruct x;simpl;intros.\n  right;exists (u+1);exists (u+1);exists u;split;trivial.\n  destruct (is_gcd (b*v) x) as [u|u]; destruct u;simpl;intros.\n  left;exists u;exists (u+1);exists u;split;trivial.\n  right;exists u;exists u;split;trivial.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (is_gcd d a b);intros.\n  left; exists 0%nat;exists 0%nat;exists 0%nat;exists 0%nat;exists 0%nat;\n    rewrite mult_comm; rewrite (mult_comm a); trivial.\n  right; exists 0%nat; exists 0%nat; exists 0%nat;\n    rewrite mult_comm; rewrite (mult_comm a); trivial.\n  right; exists 0%nat; exists 0%nat; exists 0%nat;\n    rewrite mult_comm; rewrite (mult_comm a); trivial.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\nelim (is_gcd d a b);intros.\nexists (b*u).\nexists (b*u).\nexists (c*u).\nexists (c*u).\nexists (b*u).\nexists (c*u).\nsplit.\napply (is_gcd (b*u)).\napply (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\napply gcd_greatest; trivial.\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcd (b*u)).\nrewrite <- (is_gcdQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\ndestruct (is_gcd d a b) as [a0 b0|a1].\nexists a1;exists b0;exists 0;exists 0;exists 0;exists 0;exists 0;\nexists a1;exists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;\nexists 0;exists 0;exists 0;exists 0;exists 0;\nexists (S n, 0);exists 0;exists (S n);\nexists 0;exists 0;exists 0;exists 0;exists 0;\nexists (S n, 0);exists 0;exists 0;exists 0;exists 0;exists 0;\nexists 0; exists 0Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\nelim (is_gcd (gcd a b));intro.\nexists (gcd a b);split.\nexists (gcd a b);split.\nexists (gcd a b);split.\nexists (gcd a b);split.\nexists (gcd a b);split.\nexists (gcd a b);split.\nsplit.\nexists (gcd a b);split.\nsplit.\nexists (gcd a b);split.\nrewrite <- (mult_comm a b); auto.\nexists (gcd a b);split.\nsplit.\nexists (gcd a b);split.\nexists (gcd a b);split.\nsplit;auto.\nexists (gcd a b);split.\nexists (gcd a b);split.\nsplit.\nsplit;auto.\nexists (gcd a b);split.\nsplit.\nsplit.\nexists (gcd a b);split.\nsplit;auto.\nexists (gcd a b);split.\nsplit.\nexists (gcd a b);split.\nsplit;auto.\nexists (gcd a b);split.\nsplit;auto.\nexists (gcd a b);split.\nsplit;auto.\nexists (Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  elim (is_gcd_bezout d a b).\n  intro.\n  elim a0;intros.\n  right; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\n    split; [reflexivity | split;trivial];\n  unfold is_gcd; exists 0; exists 0; exists 0; exists 0;\n    split; [reflexivity | split;trivial];\n  unfold is_gcd; exists 0; exists 0; exists 0; exists 0;\n    split; [reflexivity | split;trivial];\n  unfold is_gcd; exists 0; exists 0; exists 0; exists 0;\n    split; [reflexivity | split;trivial];\n  unfold is_gcd; exists 0; exists 0; exists 0; exists 0;\n    split; [reflexivity | split;trivial];\n  unfold is_gcd; exists 0; exists 0; exists 0;\n    split; [reflexivity | split;trivial];\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintro d.\ndestruct (is_gcd_exists d a b).\nexists u.\nexists (d*u-a).\nexists u.\nexists u.\nexists (d*u).\nexists (d*u).\nexists d.\nexists u.\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists d.\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists d.\nexists (d*u).\nexists (d*u).\nexists (d*u).\nexists d.\nexists (d*u).\nexists (d*u).\nexists d.\nexists (d*u).\nexists (d*u).\nexists d.\nsplit.\nexists (d*u).\nexists d.\nsplit.\napply (is_gcd_exists d (d*u).\nexists dQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (is_gcd_prime d a b);intros.\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*u).\n  exists (2*Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  destruct (exists_div_eucl d a b) as [u|u]; destruct u as [v|v].\n  left; exists v.\n  exists (fun x => (exists v:nat, u - v = cons v x * u) v).\n  destruct (exists_div_eucl (pos a) b) as [u|v].\n  left; exists u.\n  exists u.\n  exists (fun x => (exists v:nat, u - v = cons v x) v).\n  simpl; apply is_gcd_pos;auto.\n  right; exists u.\n  exists (fun x => (exists v:nat, u - v = cons v x) v).\n  simpl; apply is_gcd_pos;auto.\n  left; exists u.\n  exists (fun x => (exists v:nat, u - v = cons v x * u) v).\n  simpl; apply is_gcd_pos;auto.\n  right; exists u.\n  split;auto.\n  exists u.\n  split;auto.\n  exists u.\n  split;auto.\n  exists u;auto.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintro d.\nelim (is_gcd (a*u) (a/2) (b/2) (b/2) (b/2) H).\nintro H1.\nelim (is_gcd (a/2) (b/2) (b/2) (b/2) H1).\nintro H2.\nelim (is_gcd (a/2) (b/2) (b/2) (b/2) H1).\nintro H3.\nelim (is_gcd (a/2) (b/2) (b/2) (b/2) (b/2) H3).\nintro H4.\nelim (is_gcd (a/2) (b/2) (b/2) (b/2) (b/2) H4).\nintro H5.\nelim (is_gcd (a/2) (b/2) (b/2) (b/2) H3).\nintro H5.\nelim (is_gcd (a/2) (b/2) (b/2) (b/2) H4).\nintroQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\n",
                "context_tokens": 704,
                "proof_start_offset": 9434,
                "proof_end_offset": 10062,
                "proof": "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nunfold rel_prime.\nsplit;intro.\napply bezout;trivial.\nelim H;intro u;intro H0.\nelim H0;intro v;intro.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H2;intros.\nelim H3;intro q;intro.\nelim H4;intro q';intro.\nrewrite H5 in H1;rewrite H6 in H1.\ncase H1;intro.\nexists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nexists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  elim (rel_prime_dec a b);intro.\n  exists 1.\n  left; exists 0.\n  split;auto.\n  exists 0.\n  split;auto.\n  elim a0;intro.\n  left; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\n    split;auto.\n  destruct a0;intro.\n  left; exists 0.\n  split;auto.\n  right; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\n    split;auto.\n  elim b0;intro.\n  right; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\n    split;auto.\n  elim b0;intro.\n  right; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\n    split;auto.\n  right; exists 0;exists 0;exists 0;existsQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros a b.\ndestruct a as [|a|a].\nleft;exists a;exists b;split;auto.\nright; exists (a*b);split;auto.\nright; exists (a*u);split;auto.\nright; exists a;split;auto.\nright; exists a;split;auto.\nright; exists a;split;auto.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros a b Ha Hb.\n  elim (hasfactor_prime a b);intro.\n  exists (1, (a,b));exists a;exists b;exists 1;exists 0;exists 0; auto.\n  elim (hasfactor_prime a b);intro.\n  exists (1, (b,b));exists (2, a);exists (2, b);exists b;split;trivial.\n  destruct (rel_prime_dec a b);intro.\n  exists (1, b);exists (2, b);exists (2, b);exists (2, b);split;trivial.\n  destruct (rel_prime_dec a b);intro.\n  exists (2, b);exists (2, b);exists (2, b);split;trivial.\n  destruct (rel_prime_dec a b);intro.\n  exists (2, b); exists (2, b);split;trivial.\n  destruct (rel_prime_dec b b);intro.\n  exists (2, b); exists (2, b);exists (2, b);split;trivial.\n  destruct (rel_prime_dec a b);intro.\n  exists (2, b);exists (Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros a b.\n  elim (rel_prime a b);intro.\n  elim (rel_prime a b);intro.\n  elim (rel_prime a b);intro.\n  elim (rel_prime a b);intro.\n  elim (rel_prime a b);intro.\n  left; exists (S a, b).\n  split;split;auto.\n  elim (rel_prime a b);intro.\n  left; exists 0.\n  split;auto.\n  elim (rel_prime a b);intro.\n  right; exists 0.\n  split;auto.\n  elim (rel_prime a b);intro.\n  left; exists 0.\n  split;auto.\n  elim (rel_prime a b);intro.\n  right; exists 1.\n  split;auto.\n  elim (rel_prime a b);intro.\n  elim (rel_prime b a);intro.\n  elim (rel_prime a b);intro.\n  left; exists 0.\n  split;auto.\n  elim (rel_prime b a);intro.\n  right; exists 0.\n  split;auto.\n  elim (rel_prime b a);intro.\n  right; exists 0.\n  split;auto.Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  exists (rel_prime a b).\n  exists (rel_prime a b).\n  exists (rel_prime a b).\n  split.\n  exists (rel_prime a b).\n  split.\n  rewrite H.\n  apply (rel_prime_noncyclic (b*u) a b).\n  split.\n  rewrite H.\n  apply rel_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.\n  apply mod_prime_noncyclic.Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nelim (rel_prime_dec a b);intro.\nelim (rel_prime_dec a b);intro.\nelim (rel_prime_dec a b);intro.\nelim H1;intros.\nelim H1;intro; exists (x, y);apply (rel_prime_dec x b); auto.\n\nelim H1;intro.\nelim H1;intro.\nelim H1;intro.\nexists (x, y);apply (rel_prime_dec x b); auto.\n\nelim H1;intro.\nexists (x, y);apply (rel_prime_dec x b); auto.\n\nelim H1;intro.\nexists (x, y);apply (rel_prime_dec x b); auto.\n\nelim H1;intro.\nexists (x, y);apply (rel_prime_dec x b); auto.\n\nelim H1;intro.\nexists (x, y);apply (rel_prime_dec x b); auto.\n\nelim H1;intro.\nexists (x, y);apply (rel_prime_dec x b); auto.\n\nelimQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros a b H.\n  destruct (rel_prime_dec a b) as [u|u].\n  left.\n  exists u;exists u;exists u;exists u;split.\n  destruct u;destruct u;destruct u;destruct u;simpl;intros.\n  right;exists u;exists (u-b*u);exists u;split;trivial.\n  left;exists u;exists u;exists u;split;trivial.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros a b H.\n  elim (rel_prime a b);intro.\n  exists (a, b);split.\n  destruct a0; destruct b;simpl;intros.\n  right;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;apply (gcd_intro b H).\n  split; [apply (rel_prime_intro b H) | idtac ].\n  split; [assumption | apply (rel_prime_intro b H) ].\n  elim (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n  intros.\n  apply (rel_prime_intro b H).\n Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  exists (rel_prime a b).\n  elim a0;intro b;intros.\n  elim (rel_prime_gt_1 a b);intro.\n  left; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;split;\n    rewrite <- (mult_comm a0 (S a0) (S b0) (S a0) (S b0) H0 H1)).\n  left; split; trivial.\n  elim b0;intro b;intros.\n  elim (rel_prime_gt_2 a b);intro.\n  right; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\n    apply (gcd_unique (b*u) a b).\n  elim b0;intro b;intros.\n  elim (rel_prime_gt_1 a b);intro.\n  right; exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;exists 0;\n    split; [apply (gcd_unique (b*u) a b); assumption | ].\n  right; exists 0;exists 0;exists 0;exists 0;exists 0Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  elim (rel_prime_dec a b);intro.\n  elim (rel_prime_dec a b);intro.\n  elim (rel_prime_dec a b);intro.\n  elim (rel_prime_dec a b);intro.\n  left; exists (1, a);split;auto.\n  right; exists (2, b);split;auto.\n  right; exists (1, b);split;auto.\n  right; exists (2, b);split;auto.\n  right; exists (1, b);split;auto.\n  right; exists (2, b);split;auto.\n  right; exists (2, b);split;auto.\n  right; exists (2, b);split;auto.\n  right; exists (2, b);split;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 10097,
                "proof_end_offset": 10866,
                "proof": "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nunfold is_gcd;unfold is_cd.\nintros.\nelim H;intros.\nelim H0;intros.\nsplit.\nelim H2;intro q;intro.\nelim H3;intro q';intro.\nrewrite H4;rewrite mult_assoc.\nrewrite H5;rewrite mult_assoc.\nsplit;[exists q;trivial | exists q';trivial].\nintros.\nelim H4;intros.\nelim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\nintro u;intro.\nelim H7;intro v;intro.\nelim H5;intro q;intro.\nelim H6;intro q';intro.\ncase H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n  intros.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_mult.\n  apply gcd_Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n intros.\n unfold gcd in |- *.\n unfold gcd in |- *.\n unfold gcd in |- *.\n unfold gcd in |- *.\n unfold gcd in |- *.\n unfold rel_prime in H.\n unfold gcd in |- *.\n unfold gcd in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n intros.\n generalize (gcd_mult_strong (gcd n (a*b) (n*b) a) (gcd n (a*b) (n*b)).\n rewrite <-gcd_mult.\n rewrite gcd_mult.\n rewrite gcd_mult.\n rewrite <- gcd_mult_strong; rewrite <- gcd_mult.\n rewrite <- gcd_mult.\n rewrite <- gcd_mult.\n rewrite <- gcd_mult.\n rewrite gcd_assoc.\n rewrite <- gcd_mult.\n rewrite gcd_mult.\n rewrite <- gcd_mult.\n rewrite gcd_mult.\n rewrite <- gcd_mult.\n rewrite gcd_mult.\n rewrite <- gcd_mult.\n rewrite <- gcd_mult.\n rewrite gcd_mul.\n rewrite <- gcd_mult.\n rewrite <- gcd_mult.\n rewrite gcd_mult.\n rewrite gcd_comm.\n rewrite <- gcd_mult.\n rewrite <- gcd_mult.\n rewrite <- gcd_mul.\n rewrite gcd_comm.\n rewrite gcd_mult.\n rewrite gcd_comm.\n rewrite <- gcd_mult.\n rewrite gcd_mul.\n rewrite <- gcd_mul.\n rewrite <- gcd_mult.\n rewriteQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nintros.\nelim (gcd_mult_strong (n*a) (n*b) (n*a)).\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*b)).\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*b)).\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*b)); auto with arith.\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*b)); auto with arith.\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*b)); auto with arith.\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*b)); auto with arith.\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*b)); auto with arith.\nintro.\nelim (gcd_mult_strong (n*a) (n*b) (n*aQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n intros.\n destruct (is_gcd (n*a*b) (n*b));\n destruct (is_gcd (n*a*b));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*b) (n*b));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*a));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*b) (n*b));\n destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*a) (n*b)); destruct (is_gcd (n*a) (n*b));\n destruct (is_gcd (n*a) (n*b));\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n intros.\n unfold rel_prime.\n case (gcd_mult_strong (a*b) (n*b));intro.\n elim (gcd_mult_strong (a*b) (n*b));intro.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_mult.Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n intros.\n rewrite <- (gcd_mult d a b).\n apply gcd_mult.\n apply gcd_mult.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_sym.\n apply gcd_symQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n  intros.\n  elim (gcd_mult_strong (gcd n a) (gcd n b));intro.\n  elim (gcd_mult_strong (gcd n a) (gcd n b));intro.\n  elim (gcd_mult_strong (gcd n a) (gcd n b));intro.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite H0.\n  rewrite <- H2.\n  rewrite H1.\n  rewrite <- H3.\n  rewrite <- H2.\n  rewrite <- H3.\n  rewrite H3.\n  rewrite <- H2.\n  rewrite H1.\n  rewrite <- H3.\n  rewrite <- H2.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite H0.\n  rewrite <- H3.\n  rewrite H3.\n  rewrite <- H3.\n  rewrite <- H1.\n  rewrite <- H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewrite H3.\n  rewrite <- H3.\n  rewrite <- H3.\n  rewriteQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n intros.\n generalize (gcd_mult_l (a*b) (b*a) (b*b) (b*a)).\n generalize (gcd_mult_r (a*b) (b*a) (b*b)).\n generalize (gcd_mult_l (a*b) (b*a) (b*b) (b*a)).\n destruct (gcd_mult_l (a*b) (b*a) (b*b) (b*a)).\n destruct (gcd_mult_l (a*b) (b*b) (b*a)).\n split.\n apply div_mult_l; trivial.\n apply div_mult_l; trivial.\n apply div_mult; trivial.\n apply div_mult_l; trivial.\n apply div_mult_l; trivial.\nQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\n intros.\n generalize (is_gcd_divide d a b).\n generalize (is_gcd_divide d a b).\n generalize (is_gcd_divide d a b).\n generalize (is_gcd_divide d a b).\n destruct (is_gcd (n*a) (n*b) (n*a)).\n destruct (is_gcd (n*a) (n*b) (n*b)); tauto.\n generalize (is_gcd_divide d a b).\n destruct (is_gcd (n*b) (n*b)); tauto.\n generalize (is_gcd_divide d a b).\n destruct (is_gcd (n*a) (n*b)); tauto.\n generalize (is_gcd_divide d a b).\n destruct (is_gcd (n*a) (n*b)); tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "formulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 10903,
                "proof_end_offset": 11396,
                "proof": "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nintros.\nelim (bezout 1 a d H);intro u;intro.\nelim H1;intro v;intro.\nelim H0;intro q;intro.\ncase H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\n  unfold rel_prime.\n  split.\n  apply rel_prime; assumption.\n  apply rel_prime; assumption.\n  apply rel_prime; assumption.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros.\ndestruct (rel_prime_dec (gcd a b) (gcd a d)); auto with *.\nrewrite <- (mult_assoc (a*b) d);auto with *.\nrewrite <- (mult_assoc (a*b) d);auto with *.\nrewrite <- (mult_assoc (a*b) d);auto with *.\nrewrite <- (mult_assoc (a*b) d);auto with *.\nrewrite <- (mult_assoc a d);auto with *.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nintros.\nelim H.\nunfold rel_prime in |- *.\nintros.\nelim H.\nunfold rel_prime in |- *.\nintros.\nelim (rel_prime a b);intros.\nelim (rel_prime a b);intros.\nelim (rel_prime_intro b d);intros.\nelim (rel_prime_intro b d);intros.\nelim (rel_prime_intro b d);intros.\nelim (rel_prime_intro b d);intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d);intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b d); intros.\nelim (rel_prime_intro b dQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nunfold rel_prime.\nunfold rel_prime.\nintros.\nelim (rel_prime a b);intro.\nelim (rel_prime a b);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime_intro b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b a);intro.\nelim H3;intro q';intro.\nelim (rel_prime b a);intro.\nelim (rel_prime b b);intro.\nelim (rel_prime b a);intro.\nelim H3;intro q';intro.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold gcd;intros;split.\n  rewrite (rel_prime_mult d a b); apply div_mult; trivial.\n  apply gcd_mult; trivial.\n  apply gcd_mult; trivial.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\n  intros.\n  elim (divide_antisym d a);intro.\n  elim (divide_antisym d a);intro.\n  elim (divide_antisym d a);intro.\n  elim (divide_antisym d a);intro.\n  rewrite H2; rewrite mult_assoc; rewrite <- H1; rewrite mult_assoc; rewrite <- H2; rewrite H; rewrite H0;\n  rewrite (mult_comm a b); rewrite (mult_comm b d); reflexivity.\n  intros.\n  elim (divide_antisym d a);intro.\n  elim (divide_antisym d a);intro.\n  rewrite H2; rewrite H3; rewrite mult_assoc; rewrite (mult_comm b d); reflexivity.\n  intros.\n  elim (divide_antisym d a);intro.\n  elim (divide_antisym d a);intro.\n  rewrite H2; rewrite mult_assoc; rewrite <- H1; rewrite (mult_comm a d); reflexivity.\n  intros.\n  elim (divide_antisym d a);intro.\n  rewrite H2; rewrite mult_comm; rewrite (mult_comm a d); reflexivity.\n  intros.\n  elim (divide_antisym d a);intro.\n  rewrite H2; rewrite mult_Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nintros d a b H.\ndestruct (rel_prime_dec a b) as [H|H].\nrewrite H.\napply div_mult_strong; trivial.\ndestruct (rel_prime_dec a b) as [H|H].\nexists (a*b); trivial.\nexists (a*b); trivial.\nQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros d a b.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in |- *.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in H.\nunfold rel_prime in HQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros.\nunfold rel_prime.\nsplit;intro.\nelim H;intro.\nelim (divide_intro _ H3).\nelim (divide_intro _ H4).\napply (divide_intro _ H4).\nelim (divide_intro _ H5).\nelim (divide_intro _ H5).\napply (divide_intro _ H4).\nelim (divide_intro _ H5).\napply (divide_intro _ H5).\nelim (divide_intro _ H5).\napply (divide_intro _ H5).\nelim (divide_intro _ H5).\napply (divide_intro _ H4).\napply (divide_intro _ H4).\napply (divide_intro _ H4).\napply (divide_intro _ H4).\nelim (divide_intro _ H5).\nelim (divide_intro _ H5).\nelim (divide_intro _ H5).\napply (divide_intro _ H5).\nelim (divide_intro _ H4).\napply (divide_intro _ H4).\nelim (divide_intro _ H5).\napply (divide_intro _ H4).\napply (Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros d a b.\nunfold rel_prime.\nintros d a b.\nunfold rel_prime.\nelim (rel_prime a b);intro.\nelim (rel_prime_intro d a);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d a);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d b);intro.\nelim (rel_prime_intro d bQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\nTheorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro u;intro.\n  elim H1;intro v;intro.\n  elim H0;intro q;intro.\n  case H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 11456,
                "proof_end_offset": 13305,
                "proof": "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nintros.\ngeneralize (quo_rem_euclide a b H);intro.\nred;split;intro.\nrewrite H0 in H1.\nelim H1;intros.\nunfold is_gcd;unfold is_cd.\nelim H2;intros.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nreplace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\nassert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\nrewrite <- H6;rewrite minus_plus;trivial.\nrewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\nexists (q-q'*(quotient_euclide a b H));trivial.\nrewrite <- H7;trivial.\nintros.\nelim H6;intros.\napply H3.\nunfold is_cd;split;try tauto.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nrewrite H10.\nreplace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H9;trivial.\nunfold is_gcd;unfold is_cd.\nunfold is_gcd in H1;unfold is_cd in H1.\nelim H1;intros.\nelim H2;intros.\nrewrite H0.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H7.\nreplace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H6;trivial.\nintros.\napply H3.\nsplit;try tauto.\nelim H6;intros.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nassert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\nrewrite minus_plus;trivial.\nrewrite H9 in H11.\nexists (q-q'*(quotient_euclide a b H)).\nrewrite mult_minus_lemma2;rewrite mult_assoc.\nrewrite <- H10;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\n intros.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(a/b)); trivial.\n apply mod_unique with (b*(a/b)); trivial.\n apply mod_unique with (b*(a/b)); trivial.\n apply mod_unique with (b*(a/b)); trivial.\n apply mod_unique with (b*(b/b))); trivial.\n apply mod_unique with (b*(a/b))); trivial.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(b/b)); trivial.\n apply mod_unique with (b*(a/b)); trivial.\n apply mod_unique with (b*(a/b))); trivial.\n apply mod_unique with (b*(aQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime in |- *.\n  intros.\n  elim (divide_antisym b d H);intro.\n  apply H; trivial.\n  apply H; trivial.\n  apply H; trivial.\nQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\n  intros.\n  elim (gcd_eucl_sound _ _ _ _ H);intro u;intro.\n  elim H1;intro q;intro.\n  elim H0;intro q;intro q;intro.\n  elim H1;intro q;intro q;intro.\n  elim H3;intro q;intro q;intro.\n  elim H3;intro q;intro q;intro q.\n  elim H3;intro q;intro q.\n  elim H5;intro q;intro q; elim q;intro q.\n  elim H5;intro q;intro q.\n  rewrite H5 in H1; rewrite H6 in H1.\n  case H1;intro q;intro q; elim H1;intro q.\n  elim H5;intro q;intro q.\n  elim H5;intro q;intro q; elim H5;intro q.\n  rewrite H5 in H1; rewrite H6 in H1.\n  case H1; intro q; elim H5;intro q.\n  elim H5;intro q;intro q.\n  rewrite H5 in H1; rewrite H5 in H1.\n  case H1; intro q; elim H5Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (divide_1_l (a*b) (b*a) (b*b) (d*a));intro u;intro u;intro.\n  elim H1;intro q;intro q;intro.\n  elim H2;intro q;intro.\n  rewrite H3 in H1; rewrite <- H1 in H1; rewrite <- H2 in H1.\n  case H1;intro q';intro q';intro q'.\n  rewrite H4 in H1; rewrite <- H1 in H1.\n  case (le_or_lt q q);intro; [exists (q*u-q*u).\n  rewrite mult_minus_lemma2; rewrite <- H3; rewrite <- H3; rewrite <- H4; rewrite (mult_comm a b); rewrite (mult_comm b b);\n  rewrite <- mult_minus_lemma2; rewrite <- H4; rewrite (mult_comm b a); rewrite (mult_comm b a);\n  rewrite (mult_comm b b); rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b a);\n  rewrite (mult_commQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;\n  unfold is_gcd;simpl; unfold is_gcd;\n  unfold is_gcd;simpl; unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;simpl; unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd; unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;\n  unfold is_gcd;Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime.\nintros.\nelim (gcd_euclNondiv_euclaux_aux d a b);intro.\nelim (gcd_euclNondiv_euclaux_aux d a b);intro.\nelim (gcd_euclNondiv_euclaux d a b);intro.\nelim (gcd_euclNondiv_aux_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux d a b);intro.\nelim (gcd_euclNondiv_aux dQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\n unfold rel_prime.\n intros.\n destruct (rel_prime_dec (d a) (d * b) (d * b) (d * b) (d * b) d H0);\n  [ rewrite (H d) in H; rewrite (H d) in H; rewrite (H d) in H; rewrite (H d) in H; rewrite (H d) in H;\n    rewrite (mult_comm a b) in H; rewrite (mult_comm d b) in H; rewrite (mult_comm b d) in H;\n    rewrite (mult_comm a b) in H; rewrite (mult_comm a b) in H; rewrite (mult_comm d b) in H;\n    rewrite (mult_comm b a) in H; rewrite (mult_comm b d) in H; rewrite (mult_comm a b) in H;\n    rewrite (mult_comm b b) in H; rewrite (mult_comm b a) in H; rewrite (mult_comm b b) in H;\n    rewrite (mult_comm b b) in H; rewrite (mult_comm a b) in H; rewrite (mult_comm b bQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime.\nintros.\nelim (divide_0_l (gcd_euclOK b H)).\nintro u;intro.\nelim H1;intro q;intro.\nelim H1;intro q;intro q.\nelim H1;intro q;intro q.\nelim H1;intro q;intro q.\nelim H2;intro q;intro q.\nelim H3;intro q;intro q.\nelim H3;intro q;intro q.\nelim H4;intro q.\nelim H3;intro q;intro q.\nelim H5;intro q.\nelim H5;intro q.\nelim H5;intro q.\nelim H5;intro q.\nelim H5;intro q.\nelim H5;intro q.\nrewrite H5; rewrite mult_minus_lemma2; rewrite mult_comm;\n rewrite <- H5; rewrite <- H5; rewrite mult_minus_lemma2; rewrite <- H5;\n rewrite (mult_comm a b); rewrite <- mult_minus_lemma2; rewrite <- H5;\n rewrite (mult_comm a b); rewrite (mult_commQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;unfold is_gcd;\n    unfold is_gcd; unfold is_gcd; unfold is_gcd;\n      unfold is_rel; unfold is_rel;\n      unfold is_rel; unfold is_rel; simpl; unfold is_rel;\n        unfold is_rel; intros; elim H; clear H; intros;\n          elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n            intros; elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n                  intros; elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n                  intros; elim H1; clear H1; intros; elim H1; clear H1;\n                  intros; elim H1; clear H1; intros; elim H1; clear H1;\n                  intros; elim H1; clear H1; intros; elim H1; clear H1; intros; elim H1; clear H1;\n                  intros; elim HQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime in |- *.\nintros.\nelim (divide_antisym (gcd_gcd a d b) H);intro; elim H;intro q; elim q;intro q;\n elim H1;intro q; elim q;intro q; elim q;intro q; elim q;intro q;\n elim H2;intro q; elim q;intro q; elim q;intro q; elim q;intro q;\n elim H2;intro q; elim H4;intro q; elim q;intro q;\n elim q;intro q; elim H4;intro q; elim q;intro q;\n elim H5;intro q; elim q;intro q; elim q;intro q;\n elim H5;intro q; elim q;intro q; elim q;intro q;\n elim H5;intro q; elim q;intro q; elim q;intro q;\n elim H5;intro q; elim q;intro q; elim q;intro q;\n elim H5;intro q; elim H5;intro q; elim q;intro q;\n elim q;intro q; elim H5;intro q; elim q;introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\nLemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  intros.\n  generalize (quo_rem_euclide a b H);intro.\n  red;split;intro.\n  rewrite H0 in H1.\n  elim H1;intros.\n  unfold is_gcd;unfold is_cd.\n  elim H2;intros.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  replace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\n  assert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\n  rewrite <- H6;rewrite minus_plus;trivial.\n  rewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\n  exists (q-q'*(quotient_euclide a b H));trivial.\n  rewrite <- H7;trivial.\n  intros.\n  elim H6;intros.\n  apply H3.\n  unfold is_cd;split;try tauto.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  rewrite H10.\n  replace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 13371,
                "proof_end_offset": 14277,
                "proof": "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof;unfold f;intros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ncase (eq_nat_dec (fst x) 0);intro.\nrewrite e;exists (snd x);apply gcd_zero.\nelim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\nintro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_euclide d (snd x) (fst x) n);auto.\ngeneralize (rem_euclide (snd x) (fst x) n);try omega.\nrewrite e;exists (snd x);apply gcd_refl.\ncase (eq_nat_dec (snd x) 0);intro.\nrewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\nintro d;intro.\nexists d.\nelim (gcd_euclide d (fst x) (snd x) n);auto.\ngeneralize (rem_euclide (fst x) (snd x) n);try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  unfold gcd.\n  apply gcd_unique with (gcd x (fst x) (snd x)); trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (is_gcd_nonneg x).\n  generalize (is_gcd_nonneg x).\n  destruct (is_gcd x (snd x) (snd x)).\n  exists (1,(1,1)).\n  split;try tauto.\n  elim H1;intros.\n  apply H1;trivial.\n  unfold is_gcd;unfold is_gcd;simpl;split;try tauto.\n  elim H2;intros.\n  split;try tauto.\n  elim H2;intro q;intro.\n  elim H5;intro q';intro.\n  replace (a*q*q'*(a/b)*q'*(a/b)*q'*(a/b) mod b) with (a*q*(a/b)).\n  rewrite <- (mult_comm a).\n  rewrite <- (mult_comm a).\n  rewrite <- (mult_comm a).\n  rewrite <- (mult_comm a).\n  rewrite (mult_comm b).\n  rewrite <- (mult_comm b).\n  rewrite <- mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite <- mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm a).Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  unfold gcd, is_gcd, gcd.\n  generalize (is_gcd_nan_correct x H);intro.\n  generalize (is_gcd_nan_correct x H);intro.\n  generalize (is_gcd_correct x H);intro.\n  generalize (is_gcd_correct x H);intro.\n  rewrite (is_gcd_correct x H);intro.\n  generalize (is_gcd_correct x H);intro.\n  generalize (is_gcd_correct x H);intro.\n  rewrite H0 in H1.\n  generalize (is_gcd_correct x H1);intro.\n  rewrite (is_gcd_correct x H0);intro.\n  rewrite (is_gcd_correct x H0);intro.\n  rewrite H0 in H1.\n  generalize (is_gcd_correct x H0);intro.\n  rewrite (is_gcd_correct x H0);intro.\n  rewrite (is_gcd_correct x H0);intro.\n  rewrite (is_gcd_correct x H0);intro.\n  rewrite (is_gcd_correct x H0);intro.\n  rewrite (is_gcd_correct x H0);intro.\n  rewrite (Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n intros.\n generalize (is_gcd_divisors x (fst x));intro.\n generalize (is_gcd_divisors x (fst x));intro.\ngeneralize (is_gcd_divisors x (snd x));intro.\ngeneralize (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (snd x));intro.\nrewrite (is_gcd_divisors x (Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n intros.\n destruct x.\n rewrite <- gcd_div_eucl.\n rewrite <- H.\n rewrite <- H.\n apply gcd_refl.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros; destruct x;simpl;split;try tauto.\n  elim H;intros.\n  split.\n  split;try tauto.\n  elim H1;intros.\n  split;try tauto.\n  elim H2;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H2.\n  split;try tauto.\n  elim H3;intros.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;try tauto.\n  elim H3;intros.\n  rewrite H3.\n  split;Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (gcd_mult_nan x (fst x) (snd x)).\n  generalize (gcd_mult_nan x (fst x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (snd x)).\n  generalize (gcd_mult_nan x (snd x) (sndQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  destruct x as [ | x| x].\n  right.\n  exists (x,(d,d)).\n  apply gcd_unique.\n  apply gcd_unique.\n  apply gcd_unique.\n  apply gcd_unique; trivial.\n  apply gcd_unique; trivial.\n  apply gcd_unique; trivial.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n  intros.\n  case (is_gcd_prop _ _ (proj1 (H x))).\n  intro.\n  case (is_gcd_prop _ _ (proj2 (H x))).\n  intros.\n  unfold is_gcd in H.\n  elim H;intros.\n  split.\n  elim H0;intros.\n  apply H1; auto.\n  apply H0; auto.\n  apply H1; auto.\n  apply H1; auto.\nQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\n intros.\n generalize (is_gcd_nonneg x).\n generalize (is_gcd_nonneg x).\n generalize (is_gcd_nonneg x).\n generalize (is_gcd_nonneg x).\n generalize (is_gcd_pos x).\n generalize (is_gcd_pos x).\n generalize (is_gcd_pos x).\n destruct (is_gcd_nonneg x) as (n,H).\n destruct (gcd_pos_spec x) as (d,H).\n split;intro.\n  split;intro.\n  split;intro.\n  split;intro.\n  rewrite H in H0.\n  apply gcd_divide_l;assumption.\n  split;intro.\n  rewrite H in H0.\n  apply gcd_divide_r;assumption.\n  split;intro.\n  rewrite H in H0.\n  apply gcd_divide_r;assumption.\n  split;intro.\n  rewrite H in H0.\n  apply gcd_divide_r;assumption.\n  split;intro.\n  rewrite H in H0.\n  apply gcd_divide_r;assumption.\n  split;intro.\n  rewrite H in H0.\n  apply gcd_divide_r;assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 730,
                "proof_start_offset": 14326,
                "proof_end_offset": 14485,
                "proof": "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\nexists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  unfold gcd.\n  apply (is_gcd_intro (is_gcd (is_gcd (gcd a b) a b)); auto.\n  intros.\n  apply (is_gcd_intro (is_gcd (gcd a b) a b)); auto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  unfold gcd; intros.\n  case (le_gt_dec a b);intro.\n  rewrite H0.\n  replace (a*b) with (a*b); auto with arith.\n  apply gcd_intro; auto with arith.\n  case (gcd_eucl_OK a b); auto with arith.\n  intros.\n  apply H0.\n  apply gcd_intro; auto with arith.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros a b.\n  apply (is_gcd_unique b (is_gcd_bound a b)); auto.\n  destruct (is_gcd_unique b (is_gcd_bound a b)); auto.\n  apply is_gcd_intro.\n  apply (is_gcd_unique b (is_gcd_bound a b)); auto.\n  destruct (is_gcd_unique b (is_gcd_bound b (is_gcd_bound a b)); auto.\n  apply (is_gcd_unique b (is_gcd_bound b (is_gcd_bound a b))); auto.\n  destruct (is_gcd_unique b (is_gcd_bound a b)); auto.\n  apply (is_gcd_unique b (is_gcd_bound a b)); auto.\n  apply (is_gcd_unique b (is_gcd_bound b (is_gcd_bound b (is_gcd_bound a b))); auto.\n  apply (is_gcd_unique b (is_gcd_bound b (is_gcd_bound a b))); auto.\n  apply (is_gcd_unique b (is_gcd_bound a b)); auto.\n  apply (is_gcd_uniqueQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros a b.\n  destruct (is_gcd d a b) as [H|H].\n  apply (gcd_intro _ _ H).\n  apply gcd_unique in H; destruct H as [H|H].\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ H).\n  apply (gcd_intro _ _ HQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  unfold gcd; unfold gcd; intros.\n  case (le_gt_dec (fst a) (snd b));intro.\n  rewrite e;exists (fst x);apply gcd_0_l; auto.\n  intros.\n  case (eq_nat_dec (fst a) 0);intro.\n  rewrite e;exists (fst x);apply gcd_0_l; auto.\n  rewrite e;exists (snd x);apply gcd_0_r; auto.\n  intros.\n  elim H1;intros.\n  rewrite H0 in H0.\n  apply gcd_trans with (fst x) (snd x); auto.\n  apply gcd_0_l; auto.\n  rewrite H3 in H0.\n  apply gcd_0_l; auto.\n  rewrite H3 in H0.\n  apply gcd_trans with (fst x); auto.\n  apply gcd_0_l; auto.\n  rewrite H3 in H0.\n  apply gcd_0_r; auto.\n  rewrite H3 in H0.\n  apply gcd_0_l; auto.\n  rewrite H3 in H0.\n  apply gcd_trans with (fst x); auto.\n  apply gcd_0Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  generalize (gcd_eq_dec a b); intro.\n  case (gcd_eucl_OK a b); intros.\n  rewrite H; auto.\n  rewrite <- H; auto.\n  rewrite <- H; auto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  unfold gcd; intros a b.\n  case (gcd_spec a b);intros.\n  case (gcd_spec a b);intros.\n  generalize (gcd_antisym a b);intros.\n  generalize (gcd_spec a b);intros.\n  generalize (gcd_spec a b);intros.\n  generalize (gcd_spec a b);intros.\n  rewrite (gcd_spec a b);intros.\n  rewrite (gcd_spec a b);intros.\n  rewrite (gcd_spec a b);intros.\n  apply gcd_divide; auto.\n  rewrite <- H1; tauto.\n  rewrite <- H2; tauto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (gcd_exists_prod a b);intros.\n  case (gcd_eucl_OK b (fst a) (snd b));intros.\n  case (gcd_eucl_OK b (snd a) (snd b));intros.\n  case (gcd_eucl_OK b (snd a) (snd b));intros.\n  case (gcd_eucl_OK b (snd a) (snd b));intros.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H.\n  replace (c*(quotient_eucl (fst a) (fst b) n)) with\n   (c*(c*(quotient_eucl (fst a) (snd b) n)));\n    [ | apply gcd_mult_l; trivial].\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H.\n  rewrite H0 in H.\n  rewrite H.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H in H.\n  rewrite H0 in H.\n  rewrite HQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  destruct (le_gt_dec a b) as [H|H].\n  apply gcd_intro with b.\n  rewrite <- H; rewrite <- H; rewrite <- H; rewrite <- H; rewrite <- H; rewrite <- H; auto.\n  apply gcd_intro with b.\n  rewrite <- H; rewrite <- H; rewrite <- H; rewrite <- H; rewrite <- H; rewrite <- H; auto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  unfold gcd; intros; destruct a; simpl; trivial.\n  case_eq (gcd_eucl d a);intro.\n  case_eq (gcd_eucl (snd a) (snd b));intro.\n  rewrite H; rewrite H; rewrite gcd_0_l; trivial.\n  intro.\n  elim (H a); intros.\n  rewrite H; rewrite gcd_0_l; trivial.\n  rewrite H; rewrite gcd_0_l; trivial.\n  apply gcd_0_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\n",
                "context_tokens": 729,
                "proof_start_offset": 14549,
                "proof_end_offset": 14831,
                "proof": "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\nintros.\nunfold rel_prime.\ngeneralize (gcd_is_gcd a b);intro.\ncase (eq_nat_dec (gcd a b) 1);intro.\nleft;rewrite e in H;trivial.\nright;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intro a.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  elim (gcd_gcd_for_euclid (a,b));intro d;simpl.\n  destruct (eq_nat_dec (c,d) a);simpl.\n  rewrite e;exists (fst x);apply gcd_mult;trivial.\n  apply gcd_refl.\n  elim (gcd_gcd_for_euclid (a,b));intro d;simpl.\n  rewrite e;exists (snd x);apply gcd_mult;trivial.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\n  apply gcd_refl.\nQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b);intro.\n  case (rel_prime_dec b a);intro.\n  case (rel_prime_dec a b);intro.\n  rewrite e;exists (1,(1, b));unfold rel_prime;simpl;intros.\n  elim (rel_prime_dec b a);intro.\n  rewrite e;exists (1,(1, b));unfold rel_prime;simpl;intros.\n  elim (rel_prime_dec b a);intro.\n  rewrite e;exists (1,(1, b));unfold rel_prime;simpl;intros.\n  elim (rel_prime_dec a b);intro.\n  rewrite e;exists (2,(1, b));unfold rel_prime;simpl;intros.\n  elim (rel_prime_dec b a);intro.\n  rewrite e;exists (2,(1, b));unfold rel_prime;simpl;intros.\n  elim (rel_prime_dec b a);intro.\n  rewrite e;exists (2,(1, b));unfold rel_prime;simpl;intros.\n  elim (rel_prime_dec b a);intro.\n  rewrite e;exists (1,(1,Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intro a.\n  case (rel_prime_dec a b);intro.\n  case (rel_prime_dec a b);intro.\n  case (rel_prime_dec a b);intro.\n  case (rel_prime_dec a b);intro.\n  rewrite e;exists (fst x);apply gcd_intro; auto.\n  case (rel_prime_dec a b);intro.\n  rewrite e;exists (fst x);apply gcd_intro; auto.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  case (rel_prime_dec a b);intro.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  rewrite e;exists (snd x);apply gcd_intro; auto.\n  rewrite e;exists (snd x); apply gcd_intro;Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b) (a,b)).\n  intro d;simpl.\n  destruct (rel_prime_dec a b);intro.\n  destruct (rel_prime_dec a b);intro.\n  destruct (rel_prime_dec a b);intro.\n  destruct (rel_prime_dec a b);intro.\n  destruct (rel_prime_dec b b);intro.\n  destruct (rel_prime_dec b b);intro.\n  destruct (rel_prime_dec b b);intro.\n  destruct (rel_prime_dec b b);intro.\n  destruct H.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  unfold rel_prime, rel_prime; simple induction a; intros.\n  destruct (dec_eq_dec a a); destruct b; inversion 1.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (fst x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (fst x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (fst x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (fst x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (snd x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (fst x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (snd x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (snd x);auto.\n  elim (dec_eq_lt a b); intro.\n  rewrite e; exists (snd x);auto.\n  elim (dec_eq_Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b);intros.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_prime_dec b a);intro.\n  generalize (rel_prime_dec a b);intro.\n  generalize (rel_primeQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros a b.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (2*a).\n  apply gcd_exists_rel_prime; auto.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists (2*a).\n  apply gcd_exists_rel_prime; auto.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  exists (2*a).\n  apply gcd_exists_rel_prime; auto.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  exists (2*a).\n  apply gcd_exists_rel_prime; auto.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  exists (2*a).\n  apply gcd_exists_rel_prime; auto.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  exists (2*a).\n  apply gcd_exists_rel_prime; auto.\n  elim (gcd_exists_prod_bis (a,b)).\n  intros.\n  exists (Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  unfold rel_prime; intros.\n  elim (dec_eq_lt_dec a b); intro.\n  rewrite e; exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) n) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n)))))))))) n) (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))) n))))) n))))) 0) = S (S (S (S (S (SQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (dec_prime_dec a b);intro.\n  case (dec_prime_dec a b);intro.\n  case (dec_prime_dec a b);intro.\n  rewrite e; exists (S q).\n  apply gcd_intro.\n  rewrite e; exists (S q).\n  apply gcd_intro.\n  rewrite e; exists (S q).\n  apply gcd_intro.\n  rewrite e; exists (S q).\n  apply gcd_intro.\n  rewrite <- H1; exists (S q).\n  apply gcd_intro.\n  rewrite <- H0; exists (S q).\n  apply gcd_intro.\n  rewrite <- H1; exists (S q).\n  apply gcd_intro.\n  rewrite <- H0; exists (S q).\n  apply gcd_intro.\n  rewrite <- H1; exists (S q).\n  apply gcd_intro.\n  rewrite <- H1; exists (S q).\n  apply gcd_intro.\n  rewrite <- H0; exists (S q).\n  apply gcd_intro.\n  rewrite <- H1; exists (S q).\n  apply gcd_intro.\n  rewrite <- H1; exists (S q).\n  apply gcd_intro.\n Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intro a; case (rel_prime_dec a b);intro.\n  case (rel_prime_dec a b);intro.\n  case (dec_prime_dec a b);intro.\n  case (dec_prime_dec a b);intro.\n  case (dec_prime_dec b a);intro.\n  elim (dec_prime_dec a b);intro.\n  case (dec_prime_dec a b);intro.\n  case (dec_prime_dec b a);intro.\n  rewrite e;exists (fst x);apply gcd_intro; apply gcd_intro.\n  rewrite e;exists (snd x);apply gcd_intro.\n  rewrite e;exists (snd x);apply gcd_intro; apply gcd_intro; apply gcd_intro; apply gcd_intro;\n    apply gcd_intro; apply gcd_intro; apply gcd_intro; apply gcd_intro;\n    apply gcd_intro; apply gcd_intro; apply gcd_intro; apply gcd_intro.\n  rewrite e;exists (snd x);apply gcd_intro.\n  rewrite e;exists (snd x);apply gcd_intro.\n  rewrite e;exists (snd x);apply gcd_intro.\n  rewrite eQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\n",
                "context_tokens": 721,
                "proof_start_offset": 14887,
                "proof_end_offset": 15621,
                "proof": "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\nintros.\nsplit.\nsplit;try (apply one_min_div).\nintros.\nelim H1;intros.\ncase (rel_prime_dec b d');intro.\nassert (divides c d').\napply gauss with b;trivial.\nelim H0;intros.\napply H6;unfold is_cd;tauto.\ngeneralize (gcd_is_gcd b d');intro.\nassert ((gcd b d')<>1).\nintro;apply n.\nunfold rel_prime;rewrite <- H5;trivial.\ngeneralize (gcd_div_l (gcd b d') b d' H4);intro.\ngeneralize (gcd_div_r (gcd b d') b d' H4);intro.\nassert (divides a (gcd b d')).\napply divides_trans with d';[apply H2 | apply H7].\nelim H5.\napply divides_antisym.\napply one_min_div.\nelim H;intros;apply H10;unfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  elim (rel_prime_dec a b);intro.\n  right;rewrite e in H.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 0);intro.\n  rewrite e in H.\n  destruct (le_lt_eq_dec (gcd a b) 1);intro.\n  rewrite e in H.\n  elim (lt_eq_lt_dec (gcd a b) 1);intro.\n  rewrite e in H.\n  generalize (H0 (gcd_is_gcd a b));intro.\n  rewrite e in H.\n  generalize (H0 (gcd_is_gcd a b));intro.\n  rewrite e in H.\n  rewrite H.\n  rewrite H0; trivial.\n  generalize (gcd_is_gcd a b);intro.\n  rewrite e in H.\n  rewrite H.\n  rewrite H0; trivial.\n  generalize (H0 (gcd_is_gcd a b));intro.\n  rewrite e in H.\n  rewrite H0; trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  unfold rel_prime.\n  generalize (rel_prime_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  rewrite e in H;trivial.\n  rewrite e in H;trivial.\n  left;auto.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  elim (gcd_for_euclid a b c);intro.\n  right;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a (gcd_gcd a b));\n  auto.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 b);auto.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_is_gcd a b);intro.\n  case (lt_eq_dec (gcd a b) 1);intro.\n  right;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  apply (rel_prime_mult_strong (a,b) (c,d) (a,b));trivial.\n  apply rel_prime_dec; trivial.\n  apply rel_prime_dec; trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  elim (gcd_is_gcd a b);intro.\n  right;rewrite e in H0.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e;exists (fst x);apply gcd_refl.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_is_gcd a b);intro.\n  case (lt_eq_dec (gcd a b) 0);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (rel_prime_intro b); auto.\n  right;intro;apply n;apply (rel_prime_intro b); auto.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  unfold rel_prime.\n  generalize (rel_prime_is_gcd a b);intro.\n  elim (rel_prime_is_gcd a b);intro.\n  right;intro.\n  elim (rel_prime_is_gcd b c);intro.\n  right;intro.\n  apply n.\n  apply (rel_prime_is_gcd (gcd a b) 1 a b c);trivial.\n  right;intro.\n  apply n.\n  apply (rel_prime_is_gcd (gcd a b) 1 a b c);trivial.\n  right;intro.\n  apply n.\n  apply (rel_prime_is_gcd (gcd a b) 1 b c);trivial.\n  right;intro.\n  apply n.\n  apply (rel_prime_is_gcd (gcd a b) 1 b c);trivial.\n  right;intro.\n  apply n.\n  apply (rel_prime_is_gcd (gcd a b) 1 b c);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros a b c.\n  elim (gcd_is_gcd a b);intros.\n  right;exists (c*c);trivial.\n  right;exists (c*c);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_is_gcd a b);intro.\n  case (lt_eq_lt_dec (rel_prime a b) 1);intro.\n  left;rewrite e in H;trivial.\n  left;rewrite e in H;trivial.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a c);trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a c);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\n",
                "context_tokens": 718,
                "proof_start_offset": 15677,
                "proof_end_offset": 15983,
                "proof": "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\nintros.\nsplit;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  elim (rel_prime_dec a b);intro.\n  elim (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  case (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  destruct (gcd_is_gcd b b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  apply H1; unfold is_gcd;rewrite <- H5; tauto.\n  generalize (gcd_is_gcd a b);intro.\n  apply H1; unfold is_gcd;rewrite <- H5; tauto.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  elim (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b c);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  rewrite e;rewrite <- H5; rewrite <- H6; rewrite <- H6; rewrite <- H6; ring.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  case (rel_prime_dec a b);intro.\n  right;apply div_prime_dec.\n  intros.\n  elim H1;intros.\n  apply H2;unfold is_c in H0.\n  elim H1;intros.\n  apply H3;unfold is_c in H1.\n  elim H1;intros.\n  apply H3;unfold is_c in H0.\n  elim H1;intros.\n  apply H3;unfold is_c in H1.\n  elim H1;intros.\n  apply H3; unfold is_c in H1.\n  elim H1;intros.\n  apply H3; unfold is_c in H1.\n  elim H1;intros.\n  apply H3; unfold is_c in H1.\n  elim H1; intros.\n  apply H3; unfold is_c in H1.\n  elim H1; intros.\n  apply H3; unfold is_c in H1.\n  elim H1; intros.\n  apply H3; unfold is_c in H1.\n  elim H1; intros.\n  apply H3; unfold is_c in H1.\n  elim H1Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  elim (rel_prime_dec a b);intro.\n  left;rewrite e in H.\n  elim (gcd_is_gcd a b);intro.\n  right;rewrite e in H.\n  elim (gcd_is_gcd a b);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd a b);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd a b);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd a b);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd b c);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd a b);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd b c);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd a b);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd b c);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd b c);intro.\n  rewrite e in H.\n  elim (gcd_is_gcd b c);intro.\n  rewrite e in HQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  right;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_intro _ _ H2).\n  apply H3;unfold is_gcd;rewrite <- H3;trivial.\n  elim H;intros.\n  case (gcd_spec a b);intro.\n  assert (gcd b (gcd b a) (gcd b b)); auto.\n  generalize (gcd_mod_mult _ _ _ H2);intro.\n  generalize (gcd_div_l (gcd b a) b (gcd b b));\n  generalize (gcd_mod_mult _ _ _ H2);intro.\n  generalize (gcd_mod_mult _ _ _ H3);intro.\n  generalize (gcd_mod_mult _ _ _ H4);intro.\n  generalize (gcd_mod_mult _ _ _ H4);intro.\n  generalize (gcd_mod_mult _ _ _ H4);intro.\n  generalize (gcd_mod_mult _ _ _ H4);intro.\n  generalize (gcdQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (lt_gt_cases a b); intro.\n  left; rewrite e in H; tauto.\n  right;intro;apply n;apply (gcd_unique (gcd a b) (gcd a b)); trivial.\n  right;intro; apply n;apply (gcd_unique (gcd a b) 1 a); trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a); trivial.\n  left;intro; apply n;apply (gcd_unique (gcd a b) 1 a); trivial.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  split.\n  split.\n  unfold rel_prime.\n  apply div_prime.\n  elim H0;intros.\n  apply H.\n  apply lt_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd b b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd a b); trivial.\n  apply mod_le_trans with (gcd b b); trivial.\n  apply mod_le_trans with (gcd bQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (mult_rel_prime_dec a c);intro.\n  left;apply le_antisym; assumption.\n  right;intro;apply le_antisym; assumption.\n  right;intro;apply le_antisym; assumption.\nQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (lt_nat_dec (gcd a b) 1);intro.\n  rewrite e in H; tauto.\n  generalize (gcd_is_gcd a b);intro.\n  apply div_gt_0 in H; tauto.\n  generalize (gcd_is_gcd a b);intro.\n  apply div_gt_0 in H; tauto.\n  generalize (gcd_is_gcd b b);intro.\n  apply gcd_gt_0 in H; tauto.\n  generalize (gcd_is_gcd b c);intro.\n  apply gcd_gt_0 in H; tauto.\n  generalize (gcd_is_gcd b c);intro.\n  apply H;unfold is_gcd;rewrite <- H5; tauto.\n  generalize (gcd_is_gcd b c);intro.\n  apply H; unfold is_gcd;rewrite <- H5; tauto.\n  generalize (gcd_is_gcd b c);intro.\n  apply H; unfold is_gcd;rewrite <- H5; tauto.\n  generalize (gcd_is_gcd b c);intro.\n  apply H; unfold is_gcd;Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;try (apply a_le_antisym;apply H).\n  apply mult_rel_prime;auto.\n  elim H1;intros.\n  apply H1;unfold is_c in |- *; auto.\n  apply H; unfold is_c in |- *; auto.\n  apply H; unfold is_c in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 16024,
                "proof_end_offset": 16251,
                "proof": "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\ninduction n;simpl;intros.\nunfold rel_prime;apply gcd_sym;apply gcd_one.\ngeneralize (IHn H);intro.\napply rel_prime_mult;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_refl.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_trans with (rel_prime a (power d (S n))); auto.\n  apply gcd_trans with (rel_prime a (power d (S n))).\n  apply gcd_sym.\n  apply gcd_trans with (rel_prime a (power d (S n))); auto.\n  apply gcd_trans withQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  split.\n  apply le_trans with d;auto.\n  apply (lt_le_trans _ _ _ (lt_le_weak _ _ H0)).\n  apply (lt_le_weak _ _ (lt_le_weak _ _ H)).\n  apply (lt_le_weak _ _ (lt_le_weak _ _ H)).\n  apply (lt_le_weak _ _ (lt_le_weak _ _ H)).\n  apply (lt_le_weak _ _ H).\n  apply (lt_le_weak _ _ H).\n  apply (lt_le_weak _ _ H).\n  apply (lt_le_weak _ _ H).\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\n  intros.\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,P)).\n  generalize (rel_prime_divisors (a,b) (P,Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply rel_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  apply mod_prime_dec.\n  applyQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  destruct (rel_prime_dec (a,c) (S n) (S n)) as [H|H].\n  exists (S n).\n  split.\n  apply div_prime_pos;trivial.\n  destruct (rel_prime_dec (a,c) (S n) (S n));destruct (rel_prime_dec (a,c) (S n));trivial.\n  exists (S n).\n  split.\n  apply div_prime_div.\n  exists (S n).\n  split.\n  apply div_prime_dec.\n  exists (S n).\n  split.\n  apply div_prime_dec.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b a);intro.\n  generalize (gcd_is_gcd b a);intro.Qed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  generalize (rel_prime_divisors (factor_coh a d n)).\n  intros.\n  unfold rel_prime in |- *.\n  generalize (rel_prime_divisors (factor_coh a d n)).\n  unfold rel_prime in |- *.\n  generalize (rel_prime_divisors (factor_coh a d n)).\n  unfold rel_prime in |- *.\n  generalize (rel_prime_divisors (factor_coh a d n)).\n  unfold rel_prime in |- *.\n  unfold rel_prime in |- *.\n  unfold rel_prime in |- *.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfold rel_prime in H.\n  unfoldQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  case (le_gt_dec n m);intro.\n  exists (fun m n:nat => mult_rel_prime m n);intro.\n  split;intros.\n  elim (div_eucl_equiv m n m);intro.\n  exists (fun m n:nat => mult_rel_prime m n);intro.\n  exists (fun m n:nat => mult_rel_prime m n);intro.\n  rewrite <- (mult_comm (fun m n:nat => mult_rel_prime m n));intro.\n  rewrite <- (mult_comm (fun m n:nat => mult_rel_prime m n));intro.\n  rewrite <- (mult_comm (fun m n:nat => mult_rel_prime m n));intro.\n  rewrite <- (mult_comm (fun m n:nat => mult_rel_prime m n));intro.\n  rewrite <- (mult_comm (fun m n:nat => mult_rel_prime m n));intro.\n  rewrite <- (mult_comm (fun m n:nat => mult_rel_prime m n));intro.\n  rewrite <- (mult_comm (fun m n:nat => mult_rel_prime mQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply (rel_prime_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_prime_dec (rel_prime a d) (power d n)).\n  apply (rel_primeQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  split.\n  apply rel_prime_prime; auto.\n  apply rel_prime_prime; auto.\n  apply rel_prime_div; auto.\n  apply rel_prime_prime; auto.\n  apply rel_prime_div; auto.\n  apply rel_prime_prime; auto.\n  apply rel_prime_div; auto.\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  destruct (rel_prime_dec a d).\n  left.\n  elim H;intros.\n  apply lt_le_trans with (1:=H);auto.\n  apply H.\n  apply mod_prime_div; auto.\n  left.\n  elim H;intros.\n  apply lt_le_trans with (1:=H);auto.\n  apply div_prime_div; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\n",
                "context_tokens": 723,
                "proof_start_offset": 16300,
                "proof_end_offset": 16486,
                "proof": "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\ndestruct n;simpl;intros.\ninversion H.\nelim (mult_rel_prime a d (power d n));auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  destruct (rel_prime_dec a d) as [p| p].\n  elim (prime_gt_dec p p).\n  left; rewrite e; reflexivity.\n  right; reflexivity.\n  right; reflexivity.\n  right; reflexivity.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  case (lt_eq_dec (gcd a d) 1);intro.\n  left;rewrite e in H.\n  elim (gcd_intro _ _ H); intros.\n  apply H.\n  apply H.\n  apply H1.\n  apply H2.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  induction n;simpl;intros.\n  inversion H; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0; trivial.\n  inversion H0Qed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  induction n;simpl;intros.\n  unfold rel_prime.\n  apply div_mult; apply gcd_refl.\n  unfold rel_prime.\n  apply div_mult; apply gcd_refl.\n  apply div_mult; apply gcd_refl.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply div_prime_power.\n  apply div_prime_factor_r.\n  apply div_prime_factor_r.\n  apply div_prime;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  unfold rel_prime.\n  apply div_prime_mult;trivial.\n  intros.\n  unfold rel_prime in H.\n  apply div_prime_mult;trivial.\n  unfold rel_prime in H.\n  apply div_prime_mult;trivial.\n  apply H.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  induction n;simpl;intros.\n  unfold rel_prime.\n  generalize (rel_prime_plus_1 (gcd d a) (factor_factor_factor_factor_factor_factor_factor_factor_factor_div n m n n) H).\n  generalize (factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor n m n n) H.\n  rewrite (factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor n m n n) in H; rewrite H; trivial.\n  apply mult_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_factor_Qed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  unfold rel_prime.\n  generalize (rel_prime_mult_strong (rel_prime a (power d n)))) as q.\n  apply rel_prime_mult.\n  generalize (rel_prime_mult_strong (rel_prime a (power d n)));intro.\n  apply rel_prime_mult; tauto.\n  generalize (rel_prime_mult_strong (rel_prime a (power d n)));intro.\n  apply rel_prime_mult; tauto.\n  generalize (rel_prime_mult_strong (rel_prime a (power d n))); intro.\n  apply rel_prime_mult; tauto.\n  generalize (rel_prime_mult_strong (rel_prime a (power d n)));intro.\n  apply rel_prime_mult; tauto.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  induction n;simpl;intros;auto with zarith.\n  unfold rel_prime in |- *.\n  apply rel_prime_mult;auto with zarith.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  apply div_prime_div_prime; trivial.\n  apply div_prime_div_prime; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\nLemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  destruct n;simpl;intros.\n  inversion H.\n  elim (mult_rel_prime a d (power d n));auto.\nQed.\n\n(** if n>0 and m>0 then gcd(a^n,b^m)=1 iff gcd(a,b)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 16545,
                "proof_end_offset": 16906,
                "proof": "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\nsplit;intro.\napply power_rel_prime with m;trivial;apply rel_prime_sym;apply power_rel_prime with n;trivial;apply rel_prime_sym;trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power;apply rel_prime_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  destruct n;simpl;intros.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  unfold rel_prime in |- *; apply div_prime_mult; trivial.\n  destruct (rel_prime_mult a b m (power b m));auto.\n  destruct (rel_prime_mult b m (power b m));auto.\n  destruct (rel_prime_mult a b m);auto.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\n  intros.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  destruct n;simpl;intros.\n  inversion H.\n  apply rel_prime_mult.\n  generalize (IHn H0);intro.\n  apply rel_prime_mult;trivial.\n  generalize (IHn H0);intro.\n  apply rel_prime_mult;trivial.\n  generalize (IHn H1);intro.\n  apply rel_prime_mult;trivial.\n  generalize (IHn H0);intro.\n  apply rel_prime_mult;trivial.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\n  intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\n intros.\n apply rel_prime_mult; auto.\n apply div_mult; auto.\n apply div_mult; auto.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  inversion H; clear H.\n  apply rel_prime_mult;trivial.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  inversion H.\n  elim (mult_rel_prime a n (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\n  elim (mult_rel_prime a m (power b m));auto.\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  destruct n;simpl;intros.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\n intros.\n destruct (rel_prime_mult a b) as (a,b); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\n",
                "context_tokens": 275,
                "proof_start_offset": 1044,
                "proof_end_offset": 1166,
                "proof": "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b.\nunfold square, square, square, square, square, square, square, square, square, square, square,\n square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square, square,sqrt, square, square, square, square, square, square, square, square, square,sqrt, square, square, square, square, square, square, square, square, square,sqrt, square, square,sqrt, square, square, square,sqrt, square,sqrt, square,sqrt, square, square, square,sqrt, square, square,sqrt, square, square, square,sqrt, squareQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b.\n rewrite (square_comm a b).\n rewrite (square_comm b (-a)).\n rewrite (square_mult_distr_r a b).\n rewrite (square_mult_distr_r b (-a)).\n rewrite (square_mult_distr_r b (-a)).\n rewrite (square_mult_distr_r b (-a)).\n rewrite (square_mult_distr_r b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_r b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_mult_distr_l b (-a)).\n rewrite (square_multQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\n apply square_mult_lemma.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b; unfold square, square, square, square, square, square, square, square, x.\nsplit; auto with zarith.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b.\nunfold square.\nunfold square.\nsimpl.\nauto with zarith.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros.\nunfold square, square, square, square, square, square, square, square, x.\nintros a b.\nsplit.\napply square_mult_lemma; auto with arith.\napply square_mult_lemma; auto with arith.\napply square_mult_lemma; auto with arith.\napply square_mult_lemma; auto with arith.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b.\nrewrite <- (mult_comm (a*b)).\nrewrite (mult_comm (a*b)).\nrewrite (mult_comm (a*b)).\nrewrite (mult_comm (a*b)).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b; unfold square.\ndestruct (le_dec a b).\nrewrite mult_1_r; auto with arith.\nrewrite mult_1_l; auto with arith.\nrewrite mult_1_l; auto with arith.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b.\n apply square_mult_lemma; auto with arith.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b; unfold square, square, square, square, square, square, sqrt, square, sqrt, sqrt, sqrt, b.\n destruct a; unfold square, square, square, sqrt, sqrt, sqrt, sqrt, sqrt;\n unfold sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt, sqrt,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 1331,
                "proof_end_offset": 1483,
                "proof": "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\ninduction n;simpl;trivial.\nintros;rewrite (IHn x y);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  Proof.\n    induction n.\n      simpl; auto.\n    simpl; auto.\n    simpl; auto.\n  Qed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  unfold square.\n  intros.\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  reflexivity.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n intros.\n apply mult_comm.\n apply mult_comm.\n apply mult_assoc.\n apply mult_assoc.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  induction n.\n  reflexivity.\n  simpl.\n  destruct x.\n  simpl.\n  destruct y.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  unfold power.\n  intros.\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  replace (power x n) with (power x n).\n  rewrite mult_plus.\n  reflexivity.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  induction n.\n  simpl.\n  reflexivity.\n  simpl.\n  rewrite IHn.\n  reflexivity.\n  simpl.\n  rewrite IHn.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  Proof.\n    simple induction n.\n    intros.\n    simpl in |- *.\n    elim (mult_comm x n1).\n    intros.\n    simpl in |- *.\n    elim (mult_comm x n1).\n    intros.\n    rewrite mult_assoc.\n    rewrite mult_assoc.\n    rewrite mult_assoc.\n    rewrite mult_assoc.\n    rewrite mult_plus_distr_r.\n    reflexivity.\n  Qed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite (mult_comm x).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1485,
                "proof_end_offset": 1642,
                "proof": "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\nProof.\ninduction n;simpl;intros.\nauto with arith.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  intros; rewrite (power_mult_lemma1 n m x); auto with arith.\n  Qed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  intros.\n  replace (power (x*m) x) with (power x m).\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_r.\n  apply mult_le_compat_l.\n  apply mult_le_Qed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  intros; rewrite (power_plus_lemma1 n m x); auto.\n  apply power_mult_lemma1; auto.\n  apply power_mult_lemma2; auto.\n  apply power_mult_lemma1; auto.\n  apply power_mult_lemma1; auto.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  intros.\n  ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros;auto with arith.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\n",
                "context_tokens": 483,
                "proof_start_offset": 1644,
                "proof_end_offset": 1799,
                "proof": "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\nProof.\ninduction n;simpl;intros.\ninversion H.\nexists (power x n);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  intros.\n  unfold square.\n  replace (x*x) with (1 + x*(power x n)).\n  replace (x*(power x n)) with (1 + x*(power x n)).\n  rewrite mult_minus_distr_r; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  apply mult_le_compat_r; auto with arith.\n  Qed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros;auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  intros.\n  rewrite <- mult_1_l.\n  rewrite (mult_comm x x); auto with arith.\n  rewrite (mult_comm x x); auto with arith.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  intros; elim n;simpl;auto.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros;auto.\n  rewrite (IHn x y);auto with arith.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\n  apply IHn.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  unfold square.\n  intros.\n  ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  unfold square.\n  intros.\n  rewrite (mult_comm (power x n) (power x n)).\n  rewrite (mult_comm (power x n) (power x n)).\n  apply mult_le_compat_r; auto with arith.\n  apply mult_le_compat_r; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\n",
                "context_tokens": 536,
                "proof_start_offset": 1801,
                "proof_end_offset": 2053,
                "proof": "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\nProof.\ninduction n;simpl;intros.\ninduction m;simpl;auto with arith.\nrewrite IHm;ring.\nrewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n); auto with arith.\n  inversion H.\n  exists (power x n); auto with arith.\n  inversion H.\n  exists (power x m); auto with arith.\n  inversion H.\n  exists (power x m); auto with arith.\n  inversion H.\n  exists (power x m); auto with arith.\n  inversion H.\n  exists (power x n); auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.Qed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x m);trivial.\n  inversion H.\n  exists (power x m);trivial.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x m);trivial.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn; auto with arith.\n  rewrite IHn; auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x m);auto with arith.\n  inversion H0.\n  exists (power x (S m)).\n  apply IHn; auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  exists 0;trivial.\n  inversion H.\n  exists 0;trivial.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.Qed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);auto with arith.\n  inversion H.\n  exists (power x n);auto with arith.\n  inversion H.\n  exists (power x n);auto with arith.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\n  inversion H.\n  exists (power x m);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\n",
                "context_tokens": 619,
                "proof_start_offset": 2055,
                "proof_end_offset": 2202,
                "proof": "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\ninduction n;simpl;intros.\ndiscriminate.\ncase (mult_lemma2 x (power x n) H);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);auto with arith.\n  inversion H.\n  exists (power x n);auto with arith.\n  exists (power x n);auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);simpl;auto with arith.\n  rewrite IHn;auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  intros.\n  generalize (power_zero (power x n)).\n  rewrite (power_zero (power x n)).\n  rewrite (power_zero (power x n)).\n  rewrite (power_one (power x n)).\n  rewrite (power_one (power x n)).\n  rewrite (power_one (power x n)).\n  rewrite (power_one (power x n)).\n  rewrite (power_one (power x n)).\n  rewrite (power_one (power x n)).\n  apply power_mult_strong; auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n intros.\n destruct n;simpl;intros;auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros; apply power_zero.\n  apply power_zero.\n  apply power_zero.\n  apply power_zero.\n  apply power_zero.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\n  inversion H.\n  exists 0;auto.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);auto with arith.\n  inversion H.\n  exists (power x n);auto with arith.\n  inversion H.\n  exists (power x n);auto with arith.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros; simpl;auto with arith.\n  Qed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  intros.\n  inversion H.\n  exists (power x n);simpl;auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\n  induction n;simpl;intros.\n  inversion H; auto with arith.\n  inversion H; auto with arith.\n  inversion H; auto with arith.\n  inversion H; auto with arith.\n  inversion H; auto with arith.\n  inversion H; auto with arith.\n  inversion H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\n",
                "context_tokens": 692,
                "proof_start_offset": 2237,
                "proof_end_offset": 2543,
                "proof": "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nProof.\ninduction m;simpl;try omega;intros.\ndestruct m;simpl;try omega.\nsimpl in IHm.\nassert (1 < p*(power p m)).\napply IHm;auto with arith.\nrewrite mult_comm.\napply lt_trans with (1*p);try omega.\napply mult_lt_compat_r;try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  inversion H.\n  destruct m;simpl;auto with arith.\n  rewrite IHn; auto with arith.\n  inversion H.\n  destruct m;simpl;auto with arith.\n  inversion H.\n  destruct m;simpl;auto with arith.\n  rewrite IHn; auto with arith.\n  inversion H.\n  destruct m;simpl;auto with arith.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  intros p m; elim p; auto with arith.\n  destruct (le_gt_dec p p); auto with arith.\n  destruct (le_gt_dec p p); auto with arith.\n  rewrite <- (mult_1_l p) at 1; rewrite <- mult_n_O; auto with arith.\n  rewrite <- (mult_1_l p) at 1; rewrite <- mult_n_O; auto with arith.\n  rewrite <- (mult_1_l p) at 1; rewrite <- mult_n_O; auto with arith.\n  rewrite <- (mult_1_l p) at 1; rewrite <- mult_n_O; auto with arith.\n  rewrite <- (mult_1_l p) at 1; rewrite <- mult_n_O; auto with arith.\n  rewrite <- (mult_1_l p) at 1; rewrite <- mult_n_O; auto with arith.\n  rewrite <- (mult_1_l p) at 1; rewrite <- mult_n_O; auto with arith.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  intros p m; destruct (le_gt_dec p m);auto with arith.\n  destruct p;simpl;auto with arith.\n  Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction n;simpl;intros.\n  inversion H.\n  exists m;auto with arith.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;intros.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion HQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H.\n  inversion H1.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H1.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\n",
                "context_tokens": 740,
                "proof_start_offset": 2560,
                "proof_end_offset": 2661,
                "proof": "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\ninduction n;simpl;trivial.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  reflexivity.\n  destruct n;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destructQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  auto with arith.\n  destruct (mult_lemma2 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma1 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma2 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma2 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma2 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma2 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma2 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma2 x n) as [H|H].\n  (* n=0 *)\n  apply IHn.\n  omega.\n  destruct (mult_lemma2 x n) asQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  destruct n;simpl;try omega.\n  apply IHn;auto with arith.\n  apply IHn;auto with arith.\n  apply IHn;auto with arith.\n  apply IHn;auto with arith.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  discriminate.\n  destruct n;simpl;try omega;apply mult_0_l.\n  destruct n;simpl;try omega;apply mult_0_r.\n  destruct n;simpl;try omega;apply mult_0_l.\n  destruct n;simpl;try omega;apply mult_0_r.\n  destruct n;simpl;try omega;apply mult_0_l.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  intros; apply (power_one (S n)).\n  apply (mult_comm n); auto with arith.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  discriminate.\n  destruct n;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destructQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  inversion H; clear H; subst.\n  destruct n;simpl;auto.\n  destruct n;simpl;auto.\n  destruct n;simpl;auto.\n  destruct n;simpl;auto.\n  destruct n;simpl;auto.\n  destruct n;simpl;auto.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros;auto with arith.\n  destruct (mult_lemma2 x (S n));simpl;auto with arith.\n  destruct (mult_lemma2 x (S n));simpl;auto with arith.\n  destruct (mult_lemma2 x (S n));simpl;auto with arith.\n  destruct (mult_lemma2 x (S n));simpl;auto with arith.\n  destruct (mult_lemma2 x (S n));simpl;auto with arith.\n  elim (mult_lemma2 x (S n));simpl;auto with arith.\n  rewrite mult_comm.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  rewrite (mult_comm 1).\n  rewrite mult_1_l.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_l;try omega.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  intros.\n  destruct n;simpl;intros.\n  discriminate.\n  apply IHn;auto with arith.\n  simpl in IHn.\n  assert (0 < n)%nat.\n  apply le_trans with (1*n)%nat;auto with arith.\n  apply le_trans with (1*n)%nat;auto with arith.\n  apply le_trans with (1*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (1*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arith.\n  apply le_trans with (2*n)%nat;auto with arithQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": ".  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\nLemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;trivial.\n  rewrite IHn;ring.\nQed.\n\n(** if x>1 and x^m | x^n then m<=n *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2701,
                "proof_end_offset": 3361,
                "proof": "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\nintros.\ncase (le_lt_dec m n);trivial.\nintro.\ngeneralize (le_plus_minus n m);intro.\nrewrite H1 in H0;try omega.\nelim H0;intro q;rewrite power_plus_lemma1;intro.\nassert (1=(power x (m-n))*q).\napply mult_lemma6 with (power x n).\nintro;generalize (power_zero n x H3);omega.\nrewrite mult_assoc;rewrite <- H2;ring.\nsymmetry in H3;elim (mult_lemma5 (power x (m-n)) q H3);intros.\ncase (eq_nat_dec (m-n) 0);intro;try omega.\nassert (x=1);try omega.\napply divides_antisym;[apply one_min_div | rewrite <- H4;apply power_divides_lemma1;omega].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0Qed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  inversion H; subst; try apply mult_lt_compat_l;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  destruct m;simpl;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compat_r;try omega.\n  apply mult_le_compatQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;intros;auto with arith.\n  destruct m;simpl;intros.\n  auto with arith.\n  apply le_trans with m;auto with arith.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n  apply le_plus_minus_r.\n Qed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  auto with arith.\n  destruct x;simpl;intros;rewrite IHn;ring.\n  auto with arith.\n  intros;rewrite IHn;auto with arith.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  rewrite (mult_comm n (S m)); rewrite mult_comm;\n  rewrite (mult_comm m (n-m)); repeat rewrite (mult_comm m (n-m));\n  repeat rewrite mult_assoc;\n  rewrite (mult_comm m (n-m)); repeat rewrite (mult_comm m (n-m));\n  repeat rewrite mult_assoc;\n  rewrite (mult_comm m (n-m)); repeat rewrite (mult_comm m (n-m));\n  repeat rewrite (mult_comm m (n-m));\n  repeat rewrite mult_assoc;\n  rewrite (mult_comm m (n-m)); repeat rewrite (mult_comm m n (m-m));\n  repeat rewrite (mult_comm m n (n-m));\n  repeat rewrite mult_assoc;\n  rewrite (mult_comm m n (n-m)); repeat rewrite (mult_comm m n (n-m));\n  repeat rewrite (mult_comm m n (n-m));\n  repeat rewrite mult_assoc;\n  rewrite (mult_comm m n (m-m)); repeat rewrite mult_assoc;\n  rewrite (mult_comm m n (n-m)); repeatQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  auto with arith.\n  replace (x*m+1) with (x*m+1).\n  replace (x*m+1) with (x*m+1).\n  apply IHn;auto with arith.\n  rewrite IHn; auto with arith.\n  apply le_plus_minus; auto with arith.\n  apply le_plus_minus; auto with arith.\n  apply le_plus_minus; auto with arith.\n  rewrite IHn; auto with arith.\n  apply le_plus_minus; auto with arith.\n  apply le_plus_minus; auto with arith.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros;auto with arith.\n  destruct m;simpl;intros;auto with arith.\n  destruct m;simpl;intros;auto with arith.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  reflexivity.\n  rewrite IHn;ring.\n  destruct m;simpl;try omega.\n  rewrite IHn;ring.\n  destruct m;simpl;try omega;simpl;try omega.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n exists (q - 1).\n rewrite <- (mult_comm (n * q)).\n rewrite <- (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite <- (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n * q)).\n rewrite (mult_comm (n *Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n cut (exists q:nat, exists r:nat, n = r /\\ n = r).\n intros.\n case (le_gt_dec n 2).\n intro.\n rewrite H2 in H.\n simpl in H.\n discriminate H.\n intro.\n rewrite H2 in H.\n discriminate H.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists 1.\n  exists 1.\n  exists 1.\n  simpl in |- *.\n  auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintro.\nexists (mult a (b*q)).\nexists (mult a (b*q)).\nexists (mult b (b*q)).\nsplit.\napply le_mult_l.\napply le_mult_r.\napply le_mult_r.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro n; elim n; auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  unfold order in |- *. intros.\n  elim H.\n  intros.\n  elim H0.\n  intros.\n  exists x0.\n  split.\n  assumption.\n  split.\n  assumption.\n  split.\n  assumption.\n  simpl in |- *.\n  intros.\n  elim H2.\n  intros.\n  exists x0.\n  split.\n  assumption.\n  split.\n  assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro n.\n case n; auto.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n apply le_n_S.\n apply le_S_n.\n apply le_n_S.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n simple induction n.\n simpl in |- *.\n intros a a' H.\n simpl in |- *.\n rewrite H.\n reflexivity.\n intros a' H.\n simpl in |- *.\n apply le_trans with a'.\n apply le_n_S.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros.\n exists (S (S (pred n))) at 2.\n exists (S (pred (pred n))) at 2.\n split.\n apply le_trans with (pred n).\n apply le_pred.\n apply le_pred.\n apply le_pred.\n apply le_pred.\n apply le_pred.\n apply le_pred.\n apply lt_pred.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H0.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H0.\n  auto with arith.\n  intro.\n  rewrite H0.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H0.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H0.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H1.\n  auto with arith.\n  intro.\n  rewrite H0.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H1.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  rewrite H1.\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 1).\n Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists (pred n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (mult_gt_dec n 1).\n  intros.\n  exists (q, q).\n  auto with arith.\n  exists (q, q).\n  auto with arith.\n  exists (q, q).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (le_gt_dec n 0).\n  intro.\n  right.\n  exists n.\n  auto with arith.\n  exists (S n).\n  apply le_trans with (pred n).\n  auto with arith.\n  apply le_n_S.\n  unfold pred in |- *.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim H.\n  intro.\n  elim H.\n  intro.\n  left.\n  assumption.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (le_gt_dec n 1).\n  intro.\n  exists (x0, x1).\n  exists (x1, x2).\n  simpl in |- *.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists n.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (le_gt_dec n 0).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 0).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 0).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 0).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n 0).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n (S n0)).\n  auto with arith.\n  intro.\n  elim (le_gt_dec n n0).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n0 0).\n  auto with arith.\n  intro.\n  elim (le_gt_dec n0 0).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n0 (S n0)).\n  auto with arith.\n  intro.\n  elim (le_gt_dec n0 0).\n  auto with arith.\n  intro.\n  elim (le_gt_dec n0 (S n1)).\n  auto with arith.\n  intros.\n  elim (le_gt_dec n0Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim (le_gt_dec n 1).\n  exists 1.\n  exists (pred n).\n  exists (pred n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists (S n).\n  auto with arith.\n  exists (S n).\n  simpl in |- *.\n  apply zero_min_div.\n  auto with arith.\n  exists (S n).\n  simpl in |- *.\n  apply zero_min_div.\n  auto with arith.\n  exists (S n).\n  simpl in |- *.\n  apply succ_inj.\n  intros.\n  elim H.\n  intros.\n  exists (S n0).\n  simpl in |- *.\n  apply zero_min_div_upper.\n  auto with arith.\n  exists (S n0).\n  simpl in |- *.\n  apply zero_min_div.\n  auto with arith.\n  exists (S n0).\n  simpl in |- *.\n  apply zero_min_div.\n  auto with arith.\n  exists (S n0).\n  simpl in |- *.\n  apply zero_min_div.\n  auto with arith.\n  exists (S n1).\n  simpl in |- *.\n  apply zero_min_div.\n  auto with arith.\n  exists (S n1).\n  simpl in |- *.\n  apply zero_min_div.\n  auto with arith.\n  exists (S n1).\n  simpl in |- *.\n  apply succQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  case (le_gt_dec a 1).\n  intro.\n  exists (Zabs_nat a).\n  split.\n  exists (Zabs_nat a).\n  split.\n  apply abs_le_abs_pos.\n  split.\n  assumption.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_abs_pos.\n  split.\n  apply abs_le_Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply (gcd_refl a).\n  apply (gcd_sym a).\n  apply (gcd_refl a).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intro.\n  exists (a/a).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  exists (a*a).\n  auto with arith.\n  destruct (lt_gt_dec a 0).\n  left.\n  auto with arith.\n  right.\n  exists (a*a).\n  auto with arith.\n  apply le_trans with (a*a).\n  auto with arith.\n  apply le_trans with (a*a).\n  auto with arith.\n  apply le_trans with (a*a).\n  auto with arith.\n  apply le_trans with (a*a).\n  auto with arith.\n  apply le_trans with (a*a).\n  auto with arith.\n  apply le_trans with (a*a).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply (gcd_refl a).\n  intro.\n  apply (gcd_sym a).\n  apply (gcd_refl a).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply (is_odd_ind a).\n  assumption.\n  intros.\n  apply (is_odd_ind a).\n  assumption.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  split.\n  auto with arith.\n  intros.\n  elim H.\n  intros.\n  exists (a0, a).\n  split.\n  auto with arith.\n  intros.\n  elim H.\n  intros.\n  exists (a0, (b0, b0)).\n  split.\n  auto with arith.\n  elim H.\n  intros.\n  exists (a1, (b1, b1)).\n  split.\n  auto with arith.\n  split.\n  auto with arith.\n  intros.\n  elim H.\n  intros.\n  exists (b0, (b0, b1)).\n  split.\n  auto with arith.\n  split.\n  auto with arith.\n  intros.\n  elim H.\n  intros.\n  exists (b0, (b0, b1)).\n  split.\n  auto with arith.\n  split.\n  auto with arith.\n  split.\n  auto with arith.\n  split.\n  auto with arith.\n  auto with arith.\n  intros.\n  elim H.\n  intros.\n  exists (b0, (b0, b1)).\n  split.\n  auto with arith.\n  split.\n  auto with arith.\n  split.\n  auto with arith.\n  split.Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  exists (a * a).\n  auto with arith.\n  exists 1.\n  auto with arith.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  exists (a, (a, b)).\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  generalize (gcd_total a b H0); intro.\n  rewrite H0 in H.\n  rewrite H0 in H0.\n  apply H0.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  destruct H.\n  auto with arith.\n  exists (a * b).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  rewrite (div_mod a b c H).\n  rewrite <- (abs_eq a b H).\n  rewrite H.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  apply (divide_trans _ (divide_trans _ (divide_trans a b) c)).\n  apply (divide_trans _ (divide_trans _ (divide_trans a b) c)).\n  apply (divide_trans _ (divide_trans _ (divide_trans a b) c)).\n  apply (divide_trans _ (divide_trans a b) c).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_trans _ (divide_trans b c)).\n  apply (divide_transQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  destruct (le_gt_dec a b).\n  left.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  case H.\n  auto with arith.\n  exists (a * b).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  elim H.\n  intros.\n  elim H0.\n  intro.\n  elim H2.\n  intros.\n  elim H1.\n  intro.\n  exists (c * a).\n  auto with arith.\n  elim H2.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H2.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H2.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  exists (c * a).\n  auto with arith.\n  elim H3.\n  intros.\n  existsQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  destruct (le_gt_dec a b) as [H|H].\n  apply (divide_trans _ _ H).\n  apply (divide_trans _ _ H).\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  intros.\n  elim H.\n  exists 1.\n  auto with arith.\n  exists 1.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  case (gcd_dec a b); auto.\n  intros.\n  apply (gcd_antisym a b); auto.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  apply divide_refl.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  apply (divide_trans _ (gcd_divide_r a b)); auto with arith.\n  apply divide_refl.\n  apply divide_refl.\n  apply divide_refl.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros a b c H.\n  destruct (le_gt_dec a b).\n  auto with arith.\n  exists (q * a).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  apply H.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  red.\n  exists (q * a).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H;intro q'; elim q';intro q'; case q''; auto.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  exists (q' * a).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H;intro q; elim q;intro q; elim q;intro.\n  rewrite H1 in H1.\n  exists (q' * q').\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H;intro.\n  exists (q' * q').\n  auto with arith.\n  exists (q' * q').\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2349,
                "proof_end_offset": 2501,
                "proof": "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\nintros.\nred.\nintro.\napply H.\napply divides_antisym;trivial.\napply one_min_div.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  elim H;intro q';intro.\n  rewrite H1 in H1;simpl in H1;rewrite H2;trivial.\n  apply H.\n  apply H.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  elim H.\n  intros; elim H.\n  intros; elim H0.\n  intros; elim H1.\n  intros; elim H1.\n  intros; elim H2.\n  intros; elim H2.\n  intros; elim H3.\n  intros; elim H4.\n  intros; elim H5.\n  intros; elim H5.\n  intros; elim H5.\n  intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n   intros; elim H6; intros; elim H6; intros; elim H6;\n   intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n   intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8;\n   intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n   intros; elim H9; intros; elim H9; intros; elim H11;\n   intros; elim H12; intros; elim H12; intros; elim H12; intros;\n   elim H12;Qed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H;intro q;intro q';intro.\n  rewrite H1 in H1;simpl in H1; rewrite H1 in H1;discriminate.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  elim H;intro q;intro q;intro q;intro.\n  elim (mult_lemma_2 q q H0);intros.\n  rewrite H0 in H1;simpl in H1;rewrite <- plus_n_O in H1;simpl in H1;rewrite <- plus_n_O in H1; simpl in H1;\n   rewrite H1 in H1;simpl in H1; rewrite H1; auto.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro.\n  rewrite H1 in H1.\n  rewrite H2 in H1; rewrite H1;trivial.\n  elim (mult_lemma_5 q' q' H4);intros.\n  rewrite H1 in H1; rewrite H1;trivial.\n  elim (mult_lemma_5 q' q' H4);intros.\n  rewrite H1 in H1; rewrite H1;trivial.\n  elim (mult_lemma_5 q' q' H4);intros.\n  rewrite H1 in H1; rewrite mult_comm in H1;rewrite plus_comm in H1;simpl in H1;\n    rewrite plus_comm in H1; rewrite <- plus_comm in H1; simpl in H1;\n    rewrite H1; rewrite <- plus_comm in H1; simpl in H1;\n    rewrite <- plus_comm in H1; rewrite <- plus_comm in H1; simpl in H1;\n    rewrite <- plus_comm in H1; rewrite <- plus_comm in H1; simpl in H1;\n    rewrite <- H1; rewrite <- H0; rewrite <- plusQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  elim H;intro.\n  auto with arith.\n  auto with arith.\n  auto with arith.\n  auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  unfold a, b, b, b, a, b, b, b, c, b, b, c, d, d, b, d, d, d, d, d, d, d, b, d, d, d.\n  unfold d, d, d, b, d, d, d, d, d, d, d, d, d, b, d, d, d, d, d, b, d.\n  unfold d, d, b, d, d, d, b, d, d, d, d, d, d, d, d, d.\n  unfold d, d, b, d, d, d, d, d, d, d, b, d, d.\n  unfold d, b, b, d, d, d, d, d, b, d, d, d, d, b, d, d, d, d, d, d, d, d, d, d.\n  unfold d, d, b, d, d, d, d, d, d, d, b, d, d, d, d, d, d, d, d, d, d, d.Qed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  case (le_gt_dec 1 a); intro.\n  rewrite H1 in H0;rewrite H1 in H0;rewrite H1;trivial.\n  auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n intros.\n case (le_gt_dec 1 a); auto.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  unfold divide in |- *; intros.\n  elim H;intro q;intro.\n  rewrite H2 in H1.\n  apply (H a).\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "s *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2544,
                "proof_end_offset": 2770,
                "proof": "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nexists (q+q').\nrewrite H1;rewrite H2.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H;intro q;intro.\n  exists (p * q).\n  rewrite H2.\n  rewrite H2.\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  case (le_gt_dec (plus a b) (plus a b)); intros.\n  rewrite H0 in H; rewrite H; rewrite H0; auto.\n  rewrite H0; rewrite H0; auto.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H;intro.\n  rewrite H2.\n  rewrite H3.\n  rewrite H3.\n  auto with arith.\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro.\n  rewrite H2 in H0.\n  elim H0; intro.\n  rewrite H2 in H0.\n  elim H0; intro.\n  rewrite H1 in H0; rewrite H2 in H0; rewrite H0 in H0; discriminate H0.\n  elim H0; intro.\n  rewrite H2 in H0; rewrite H2 in H0; discriminate H0.\n  elim H0; intro.\n  rewrite H2 in H0; rewrite H2 in H0; discriminate H0.\n  elim H0; intro.\n  rewrite H2 in H0; rewrite H2 in H0; discriminate H0.\n  elim H0; intro.\n  rewrite H2 in H0; rewrite H2 in H0; discriminate H0.\n  elim H0; intro.\n  rewrite H2 in H0; rewrite H2 in H0; discriminate H0.\n  elim H0; intro.\n  rewrite H2 in H0; rewrite H2 in H0; discriminate H0.\n  elim H0; intro.\n  rewrite H2 in H0; rewrite H2 in H0; discriminate H0.\n  elim H0; intro.\n  rewriteQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  case (le_gt_dec d a); auto with arith.\n  apply le_antisym; tauto.\n  apply le_trans with (a*b); auto with arith.\n  apply le_trans with (a*b); auto with arith.\n  apply le_trans with (a*b); auto with arith.\n  apply le_trans with (b*b); auto with arith.\n  apply le_trans with (a*b); auto with arith.\n  apply le_trans with (b*b); auto with arith.\n  apply le_trans with (a*b); auto with arith.\n  apply le_trans with (b*b); auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  case H.\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold Zdivides.\n  intros.\n  elim H; intro.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divide in |- *.\n  intros.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro.\n  rewrite H1.\n  trivial.\n  apply mod_trans with (a * b).\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_sym.\n  apply mod_refl.\n  apply mod_trans with (a * b).\n  apply mod_sym.\n  apply mod_refl.\n  apply mod_trans with (b * d).\n  apply mod_refl.\n  rewrite mod_plus_full_l; auto with arith.\n  apply mod_refl.\n  apply mod_trans with (a * b).\n  apply mod_refl.\n  apply mod_refl.\n  apply mod_trans with (b * d).\n  apply mod_refl.\n  apply mod_trans with (b * d).\n  apply mod_refl.\n  apply mod_refl.\n  apply mod_trans with (b * d).\n  apply mod_refl.\n  rewrite mod_add_full_l; auto with arith.\n  apply mod_trans with (b * d).\n  apply mod_refl.\n  rewrite mod_assoc.\n  apply mod_refl.\n  apply mod_trans with (b * d).\n  apply mod_refl.\n  apply mod_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\n",
                "context_tokens": 732,
                "proof_start_offset": 2801,
                "proof_end_offset": 2971,
                "proof": "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nexists (b * q).\nrewrite H0.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold Order.\n  intros.\n  elim H;intro q;intro.\n  elim q;intro q0; intro.\n  exists (q0*q0).\n  rewrite H1; rewrite H2; rewrite H1; rewrite H2; simpl; auto with arith.\n  elim H0; intro.\n  exists (q0*q0).\n  rewrite H1; rewrite H2; rewrite H2; simpl; auto with arith.\n  rewrite H2; rewrite H2; simpl; auto with arith.\n  elim H0; intro.\n  exists (q0*q).\n  rewrite H1; rewrite H2; rewrite H2; simpl; auto with arith.\n  elim H0; intro.\n  exists (q0*q0).\n  rewrite H1; rewrite H2; simpl; auto with arith.\n  elim H0; intro.\n  exists (q0 * q0).\n  rewrite H2; rewrite H3; simpl; auto with arith.\n  elim H0; intro.\n  exists (q0 * q0).\n  rewrite H1; rewrite H2; simpl; auto with arith.\n  elim H0; intro.\n  exists (q0 * q0).\n  rewrite H1;Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divide.\n  intro.\n  case (le_gt_dec 0 d).\n  intro.\n  apply H.\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (a * b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (b * (b*b))).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (b*a)).\n  apply le_trans with (m * (b*b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (b*b)).\n  apply le_trans with (m * (a*b)).\n  apply le_trans with (m * (b*b)).\n  apply le_Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divide in |- *.\n  intros.\n  elim H;intro q';intro.\n  elim H0;intro q'; elim q';intro.\n  exists q'; elim H0;intro q''; elim q''; intro.\n  rewrite H2.\n  exists (q*q').\n  rewrite H1; rewrite H2.\n  rewrite H2; rewrite H3.\n  ring.\n  exists q'; rewrite H2.\n  rewrite H3; rewrite H3.\n  ring.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nunfold divides.\n  unfold Zdivides in |- *.\n  intros.\n  elim H;intro q';intro.\n  rewrite H0; rewrite H1; rewrite H2.\n  rewrite <- H2; auto with arith.\n  intro.\n  elim H0;intro q';intro.\n  rewrite H2; rewrite H3; rewrite H2; rewrite H2; auto with arith.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q'; elim q';intro.\n  rewrite H1.\n  unfold Zlt in |- *; intro; rewrite q'0; rewrite <- H2; auto.\n  elim H0;intro q'; case q'; intro.\n  rewrite H2.\n  unfold Zlt in |- *; intro; rewrite q'0; apply (H0 q').\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\n  intros.\n  elim H;intro q;intro q; elim q;intro q'; elim q';intro q'; elim q';intro q'; elim q';intro q';\n    intro; elim q'; intro q''; elim q''; intro q''; elim q''; elim q'';\n    intro q''; elim q''; intro q''; elim q''; elim q'';\n    intro q''; elim q''; elim q''; intros q'' q''; elim q''; elim q'';\n      intros q'' q''''''; elim q''; apply q''; elim q'';\n       intros q''''''''''''; elim q''; elim q''; elim q''; intros q'''''';\n       elim q''; elim q''; elim q'';\n       intros q''''''; elim q''; elim q''; elim q''; clear q'';\n       intros q''''; elim q''; elim q''; elim q'';\n       intros q''''''''; elim q''; elim q''; clear q'';\n       intros q''''; elim q''; elim q'';\n       intros q''''''''; elim q''; elim q''; elim q''; elim q'';\n       intros q''''''''; elim q''; elim q''; clear q'';\n       intros q''''''''; elim q''; elim q''; elimQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q';intro.\n  exists (q+q).\n  rewrite H2; rewrite H2; rewrite H2; rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H1; rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply le_refl.\n  apply le_trans with (p*q).\n  rewrite H2; apply leQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim q';intro q';intro.\n  exists (q + q').\n  rewrite H1; rewrite <- H2.\n  rewrite <- H0.\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q'') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).\n  apply (le_trans (m + q') (m + q')).Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\n  unfold divide in |- *.\n  intros.\n  elim H;intro q.\n  elim q.\n  intro q'.\n  simpl in |- *.\n  rewrite H1.\n  replace (q*a + q * a + q * a + q * a + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b + q * b +Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divide.\n  intros.\n  elim H;intro q;intro.\n  rewrite H0.\n  apply divide_trans with (a*(a*b)); try (auto with arith).\n  apply (H2 (a*b)); try (auto with arith).\n  apply (H1 (a*b)); try (auto with arith).\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3014,
                "proof_end_offset": 3325,
                "proof": "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H1;rewrite H2.\nexists (q'-q).\nrewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q; intro.\n  elim H1; intro.\n  rewrite H2 in H1; rewrite H2 in H1; rewrite H2 in H1; discriminate H1.\n  exists (b * q).\n  rewrite H1.\n  rewrite H2.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold gcd in |- *.\n  intros.\n  elim H;intro.\n  rewrite H1.\n  apply (le_trans (gcd a b) (gcd a b)); auto with arith.\n  apply (le_trans (gcd a b) (gcd b d)); auto with arith.\n  apply (le_trans (gcd a b) (gcd b d)); auto with arith.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intro.\n  elim H.\n  intro q; elim q.\n  intro.\n  rewrite H2 in H0.\n  unfold modulo in |- *.\n  exists (b * q).\n  rewrite H1.\n  rewrite H2.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q.\n  elim H;intro q.\n  elim H1;intro q0; elim q0;intro q0.\n  rewrite H1.\n  rewrite H2.\n  rewrite <- H0.\n  auto with arith.\n  rewrite <- H2.\n  auto with arith.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\nProof.\n  unfold hereditary, modulo.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H0; simpl in H0; rewrite H0.\n  elim (mult_lemma_5 q' q' H0).\n  intros.\n  apply H0.\n  rewrite <- H2 in H0; rewrite H0.\n  elim (mult_lemma_5 q' q' H0).\n  intros.\n  apply H0.\n  rewrite <- H2.\n  rewrite <- H3.\n  apply H0.\n  rewrite <- H1.\n  apply H0.\n  rewrite <- H3.\n  apply H0.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q; intro.\n  elim q;intro.\n  rewrite H2.\n  rewrite H2.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\nProof.\n  unfold same_prime in |- *.\n  intros.\n  elim H;intro q;intro.\n  rewrite H2 in H1.\n  apply H.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q; elim q;intro.\n  rewrite H0.\n  unfold divides in |- *; simpl in |- *.\n  rewrite <- H1.\n  apply H1.\n  apply H1.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold modulo.\n  intros.\n  elim H;intro.\n  rewrite H0.\n  apply (H (a * b) (b * d)).\n  rewrite H0.\n  apply (H (a * b) (b * d)).\n  rewrite H0.\n  rewrite H0.\n  apply (H0 (a * b) (b * d)).\n  rewrite H.\n  apply (H (a * b) (b * d)).\n  rewrite H0.\n  apply (H (a * b) (b * d)).\n  rewrite H0.\n  apply (H (b * d)).\n  apply (H (b * d)).\n  rewrite H0.\n  apply (H0 (b * d)).\n  rewrite H1.\n  apply (H (b * d)).\n  rewrite H1.\n  apply (H (b * d) (b * d)).\n  rewrite H0.\n  apply (H (b * d)).\n  rewrite H0.\n  apply (H (b * d)).\n  rewrite H0.\n  apply (H (b * d)).\n  apply (H0 (b * d) (b * d)).\n  rewrite H0.\n  apply (H (b * d)).\n Qed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold hereditary in |- *; intros.\n  elim H; intro q; elim q;intro q; elim q;intro q; elim q;intro q; elim q; intro q;\n    clear q q q; elim q; intro q; elim q; intro q; elim q;\n    intros; elim q0; intros; elim q0; elim q0; intros; elim q0;\n      intros; elim q0; intros; elim q0; intros; elim q0; intros;\n       clear q q q0; elim q0; intros; elim q0; intros;\n       clear q q0 q0; elim q0; intros; elim q0;\n       intros; elim q0; intros; elim q0; intros; elim q0;\n       intros; elim q0; intros; elim q0; intros; elim q0;\n       intros; elim q0; intros; elim q0; intros; elim q0;\n       intros; elim q0; intros; elim q0; intros; elim q0;\n       intros; elim q0; intros; elim q0; intros; elim q0;\n       intros; elim q0; intros; elim q0; intros;\n       intros; elim qQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\n",
                "context_tokens": 730,
                "proof_start_offset": 3412,
                "proof_end_offset": 4144,
                "proof": "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\nProof.\nintros.\napply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\nintro.\ncase n;intros.\nexists 0;auto with arith.\nelim (H0 ((S n0)-b)).\nintro q;intro.\nexists (S q).\nreplace (S n0) with (b+(S n0-b)).\nrewrite p;rewrite plus_comm;auto with arith.\nsymmetry.\napply le_plus_minus.\nelim H1;intros.\nrewrite H2.\nreplace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\napply mult_le_compat_r.\ndestruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\nsimpl;auto with arith.\ndestruct b.\nelim H1;simpl;intros;discriminate.\nomega.\napply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  intros.\n  elim H;intro q.\n  elim H0;intro q';intro.\n  elim H;intro q';intro.\n  rewrite H2; rewrite <- H3.\n  rewrite (mult_comm q'); rewrite (mult_comm q' q'); auto with arith.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  intros.\n  elim H;intro q;intro.\n  rewrite H1.\n  rewrite H2.\n  unfold modulo in |- *; rewrite (mult_comm d q); rewrite (mult_comm d q);auto with arith.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  intros.\n  elim H;intro q;intro q; elim q;intro q;intro q; elim q;intro q; elim q;intro q; elim q;intro q; elim q;intro q;\n   elim q;intro q; elim q;intro q; elim q;intro q; elim q; intro q;\n   elim q;intro q; elim q;intro q; elim q; intro q;\n   elim q; intro q; elim q; intro q; elim q; elim q; intro q;\n   elim q; intro q; elim q; elim q; intro q; elim q;\n   intros q0 q1 q2; elim q1; intros q2 q3; elim q3; intros q4 q5; elim q5;\n   intros q5 q6 q7; elim q5; intro q6; elim q6; intros q6 q7;\n   elim q6; intros q7 q8; elim q8; elim q9;\n   intros q8 q9; elim q10; intros q11 q11; elim q11; intros q12 q13; elim q12;\n   intros q11 q12; elim q12;Qed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  intros.\n  elim (mod_lt_or_eq a b); intro q; elim q;intro q; elim q;intro q; elim q; intro q;\n    [ elim q; intro q'; elim q; intro q';\n        [ elim q; intro q' | elim q'; intro q' ]\n        | elim q'; intro q'0;\n        [ elim q'; intro q'0; elim q'0; intro q'0;\n          [ elim q'0; intro q'0; elim q'0; intro q'0;\n            [ rewrite q'0; rewrite q'0; rewrite q'0;\n                rewrite (mult_comm q q'); rewrite (mult_comm q q')0;\n                  rewrite (mult_comm q q'); rewrite (mult_comm q q')0;\n                  rewrite (mult_comm q' q'0); rewrite (mult_comm q' q'0);\n                  rewrite (mult_comm q' q0); rewrite (mult_comm q' q0);\n                  rewrite (mult_comm q' q0); rewrite (mult_comm q' q'0);\n                    rewrite (mult_comm q' q0); rewriteQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold gcd in |- *.\n  intros.\n  elim H;intro q;intro.\n  elim q;intro q';intro.\n  elim q';intro q';intro q'.\n  rewrite H1.\n  apply (H0 q');intro q';intro.\n  elim q';intro q';intro q';intro.\n  rewrite H2.\n  apply (H0 q').\n  apply (H1 q');intro q'';intro q'';intro.\n  rewrite <- H2.\n  apply (H0 q').\n  apply (H1 q');intro q'';intro q''; intro.\n  rewrite <- H3.\n  apply (H1 q');intro q'';intro q''; rewrite <- H3; apply (H1 q');intro q'';\n  rewrite <- H3.\n  apply (H2 q');intro q''; elim q'';intro q''; rewrite <- H4; apply (H1 q''); intro q'';\n  apply (H1 q');intro q''; elim q''; intro q''; rewrite <- H4; apply (H1 q');intro q'';\n  apply (H2 q');intro q''; elim q''; intro q''; rewrite <- H4; apply (H2 q''); intro q'';\n  apply (H1 qQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold prime.\n  intros.\n  elim H;intro q;intro q; elim q;intro q.\n  rewrite H0.\n  replace (q - (p-q)) with (q - (p-q)).\n  rewrite H; ring.\n  replace (q - (p-q)) with (q - (p-q)); try ring.\n  rewrite H; ring.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  destruct (le_gt_dec a b).\n  right.\n  left.\n  apply (div_mod_eq a b q H0).\n  left.\n  apply (div_mod_eq a b q H).\n  right.\n  apply (div_mod_eq a b q H0).\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\nProof.\n  intros.\n  elim H;intro q;intro q; case q;intro q';intro.\n  rewrite H0.\n  rewrite H2.\n  rewrite H0.\n  rewrite H1.\n  rewrite H2.\n  auto.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold gcd, modulo.\n  intros.\n  elim H;intro q;intro.\n  elim q;intro q';intro.\n  rewrite H2 in H1; inversion H1; inversion H1; inversion H1; inversion H1; inversion H1; inversion H1; inversion H1.\n  unfold gcd, gcd, gcd, gcd, gcd.\n  rewrite <- H; auto with arith.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  unfold modulo.\n  intros.\n  elim H;intro q;intro q; elim q;intro q;intro q; elim q;intro q; intro q; elim q; intro q;\n    rewrite H2; rewrite H3; auto.\n  elim H0;intro q; elim q;intro q; elim q; intro q; elim q; intro q;\n    rewrite H2; rewrite H3; auto.\n  elim H0;intro q; elim q; intro q; elim q; intro q; elim q; intro q;\n    rewrite H3; rewrite H3; auto.\n  elim H0; intro q; elim q; intro q; elim q; intro q; elim q; intro q;\n    rewrite H2; rewrite H3; auto.\n  elim H0; intro q; elim q; intro q; elim q; intro q; elim q; intro q;\n    rewrite H2; auto.\n  elim H0; intro q; elim q; intro q; elim q; intro q; elim q;\n    rewrite H2; auto.\n  elim H0; intro q; elim q; intro q; elim q; intro q; elim q;\n    rewrite H3; auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": ".\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\n",
                "context_tokens": 727,
                "proof_start_offset": 4328,
                "proof_end_offset": 4482,
                "proof": "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\nintros.\nunfold quo.\ngeneralize (quo_dec a b H);intro;elim s;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  case (mod_lt_dec a b); intros.\n  rewrite H0.\n  rewrite (H0 (mod_eq _ _ H0)).\n  rewrite (mod_eq _ _ H0).\n  rewrite <- (mod_eq _ _ H).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).\n  rewrite (mod_eq _ _ H0).Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nunfold modulo.\ndestruct (mod_lt_dec a b H) as [H|H].\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_lt_dec a b H).\nrewrite (mod_ltQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  unfold modulo.\n  intros.\n  elim (le_gt_dec a b); intro H.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite H0.\n  ring.\n  auto with arith.\n  auto with arith.\n  Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  unfold mod, eqm; intros.\n  elim H;intro.\n  elim H;intro.\n  exists (S q).\n  rewrite H.\n  rewrite (mult_comm (mod a b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite <- (mult_assoc b (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite <- (mult_assoc b (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (mult_comm (mod b b H)).\n  rewrite (multQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nunfold quotient in |- *.\nintros a b H.\nelim H; intro.\nunfold quotient in |- *.\nintros.\nelim H; intro.\nunfold quotient in |- *.\nintros.\nelim H; intro.\nunfold quotient in |- *.\nintros.\nelim H; intro.\nunfold quotient in |- *.\nintros.\nelim (H0 (quotient_of_well_founded_induction_dec _ _ _ H0)).\nelim H0; intro.\nunfold quotient in |- *.\nintros.\nelim H1; intro.\nunfold quotient in |- *.\nintros.\nelim H1; intro.\nunfold quotient in |- *.\nintros.\nelim H1; intro.\nunfold quotient in |- *.\nintros.\nelim H1; intro.\nunfold quotient in |- *.\nintros.\nelim H1; intro.\nunfold quotient in |- *.\nintros.\nelim H1; intro.\nunfold quotient in |- *.\nintros.\nelim (H1 (quotient_of_well_founded_induction_dec _ _ _ H0)).\nelim H1; intro.\nunfold quotient in |- *.\nintros.\nelim H1; intro.\nunfold quotientQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  unfold a, b, a, b, b, c, d in H.\n  unfold mod in |- *.\n  apply mod_unique with (a/b).\n  apply mod_unique with (b mod a).\n  apply mod_sym.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_unique with b; trivial.\n  apply mod_Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intro.\n  case H;intro.\n  elim H;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H2;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H2;intro.\n  exists (c+p);auto with arith.\n  elim H2;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);auto with arith.\n  elim H1;intro.\n  exists (c+p);Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  elim H;intro q;intro.\n  exists (p+p).\n  rewrite H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite H0.\n  rewrite <- H0.\n  rewrite <- HQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  unfold mod.\n  simple induction a.\n  simpl in |- *.\n  unfold modulo in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  unfold eqm in |- *.\n  intros.\n  apply (H a).\n  apply (H a).\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intro; red; intro.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\nLemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  unfold quo.\n  generalize (quo_dec a b H);intro;elim s;trivial.\nQed.\n\n(** if b | a then (n*a/b) = n*(a/b) *) \n",
                "context_tokens": 706,
                "proof_start_offset": 4524,
                "proof_end_offset": 5018,
                "proof": "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\nintros.\ngeneralize (quo_is_quo (a*n) b (divides_mult b a n H));intro.\ngeneralize (quo_is_quo a b H);intro.\nreplace (a*n = b * quo (a * n) b (divides_mult b a n H)) with (b*(quo a b H)*n = b * quo (a * n) b (divides_mult b a n H)) in H1.\nsymmetry;rewrite mult_comm.\napply mult_lemma6 with b;trivial.\nrewrite mult_assoc;trivial.\nrewrite <- H2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold modulo.\n  generalize (mod_mult_full a b H);intro;elim s;trivial.\n  apply (H0 ((a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b))).\n  unfold modulo.\n  generalize (mod_mult_full a b H);intro; elim s;trivial.\n  apply (H0 ((a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (b/b))).\n  unfold modulo.\n  generalize (mod_mult_full a b H);intro; elim s;trivial.\n  apply (H0 ((a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (a/b) mod (b/b))).\n  unfold modulo.\n  generalize (mod_mult_full a b H);intro; elim s;trivial.\n  apply (H0 ((a/b) modQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  unfold modulo.\n  intros.\n  case (mod_eq_dec a b H); intros.\n  generalize (H0 (mod_eq_dec a b H0));intro; elim H;intro.\n  rewrite <- H1; rewrite H2; auto with arith.\n  rewrite H2; auto with arith.\n  rewrite <- H1; auto with arith.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold modulo, modulo.\n  rewrite H0.\n  rewrite <- H1.\n  rewrite <- H0.\n  apply mod_divides.\n  rewrite (mod_mult_full a b H H0).\n  rewrite <- H0.\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  rewrite (mod_mult_full a b H0).\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides. omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides. omega.\n  apply mod_divides. omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides. omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides. omega.\n  apply mod_divides. omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides.\n  omega.\n  apply mod_divides. omega.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros a b H.\n  rewrite (div_mod a b H).\n  unfold modulo.\n  rewrite <- (mod_plus b (a/b) b); rewrite (mod_plus b b (a/b)); auto with arith.\n  rewrite <- (mod_plus b (a/b) b (a/b)); auto with arith.\n  rewrite <- (mod_plus b (a/b) b (a/b)); auto with arith.\n  rewrite <- (mod_plus b (a/b) b (a/b)); auto with arith.\n  rewrite <- (mod_plus b (a/b) b (a/b)); auto with arith.\n  rewrite <- (mod_plus b (a/b) b (a/b)); auto with arith.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (div_unique a b H); trivial.\n  apply (mod_unique a b H); trivial.\n  apply (mod_unique a b H); trivial.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold mod.\n  generalize (mod_lt_dec a b H);intro; elim s;trivial.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  unfold modulo.\n  intros.\n  elim H;intro.\n  exists (n * a).\n  rewrite <- H0.\n  ring.\n  intros.\n  exists (n * a).\n  rewrite <- H.\n  ring.\n  simpl.\n  ring.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  unfold is_lin_left in H.\n  rewrite <- (mod_plus b a b H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <- (mod_plus b a H).\n  rewrite <-Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold mod.\n  generalize (mod_mult a b H);intro;elim s;intro.\n  rewrite <- H1; rewrite <- H2.\n  rewrite <- H0; rewrite <- H2.\n  auto.\n  unfold mod.\n  generalize (mod_mult a b H);intro;elim s;intro.\n  rewrite <- H1; rewrite <- H2.\n  auto.\n  unfold div.\n  generalize (mod_mult a b H);intro;elim s;intro.\n  rewrite <- H1; rewrite <- H2.\n  auto.\n  unfold div.\n  generalize (mod_mult a b H);intro; elim s;intro.\n  rewrite <- H1; rewrite <- H2.\n  auto.\n  unfold div.\n  generalize (mod_mult_is_mod b a b H);intro; elim s;intro.\n  rewrite <- H1; rewrite <- H2.\n  auto.\n  unfold div in |- *.\n  generalize (mod_mult_is_mod b a b H);intro; elim s;intro.\n  rewrite <- H1; rewrite <- H2.\n  auto.\n  unfold div in |- *.\n  generalize (mod_mult b a b H);intro; elimQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros a b H.\n  unfold modulo.\n  generalize (H (mod a b H));intro;elim s;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\n",
                "context_tokens": 314,
                "proof_start_offset": 1197,
                "proof_end_offset": 1343,
                "proof": "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime.\nintro.\nelim H;intros.\ncase (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n intros.\n destruct (is_prime O); trivial.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  intros d.\n  destruct (Zle_or_lt 0 d).\n  apply lt_le_weak.\n  apply lt_le_weak.\n  assumption.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n apply (is_prime_zero p).\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  apply (is_prime_zero (pos_pos p)).\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n intro.\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 0).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_cases O 1).\n generalize (lt_gt_casesQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n intros.\n apply H.\n apply H.\n apply Z.divide_1_r.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  unfold is_prime in |- *.\n  unfold Z.abs in |- *.\n  intros.\n  elim H0.\n  intro.\n  apply H1.\n  assumption.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  intros d.\n  apply (is_prime_zero d).\n  apply H.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  intros.\n  apply (dec_prime_zero (p:=p)).\n  exact (dec_prime_zero (p:=p)).\n  exact (dec_prime_zero (p:=p)).\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold is_prime in |- *.\n unfold is_prime in |- *.\n unfold prime in |- *.\n unfold Zle in |- *.\n unfold not in |- *; intros.\n case (prime_not_prime O); intros.\n apply H.\n elim H2.\n elim H2.\n intros.\n apply H.\n elim H2.\n elim H2.\n intros.\n apply H1.\n elim H2.\n elim H2.\n intros.\n apply H1.\n elim H2.\n intros.\n apply H2.\n elim H2.\n intros.\n apply H2.\n elim H2.\n intros.\n apply H3.\n elim H2.\n elim H2.\n intros.\n apply H4.\n elim H3.\n intros.\n apply H2.\n elim H2.\n intros.\n apply H1.\n elim H2.\n intros.\n apply H2.\n elim H2.\n intros.\n apply H3.\n elim H3.\n intros.\n apply H3.\n elim H4.\n intros.\n apply H2.\n elim H4.\n intros.\n apply H4.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\n",
                "context_tokens": 376,
                "proof_start_offset": 1372,
                "proof_end_offset": 1780,
                "proof": "Lemma is_prime_2 : (is_prime 2).\nProof.\nunfold is_prime.\nsplit.\nintro;discriminate.\nintros.\nelim H;destruct x;rewrite mult_comm.\nintro;discriminate.\nsimpl.\ncase d.\nsimpl.\nrewrite mult_comm;simpl;intro;discriminate.\nintros.\ninversion H0.\nsymmetry in H2.\ncase (plus_is_one n (x*(S n)) H2);intro.\nelim a;intros.\nleft;rewrite H1;trivial.\nelim a;intros.\nright;rewrite H1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  elim H0;intros.\n  case (prime_intro q);intro.\n  rewrite H1 in H.\n  simpl in H.\n  simpl in H.\n  rewrite H.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H0.\n  rewrite HQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime in |- *; simpl in |- *.\n  intros.\n  elim H;intros.\n  case (H2 2);intros.\n  case (H3 2);intros.\n  case (H3 2);intros.\n  case (H4 2);intros.\n  case (H4 3);intros.\n  case (H5 3);intros.\n  case (H7 3);intros.\n  case (H4 3);intros.\n  case (H6 3);intros.\n  case (H5 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H7 3);intros.\n  case (H8 3);intros.\n  case (H7 3);intros.\n  case (H8 3);intros.\n Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime in |- *.\n  intro.\n  elim H;intros.\n  case (H1 2);intros.\n  case (H2 4);intros.\n  apply H1;auto.\n  apply H2;auto.\n  apply H2;auto.\n  apply H1;auto.\n  apply H1;auto.\n  apply H1;auto.\n  apply H1;auto.\n  apply H1;auto.\n  apply H1;auto.\n  apply H1;auto.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime in |- *.\n  intro.\n  elim H;intros.\n  case (prime_odd_dec 2).\n  intro.\n  apply H.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H;intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H; intros.\n  apply H0.\n  auto with arith.\n  intro.\n  elim H0; intros.\n  apply H1.\n  auto with arith.\n  intro.\n  elim H0; introsQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  left; apply (is_prime_intro (P:=fun q:nat => q=1) H).\n  elim H0;intros.\n  right; apply (is_prime_intro (P:=fun q:nat => q=1) H).\n  elim H1;intros.\n  right; apply (is_prime_intro (P:=fun q:nat => q=1) H).\n  elim H1;intros.\n  left; apply (is_prime_intro (P:=fun q:nat => q=1) H0).\n  elim H1;intros.\n  right; apply (is_prime_intro (P:=fun q:nat => q=1) H0).\n  elim H1;intros.\n  right; apply (is_prime_intro (P:=fun q:nat => q=1) H0).\n  elim H1; intros.\n  right; apply (is_prime_intro (P:=fun q:nat => q=1) H0).\n  elim H1;intros.\n  right; apply (is_prime_intro (P:=fun q:nat => q=Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div; assumption).\n  apply False_ind;intros.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div; assumption).\n  apply False_ind;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  case (H4 3);try (apply zero_max_div; assumption).\n  apply False_ind;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\nProof.\n  trivial.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\nProof.\n  intro.\n  elim H.\n  intros.\n  case (prime_odd_dec 2) with 1%Z.\n  intro.\n  assumption.\n  intro.\n  elim H1.\n  intros.\n  case (prime_odd_dec 2 (2 * d)).\n  intro.\n  assumption.\n  intro.\n  elim H2.\n  intros.\n  case (prime_odd_dec 2 (2 * d)).\n  intro.\n  assumption.\n  intro.\n  elim H2.\n  intros.\n  case (prime_odd_dec 2 (2 * d)).\n  intro.\n  assumption.\n  intro.\n  assumption.\n  intro.\n  elim H2.\n  intros.\n  case (prime_odd_dec 2 (2 * d)).\n  intro.\n  assumption.\n  intro.\n  elim H3.\n  intros.\n  elim H3.\n  intros.\n  case (prime_odd_dec 2 (2 * d))).\n  intro.\n  assumption.\n  intro.\n  elim H4.\n  intros.\n  elim H4.\n  intros.\n  case (prime_odd_dec 2 (2 * d))).\n  intro.\n  assumption.\n  intro.\n  elim H4.\n  intros.\n  assumption.Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  elim H0;intros.\n  case (H2 5);try (apply zero_max_div;auto with arith).\n  intro.\n  left.\n  apply H1;auto with arith.\n  intro.\n  elim H1;intros.\n  left.\n  apply H1;auto with arith.\n  intro.\n  right.\n  apply H1;auto with arith.\n  intro.\n  elim H0;intros.\n  right.\n  apply H2;auto with arith.\n  intro.\n  elim H1;intros.\n  right.\n  apply H1;auto with arith.\n  intro.\n  elim H1;intros.\n  right.\n  apply H0;auto with arith.\n  intro.\n  elim H1;intros.\n  right.\n  apply H1;auto with arith.\n  intro.\n  elim H1;intros.\n  right.\n  apply H1;auto with arith.\n  intro.\n  elim H1;intros.\n  left.\n  apply H1;auto with arith.\n  intro.\n  elim H1;intros.\n  right.\n  apply H1;auto with arith.\n  intro.\n  left.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\n",
                "context_tokens": 535,
                "proof_start_offset": 1852,
                "proof_end_offset": 2186,
                "proof": "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nunfold is_prime.\nunfold rel_prime.\nintros.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H;intros.\nelim H1;intros.\ncase (H3 d' H4);intro.\nrewrite H6;apply divides_refl.\nrewrite H6 in H5;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  left; rewrite H1;trivial.\n  right; rewrite H1;trivial.\n  right; rewrite H1;trivial.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros; elim H;intros.\n  apply (divide_1_r p).\n  apply (divide_1_r p).\n  apply (divide_1_r p).\n  apply (divide_1_r p).\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros; apply (is_prime_intro p); auto.\n  apply prime_div_prime; auto.\n  apply prime_div_prime; auto.\n  apply prime_div_prime; auto.\n  apply prime_div_prime; auto.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  elim H;intros.\n  case (prime_div_prime p a);intros.\n  right;rewrite H1;trivial.\n  intro;rewrite H2;trivial.\n  right;rewrite H1;trivial.\n  elim H2;intros.\n  right;rewrite H1;trivial.\n  right;rewrite H1;trivial.\n  elim H2;intros.\n  right;rewrite H1;trivial.\n  elim H2;intros.\n  left;rewrite H1;trivial.\n  elim H2;intros.\n  right;rewrite H1;trivial.\n  elim H2;intros.\n  right;rewrite H1;trivial.\n  elim H3;intros.\n  right;rewrite H1;trivial.\n  elim H2;intros.\n  left;rewrite H1;trivial.\n  elim H3;intros.\n  left;rewrite H1;trivial.\n  elim H4;intros.\n  right;rewrite H1;trivial.\n  elim H4;intros.\n  left;rewrite H1;trivial.\n  elim H2;intros.\n  right;rewrite H1;trivial.\n  elim H4;intros.\n  left;rewrite H1;trivial.\n  elim HQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a.\n  elim H.\n  intros; left; rewrite H0; assumption.\n  right; rewrite H0; assumption.\n  right; rewrite H0; assumption.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  destruct (prime_div_prime p a H H0) as (a,H).\n  rewrite H in H.\n  elim H;intros.\n  right;rewrite H;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H;trivial.\n  right;rewrite H;trivial.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  case (prime_inf p); intros.\n  case (prime_inf p); intros.\n  left.\n  trivial.\n  right; rewrite H1;trivial.\n  apply prime_div_prime; trivial.\n  left.\n  trivial.\n  right; rewrite H1;trivial.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a.\n  generalize (is_prime_odd a).\n  destruct (is_prime_odd p) as (b,d).\n  split.\n  intro; discriminate.\n  intro; inversion H0.\n  right;rewrite H0;trivial.\n  right;rewrite H1;trivial.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n intros.\n destruct p.\n apply prime_div_exact_equal.\n apply prime_div_exact.\n apply prime_div_exact.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  elim H.\n  intros.\n  apply (is_prime_intro p H).\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\n",
                "context_tokens": 691,
                "proof_start_offset": 2286,
                "proof_end_offset": 2466,
                "proof": "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nunfold is_prime.\nintros.\nelim H;intros.\napply H2.\nelim H0;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n intros.\n apply prime_intro.\n unfold is_prime, is_prime.\n split.\n apply prime_intro.\n unfold is_prime.\n split.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n unfold is_prime in H.\n split.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\n apply prime_intro.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H3.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim H2;intros.\n  elim H3;intros.\n  right;rewrite H2;auto.\n  simpl.\n  rewrite <- H3;auto.\n  rewrite <- H4;auto.\n  rewrite <- H4;auto.\n  rewrite <- H4;auto.\n  elim H4;intros.\n  right;rewrite H3;auto.\n  rewrite <- H4;auto.\n  rewrite <- H4;auto.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n intros.\n destruct p.\n destruct p.\n destruct p.\n destruct p.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p.\n simpl in H.\n discriminate H.\n destruct p0.\n destruct p0.\n destruct p0.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p.\n simpl in H.\n discriminate H.\n destruct p.\n destruct p0.\n destruct p0.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p.\n destruct p0.\n destruct p0.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p.\n destruct p0.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p.\n destruct p0.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p0.\n destruct p0.\n destruct p0.\n simpl in H.\n discriminate H.\n destruct p0.\n simpl in H.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  intros.\n  elim H.\n  intros.\n  elim H0.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H2.\n  intros.\n  elim H1.\n  intros.\n  elim H2.\n  intros.\n  elim H4.\n  intros.\n  elim H5.\n  intros.\n  apply H4.\n  intros.\n  elim H5.\n  intros.\n  elim H6.\n  intros.\n  apply H5.\n  intros.\n  elim H6.\n  intros.\n  apply H5.\n  intros.\n  elim H5.\n  intros.\n  apply H5.\n  intros.\n  apply H6.\n  intros.\n  elim H5.\n  intros.\n  elim H5.\n  intros.\n  apply H6.\n  intros.\n  elim H6.\n  intros.\n  apply H6.\n  intros.\n  elim H6.\n  intros.\n  apply H7.\n  intros.\n  elim H6.\n  intros.\n  apply H6.\n  intros.\n  elim H7.\n  intros.\n  elim H7.\n  intros.\n  elim H8.\n  intros.\n  apply H7.Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  simple induction d.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  rewrite H6; apply H1; auto.\n  elim H6; intros.\n  rewrite H6; apply H2; auto.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  rewrite H6; apply H2; auto.\n  elim H6; intros.\n  rewrite H6; apply H1; auto.\n  elim H6; intros.\n  elim H7; intros.\n  rewrite H6; apply H3; auto.\n  elim H6; intros.\n  rewrite H6; apply H1; auto.\n  elim H7; intros.\n  rewrite H6; apply H3; auto.\n  elim H7; intros.\n  rewrite H7; apply H1; auto.\n  elim H7; intros.\n  rewrite H7; apply H1; auto.\n  elim H7; intros.\n Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  case (H4 d H4);intro.\n  rewrite H5;apply divide_refl.\n  apply H4; apply divide_refl.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  rewrite H6; apply divide_refl.\n  apply H4; apply divide_refl.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  rewrite H6; apply divide_refl.\n  apply H4; apply divide_refl.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  rewrite H6; apply divide_refl.\n  apply H4; apply divide_refl.\n  apply H4; apply divide_refl.\n  apply H4; apply divide_refl.\n  apply H4; apply divide_reflQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  unfold is_prime.\n  case (gcd_is_prime p).\n  intros.\n  elim H1;intros.\n  rewrite H1.\n  apply (H0 (d:=0) (d':=0) (d':=0) (d':=0).\n  unfold is_prime in |- *.\n  split.\n  apply prime_div_div_prime; intros.\n  elim H2;intros.\n  elim H2;intros.\n  rewrite H2.\n  apply (H (d':=0) (d':=0) (d':=0) (d':=0) (d':=0) (d':=0).\n  unfold is_prime in |- *.\n  unfold is_prime in |- *.\n  unfold is_prime in H.\n  split.\n  apply prime_div_prime; intros.\n  elim H3; intros.\n  elim H3; intros.\n  rewrite H4.\n  apply (H0 (d':=0) (d':=0) (d':=0) (d':=0) (d':=0) (d':=0) (d':=0).\n  unfold is_prime in |- *.\n  unfold is_prime in H.\n  unfold prime in H.Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim H1;intros.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "NU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2516,
                "proof_end_offset": 2785,
                "proof": "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (gcd_is_gcd a p);intros.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\nelim H1;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  apply H3.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  apply H5;intros.\n  apply H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  apply H5;intros.\n  apply H5;intros.\n  apply H5;intros.\n  elim H5;intros.\n  apply H5;intros.\n  apply H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  apply H5;intros.\n  elim H5;intros.\n  apply H6;intros.\n  apply H5;intros.\n  apply H5;intros.\n  apply H6;intros.\n  apply H5;intros.\n  elim H5;intros.\n  apply H5;intros.\n  apply H5;intros.\n  elim H5; intros.\n  apply H5;intros.\n  apply H5;intros.\n  apply H5;intros.\n  apply H5;intros.\n  elim H5; intros.\n  apply H5;Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H2; intros.\n  elim H4; intros.\n  apply H1.\n  elim H3; intros.\n  apply H2.\n  elim H4; intros.\n  apply H1.\n  elim H4; intros.\n  apply H4.\n  elim H5; intros.\n  apply H4.\n  elim H5; intros.\n  apply H6.\n  elim H5; intros.\n  apply H1.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H6; intros.\n  apply H5.\n Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H1;intros.\n  elim H2;intros.\n  apply H1.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  apply H4.\n  elim H5;intros.\n  apply H5.\n  elim H5;intros.\n  apply H5.\n  elim H6;intros.\n  elim H5; intros.\n  apply H5.\n  elim H5;intros.\n  apply H5.\n  elim H5; intros.\n  apply H6.\n  elim H6; intros.\n  apply H5.\n  elim H5; intros.\n  apply H6.\n  elim H6; intros.\n  apply H6.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H6; intros.\n  apply H5.\n  elim H5; intros.\n  apply H6.\n  elim H6; intros.\n  apply H6.\n  elim H6; intros.\n  apply H6.\n  elim H6; intros.\n  applyQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\nProof.\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H1.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  apply H2.\n  elim H2;intros.\n  elim H3;intros.\n  apply H3; intros.\n  apply H4; intros.\n  elim H4;intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H6; intros.\n  elim H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5; intros.\n  apply H5Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\nProof.\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  unfold is_prime in |- *.\n  intros.\n  apply H1.\n  elim H;intros.\n  elim H1;intros.\n  case (H0 p);intros.\n  rewrite H1; apply H2.\n  elim H1;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  apply H1; split;\n    [ assumption | apply H5; split; assumption ].\n  apply H1; split;\n    [ assumption | apply H5; split; assumption ].\n  apply H1; split;\n    [ assumption | apply H5; split; assumption ].\nQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (prime_inf a p);intro.\n  left;rewrite <- H2;apply H.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H6; intros.\n  apply H7; intros.\n  elim H7; intros.\n  apply H8; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elimQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  apply H2.\n  elim H2; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H2; intros.\n  apply H4.\n  apply H3.\n  elim H3; intros.\n  apply H4.\n  elim H1; intros.\n  apply H4.\n  apply H1.\n  elim H4; intros.\n  apply H4.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H6; intros.\n  apply H4.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H4.\n  elim H5; intros.\n  apply H5.\n  elim H6; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H6.\n  elim H5Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim HQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  apply H5.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  apply H6.\n  elim H6; intros.\n  elim H6; intros.\n  apply H6.\n  elim H6; intros.\n  apply H6.\n  elim H6; intros.\n  apply H7.\n  elim H6; intros.\n  apply H6.\n  elim H6; intros.\n  apply H6.\n  elim H6; intros.\n  elim H6; intros.\n  apply H7.\n  elim H6; intros.\n  apply H8.\n  elim H6; intros.\n  apply H8.\n  elim H6; intros.\n  apply H8.\n  elim H7; intros.\n  apply H7.\n  elim H8; intros.\n  apply H9.\n  elim H9; intros.\n Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\nProof.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H4;intros.\n  elim H1;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6; intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H9; intros.\n  elim H6; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\n",
                "context_tokens": 720,
                "proof_start_offset": 2840,
                "proof_end_offset": 3139,
                "proof": "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a p);intro.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\nright;apply gauss with a;trivial.\nred in H1;elim H1;intros.\nred in H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H1;intros.\n  apply H2.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H11Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n  unfold is_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_divisors (a*b) p);intro.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H8;intros.\n  elim H9;intros.\n  elim H6;intros.\n  elim H9;intros.\n  elim H9;intros.\n  elim H9;intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim H12; introsQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n unfold is_prime.\n  intros.\n  generalize (gcd_is_prime p);intro.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H8;intros.\n  elim H8;intros.\n  elim H8;intros.\n  elim H8;intros.\n  elim H8;intros.\n  elim H9;intros.\n  elim H9; intros.\n  elim H9;intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H10; intros.\n  elim H10;Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_divisors (gcd a p) p a H H0);intro; rewrite H2 in H0; try tauto.\n  elim H0;trivial.\n  elim H0;trivial.\nQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n  unfold is_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_divisors (a*b));intro.\n  apply H2; trivial.\n  elim H0;intros.\n  elim H0;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7; intros.\n Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_dec (gcd a p) p);intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  rewrite H1;auto.\n  elim H1;intros.\n  rewrite H1;auto.\n  elim H2;intros.\n  elim H2;intros.\n  rewrite H2;auto.\n  elim H4;intros.\n  rewrite H2;auto.\n  elim H3;intros.\n  elim H4;intros.\n  rewrite H3;auto.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  rewrite H1;auto.\n  elim H4;intros.\n  elim H4;intros.\n  rewrite H4;auto.\n  elim H4;intros.\n  elim H5;intros.\n  rewrite H5;auto.\n  elim H5;intros.\n  rewrite H5;auto.\n  elim H4; intros.\n  rewrite H5;auto.\n  elim H5;intros.\n  rewrite H5;auto.\n  elimQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n  intros.\n  generalize (gcd_is_prime p);intros.\n  generalize (gcd_is_gcd a p);intros.\n  generalize (gcd_is_gcd a p);intros.\n  elim H1;intros.\n  apply H1.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H8;intros.\n  elim H8;intros.\n  elim H7; intros.\n  elim H8;intros.\n  elim H9;intros.\n  elim H8;intros.\n  elim H9;intros.\n  elim H9;intros.\n  elim H9;intros.\n  elim H9;intros.\n  elim H9;intros.\n  elim H9; intros.\n  elim H11; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim H12Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H0);intro; rewrite H3 in H1; try tauto.\n  elim H1;intros.\n  elim H2;trivial.\n  case (prime_gcd (gcd a p) p0);intro; rewrite H3 in H1; try tauto.\n  elim H1;trivial.\n  elim H1;trivial.\n  Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n intros.\n generalize (gcd_is_gcd a p);intros.\ngeneralize (gcd_is_gcd a p);intros.\ngeneralize (gcd_is_gcd a p);intros.\ngeneralize (gcd_is_gcd a p);intros.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);intros.\nrewrite H.\ngeneralize (gcd_is_gcd a p);Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  generalize (gcd_is_prime a p);intros.\n  case (prime_gcd (gcd a p) p);intro.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  rewrite H1; apply H2.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  rewrite H5; apply H2.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7;intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  rewrite H8; apply H8.\n  elim H8; intros.\n  elim H8; intros.\n  elim H9; intros.\n  rewrite H9; apply H9.\n  elim H9; intros.\n  elim H9; intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\n",
                "context_tokens": 729,
                "proof_start_offset": 3196,
                "proof_end_offset": 3355,
                "proof": "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\nunfold square.\nintros;case (prime_mult p a a H H0);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  apply prime_div_prime; trivial.\n  apply prime_div_prime; trivial.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\n  unfold prime.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim HQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\n  unfold prime, is_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H0);intro.\n  apply H2.\n  elim H1;intros.\n  elim H1;intros.\n  apply H2;intros.\n  elim H2;intros.\n  apply H2;intros.\n  elim H3;intros.\n  elim H1;intros.\n  apply H3;intros.\n  elim H3;intros.\n  apply H3;intros.\n  apply H1;intros.\n  elim H3;intros.\n  apply H4;intros.\n  apply H4;intros.\n  elim H1;intros.\n  apply H4;intros.\n  elim H5;intros.\n  apply H5;intros.\n  elim H5;intros.\n  apply H5;intros.\n  elim H6;intros.\n  apply H5;intros.\n  apply H6;intros.\n  elim H5;intros.\n  apply H6;intros.\n  elim H6;intros.\n  apply H6;intros.\n  elim H6;intros.\n  apply H6;intros.\n  applyQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\n  unfold prime.\n  unfold gcd.\n  intros.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  apply prime_mult.\n  applyQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\n  intros.\n  generalize (gcd_is_gcd p a);intro.\n  case (prime_divisors (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  generalize (gcd_is_gcd a p);intro.\n  generalize (gcd_is_gcd a p);intro.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  rewrite H5;rewrite H5;trivial.\n  auto.\n  auto.\n  auto.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim HQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro; rewrite H2 in H1.\n  apply H2.\n  elim H1;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  unfold is_prime.\n  elim H; intros.\n  elim H; intros.\n  rewrite H1; rewrite H2; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H2; rewrite H3; rewrite H3; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H2; rewrite H3; rewrite H3; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H2; rewrite H3; rewrite H3; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H2; rewrite H3; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H1; rewrite H3; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H2; rewrite H3; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H2; rewrite H3; rewrite H3; reflexivity.\n  apply H.\n  elim H1; intros.\n  rewrite H2; rewrite H3;Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H1.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  apply H4.\n  elim H4;intros.\n  elim H5;intros.\n  apply H5.\n  apply H2.\n  elim H4;intros.\n  apply H5.\n  elim H5;intros.\n  elim H5;intros.\n  apply H5.\n  apply H4.\n  elim H5;intros.\n  apply H5.\n  elim H4;intros.\n  apply H5.\n  elim H4;intros.\n  apply H5.\n  apply H4.\n  elim H5;intros.\n  apply H5.\n  elim H5;intros.\n  apply H5.\n  elim H5;intros.\n  apply H5.\n  elim H5;intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  apply H5.\n  elim H5; introsQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  elim H2;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  apply H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H8;intros.\n  elim H8;intros.\n  elim H6;intros.\n  elim H8;intros.\n  elim H7;intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3388,
                "proof_end_offset": 3666,
                "proof": "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\ninduction n;simpl;intros.\nelim H;intros.\nelim H1;apply divides_antisym;trivial;apply one_min_div.\ncase (prime_mult p x (power x n) H H0);trivial.\nintro;apply IHn;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  simple destruct p; intros.\n  apply H.\n  apply prime_mult.\n  apply H.\n  apply H.\n  apply prime_mult.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply prime_mult.\n  apply H.\n  apply H.\n  apply H.\n  apply prime_mult.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold prime.\n  intros.\n  apply H.\n  apply prime_div_pos; trivial.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\n  intros.\n  generalize (prime_plus_pos p x);intro.\n  case (prime_mult p x p);intro.\n  left.\n  right; apply H.\n  right; apply H.\n  apply H.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  intros.\n  case (prime_mult p x p);intros.\n  apply H.\n  elim H;intros.\n  apply H1.\n  elim H1;intros.\n  apply H2.\n  elim H2;intros.\n  apply H2.\n  elim H1;intros.\n  apply H2.\n  elim H3;intros.\n  apply H2.\n  elim H1;intros.\n  apply H1.\n  elim H3;intros.\n  apply H3.\n  elim H3;intros.\n  apply H1.\n  elim H3;intros.\n  apply H3.\n  elim H4;intros.\n  apply H4.\n  elim H4;intros.\n  apply H5.\n  elim H4;intros.\n  apply H2.\n  elim H4;intros.\n  apply H1.\n  elim H4;intros.\n  apply H4.\n  elim H5;intros.\n  apply H3.\n  elim H4;intros.\n  apply H4.\n  elim H5; intros.\n  apply H5.\n  elim H5;intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H5; intros.\n  apply HQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold prime.\n  intros.\n  apply H.\n  elim H; intros.\n  elim H1; intros.\n  apply H.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  apply H2.\n  elim H4; intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H5.\n  elim H5; intros.\n  apply H6.\n  elim H5; intros.\n  apply H6.\n  elim H5; intros.\n  apply H6.\n  elim H6; intros.\n  apply H6.\n  elim H7; intros.\n  apply H6.\n  elim H7; intros.\n  apply H6.\n  elim H7; intros.\n  apply H7.\n  elim H7; intros.\n  apply H7.\n  elim H7; intros.\n  apply H7.\n  elim H6; intros.\n  apply H6.\n  elim H7; intros.\n  apply H6.\n  elim H7; intros.\n  apply H7.\n  elim H7; intros.\n  apply HQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim H;intros.\n  apply H1.\n  elim H0;intros.\n  elim H1;intros.\n  apply H2.\n  elim H2;intros.\n  apply H3.\n  apply H1.\n  elim H2;intros.\n  elim H3;intros.\n  apply H3.\n  elim H3;intros.\n  apply H3.\n  elim H4;intros.\n  apply H3.\n  elim H4;intros.\n  apply H4.\n  apply H4.\n  elim H4;intros.\n  apply H4.\n  elim H4;intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H4; intros.\n  apply H5.\n  elim H4; intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H4; intros.\n  apply H4.\n  elim H5; intros.\n  apply H4.\n  elim H4; intros.\n  apply H5.\n  elim H4; intros.\n Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  unfold is_prime.\n  intros.\n  case (prime_mult p x (prime_gt_0 p)); intro.\n  rewrite H0 in H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros.\n  generalize (prime_plus_prime p n x);intro.\n  case (prime_mult x p);intros.\n  trivial.\n  generalize (prime_div_pos p n x);intro.\n  case (prime_mult x p);intro.\n  trivial.\n  generalize (prime_div_pos p n x);intro.\n  generalize (prime_div_pos p n x);intro.\n  rewrite H2;apply prime_mult; auto.\n  generalize (prime_div_pos p n x);intro.\n  rewrite H2;apply prime_mult; auto.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold modulo.\n  apply prime_prime.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.\n  apply prime_dec.Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H.\n  elim H0;intros.\n  elim H1;intros.\n  apply H2.\n  elim H1;intros.\n  apply H1.\n  elim H2;intros.\n  apply H2.\n  elim H2;intros.\n  apply H1.\n  elim H1;intros.\n  apply H2.\n  elim H1;intros.\n  apply H1.\n  elim H2;intros.\n  apply H1.\n  elim H2;intros.\n  apply H2.\n  elim H2;intros.\n  apply H1.\n  elim H2;intros.\n  apply H1.\n  elim H1;intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H2; intros.\n  apply H3.\n  elim H1; intros.\n  apply H3.\n  elim H2; intros.\n  apply H3.\n  elim H3; intros.\n  apply H3.\n  elim H3; intros.\n  apply H3.\n  elim H3; intros.\n  apply H3.\n  elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 3668,
                "proof_end_offset": 4798,
                "proof": "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\ninduction q;simpl;intros.\napply one_min_div.\nrewrite power_plus_lemma1 in H0.\nassert (divides x (power p q)).\napply IHq;trivial.\nelim H0;intros;exists ((power p n)*x0).\nrewrite H2;ring.\nelim H2;intros.\nrewrite H3 in H0.\nrewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\nelim H0;intros.\nassert ((power p (q*n))<>0).\nintro.\ngeneralize (power_zero (q*n) p H5).\nintro.\napply not_prime_zero.\nrewrite H6 in H;trivial.\nrewrite <- mult_assoc in H4.\ngeneralize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\nintro.\nassert (exists n':nat,n=(S n')).\ninversion H1;[exists 0 | exists m];trivial.\nelim H7;intro n';intro.\nrewrite H8 in H6;simpl in H6.\nassert (divides x0 p).\ncase (prime_mult p x0 (power x0 n'));trivial.\nrewrite H6.\nexists ((power p n')*x1);ring.\nintro.\napply prime_power with n';trivial.\nelim H9;intros.\nrewrite H10 in H3.\nrewrite H3.\nexists x2;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\n  intros; case (le_gt_dec n p);intro.\n  case (prime_mult p x (prime_plus p q));intro.\n  right;apply prime_mult;apply lt_le_weak; trivial.\n  apply H0; trivial.\n  apply H1; trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime.\n  intros.\n  generalize (gcd_is_gcd (gcd p n) (div_eucl (div_eucl (div_eucl (div_eucl (div_eucl (div_eucl (div_eucl (div_eucl a p) p) p) p) q) x) x);\n    unfold modulo in |- *; intros.\n  rewrite <- H1.\n  generalize (div_eucl (div_eucl (div_eucl (div_eucl (div_eucl a p) p) p) (div_eucl (div_eucl (div_eucl a p) p) p) x);\n    unfold modulo in |- *; intros.\n  rewrite <- H1.\n  apply mod_div_eucl.\n  apply mod_div_eucl.\n  case (div_eucl (div_eucl (div_eucl a p) p) p); intros.\n  apply div_div_eucl.\n  apply mod_div_eucl.\n  apply mod_div_eucl.\n  case (div_eucl (div_eucl (div_eucl a p) p); intros.\n  apply mod_div_eucl.\n  apply mod_div_eucl; auto.\n  apply mod_div_eucl.\n Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_gcd a p q H H0).\n  destruct (le_or_lt (gcd a p) q H0);trivial.\n  destruct H1;split;trivial.\n  elim H1;apply H1.\n  elim H2;apply H1.\n  elim H2;apply H1.\n  elim H2;apply H3.\n  elim H2;apply H3.\n  elim H3;apply H3.\n  elim H3;apply H1.\n  elim H3;apply H4.\n  elim H4;apply H4.\n  elim H1;apply H3.\n  elim H4;apply H2.\n  elim H2;apply H1.\n  elim H3;apply H4.\n  elim H3; apply H4.\n  elim H3; apply H4.\n  elim H4; apply H2.\n  elim H3; apply H4.\n  elim H3; apply H4.\n  apply H3.\n  elim H4; apply H4.\n  apply H3.\n  elim H4; apply H4.\n  elim H4; apply H4.\n  elim H4; apply H4.\n  elimQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H8;intros.\n  elim H8; intros.\n  elim H8;intros.\n  elim H8; intros.\n  elim H10; intros.\n  elim H12; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H11; intros.\n  elim H12; intros.\n  elim H11; intros.\n  elim H11; intros.\n  elim H12; intros.\n  elim H12; intros.\n  elim H12Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\n  intros; case (prime_mult p x (power p n) H0);trivial.\n  intros.\n  elim H1;apply H2;trivial.\n  elim H2;apply H1;trivial.\n  elim H2;apply H1;trivial.\n  elim H2;apply H1;trivial.\n  elim H2;apply H2;trivial.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_gt_0 p);intro.\n  case (prime_mult p x (power p n) (prime_mult p (prime_mult p q) x));intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elimQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  unfold prime.\n  intros.\n  case (prime_mult p p q);intros.\n  elim H1;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H5;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H6;intros.\n  elim H6;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H7;intros.\n  elim H8;intros.\n  elim H6;intros.\n  elim H6; intros.\n  elim H7;intros.\n  elim H7;introsQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_gcd (gcd a p) q H H0);intro.\n  case (prime_mult p q (prime_mult a p) q H0);intro.\n  rewrite H1; rewrite H2.\n  rewrite H2.\n  rewrite H3.\n  rewrite H1.\n  rewrite H2.\n  rewrite H2.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H4.\n  rewrite H2.\n  rewrite H3.\n  rewrite H1.\n  rewrite H3.\n  rewrite H2.\n  rewrite H3.\n  rewrite H3.\n  rewrite H4.\n  rewrite H2.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H4.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite HQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_is_gcd p n H);intro.\n  case (prime_mult p (div2 x n) H0);trivial.\n  intros.\n  apply H1.\n  elim H1;apply H0;trivial.\n  apply H1;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\n",
                "context_tokens": 719,
                "proof_start_offset": 4831,
                "proof_end_offset": 5126,
                "proof": "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\nintros;intro.\nelim H;intro p;intro.\nelim H1;intros.\nelim H3;intros.\nunfold is_prime in H0.\nelim H0;intros.\nunfold is_prime in H4.\nelim H4;intros.\ncase (H7 p H5);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a Ha.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  rewrite H2 in H1.\n  rewrite <- H2 in H1.\n  elim (le_or_lt (gcd a p) p H1); auto with arith.\n  intro.\n  rewrite H2 in H1; elim (le_or_lt p p H1); auto with arith.\n  rewrite H2 in H1; simpl in H1.\n  rewrite H1 in H1.\n  rewrite <- H1 in H1; rewrite <- H1 in H1; rewrite <- H1 in H1; auto with arith.\n  rewrite <- H1 in H1; rewrite <- H1 in H1; auto with arith.\n  rewrite <- H1 in H1; rewrite <- H1 in H1; auto with arith.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a H.\n  elim H.\n  apply H.\n  apply le_lt_trans with (Zabs_nat a); trivial.\n  apply H.\n  apply le_lt_trans with (Zabs_nat a); trivial.\n  apply H.\n  apply le_lt_trans with (Zabs_nat a); trivial.\n  apply H.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a p H0; elim H0; intro.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H10; intros.\n  elim H11; intros.\n  elim H10; intros.\n  elim H11; intros.\n  elim H12; intros.\n  elim H13; intros.\n  elim H12; intros.\n  elim H13; intros.\n  elim H15; intros.\n  elim H15; intros.\n  elim H15; intros.\n  elim H14; intros.\n  elim H15; intros.\n  elim H14; intros.\n  elim H15; intros.\n  elimQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n intros a Ha.\n destruct (is_prime a) as (p,H).\n exists p.\n split.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_prime.\n apply prime_primeQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros a p H.\n  elim (prime_mult_0_strong a p H); intro.\n  elim (prime_mult_0_strong a p H); intro.\n  elim (prime_mult_0_strong a p H); intro.\n  elim (prime_mult_0_strong a p H); intro.\n  elim (prime_mult_0_strong a p H); intro.\n  rewrite H in H1; inversion H1.\n  rewrite H2 in H1; inversion H1.\n  rewrite H2 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H2 in H1; inversion H1.\n  rewrite H2 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H2 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H2 in H1; inversion H1.\n  rewrite H3 in H1; inversion H1.\n  rewrite H1 in H1; inversion H1.\n  rewrite H2 in H1; inversion H1.\n  rewrite HQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a.\n  destruct (dec_prime a) as [p|p].\n  destruct (dec_prime a) as [p|p].\n  destruct (dec_prime a p) as [p|p].\n  left.\n  exists p.\n  right.\n  destruct H.\n  rewrite H0.\n  destruct H.\n  simpl.\n  right.\n  elim H0;intros.\n  elim H1;intros.\n  elim H2;intros.\n  elim H2;intros.\n  rewrite H2 in H3;rewrite H3 in H3; discriminate.\n  right.\n  elim H3;intros.\n  elim H3;intros.\n  elim H3;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H4;intros.\n  elim H5;intros.\n  elim H5;intros.\n  elim H6;intros.\n  rewrite H5 in H3; rewrite H3 in H3; discriminate.\n  right.\n  elim H4; intros.\n  elim H6;intros.\n  elim H6; intros.\n  rewrite H7 in H3; rewrite H3 in H3; discriminate.\n  right.\n  elim H5;Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  elim H.\n  intros.\n  split with a.\n  apply (is_prime_prime a); auto with zarith.\n  apply (is_prime_prime a); auto with zarith.\n  apply (is_prime_prime a); auto with zarith.\n  apply (is_prime_prime a); auto with zarith.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a H H1.\n  generalize (gcd_is_prime a p H1).\n  pattern (exists p; trivial.\n  apply lt_wf with (1 := H1).\n  red in H1; elim H1; intros.\n  apply H2;trivial.\n  elim H1; intros.\n  apply H2;trivial.\n  apply H2;trivial.\n  apply H2;trivial.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a H H1; elim H1; intros.\n  generalize (gcd_is_gcd a p H1);intro.\n  elim H1;intros.\n  elim H1;intros.\n  elim H1;intros.\n  apply H2;apply H1; apply H2; apply H3; apply H1; split; assumption.\n  apply H1; apply H2; apply H2; split; assumption.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros a Ha.\n  case (prime_mult a a Ha);intro.\n  generalize (gcd_intro a p Ha);intro.\n  case (prime_mult a p (prime_mult a p));intro.\n  generalize (gcd_intro a p Ha);intro.\n  case (prime_mult a p);intro.\n  apply prime_mult.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\n  apply prime_mult; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\n",
                "context_tokens": 713,
                "proof_start_offset": 5187,
                "proof_end_offset": 5475,
                "proof": "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\nProof.\nintros.\nsplit;try tauto.\nintro d';intro.\nassert (is_gcd d' d' p).\nunfold is_gcd;unfold is_cd.\nsplit;[split;[apply divides_refl | tauto] | tauto].\neapply H0;apply H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; elim H;intro p;intro.\n  elim H1;intro p;intros.\n  unfold is_prime in H0.\n  elim H1;intro p;elim p.\n  unfold is_prime in H0.\n  elim H1;intro.\n  unfold is_prime in H1.\n  elim H1;intro.\n  unfold is_prime in H1.\n  elim H1;intro p; elim p.\n  unfold is_prime in H1.\n  elim H1;intro p; elim p.\n  unfold is_prime in H1.\n  elim H1;intro.\n  unfold is_prime in H1.\n  elim H1;intro p; elim p.\n  unfold is_prime in H1.\n  elim H1;intro.\n  unfold is_prime in H1.\n  elim H1;intro p; elim p.\n  unfold is_prime in H1.\n  unfold is_prime in H1.\n  elim H1;intro p; elim p.\n  unfold is_prime in H1.\n  unfold is_prime in H1.\n  elim H1; intro p; elim p.\n  unfold is_prime in H1.\n  unfold is_Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  elim H;intro p.\n  unfold is_prime in H0.\n  elim H0;intro p;unfold is_prime in H0.\n  elim H0;intro p0.\n  rewrite H1 in p0; elim p0;intro.\n  rewrite H1 in p0; elim p0;intro.\n  rewrite H2 in p0; elim p0;intro.\n  rewrite H2 in p0; elim p0;intro.\n  rewrite H2 in p0; elim p0;intro.\n  rewrite H2 in p0; elim p0;intro.\n  rewrite H3 in p0; elim p0;intro.\n  rewrite H3 in p0; elim p0;intro.\n  rewrite H4 in p0; elim p0;intro.\n  rewrite H3 in p0; elim p0;intro.\n  rewrite H4 in p0; elim p0;intro.\n  rewrite H4 in p0; elim p0;intro.\n  rewrite H3 in p0; elim p0;intro.\n  rewrite H3 in p0; elim p0;intro.\n  rewrite H2 in p0; elim p0;intro.\n  rewriteQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; apply gcd_prime; auto.\n  elim H;intro p;intro.\n  unfold is_prime in H.\n  generalize H; clear H; rewrite <- H; intro.\n  elim H;intros.\n  unfold gcd in H0.\n  generalize H; rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite H2.\n  rewrite <- H3.\n  rewrite H3.\n  rewrite <- H3.\n  rewrite <- H1.\n  rewrite <- H3.\n  rewrite H3.\n  rewrite <- H3.\n  rewrite H1.\n  rewrite H3.\n  rewrite H1.\n  rewrite H3.\n  rewrite <- H4.\n  rewrite H4.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite H4.\n  rewrite <- H3.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite <- H1.\n  rewrite <- H4.\n  rewrite <- H4.\n  rewrite H4.Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  elim H;intro p;intro.\n  unfold is_prime in H.\n  elim H;intro p;unfold is_prime in H.\n  intros.\n  unfold gcd in H0.\n  elim H0;intro.\n  elim H1;intro.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  elim H1;intro.\n  elim H1;intro.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  elim H1;intro.\n  unfold gcd in H1.\n  elimQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\nProof.\n  intros.\n  elim H;intro p;unfold is_prime in H.\n  elim H;intro.\n  unfold is_prime in H.\n  elim H;intro.\n  unfold is_prime in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd in H.\n  unfold gcd inQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; elim H;intro p.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold gcd in H.\n  elim H;intros.\n  elim H0;intros.\n  elim H1;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold gcd in H0.\n  elim H0;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  elim H1;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  elim H1;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  elim H1;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  unfold gcd in H1.\n  elim H1;intros.\n  unfold gcd in H1.\n  elim H1Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;unfold gcd in |- *; unfold is_prime in |- *.\n  unfold is_prime in |- *; unfold prime in |- *.\n  unfold is_prime in |- *; unfold prime in |- *; unfold is_prime in |- *.\n  unfold is_prime in |- *; unfold is_prime in |- *.\n  unfold is_prime in H; unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H; unfold is_prime in H.\n  unfold prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold prime in H.\n  unfold is_prime in H.\n  unfold is_prime in H.\n  unfold prime in H.\n  unfold is_prime in H.\n  unfold prime in H.\n  unfold prime in H.\n  unfold prime in H.\n  unfold primeQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\nProof.\n intros; elim (gcd_prime p); intros.\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\n apply (gcd_intro p).\nQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; elim H;intro p;elim p.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  rewrite H0 in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim H2;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in HQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;split;unfold is_prime; simpl;unfold is_prime; simpl in |- *;\n    auto with zarith.\n  intros; apply H; auto.\n  elim H2; intro.\n  unfold is_prime in H4.\n  elim H4; intro.\n  unfold is_prime in H4.\n  elim H4; intros.\n  elim H4; intros.\n  unfold is_prime in H4.\n  elim H4; intros.\n  split.\n  rewrite H5.\n  rewrite H6.\n  rewrite H7.\n  rewrite H7.\n  rewrite H7.\n  rewrite H7.\n  rewrite H7.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H7.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H9.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H9.\n  rewrite H9.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewrite H8.\n  rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 5536,
                "proof_end_offset": 5890,
                "proof": "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\nsplit;intros.\nelim H;intros.\nsplit;try tauto.\nintros.\ncase (eq_nat_dec d 1);intro;try tauto.\ncase (eq_nat_dec d p);intro;try tauto.\nelim (H1 d n n0 H2).\nelim H;intros.\nsplit;try tauto.\nintros;intro.\nelim (H1 a H4);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;split;auto.\n  generalize (prime_correct p);intro;split;auto.\n  intros;split;auto.\n  apply H2;apply H1.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_prime.\n  apply prime_Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros.\n  unfold is_prime in |- *.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H0.\n  elim H;intros.\n  unfold prime in H0.\n  elim H;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold prime in H0.\n  elim H0;intros.\n  unfold prime in H0.\n  elim H0;intros.\n  unfold prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros; destruct (p<>1); [left|right; trivial].\n  case (prime_mult a p); auto.\n  apply H; apply H.\n  apply H.\n  apply H0; apply H1.\n  apply H1; apply H1; apply H1.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros.\n  elim H;intro.\n  unfold is_prime;unfold is_prime;unfold is_prime; unfold is_prime; unfold is_prime;\n   unfold is_prime; unfold is_prime; simpl in |- *; intros.\n  unfold is_prime; unfold is_prime; unfold is_prime;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H; unfold is_prime; simpl in H;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H; unfold is_prime;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H; unfold is_prime;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H; unfold is_prime;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H; unfold is_prime;\n   unfold is_prime; simpl in H; unfold is_prime; simpl in H; unfold is_primeQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H0;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  elim H0;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in HQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n intros;\n generalize (is_prime (is_prime p));\n clear H;\n pattern p at 2; rewrite p; clear p;\n simpl; intros.\n elim H0;intro.\n apply H;apply H1.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n intros p; induction p.\n unfold is_prime; unfold is_prime; unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H0; auto.\n unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H1; auto.\n unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H1; auto.\n unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H1; auto.\n unfold is_prime; unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H0; auto.\n unfold is_prime; unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H1; auto.\n unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H1; auto.\n unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply H1; auto.\n unfold is_prime; unfold is_prime; unfold is_prime; simpl in |- *; \n intros.\n apply HQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n intros.\n generalize (Zabs_eq_dec p); intro.\n elim H0;intro p;intro.\n elim H;intro.\n absurd (p=0); auto.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros.\n  elim H;intro p;unfold is_prime in |- *; intros.\n  elim H0;intros.\n  unfold is_prime in H.\n  elim H1;intros.\n  unfold is_prime in H.\n  unfold prime in H.\n  elim H;intros.\n  unfold prime in H.\n  unfold lt in H.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H;intros.\n  unfold lt in H.\n  elim H; intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\n",
                "context_tokens": 734,
                "proof_start_offset": 5951,
                "proof_end_offset": 6368,
                "proof": "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\nintro.\ncase (divides_nat n);intro.\nelim s;intros.\nright;intro.\nunfold is_prime in H.\nelim H;intros.\nelim (H1 x);try tauto.\ncase (eq_nat_dec n 1);intro.\nright;unfold is_prime;tauto.\nleft;unfold is_prime.\nsplit;trivial.\nintros.\ncase (eq_nat_dec d 1);try tauto.\ncase (eq_nat_dec d n);try tauto;intros.\nelim (n0 d n3 n2 H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro; destruct n; destruct n; simpl in |- *; auto.\n  unfold not in |- *; intro.\n  elim H; intros.\n  unfold not in |- *; intro.\n  elim H; intros.\n  unfold not in |- *; intro.\n  elim H; intros.\n  unfold not in |- *; intro.\n  elim H0; intros.\n  unfold not in |- *; intro.\n  elim H0; intros.\n  unfold not in |- *; intro.\n  elim H0; intros.\n  unfold not in |- *; intro.\n  elim H0; intros.\n  unfold not in |- *; intro.\n  elim H1; intros.\n  unfold not in |- *; intro.\n  elim H0; intros.\n  unfold not in |- *; intro.\n  elim H1; intros.\n  unfold not in |- *; intro.\n  elim H1; intros.\n  unfold not in |- *; intro.\n  elim H1; intros.\n  unfold not in |- *; intro.\n  elim H0; intros.\n  unfold not in |- *; intro.\n  elim H1; intros.\n  unfold not in |- *; intro.\n  elim H1; intros.\n  unfold not in |- *; intro.\n  elim H1; intros.\n  unfold not inQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  intros.\n  elim H;intro.\n  elim H;intro.\n  left.\n  split;try tauto.\n  intros.\n  right.\n  elim H;intro.\n  left.\n  elim H1;intro.\n  right.\n  elim H1;intro.\n  left.\n  left.\n  elim H1;intro.\n  right.\n  elim H1;intro.\n  right.\n  elim H2;intro.\n  right.\n  elim H2;intro.\n  left.\n  elim H2;intro.\n  left.\n  elim H3;intro.\n  right.\n  elim H2;intro.\n  right.\n  elim H3;intro.\n  right.\n  elim H3;intro.\n  right.\n  elim H4;intro.\n  right.\n  elim H4;intro.\n  right.\n  elim H4;intro.\n  right.\n  elim H3;intro.\n  right.\n  elim H4;intro.\n  left.\n  elim H4;intro.\n  left.\n  elim H4;intro.\n  left.\n  elim H4;intro.\n  right.\n  elim H4;intro.\n  left.\n  elim H4;intro.\n  left.\n Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\nintros;intro.\nunfold is_prime in H.\nelim H;intros.\nunfold is_prime in H.\nelim H;intros.\ngeneralize (nat_dec n 0);intro.\nelim (H0 n H0);intros.\nelim H1;intros.\nelim (H0 n H2);intros.\nelim (H1 n H2);intros.\napply H1;apply H2;apply H3;apply H4;apply H1; assumption.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  intros.\n  elim H;intros.\n  elim H;intros.\n  elim (H n0 H1);intros.\n  elim (H n0 H2);intros.\n  elim H1;intros.\n  elim (H n1 H2);intros.\n  apply H1;apply H2.\n  elim H2;intros.\n  elim H1;intros.\n  split;try tauto.\n  elim (H n1 H2);intros.\n  elim H1;intros.\n  elim H1;intros.\n  split;try tauto.\n  apply H1;apply H2;apply H2;apply H3;apply H3;apply H3;apply H3;apply H3;apply H4;apply H4;apply H4;apply H5;apply H3; apply H4; apply H4; apply H4;\n    apply H4; apply H5; apply H4; apply H3; apply H4; apply H5;\n    apply H3; apply H4; apply H5; apply H4; apply H4; apply H5;\n    apply H4; apply H4; apply H4; apply H4; apply H4; apply HQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  split;intros.\n  elim H;intros.\n  split.\n  apply H;apply H;apply H1.\n  apply H1;apply H2.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  elim H;intro.\n  exists 1%nat.\n  split;try tauto.\n  elim (H n0);intro.\n  elim H0;intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n0);intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n0);intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n0);intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n0);intro.\n  exists 1%nat;split;try tauto.\n  elim (H n0);intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n1);intro.\n  exists 1%nat;split;try tauto.\n  elim (H n0);intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n1);intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n1);intro.\n  exists 1%nat;split;try tauto.\n  elim (H0 n1);intro.\n  exists 1%nat;split;try tauto.Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\nintro n; elim n;intros.\nexists 0;trivial.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  intros; apply prime_dec; tauto.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  intros.\n  elim H;intros.\n  elim H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\n  apply H;intro.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro n.\n  elim H;intro.\n  elim H;intros.\n  unfold is_prime;intro.\n  elim H;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n  unfold is_prime;intro.\n  elim H1;intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ".\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\n",
                "context_tokens": 711,
                "proof_start_offset": 6458,
                "proof_end_offset": 7237,
                "proof": "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\nintro.\napply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\ncase (eq_nat_dec n0 1);try tauto;intro.\ncase (eq_nat_dec n0 0);intro.\nleft;exists 2.\nsplit;[apply is_prime_2 | rewrite e;apply zero_max_div].\ncase (divides_nat n0);intro.\nelim s;intro d;intro.\nelim p;intros.\nelim H2;intros.\nassert (d<n0).\ngeneralize (divides_le n0 d n2 H4);omega.\ncase (prime_dec d);intro.\nleft;exists d;tauto.\nelim (H d H5 n3);try tauto.\nintro.\nelim a;intro q;intro.\nleft;exists q.\nsplit;try tauto.\napply divides_trans with d;try tauto.\nelim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intro.\n  case (dec_prime p).\n  left;auto.\n  right;intro.\n  right;intro.\n  left;intro.\n  right;intro.\n  elim (dec_prime p);intro.\n  left;intro.\n  right;intro.\n  elim (H1 n0 H2).\n  right;intro.\n  elim (H2 n0 H4).\n  intro.\n  right;intro.\n  elim (H2 n0 H4).\n  right;intro.\n  elim (H2 n0 H4).\n  left;intro.\n  elim (H2 n1 H4).\n  right;intro.\n  elim (H2 n0 H4).\n  right;intro.\n  elim (H1 n1 H4).\n  right;intro.\n  elim (H2 n1 H4).\n  right;intro.\n  elim (H3 n1 H4).\n  left;intro.\n  elim (H2 n2 H4).\n  right;intro.\n  elim (H3 n2 H4).\n  right;intro.\n  elim (H3 n2 H4).\n  right;intro.\n  elim (H4 n1 H4).\n  right;introQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intros.\n  elim H;intro.\n  unfold is_prime in H.\n  elim H;intro.\n  unfold is_prime in H.\n  elim H;intro.\n  elim (H0 p H0).\n  auto.\n  auto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intro n.\n  case (prime_dec n).\n  intro.\n  left.\n  elim (prime_dec n p).\n  intro.\n  right;intro.\n  elim (prime_dec n p).\n  intro.\n  left.\n  apply prime_prime_prime.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply prime_prime_intro.\n  apply primeQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intro.\n  case (prime_dec n 0);intro.\n  left;intro.\n  elim (prime_dec n (is_prime n));intro.\n  left;intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  right;intro.\n  left;intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  left;intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  right;intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  right;intro.\n  elim (prime_dec n (is_prime n));intro.\n  left.\n  elim (prime_dec n (is_prime n));intro.\n  right;intro.\n  elim (prime_dec n (is_primeQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intros.\n  generalize (n_O_or_prime n); intro.\n  elim (prime_not_prime n); intro.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  apply prime_prime_prime_sym; assumption.\n  intro.\n  elim (prime_not_prime n); intro.\n  right; intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (prime_not_prime n); intro.\n  right; intro.\n  unfold is_prime in H.\n  elim H;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim (prime_not_prime n); intro.\n  right; intro.\n  unfold is_prime in H0.\n  elim H0;intros.\n  right;intro.\n  unfold is_prime in HQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intro.\n  elim H;intros.\n  case (dec_prime_dec n 0);intro.\n  left; intro.\n  right; intro.\n  elim (H1 n0 H3);intros.\n  right; intro.\n  left; intro.\n  elim (H2 n0 H3);intros.\n  right; intro.\n  elim (H3 n0 H4);intros.\n  right; intro.\n  elim (H1 n0 H4).\n  left; intro.\n  elim (H1 n0 H4);intros.\n  right; intro.\n  elim (H4 n0 H5);intros.\n  right; intro.\n  elim (H4 n0 H5);intros.\n  right; intro.\n  elim (H4 n0 H5);intros.\n  right; intro.\n  elim (H5 n H5).\n  left; intro.\n  elim (H4 n0 H5);intros.\n  right; intro.\n  elim (H1 n0 H5);intros.\n  right; intro.\n  elim (H5 n0 H5);intros.\n  right; intro.\n  elim (H5 n0 H5);intros.\n  right; intro.Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intro.\n  case (prime_dec n 1);intro.\n  apply prime_prime_not_prime_plus_prime; trivial.\n  elim (H1 n);intros.\n  elim (prime_dec n 1);intro.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  split;try tauto.\n  elim (prime_dec n 1);intro.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (prime_dec n 1);intro.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold prime in H.\n  elim H;intros.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold prime in H.\n  elim H;intros.\n  unfold prime in H0.\n  elim H0;intros.\n  unfold prime in HQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intros.\n  case (prime_dec n).\n  right;intro.\n  elim (prime_dec n p);intros.\n  right;intro.\n  left;intro.\n  elim (prime_dec n p);intros.\n  left;intro.\n  elim (prime_dec n p);intros.\n  right;intro.\n  elim (prime_dec n p);intro.\n  right;intro.\n  elim (prime_dec n p);intro.\n  right;intro.\n  elim (prime_dec n p);intro.\n  right;intro.\n  elim (prime_dec n p);intro.\n  left;intro.\n  elim (prime_dec n p);intro.\n  right;intro.\n  elim (prime_dec n p);intro.\n  right;intro.\n  elim (prime_dec n p);intro.\n  right;intro.\n  elim (prime_dec n p);intro.\n  left;intro.\n  elim (prime_dec n p);intro.\n  left;intro.\n  elim (prime_dec n p);intro.\n  right;intro.\n  elim (prime_dec n p);intro.\n  left;intro.\n  elim (prime_dec n pQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intro.\n  case (prime_not_prime n);intro.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  right.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim (H0 p);intros.\n  right;intro.\n  unfold is_prime in H0.\n  elim H0;intros.\n  elim (H0 p);intros.\n  right;intro.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H1.\n  elim H1;intros.\n  unfold is_prime in H.\n  elim H1;intros.\n  right.\n  unfold is_prime in H1.\n  elim H1;intros.\n  right;intro.\n  unfold is_prime in H0.\n  elim H1;intros.\n  right.\n  unfold is_prime in H0.\n  elim H1;intros.\n  split;try tauto.\n  elim (prime_not_prime nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intro.\n  case (prime_dec n);intro.\n  left.\n  unfold is_prime; tauto.\n  right.\n  unfold is_prime; tauto.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime; tauto.\n  right;intro.\n  elim H;intros.\n  unfold is_prime; tauto.\n  right;intro.\n  elim H;intros.\n  elim (H1 x);intros.\n  left.\n  elim H3;intros.\n  elim H3;intros.\n  right.\n  apply H2.\n  split;try tauto.\n  right;intro.\n  elim H3;intros.\n  right.\n  apply H3.\n  split;try tauto.\n  right;intro.\n  elim H3;intros.\n  right;intro.\n  apply H3.\n  apply H4.\n  split;try tauto.\n  right;intro.\n  elim H3;intros.\n  right;intro.\n  elim H4;intros.\n  right;intro.\n  apply H4.\n  split;try tauto.\n  right;intro.\n  elim H4;intros.\n  left.\n  elim H4;intros.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\nLemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intro.\n  apply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\n  case (eq_nat_dec n0 1);try tauto;intro.\n  case (eq_nat_dec n0 0);intro.\n  left;exists 2.\n  split;[apply is_prime_2 | rewrite e;apply zero_max_div].\n  case (divides_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\n",
                "context_tokens": 710,
                "proof_start_offset": 7333,
                "proof_end_offset": 8614,
                "proof": "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\nintros n p H.\napply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\ncase (divides_dec n0 p);intro.\ngeneralize (quo_is_quo n0 p d);intro.\nelim (H0 (quo n0 p d)).\nintro m;intros.\nexists (m+1).\nelim p0;intros.\nelim H3;intros.\nrewrite H5 in H2;rewrite mult_assoc in H2.\nrewrite plus_comm.\nsplit;simpl.\nexists x;trivial.\nrewrite plus_comm;simpl.\nrewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\nelim H6;intros.\nrewrite H2 in H7.\nassert (p<>0).\nintro.\nrewrite H8 in H.\napply not_prime_zero;trivial.\nassert ((power p m)*x=(power p m)*p*x0).\napply mult_lemma6 with p;trivial.\nrewrite mult_assoc;rewrite H7;ring.\nrewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\napply H4.\nrewrite plus_comm;simpl.\nexists x0;trivial.\nrewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\nintro.\napply H1;rewrite H2;rewrite H3;trivial.\nelim H.\nintros.\ndestruct p;omega.\nintro;apply H1.\nrewrite H2;rewrite H3;ring.\nexists 0;simpl.\nsplit.\napply one_min_div.\nrewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intro.\n  case (le_wf_rec n (fun n:nat => (is_prime n (p+1)))=(m+1)).\n  intro.\n  elim (le_wf_ind n (fun n:nat => (is_prime n (p+1)))\n     (is_prime n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_prime n (p+1)))\n     (P n (fun n:nat => (is_Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intro.\n  apply (lt_wf_rec n (fun n:nat => (is_prime n)->(is_prime n))).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n))).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n)).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n))).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n))).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n))).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n))).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n))).\n  apply (lt_wf_ind n (fun n:nat => (is_prime n)->P (is_prime n))).\n  apply (Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intro.\n  destruct (exists_div_eucl n p) as (q,r).\n  exists (r,r).\n  split; [apply le_trans with (r := r); [apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_trans with r | assumption ].\n  apply le_trans with (r := r); [ apply le_transQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros.\n  case (le_gt_dec n 0);intro.\n  right;intro.\n  apply (le_wf_ind n (fun n:nat => n=0) H).\n  apply (lt_wf_ind (fun n:nat => n=0) H).\n  destruct (le_gt_dec n 0);intro.\n  left;exists (S m);auto.\n  right;intro.\n  apply (le_wf_ind n (fun n:nat => n=0) H).\n  apply (le_wf_ind n (fun n:nat => n=0) H).\n  destruct (le_gt_dec n 0);intro.\n  right;intro.\n  apply (le_wf_ind n (fun n:nat => n=0) H).\n  destruct (le_gt_dec n 0);intro.\n  right;intro.\n  apply (le_wf_ind n (fun n:nat => n=0) H).\n  destruct (le_gt_dec n 0);intro.\n  right;intro.\n  apply (le_wf_ind n (fun n:nat => n=0) H).\n  apply (leQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros.\n  generalize (is_prime_or_prime p).\n  generalize (is_prime_not_prime p).\n  generalize (is_prime_gt_dec n p).\n  generalize (is_prime_gt_dec n p); tauto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros.\n  case (le_wf_rec n m);intros.\n  left.\n  intro.\n  apply (le_wf_rec n (fun m:nat => (m+n)) (S m)).\n  apply (le_wf_rec n (fun m:nat => (m+n)) (S m)); auto with arith.\n  left; elim (le_wf_rec n m);intros.\n  elim (H1 (S m)).\n  left; assumption.\n  right; right; reflexivity.\n  left; left; assumption.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intro.\n  elim (is_prime_not_prime_cor n (fun n:nat => is_prime p)->((m+1)/(n+1)/(n+1)*m).\n  intro.\n  elim (is_prime_not_prime_cor n (fun m:nat => is_prime p)->((m+1)/(m+1)/(m+2)/(m+2)/(m+2))).\n  intro.\n  elim (not_prime_not_prime_cor n (fun m:nat => is_prime p)->((m+1)/(m+2)/(m+2)/(m+2)/(m+2))).\n  intro.\n  elim H;intros.\n  elim (H1 x);intros.\n  elim H2;intros.\n  assert (d=0).\n  generalize (div_pos_lt n (S m) (S n) H2);omega.\n  rewrite <- H3;apply mult_le_compat_l;auto.\n  rewrite <- H4;apply mult_le_compat_l;auto.\n  rewrite <- H4;apply mult_le_compat_l;auto.\nQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n intros.\n destruct (le_gt_dec n 0) as [H|H].\n  left; exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  destruct (le_gt_dec n 0) as [H|H].\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  destruct (le_gt_dec n 0) as [H'|H'].\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n  split;try tauto.\n  right;exists 0.\n Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (is_prime_not_prime n);intro.\n  left;exists 0%nat.\n  split;try tauto.\n  apply (lt_wf_rec n (fun m n:nat => (pos n)*m=0) (P m));try tauto.\n  right;exists 0%nat.\n  split;try tauto.\n  apply (le_wf_rec n (fun m n:nat => (pos n) <= m) (P n));try tauto.\n  right;exists 0%nat.\n  split;try tauto.\n  destruct (le_wf_rec n (fun m n:nat => (pos n) <= m) (P n));try tauto.\n  right;exists 0%nat.\n  split;try tauto.\n  apply (lt_wf_rec n (fun m n:nat => (pos n) <= m) (P n));try tauto.\n  right;exists 0%nat.\n  split;try tauto.\n  apply (le_wf_rec n (fun m n:nat => (pos n) <= m) (P n));try tauto.\n  right;exists 0%nat.\n  split;try tauto.\n  apply (leQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n intros.\n destruct (le_gt_dec n 0).\n left; exists 1.\n split;try tauto.\n right;intro.\nelim (le_gt_dec n 0);intro.\nelim (le_gt_dec n (div n m) 1);intro.\nrewrite (H n (div2 n (div2 n m (div2 n m (div2 n m (div2 n m (div2 n m (div2 n m (div2 n m (div2 n m (div2 m (div2 n m (div2 n m))))) in H.\ngeneralize (gcd_div2 n (div2 n m (div2 n m (div2 n m (div2 n m (div2 n m (div2 m (div2 n m (div2 n m (div2 n m (div2 n (div2 n m (div2 n m (div2 n m (div2 m (div2 n m (div2 n m (div2 n m (div2 m (div2 m (div2 n m (div2 n m))))))).\n right; intro.\n elim (le_gt_dec nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\nLemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros n p H.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\n  case (divides_dec n0 p);intro.\n  generalize (quo_is_quo n0 p d);intro.\n  elim (H0 (quo n0 p d)).\n  intro m;intros.\n  exists (m+1).\n  elim p0;intros.\n  elim H3;intros.\n  rewrite H5 in H2;rewrite mult_assoc in H2.\n  rewrite plus_comm.\n  split;simpl.\n  exists x;trivial.\n  rewrite plus_comm;simpl.\n  rewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\n  elim H6;intros.\n  rewrite H2 in H7.\n  assert (p<>0).\n  intro.\n  rewrite H8 in H.\n  apply not_prime_zero;trivial.\n  assert ((power p m)*x=(power p m)*p*x0).\n  apply mult_lemma6 with p;trivial.\n  rewrite mult_assoc;rewrite H7;ring.\n  rewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\n  apply H4.\n  rewrite plus_comm;simpl.\n  exists x0;trivial.\n  rewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\n  intro.\n  apply H1;rewrite H2;rewrite H3;trivial.\n  elim H.\n  intros.\n  destruct p;omega.\n  intro;apply H1.\n  rewrite H2;rewrite H3;ring.\n  exists 0;simpl.\n  split.\n  apply one_min_div.\n  rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.\n\n(** if n>1 then there is a prime number p and two integers m and q with m>0 and q<n such that n=p^m*q and gcd(p,q)=1 *)\n",
                "context_tokens": 686,
                "proof_start_offset": 8736,
                "proof_end_offset": 10293,
                "proof": "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\nintros.\ncase (prime_dec n);intro.\nexists n;exists 1;exists 1;simpl.\nsplit;try tauto.\nsplit;try omega.\nsplit;try ring.\nsplit;try omega.\napply gcd_sym;apply gcd_one.\nelim (not_prime_impl_prime_divides n n0);intro;try tauto.\nelim a;intro p;intro.\nelim p0;intros.\nelim (nat_factor n p H1).\nintro m;intro.\nelim p1;intros.\nexists p;exists m;exists (quo n (power p m) H3).\nsplit;trivial.\nsplit.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nsplit.\napply (quo_is_quo n (power p m) H3).\ngeneralize (gcd_is_gcd p (quo n (power p m) H3));intro.\nassert ((gcd p (quo n (power p m) H3))=1).\ncase (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\napply gcd_sym;trivial.\nintro.\nrewrite H6 in H5;elim H5;intros.\nelim H7;intros.\nelim H4;rewrite plus_comm;simpl.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nelim H10;intros.\nrewrite H12 in H11.\nexists x;rewrite H11;ring.\nrewrite H6 in H5;trivial.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nsplit;trivial.\nrewrite H7;rewrite mult_comm;apply mult_lemma3.\nintro.\napply H;rewrite H7.\nrewrite H8;ring.\nred;apply power_lt.\ndestruct p.\nelim (not_prime_zero H1).\ndestruct p;try omega.\nelim H1;tauto.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p H.\n apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)/\\(m>0=(m+1)}))).\n intros.\n apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_gcd p q)})).\n intros.\n apply H; rewrite <- H0; rewrite <- H0; rewrite <- H0; ring.\n apply (le_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_gcd p q)})).\n intros.\n apply H; rewrite <- H0; rewrite <- H0; rewrite <- H0; ring.\n apply (le_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_gcd p q)})).\n intros.\n apply H; rewrite <- H0; rewrite <- H0; rewrite <- H1; ring.\n apply (le_wf_ind n (fun m:nat => nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p H.\n apply (lt_wf_ind (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}:(is_gcd n q)}): \n forall (n:nat)(m:nat), {q:nat | (is_gcd n m) q} + {q:nat | (is_gcd n m) q}.\n intros n p q H.\n case (le_wf_ind (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_gcd n m)}\n       (forall n:nat, (is_gcd n m) q)}\n       (H: is_gcd n m) (H1: is_gcd n m) (H2:is_gcd n m) (H4:is_gcd n m) (H5:is_gcd n m) (H5:is_gcd n m).\n intros n p q H.\n case (le_wf_ind (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_gcd n m)}\n       (H5:Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)})).\n  intros.\n  destruct (is_prime_dec n m) as [m'|m'].\n  elim (le_wf_ind n m' (fun p:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)})).\n  intros.\n  elim (is_prime_dec m' (P:=P) n m' (fun p:nat => n <> 0 -> {m':nat & {q:nat | (is_prime p)})).\n  intros.\n  elim (is_prime_dec m' (P:=P) n m' (fun p:nat => (is_prime p)) m' (P:=P) n m' (P:=P) n m' (P:=P) n m' (P:=P) n m' (P:=P) n m' (P:=P) n m' (P:=P) n m' (P:=P) n m' (P:=P) nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)/\\(m=q)/\\(n<>m)*q})}).\n  intros n p H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}}).\n  intros.\n  apply H; apply H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}}).\n  intros.\n  apply (H (is_gcd (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}}).\n  intros.\n  apply H; apply H.\n  apply (le_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}}).\n  intros.\n  apply (H (is_gcd (fun n:nat => n <> 0 -> {m:nat & {Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}}).\n  apply (lt_wf_ind n (fun m:nat => {q:nat & {q:nat | (is_prime p)/\\(m>0)/\\(m>0)/\\(m>0)/\\(m>0)=(m>0))))); \n intros.\n  generalize (construct_correct n (fun m:nat => {q:nat | (is_prime p)} {q:nat | (is_prime q)} {q:nat} {q:nat} {q:nat} {q:nat} {q:nat} {q:nat} {r:nat} {r:nat} {q:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:nat} {r:Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\nintros n p H.\ndestruct (Z_div_eucl_correct n p) as [H|H].\n  generalize (Z_div_eucl_correct n p H); intro.\n  elim H;intros.\n  rewrite H1 in H;rewrite <- H; rewrite <- H0; rewrite <- H1; rewrite <- H1; rewrite <- H2; ring.\n  apply lt_le_trans with (m*x); trivial.\n  rewrite <- H1 in H1; rewrite <- H1; rewrite <- H2; rewrite <- H1; ring.\n  apply lt_le_trans with (m*x); trivial.\n  rewrite <- H1 in H1; rewrite <- H1; rewrite <- H1; rewrite <- H2; ring.\n  apply lt_le_trans with (m*x); trivial.\n  rewrite <- H1 in H1; rewrite <- H1; rewrite <- H1; rewrite <- H1; ring.\nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p H.\n generalize (le_gt_cases n p);intro.\n generalize (le_gt_cases n p);intro.\n elim (le_gt_cases n p);intro.\n  apply (H0 (le_trans n p H0) (le_trans n p H0) (le_n_Sn p H0) H).\n  rewrite <- (mult_comm (pred p) (pred p)) at 1.\n  rewrite <- (mult_comm (pred p)) at 1.\n  rewrite <- (mult_comm (pred p)).\n  rewrite <- (mult_comm (pred p)) at 1.\n  rewrite <- (mult_comm (pred p)) at 1.\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewrite (mult_comm (pred p)).\n  rewriteQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_ind n (fun n:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}-> {m:nat & {q:nat | (is_prime p)}-> {m:nat | (is_gcd p q)}}).\n  intros.\n  apply H.\n  destruct q.\n  apply (lt_wf_ind_rec n (fun m:nat => n <> 0 -> {m:nat & {q:nat | (is_prime p)}-> {m:nat & {q:nat | (is_gcd p q)}}).\n  intros.\n  apply (is_gcd_pos n (fun m:nat => {q:nat & {m:nat & {q:nat | (is_gcd p q)}-> {m:nat | (is_gcd p q)}}).\n  intro m; intros.\n  case (prime_dec m); intro.\n  elim (prime_dec n0 p); intro.\n  rewrite H0 in p.\n  apply (lt_wf_rec n (fun m:nat => n <> 0 -> {m:nat & {Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p H.\n apply (lt_wf_rec n (fun n => is_prime_dec n (Z_factor_prime n m p H)).\n intros.\n exists (m+1).\n destruct (is_gcd_prime_dec n m (Z_factor_prime n m p H)).\n destruct (Z_div_prime_dec m m (Z_factor_prime n m p H)).\n rewrite H.\n rewrite H.\n rewrite H.\n rewrite H.\n rewrite H.\n rewrite H0.\n reflexivity.\nQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p H.\n apply (le_wf_rec n (fun n:nat => n <> 0 -> {m:nat & {m:nat | (is_gcd p m)}}).\n apply is_gcd_prime.\n apply is_gcd_prime.\n apply H.\n apply Z_div_pos; auto.\n apply H0.\n apply Z_div_pos; auto.\n apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " omega.\n  apply gcd_sym;apply gcd_one.\n  elim (not_prime_impl_prime_divides n n0);intro;try tauto.\n  elim a;intro p;intro.\n  elim p0;intros.\n  elim (nat_factor n p H1).\n  intro m;intro.\n  elim p1;intros.\n  exists p;exists m;exists (quo n (power p m) H3).\n  split;trivial.\n  split.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  split.\n  apply (quo_is_quo n (power p m) H3).\n  generalize (gcd_is_gcd p (quo n (power p m) H3));intro.\n  assert ((gcd p (quo n (power p m) H3))=1).\n  case (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\n  apply gcd_sym;trivial.\n  intro.\n  rewrite H6 in H5;elim H5;intros.\n  elim H7;intros.\n  elim H4;rewrite plus_comm;simpl.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  elim H10;intros.\n  rewrite H12 in H11.\n  exists x;rewrite H11;ring.\n  rewrite H6 in H5;trivial.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  split;trivial.\n  rewrite H7;rewrite mult_comm;apply mult_lemma3.\n  intro.\n  apply H;rewrite H7.\n  rewrite H8;ring.\n  red;apply power_lt.\n  destruct p.\n  elim (not_prime_zero H1).\n  destruct p;try omega.\n  elim H1;tauto.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  trivial.\nQed.\n\n(** this compute p1^n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\n",
                "context_tokens": 720,
                "proof_start_offset": 10997,
                "proof_end_offset": 12081,
                "proof": "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintro.\ncase (eq_nat_dec n 0);intro.\nright;trivial.\ncase (eq_nat_dec n 1).\nintro;left;exists (nil (A:=nat*nat)).\nsplit;[apply nil_is_wf | simpl;trivial].\ngeneralize n0.\napply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\nelim (nat_factor_prime n1 H0 H1).\nintro p;intro.\nelim p0;intro m;intro.\nelim p1;intro q;intro.\nelim p2;intros.\nelim H3;intros.\nelim H5;intros.\nelim H7;intros.\ncase (eq_nat_dec q 1);intro.\nleft;exists (cons (p,m) nil);simpl;rewrite e in H6.\nsplit;trivial.\napply cons_is_wf;auto;try (apply nil_is_wf).\nunfold rel_prime;simpl;rewrite e in H8;trivial.\nassert (q<>0).\nintro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\nelim (H q H9 H10 n2).\nintro.\nelim a;intro l;intro.\nelim p3;intros.\nleft;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\napply cons_is_wf;auto.\nrewrite <- H12;unfold rel_prime;trivial.\nintro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros; apply factorisation; auto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintros n.\ninduction n as [| n IH].\nsimpl; trivial.\ndestruct l; simpl; trivial.\ndestruct n.\nrewrite IHn; trivial.\ndestruct l; simpl; trivial.\nrewrite IHn; trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n induction n.\n simpl.\n destruct l.\n inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct (IHn (S (S n))) as (q,r).\n simpl in *.\n destruct q;inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct (IHn (S (S n))) as (q,r).\n simpl in *.\n destruct q; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\n destruct n; inversion_clear H.\n simpl.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n induction n; intros; simpl; auto with arith.\n induction l; simpl; auto with arith.\n destruct a; simpl; auto with arith.\n destruct a; simpl; auto with arith.\n destruct a; simpl; auto with arith.\n destruct a; simpl; auto with arith.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintros; induction n; simpl; intros.\n rewrite IHn; trivial.\n rewrite IHn; trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros.\n destruct (is_wf l).\n left.\n destruct (is_wf l).\n left.\n destruct (is_wf l).\n right.\n right.\n destruct (is_wf l).\n left.\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n left.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n right.\n destruct (is_wf l).\n right.\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (is_wf l).\n right.\n destruct (isQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros.\n destruct n.\n simpl in H0.\n destruct (IHlist _ H0).\n destruct (le_lt_dec (length (S n) l) n).\n apply le_n_S; trivial.\n apply lt_le_trans with (S (length (extending (S n) l))); trivial.\n apply le_n_S; trivial.\n apply le_plus_lt; trivial.\n apply le_plus_lt; trivial.\n apply le_trans with (S (length (extending (S n) l))); trivial.\n apply le_plus_lt; trivial.\n apply le_plus_lt; trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n; simpl; intros.\n inversion_clear H.\ninversion_clear H.\ndestruct l; simpl;inversion_clear H.\ninversion_clear H.\ndestruct l; simpl;inversion_clear H.\ninversion_clear H.\ndestruct l; simpl;inversion_clear H.\ndestruct l; simpl;inversion_clear H.\ndestruct l; simpl;inversion_clear H.\napply (is_wf (S (S (S (length l))));simpl;auto with arith.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros; induction l; simpl; auto.\n destruct p; simpl; auto.\n destruct p; simpl; auto.\n destruct p; simpl; auto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintros n; induction l; simpl; intros.\n case (le_gt_dec n 0); intro.\n left. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply is_wf_ind; apply H0.\n right. apply isQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 12199,
                "proof_end_offset": 12539,
                "proof": "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\ninduction l;simpl;try tauto.\nintro.\ncase H;intro.\ndestruct a.\nrewrite <- H0;simpl.\nexists (refactor l);trivial.\ndestruct a.\nelim (IHl H0);intros.\nrewrite H1.\nexists ((power n n0)*x0);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n intros.\n destruct l.\n simpl.\n destruct (le_dec p 0).\n destruct p; simpl; trivial.\n destruct p; simpl; trivial.\n destruct p; simpl; trivial.\n destruct p; simpl; trivial.\n destruct p; simpl; trivial.\n destruct p; simpl; trivial.\n destruct p; simpl; trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  intros.\n  case (le_gt_dec (length x) 0);intro.\n  right;trivial.\n  left;trivial.\n  right;trivial.\n  right;trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n induction l; simpl; auto.\n destruct (le_lt_dec (length x) 0);intro.\n  left;trivial.\n right;trivial.\n right;trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\nintro x.\ndestruct l as [ | a l].\n unfold sub.\n destruct (le_lt_dec a x);\n [rewrite <- plus_n_Sm; rewrite <- plus_n_Sm; rewrite <- plus_n_Sm; rewrite <- plus_n_Sm; rewrite <- plus_n_Sm; rewrite plus_n_Sm; auto ].\n apply plus_le_compat_l; trivial; try (apply plus_le_compat_l; trivial; fail).\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  intros.\n  case_eq (x=0) l.\n  intros; apply H.\n  apply in_map_iff in H; destruct H as (x0 &? &?).\n  subst.\n  simpl.\n  apply in_map_iff in H; destruct H as (x1 &? &?).\n  subst.\n  simpl in *.\n  apply in_map_iff in H; destruct H as (x2 &? &?).\n  subst.\n  simpl in *.\n  apply in_map_iff in H; destruct H as (x3 &? &?).\n  subst.\n  simpl in *.\n  apply in_map_iff in H; destruct H as (x4 &? &?).\n  subst.\n  simpl in *.\n  apply in_map_iff in H; destruct H as (x4 &? &?).\n  subst.\n  simpl in *.\n  apply in_map_iff in H; destruct H as (x5 &? &?).\n  subst.\n  simpl in *.\n  apply in_map_iff in H; destruct H as (x5 &? &?).\n  subst.\n  simpl in *.\n  apply in_map_iff in H; destruct H as (x5 &? &?).\n Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n intros.\n destruct l; simpl; auto.\n destruct (le_lt_dec (length l) 0).\n left; trivial.\n right; trivial.\n right; trivial.\n right; trivial.\n right; trivial.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros.\n  induction l; simpl; auto.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewrite IHn.\n  rewriteQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intros.\n  rewrite (factorizable (fun p => (fst p, snd p))).\n  rewrite (factorizable (fun p => (fst p, snd p))).\n  apply factorizable; auto.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  intros.\n  apply factorisation with (R:= fun x => (list_repeat x (fst x)) (prod (fun x => length (fst x) (snd x))).\n  apply (is_wf_ind (fun x => length (snd x) (snd x))).\n  apply factorisation with (R:= fun x => (list_repeat x (fst x) (snd x))).\n  apply factorisation with (R:= fun x => (list_repeat x (snd x) (snd x))).\n  apply factorisation with (R:= fun x => (list_repeat x (snd x) (snd x))).\n  apply factorisation with (R:=fun x => (list_repeat x (snd x) (snd x)))).\n  apply factorisation with (R:= fun x => (list_repeat x (snd x) (snd x))).\n  apply factorisation with (R:= fun x => (list_repeat x (snd x) (snd x))).\n  apply factorisation with (R:=fun x => (list_repeat x (snd x) (snd x))).\n  apply factorisation with (R:= fun x => (list_repeat x (snd x) (snd x))).\n  apply factorisation withQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  intros.\n  destruct (le_gt_dec x 0).\n  left;trivial.\n  right;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\n",
                "context_tokens": 704,
                "proof_start_offset": 12623,
                "proof_end_offset": 13304,
                "proof": "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\ninduction l;simpl;intros.\nassert (p=1).\napply divides_antisym;trivial.\napply one_min_div.\nrewrite H2 in H;elim H;tauto.\ndestruct a.\ncase (divides_dec (power n n0) p);intro.\ngeneralize (prime_power p n0 n H d);intro.\nassert (n=p).\ninversion H0.\nelim H6.\nintros.\nelim H;intros.\ncase (H11 p H2);try tauto;try omega.\nexists n0;rewrite <- H3;left;trivial.\ninversion H0.\nelim (IHl H H7).\nintros;exists x;tauto.\napply gauss with (power n n0);trivial.\napply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n intros.\n destruct (prime_dec (is_nonneg l) (is_nonneg l)).\n simpl.\n destruct p.\n simpl.\n rewrite H0;simpl;auto.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;try tauto.\n  case (le_gt_dec p 0);intro.\n  rewrite (H p);rewrite H;simpl;auto.\n  destruct a.\n  apply (le_lt_wf_rec p H0 H1).\n  destruct (le_gt_dec p 0);intro.\n  apply (le_lt_trans p 0 H1 H0).\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_lt_trans with (S m); auto.\n  apply le_ltQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  induction l;simpl;intros.\n  destruct a;destruct l.\n  rewrite <- H0;simpl.\n  destruct H0.\n  simpl;rewrite H0;auto.\n  destruct (lt_eq_nat p n0);destruct (le_lt_dec m p); simpl;trivial.\n  rewrite <- H0;simpl;auto.\n  destruct (le_lt_eq_nat p n0); destruct (le_lt_eq_nat p n0); simpl;trivial.\n  rewrite <- H0;simpl;auto.\n  destruct (le_lt_eq_nat p n0); destruct (le_lt_eq_nat p n0); simpl;trivial.\n  rewrite <- H0;simpl;auto.\n  destruct (le_lt_eq_nat p n0); destruct (le_lt_eq_nat p n0); simpl;trivial.\n  rewrite <- H0;simpl;auto.\n  destruct (le_lt_eq_nat p n0); destruct (le_lt_eq_nat p n0); simpl;trivial.\n  rewrite <- H0;simpl;auto.\n  destruct (le_lt_eq_nat p n0); destruct (Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  induction l;simpl;intros.\n  rewrite H;simpl.\n  rewrite IHn;simpl;auto.\n  destruct a.\n  rewrite <- H0;simpl.\n  rewrite IHn;simpl;auto.\n  rewrite IHn;simpl;auto.\n  destruct a.\n  rewrite <- H0;simpl;auto.\n  rewrite IHn;simpl;auto.\n  destruct a.\n  rewrite <- H0;simpl;auto.\n  rewrite IHn;simpl;auto.\n  rewrite IHn;simpl;auto.\n  rewrite IHn;simpl;auto.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  induction l;simpl;intros.\n  destruct p;destruct l.\n  rewrite H;simpl.\n  exists (S m);simpl;auto.\n  destruct p;destruct l.\n  rewrite H;simpl;auto.\n  destruct p;destruct l.\n  rewrite H;simpl;auto.\n  rewrite H;simpl;auto.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  rewrite H.\n  apply (le_wf_rec (fun (p:nat*nat) => n<>0 -> {l : list (nat*nat))(is_ext (S p) -> {l : list (nat*nat))(is_ext (S p) -> {l' : list (nat*nat))(is_ext (S p) -> {l' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*nat))(is_ext (S p) -> {l'' : list (nat*Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  induction l;simpl;intros.\n  destruct a.\n  rewrite <- H.\n  destruct (le_lt_dec n (pos_Rl l (pos_Rl l p)) H0).\n  rewrite H0.\n  simpl.\n  split;trivial.\n  rewrite <- H1;trivial.\n  destruct (le_lt_dec n (pos_Rl l p)) H0).\n  rewrite H1;trivial.\n  generalize (le_lt_eq_dec (pos_Rl l p) (pos_Rl l p)) H0); intro.\n  rewrite H1.\n  simpl.\n  split;trivial.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_n.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_n.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_n.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_n.\n  apply le_S_n.\n  apply leQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\n  intros.\n  destruct (le_gt_dec p 0).\n  rewrite <- H0; rewrite <- H; rewrite <- H; rewrite <- H0; rewrite <- H0; rewrite <- H0;\n  rewrite <- H; rewrite <- H; rewrite <- H0; rewrite <- H0;\n  rewrite <- H0; rewrite <- H1; rewrite <- H0; rewrite <- H1; rewrite <- H1; rewrite <- H1;\n  rewrite <- H0; rewrite <- H0; rewrite <- H0; rewrite <- H1;\n  rewrite <- H0; rewrite <- H0; rewrite <- H1; rewrite <- H1;\n  rewrite <- H; rewrite <- H1; rewrite <- H0;\n  rewrite <- H0; rewrite <- H0; rewrite <- H1; rewrite <- H0;\n  rewrite <- H0; rewrite <- H1; rewrite <- H0; rewrite <- H0;\n  rewrite <- H0; rewrite <- H1; rewrite <- H1; rewrite <- H1;\n  rewrite <- H0; rewrite <- H0; rewrite <- H1; rewrite <- H0;\n  rewrite <- H0; rewrite <- H0; rewrite <- H1; rewrite <- HQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\ninduction l;simpl;intros.\ndestruct l.\nrewrite (prime_plus_mult a (S m) p).\nsimpl;rewrite mult_0_l.\nrewrite (mult_comm (mult_comm (mult_comm m) p)).\nrewrite mult_assoc.\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm m).\nrewrite (mult_comm m).\nrewrite (mult_comm m).\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm m).\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm m).\nrewrite (mult_comm m).\nrewrite (mult_comm (mult_comm m)).\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm (mult_comm m)).\nrewrite (mult_comm (mult_comm m) p).\nrewrite (mult_comm (multQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros;auto.\n  intros.\n  case H;intro.\n  simpl;rewrite H0;rewrite H1;rewrite H2;auto.\n  rewrite H2;rewrite H2;rewrite H2;rewrite H3;rewrite H4;rewrite H1;clear H H H2;auto.\n  rewrite H2;rewrite H2;rewrite H3;rewrite H4;rewrite H4;rewrite H1;clear H H2;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\n",
                "context_tokens": 714,
                "proof_start_offset": 13376,
                "proof_end_offset": 13646,
                "proof": "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;simpl;try tauto.\nintros;destruct a.\ninversion H0.\ncase (in_inv H);intros.\ninversion H8;rewrite <- H10;rewrite <- H11;try tauto.\napply IHl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros.\n  case (H n);intro.\n  case (le_gt_dec n p);intro.\n  rewrite <- H0;rewrite H1.\n  apply le_trans with (pred p); trivial.\n  apply le_trans with (pred p); trivial.\n  apply lt_le_trans with (pred p); trivial.\n  apply le_trans with (pred p); trivial.\n  apply le_trans with (pred p); trivial.\n  apply lt_le_trans with (pred p); trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  trivial.\n  destruct a.\n  case H;intro.\n  case H;intro.\n  case H;intro.\n  rewrite H2 in H;inversion H.\n  rewrite H3 in H;inversion H.\n  rewrite H3 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H; inversion H.\n  rewrite H4 in H;inversion H.\n  rewrite H4 in H; inversion H.\n  rewrite H4 in H; inversion H.\n  rewrite H4 in H; inversion H.\n  rewrite H4 in H; inversion H.\n  rewrite H4 in H; inversion H.\n  rewrite H4 in H; inversion H.\n  rewrite H4 in H; inversion H.Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  destruct l;intros.\n  rewrite <- H0;unfold is_length;simpl;intros.\n  destruct l;intros.\n  destruct (le_or_eq _ _ H0); auto.\n  generalize (IHn p H0);intro.\n  rewrite H1.\n  exists ((S n0) * x0) + x1);simpl;rewrite H1.\n  split;trivial.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_O_Sn.\n  apply lt_Sn_Sn.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n induction l;simpl;intros.\ninversion_clear H.\ndestruct l.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.\ndestruct p.\nsimpl in H.\ninversion_clear H.Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n intros; elim (le_gt_dec p n);intro.\n  destruct p.\n  rewrite <- H0.\n  trivial.\n  apply is_aligned_aux; trivial.\n  rewrite <- H0.\n  trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros.\n  destruct (is_bound l).\n  apply is_bound_ind with (P:= fun n => is_wf l).\n  apply is_wf_ind with (P:= fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n => is_wf l).\n  apply is_wf_ind with (P:=fun n =>Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n induction l;simpl;intros.\ninversion_clear H; simpl in H.\ninversion_clear H.\ninversion_clear H; simpl in H.\ninversion_clear H; simpl in H.\ninversion_clear H; simpl in H.\ninversion_clear H.\ninversion_clear H; simpl in H.\ninversion_clear H; simpl in H.\ninversion_clear H.\ninversion_clear H; simpl in H.\ninversion_clear H.\ninversion_clear H; simpl in H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n induction l;simpl;intros; auto.\ndestruct p.\nrewrite H1;apply in_wf.\nrewrite <- H1 in H.\nrewrite H2 in H.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_n_S in H1.\napply le_nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  apply H.\n  apply (H (fun p n => is_wf (exist _ _ H)) (le_refl n)).\n  apply (not_wf (exist _ _ H)).\n  apply (not_wf (exist _ _ H)).\n  apply (not_wf (exist _ _ H)).\n  apply (not_wf (exist _ _ H)).\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;intros.\n  destruct p;simpl in *;auto.\n  destruct p;simpl in *.\n  simpl in *.\n  destruct p;simpl in *.\n  destruct p;simpl in *.\n  rewrite <- H0;simpl in *.\n  rewrite <- H0;simpl.\n  rewrite <- H1;simpl;split;trivial.\n  destruct p;simpl in *.\n  rewrite <- H0;simpl;split;trivial.\n  destruct p;simpl in *.\n  destruct p;simpl in *.\n  rewrite <- H0;simpl;split;trivial.\n  destruct p;simpl in *.\n  rewrite <- H0;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n  apply H;simpl;split;trivial.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ";trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 13716,
                "proof_end_offset": 14282,
                "proof": "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\ninduction l;simpl;intros;try tauto.\ndestruct a.\ninversion H0;case (in_inv H);intro.\nrewrite H8 in H7;simpl in H7.\nelim (in_wf ((n0,n1)::l) p n H);trivial;intros.\nelim (mult_rel_prime q (power p n) (refactor l) H7);intros.\napply rel_prime_sym;apply power_rel_prime with n;trivial.\napply (IHl p n q m);trivial.\napply cons_is_wf;trivial.\ninversion H6;trivial.\nsimpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  inversion H; rewrite <- H0;rewrite <- H1;apply lt_O_Sn.\n  inversion H1.\n  elim (le_not_lt_eq _ _ H2).\n  apply lt_le_weak.\n  rewrite <- H5;apply lt_O_Sn.\n  inversion H2.\n  destruct a.\n  inversion H; rewrite <- H1;apply lt_O_Sn.\n  inversion H1.\n  inversion H; rewrite <- H5;apply lt_O_Sn.\n  inversion H0.\n  inversion H0; rewrite <- H5;apply lt_O_Sn.\n  inversion H0.\n  inversion H0; rewrite <- H5;apply lt_O_Sn.\n  inversion H0.\n  inversion H0; rewrite <- H6;apply lt_O_Sn.\n  inversion H0; rewrite <- H5;apply lt_O_Sn.\n  inversion H0; rewrite <- H5;apply lt_O_Sn.\n  inversion H0; rewrite <- H5; apply lt_O_Sn.\n  inversion H0.\n  inversion H0; rewrite <- H5; apply lt_O_Sn.\n Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\n  induction l;simpl;intros.\n  destruct a.\n  inversion H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\n  induction l;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion HQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  inversion H.\n  destruct (H a).\n  inversion H0.\n  inversion H0.\n  inversion H.\n  destruct (le_lt_or_eq H0 p).\n  destruct (le_lt_or_eq H0 p).\n  apply H;trivial.\n  inversion H1;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- H11;try tauto.\n  inversion H0;rewrite <- HQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion HQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  auto.\n  destruct a.\n  inversion H.\n  destruct (le_lt_or_eq p l);intros.\n  destruct (le_lt_or_eq p l);intros.\n  destruct (le_lt_or_eq p l);intros.\n  destruct (le_lt_or_eq p l);intros.\n  destruct (le_lt_or_eq p l);intros.\n  destruct (le_lt_or_eq p l);intros.\n  rewrite H3 in H1; elim H1;intros.\n  apply (H0 p);intros.\n  apply (H1 p);intros.\n  apply (H p);intros.\n  apply (H0 p);intros.\n  apply (H0 p);intros.\n  apply (H p);intros.\n  apply (H p);intros.\n  apply (H0 p);intros.\n  apply (H p);intros.\n  apply (H p);intros.\n  apply (H p);intros.\n  apply (H p);intros.\n  apply (H p);intros.\n  apply (H p);intros.\n  apply (H p);intros.\n  apply (H p);intros.Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  destruct a.\n  inversion H1.\n  destruct (le_or_lt p q H2).\n  destruct (le_or_lt p q H2).\n  inversion H4.\n  elim (le_or_lt p q H2).\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H1.Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  inversion H;clear H;trivial.\n  inversion H0;clear H;trivial.\n  inversion H0;clear H;trivial.\n  inversion H0;clear H0;trivial.\n  inversion H0;clear H;trivial.\n  inversion H0;clear H0;trivial.\n  inversion H0;clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0;clear H;trivial.\n  inversion H0;clear H0;trivial.\n  inversion H0;clear H0;trivial.\n  inversion H;clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0;clear H;trivial.\n  inversion H0;clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion H0; clear H0;trivial.\n  inversion HQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H1.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversionQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  inversion H.\n  destruct a.\n  inversion H.\n  destruct (le_lt_dec (p,n) (q,m)).\n  apply is_lt_le.\n  apply is_lt_le.\n  apply is_lt_le.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivial.\n  apply is_le_trans with (p,q); trivialQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 14570,
                "proof_end_offset": 14965,
                "proof": "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\ninduction l;intro.\napply nil_is_pwd.\ndestruct a.\ninversion H.\napply cons_is_pwd;auto.\nintros;intro.\nassert (rel_prime n n).\neapply rel_prime_wf;[apply H7 | apply H].\ngeneralize (gcd_refl n);intro.\nunfold rel_prime in H8.\nassert (1=n).\neapply gcd_unique;eauto.\nrewrite <- H10 in H3;elim H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;auto.\n  destruct a.\n  inversion H0;case (in_inv H);intros.\n  apply in_map.\n  destruct H0.\n  apply H0;simpl in H0;apply H0.\n  apply in_map.\n  destruct H0.\n  apply H0;simpl in H0;apply H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destruct H0.\n  apply in_map.\n  destructQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros.\n  inversion H.\n  destruct a.\n  inversion H.\n  apply IHl;trivial.\n  inversion H0.\n  inversion H1.\n  destruct a.\n  inversion H.\n  destruct a.\n  inversion H.\n  destruct (is_pwd a);inversion H.\n  destruct (is_pwd a);inversion H.\n  apply IHl;trivial.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H.\n  destruct (is_pwd a);inversion H.\n  apply IHl;trivial.\n  inversion H1.\n  destruct (is_pwd a);inversion H.\n  apply IHl;trivial.\n  inversion H0.\n  apply IHl;trivial.\n  inversion H0.\n  apply IHl;trivial.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  destruct (is_pwd a);inversion H.\n  apply IHl;trivial.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  apply IHl;trivial.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion H0.\n  inversion HQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;inversion H; subst; auto.\n  destruct a.\n  destruct a.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct a.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H; auto.\n  destruct (is_pwd (Peq_refl (length l)));inversion H;Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n induction l;simpl;intros;apply H;apply H;apply H0;trivial.\napply H;apply H0;trivial.\napply H0;apply H;trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros.\ndestruct a;simpl;intros;auto.\ninversion H;inversion H0;inversion H0;inversion H1;inversion H2;inversion H1;inversion H2;inversion H1; inversion H2;inversion H2;inversion H2;inversion H2;inversion H3;inversion H4;inversion H4;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H6;inversion H5;inversion H6;inversion H6;inversion H5;inversion H6;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H6;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5; inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5;inversion H5; inversion H5;inversion H5; inversion H5;inversion H5;inversion H5;inversion H5; inversion H5;inversion H5; inversion HQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  destruct a;inversion H;clear H0.\n  destruct a;inversion H0;clear H0.\n  destruct a;inversion H;inversion H0.\n  destruct a;inversion H;inversion H0.\n  destruct b;inversion H;clear H0.\n  destruct b;inversion H;inversion H;inversion H0.\n  destruct b;inversion H;inversion H0.\n  inversion H;inversion H;inversion H0.\n  destruct b;inversion H;inversion H0.\n  destruct b;inversion H;inversion H0.\n  inversion H;inversion H0.\n  destruct b;inversion H;inversion H;inversion H0.\n  inversion H;inversion H;inversion H0.\n  inversion H; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0; inversion H0.\n  inversion H0;Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  induction l;simpl;intros.\n  destruct a.\n  inversion H.\n  simpl.\n  destruct a.\n  inversion H.\n  simpl.\n  destruct a.\n  inversion H.\n  simpl.\n  destruct a.\n  inversion H.\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_inj H).\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_inj H).\n  simpl.\n  destruct (is_pos p).\n  inversion H.\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n  destruct (is_inj H).\n  simpl.\n  destruct (is_pwd a).\n  inversion H.\n  simpl.\n Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\n  destruct (IHl _ _ H);inversion H.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;trivial.\n  destruct a.\n  inversion H.\n  inversion H0;clear H0.\n  destruct a.\n  inversion H0;clear H0.\n  destruct a.\n  inversion H0;clear H0.\n  destruct (is_pwd a).\n  inversion H0;clear H0.\n  destruct a.\n  inversion H;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H0;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H0;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H0;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H0;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H0;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H0;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H;clear H0;trivial.\n  destruct (is_pwd a).\n  inversion H0;clear H0;trivial.\n  inversion H0;clear H0;trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\n  induction l;simpl;intros.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H0.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clear H.\n  inversion_clearQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\n",
                "context_tokens": 694,
                "proof_start_offset": 15062,
                "proof_end_offset": 15834,
                "proof": "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\ninduction l;simpl;intros;try tauto.\ncase H3;intro.\nrewrite H4 in H2.\nrewrite H4 in H1;inversion H1.\ngeneralize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\nrewrite mult_comm in H2.\ngeneralize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\napply power_divides_power with p;trivial.\ndestruct p.\nelim (not_prime_zero H8).\nelim H8;omega.\ndestruct a.\ninversion H1.\napply IHl;trivial.\napply gauss with (power n0 n1);trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\napply (rel_prime_wf l p m n0 n1);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction p;intros;unfold is_pwd.\n  destruct a.\n  destruct a.\n  inversion H;inversion H.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction l;intros;simpl;try tauto.\n  destruct a.\n  inversion H0.\n  apply (is_pwd l);auto.\n  apply (is_pwd l);auto.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction p;intros.\n  destruct a.\n  inversion H.\n  destruct (IH l) as (p,q).\n  simpl in IHn.\n  assert (exists p', exists n, p = S n).\n  destruct n.\n  inversion H.\n  destruct (IHn p n) as (p,r).\n  destruct (IHn p n) as (q',r').\n  destruct (IHn p n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p n) as (q',r').\n  destruct (IHn p n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p' n) as (q',r').\n  destruct (IHn p' n) as (q'',r').\n  destruct (IHn p' n) asQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction p;intros.\n  destruct a.\n  inversion H.\n  destruct p.\n  apply (le_lt_trans (S (length l)) (S (length l)) p n).\n  apply le_S_n.\n  apply (le_trans (S (length l)) (S (length l)) p n).\n  apply le_S_n.\n  apply IHn.\n  apply le_trans with (S (length l)) (S (length l)).\n  apply le_S_n.\n  apply IHn.\n  apply le_S_n.\n  apply IHn.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction l;intros.\n  destruct a.\n  inversion H0.\n  destruct a.\n  inversion H0.\n  destruct (in_inv H0);intros.\n  assert (rel_prime n m).\n  eapply rel_prime_wf;eauto.\n  apply H0.\n  generalize (IHn p n m);intro.\n  unfold rel_prime in H0.\n  assert (H1:=H0).\n  assert (H3:=H0).\n  eapply rel_prime_wf;eauto.\n  apply H3.\n  generalize (IHn p n m);intro.\n  unfold rel_prime in H3.\n  assert (H4:=H1).\n  eapply le_trans.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H4.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction p;simpl;intros;try tauto.\n  destruct a.\n  inversion H.\n  simpl in H.\n  apply H0;auto.\n  simpl in H0;apply H0;auto.\n  simpl in H0;apply H0;auto.\n  simpl in H0;apply H0;auto.\n  simpl in H0;apply H0;auto.\n  simpl in H0;apply H0;auto.\n  simpl in H0;apply H0;auto.\n  simpl in H0;apply H0;auto.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction p;intros.\n  destruct a.\n  inversion H;clear H; subst; simpl in *.\n  apply le_n.\n  apply IHn.\n  apply le_n.\n  apply IHn; auto.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction p;intros;simpl;intros.\n  destruct (is_pwd l) as [p H].\n  apply (divide_trans (fun p => (p,n) p)); trivial.\n  apply (divide_trans (fun p => (p,n) p)); trivial.\n  apply (divide_trans (fun p => (p,n) p)); trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros.\n  apply False_ind.\n  destruct a.\n  destruct (is_pwd (fun n => is_pwd (fun n => is_pwd (fun n => is_pwd n)) l)).\n  apply is_pwd; trivial.\n  apply is_pwd; trivial.\n  apply is_pwd; trivial.\n  apply is_pwd; trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction l;intro.\n  destruct a.\n  inversion H.\n  assert (forall (n:nat)(tail:list (nat*nat))(head:list (nat*nat))(head:list (nat*nat))(tail:list (nat*nat))(tail:list (nat*nat))(tail:list (nat*nat))(tl:list (list (nat*nat))(tail:list (nat*nat))(tail:list (nat*nat))(tl:list (nat*nat))(tl:list (nat*nat))(tail:list (nat*nat))(tl:list (nat*nat))(tl:list (nat*nat*nat))(tl:list (list (nat*nat*nat))(tl:list (list (nat*nat*nat))(tl:list (nat*nat))(tl:list (nat*nat*nat))(tl:list (list (nat*nat*nat))(tl:list (nat*nat))(tl:list (list (nat*nat*nat))(tl:list (nat*nat))(tl:list (nat*nat))(tl:list (list (nat*nat*nat))(tl:list (list (nat*nat*nat*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "actor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\n",
                "context_tokens": 691,
                "proof_start_offset": 15927,
                "proof_end_offset": 16738,
                "proof": "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\nintros l l';intro;intro;intro;intros p n;intro.\nelim (in_wf l p n H2 H);intros.\ngeneralize (factor_divides_refactor (p,n) l H2);simpl;intro.\nrewrite H1 in H5.\nassert (divides (refactor l') p).\napply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\nelim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\ncut (n=m).\nintro;rewrite H8;trivial.\napply le_antisym.\neapply prime_power_divides_refactor;eauto.\ngeneralize (factor_divides_refactor (p,m) l' H7);simpl;intro.\nrewrite <- H1 in H8.\napply prime_power_divides_refactor with p l;auto.\nelim (in_wf l' p m);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l';intros.\n  simpl;intros.\n  apply (IHn p n m);trivial.\n  apply (IHn p n m);trivial.\n  apply (IHn p n m);trivial.\n  apply (IHn p n m);trivial.\n  apply (IHn p n m);trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  induction l;simpl;intros;try tauto.\n  case H;intro.\n  rewrite H4;inversion H1.\n  destruct a.\n  rewrite H4 in H.\n  rewrite H in H.\n  rewrite H0 in H.\n  rewrite H in H.\n  rewrite H0 in H.\n  rewrite H in H.\n  inversion H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n intros.\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_join _ _ H).\n rewrite <- (same_correct_share_Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\ninduction l;simpl;intros;try tauto.\ndestruct l.\ndestruct l'.\ndestruct l'.\ndestruct l0.\ndestruct l0.\ndestruct l0.\nsimpl in H.\nassert (exists n0:nat, n = n0).\napply IHn0; auto.\ndestruct l0.\ndestruct l0.\ndestruct l0.\ndestruct l0.\ndestruct l1.\ndestruct l1.\ndestruct l0.\ndestruct l1.\ndestruct l1.\ndestruct l1.\ndestruct l1.\ndestruct l2.\ndestruct l1.\ndestruct l2.\ndestruct l2.\ndestruct l1.\ndestruct l2.\ndestruct l1.\ndestruct l2.\ndestruct l2.\ndestruct l2.\ndestruct l3.\ndestruct l4.\ndestruct l3.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l4.\ndestruct l5Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n induction l;simpl;intros.\ninversion H.\ninversion H.\napply IHl;trivial.\ninversion H.\ninversion H.\napply IHl';trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  case H;intro.\n  apply H;trivial.\n  apply IHis_pwd;trivial.\n  apply IHis_pwd;trivial.\n  apply IHis_pwd;trivial.\n  apply IHis_pwd;trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n  intros.\n  apply factorisation_unique_upto_aux.\n  apply (pre_is_pwd (fun n:nat => is_pwd n) (bsush l) (S n))).\n  apply factorisation_unique_upto_aux.\n  apply (pre_is_pwd (fun n:nat => is_pwd n) (bsush l') (S n))).\n  apply factorisation_unique_upto_aux.\n  apply (pre_is_pwd (fun n:nat => is_pwd n) (bsush l') (S n)).\n  apply factorisation_unique_upto_aux.\n  apply (pre_is_pwd (fun n:nat => is_pwd n) (bsush l)).\n  apply (pre_is_pwd (fun n:nat => is_pwd n) (bsush l)); auto.\n  apply (pre_is_pwd (fun n:nat => is_pwd n) (bsush l) (S n))).\n  apply factorisation_unique_upto_aux.\n  apply (pre_is_pwd (fun n:nat => is_pwd n)Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\n induction l;intros;trivial.\ndestruct l'.\ndestruct l'.\ndestruct l0.\nsimpl in H.\nrewrite H0 in H.\ndestruct l0.\ndestruct l0.\nsimpl in H.\nrewrite H0 in H.\ndestruct l0.\nsimpl in H.\nrewrite H0 in H.\ndestruct l0.\nsimpl in H.\nrewrite H0 in H.\nrewrite H0 in H.\nrewrite H in H.\nsimpl in H.\nrewrite H0 in H.\nrewrite H.\nrewrite H0 in H.\nrewrite H0 in H.\nsimpl in H.\nrewrite H0 in H.\nrewrite H in H.\nrewrite H.\napply H.\napply H.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\ninduction l;intros.\nsimpl;auto.\ndestruct l';simpl;apply Pred_valid_lt; auto.\nintros;intro.\napply H.\nrewrite H1 in H0;inversion H0.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\ninduction l;intros.\ndestruct l'.\nsimpl.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H0.\nrewrite H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 16740,
                "proof_end_offset": 16884,
                "proof": "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\ninduction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intro.\n  apply (is_nat_inf l pwd_impl_set (is_nat*nat) l');trivial.\n  destruct (is_nat_inf l) as [p [H1 H2]].\n  exists p; exists (is_nat_inf l);split;trivial.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\n  intros l l';intro;intro.\n  elim (in_wf l p n H);intro.\n  apply (pwd_iff_succ_wd l p n H);trivial.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2);intro.\n  elim H1; intro.\n  apply le_antisym; apply H.\n  eapply le_trans; [apply le_lt_trans with (S n); auto | apply H].\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\n  apply le_lt_trans with (S n); auto.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\nintros l l';intro;intro;intro.\nelim (in_wf l);intro.\nelim H;intro.\nrewrite H4 in H0.\ndestruct (le_lt_eq_dec l' l');intro.\nrewrite H4 in H0.\napply le_antisym.\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans; [apply H | apply H ].\neapply le_trans;Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intros p;intro;intros p;elim p;intros.\n  case H;intro.\n  rewrite H2 in H0.\n  rewrite H in H0.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  rewrite H0 in H0Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n);intro.\n  rewrite H0 in H.\n  apply le_antisym.\n  eapply pred_nec_hereditary; eauto.\n  generalize (pwd_prop l p n);intro.\n  apply (H0 n);intro.\n  apply le_antisym;apply le_antisym.\n  eapply pred_nec_hereditary; eauto.\n  generalize (pwd_prop l p n);intro.\n  apply le_antisym;apply le_antisym.\n  eapply pred_nec_hereditary; eauto.\n  generalize (pwd_prop l p n);intro.\n  apply le_antisym.\n  eapply pred_nec_hereditary; eauto.\n  generalize (pwd_prop l p n);intro.\n  apply le_antisym;apply le_antisym.\n  eapply pred_nec_hereditary; eauto.\n  generalize (pwd_prop l p n);intro.\n  apply le_antisym;apply le_antisym.\n  eapply pred_nec_hereditary; eauto.\n  generalize (pwd_prop l p n);intro.\n  apply le_antisym.\n  eapply pred_nec_hereditary; eauto.\n Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l;intro;intro;apply pwd_iff_set;auto.\n  destruct l;simpl;auto.\n  destruct l;simpl;auto.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;apply pwd_impl_set.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l;intro;intro;intro;intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (is_le_pred (nat*nat));intro.\n  apply (isQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\n  induction l;simpl;intros;try tauto.\n  apply le_antisym;apply le_trans with (m:=n);trivial.\n  apply le_antisym;apply le_trans with (m:=n);trivial.\n  apply le_trans with (m:=n);trivial.\n  apply le_trans with (m:=n);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\n",
                "context_tokens": 705,
                "proof_start_offset": 16982,
                "proof_end_offset": 17483,
                "proof": "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\nintros.\nassert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\napply factorisation_unique_upto_equiv_aux;trivial.\nassert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\napply factorisation_unique_upto_equiv_aux;auto.\napply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l;simpl;intros;try tauto.\n  case H;intro.\n  rewrite H1 in H.\n  rewrite H2 in H.\n  simpl in H.\n  rewrite H2 in H.\n  assert (n=m).\n  apply le_trans with (pred (nat * nat)).\n  rewrite <- le_plus_minus_r; trivial.\n  rewrite <- le_plus_minus_r; trivial.\n  omega.\n  assert (n=m).\n  apply le_trans with (pred (nat * nat)).\n  rewrite <- le_plus_minus_r; trivial.\n  omega.\n  assert (n=m).\n  apply le_trans with (pred (nat * nat)).\n  rewrite <- le_plus_minus_r; trivial.\n  omega.\n  apply le_trans with (pred (nat * nat)).\n  rewrite <- le_plus_minus_r; trivial.\n  omega.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' l' H; induction l'; simpl;intros;try tauto.\n  destruct l'.\n  destruct l' as [ | [ | ] l'].\n  destruct l'.\n  destruct l' as [ | [ | ] l'].\n  destruct l0.\n  destruct l' as [ | [ | ] l'].\n  destruct l0 as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l0 as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [ | ] l'].\n  destruct l' as [ | [Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l';simpl;intros;try tauto.\n  destruct l';simpl;try tauto.\n  destruct l';simpl;try tauto.\n  destruct l';simpl;try tauto.\n  destruct l';simpl;try tauto.\n  destruct l';simpl;try tauto.\n  destruct l';simpl;try tauto.\n  destruct l';simpl;try tauto.\n  destruct l';simpl;try tauto.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction 1;intros;apply is_true_not_eq;auto.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversion_clear H.\n  destruct l';inversionQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l';simpl;intros;try tauto.\n  case H;intro.\n  rewrite H0 in H;inversion H.\n  rewrite H0 in H0;inversion H.\n  rewrite H1 in H0;inversion H.\n  rewrite H0 in H;inversion H.\n  rewrite H1 in H0;inversion H.\n  rewrite H1 in H0;inversion H.\n  rewrite H1 in H0;inversion H.\n  rewrite H1 in H0;inversion H0.\n  rewrite H0 in H;inversion H0.\n  rewrite H1 in H0;inversion H.\n  rewrite H1 in H0;inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0;inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H0 in H0;inversion H0.\n  rewrite H1 in H0;inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H1 in H0; inversion H0.\n  rewrite H0 in H0; inversion H0.\n  rewrite H1 in H0; inversion HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H;intro;intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H);intro;intros.\n  rewrite H0 in H; inversion H.\n  apply le_antisym.\n  eapply le_trans; [apply le_lt_trans with (m:=m) | apply Nat.le_max_l].\n  apply Nat.le_max_l.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_l.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_l.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.le_max_r.\n  apply Nat.leQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l;simpl;intros;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec l l');simpl;try tauto.\n  destruct (is_basic_le_dec lQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\n induction l;simpl;intros.\ninversion H.\ninversion H.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversionQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l;simpl;intros;try tauto.\n  destruct l' as [|l'' l''].\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l'' as [|l'' l''].\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l'' as [|l'' l''].\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l'' as [|l'' l''].\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite H4;trivial.\n  destruct l''.\n  simpl in *.\n  rewrite HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  induction l;simpl;intros;try tauto.\n  destruct (le_gt_dec l l');simpl;intros.\n  apply in_or_app; tauto.\n  apply in_or_app; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\n",
                "context_tokens": 723,
                "proof_start_offset": 17745,
                "proof_end_offset": 17899,
                "proof": "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\nintros.\ncase (factorisation n);intros;try tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\nintros n.\ninduction n.\nexact (is_factorisation n l).\nexact (is_factorisation n l).\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  destruct (is_factorisation n l H0).\n  exists (is_factorisation n l H0).\n  split;auto.\n  destruct (is_factorisation n l H0).\n  destruct (is_factorisation n l H0).\n  exists (is_factorisation n l H1).\n  split.\n  apply is_factorisation_unique_upto_equiv_aux;trivial.\n  apply is_factorisation_unique_upto_equiv_aux;trivial.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  destruct (is_factorisation n l H0 H1 H2) as (n1,(n2,(H3,H4)))).\n  exists (S n1).\n  exists (S n2).\n  destruct (is_factorisation n l H3 H4) as (n1,(n2,(H5,H6)))).\n  exists (S n2).\n  destruct (is_factorisation n l H4) as (n2,(H6,H7)).\n  exists (S n2).\n  destruct (is_factorisation n l H4) as (n2,(H6,H8)).\n  exists (S n2).\n  destruct (is_factorisation n l H5 H7) as (n2,(H8,H9)).\n  exists (S n2).\n  destruct (is_factorisation n l H5) as (n2,(H11,H12,H12)).\n  exists (S n2).\n  destruct (is_factorisation n l H5) as (n3,(H12,H13)).\n  exists (S n2).\n  destruct (is_factorisation n l H5) as (n4,(H12Qed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n l.\n  induction n.\n  simpl.\n  destruct (is_factorisation n l).\n  simpl.\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  simpl.\n  destruct n.\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  simpl.\n  destruct n0.\n  destruct (is_factorisation n l).\n  destruct n0.\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  simpl.\n  destruct (is_factorisation n l).\n  destruct n0.\n  destruct (is_factorisation n l).\n  destruct n1.\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation n l).\n  destruct (is_factorisation nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n H.\n  apply (factorisation_unique_upto_equiv_aux n H);trivial.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n.\n  apply (is_factorisation_unique_upto_equiv_aux n l).\n  apply (is_factorisation_unique_upto_equiv_aux n l).\n  apply (is_factorisation_unique_upto_equiv_aux n l).\n  apply is_factorisation_unique_upto_equiv_aux;trivial.\n  apply is_factorisation_unique_upto_aux;trivial.\n  apply is_factorisation_unique_upto_aux;trivial.\n  apply is_factorisation_unique_upto_aux;trivial.\n  apply is_factorisation_unique_upto_aux;trivial.\n  apply is_factorisation_unique_upto_aux;trivial.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n H; elim H; intros; exists 0%nat; auto.\n  exists 0%nat; auto.\n  exists 0%nat; auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  destruct n.\n  exists 0%nat.\n  apply (is_factorisation_unique_upto_aux n l n);auto.\n  intros.\n  apply H0.\n  destruct H.\n  rewrite H0.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  reflexivity.\n  intros.\n  apply H0.\n  destruct H.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  rewrite H.\n  rewrite H0.\n  rewrite H.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros; apply (is_factorisation_unique_upto_equiv_aux n l H); auto.\n  apply (is_factorisation_unique_upto_equiv_aux n l H); auto.\n  apply is_factorisation_unique_upto_equiv_aux; auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nintros n H.\ndestruct n.\nsimpl in H.\ndestruct (interp_non_zero n).\nsimpl in H.\ndestruct (interp_non_zero n).\ndestruct (interp_non_zero n).\nsimpl in H.\ninversion H.\napply IHn with (2:=n) (2:=n) (2:=n) (2:=n) (n:=n) (2:=n) (2:=n) (n:=n) (2:=n) (2:=n) (n:=n) (2:=n) (n:=n) (2:=n) (2:=n) (n:=n) (2:=n) (2:=n) (2:=n) (2:=n) (3:=n) (n:=n) (n:=n) (2:=n) (n:=n) (2:=n) (n:=n) (2:=n) (2:=n) (2:=n) (n:=n) (2:=n) (2:=n) (2:=n) (2:=n) (2:=n) (n:=n) (2:=n) (3:=nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\n",
                "context_tokens": 706,
                "proof_start_offset": 17978,
                "proof_end_offset": 18273,
                "proof": "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nProof.\nunfold is_factorisation;intros.\nelim H;intros.\nelim H0;intros.\napply factorisation_unique_upto_perm;auto;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  induction n;intros.\n  exists 0.\n  destruct l.\n  destruct l'.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct (is_factorisation n); intros;\n    destruct l'.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct (is_factorisation n); intros;\n    destruct l'.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct (is_factorisation n); intros;\n    destruct l'.\n  destruct l'.\n  destruct l'.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct l'.\n  destruct l'.\n  destruct l0.\n  simpl.\n  destruct l'.\n  destruct l'.\n  destruct l'.\n  simpl.\n  destruct l0.\n  destruct l'.\n  simpl.\n  destruct l'.\n  simpl.\n  destruct (is_factorisation n); intros;\n    destruct l'.\n  simpl in *.\n  destruct l'.\n  destruct l'.\n  destruct l0.Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros; apply factorisation_unique_upto_same; auto.\n  Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  intros;inversion H1;inversion H2;inversion H3;inversion H4;inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H6; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion H5; inversion HQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  destruct (factorisation n);intros;destruct l;destruct l';inversion H0.\n  destruct (factorisation n);intros;inversion H1.\n  destruct (factorisation n);intros;inversion H2.\n  destruct (factorisation n);intros;inversion H2.\n  destruct (factorisation n);intros;inversion H1.\n  destruct (factorisation n);intros;inversion H2.\n  destruct (factorisation n);intros;inversion H2.\n  destruct (factorisation n);intros;inversion H3.\n  destruct (factorisation n);intros;inversion H4.\n  destruct (factorisation n);intros;inversion H4.\n  destruct (factorisation n);intros;inversion H4.\n  destruct (factorisation n);intros;inversion H4.\n  destruct (factorisation n);intros;inversion H5.\n  destruct (factorisation n);intros;inversion H4.\n  destruct (factorisation n);intros;inversion H5.\n  destruct (factorisation n);intros;inversion H5.\n  destruct (factorisation n);intros;inversion H5.\n  destruct (factorisation n);intros;inversion H5.\n  destruct (factorisation n);intros;inversion H5.Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  destruct l;try tauto.\n  destruct l';try tauto.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  destruct l'.\n  destruct l'.\n  simpl; trivial.\n  apply factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_sym.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_transitivity with l'; auto.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_permutation.\n  apply is_factorisation_unique_upto_transitivity with l'; auto.Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  induction n;intros.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct l;try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';try tauto.\n  destruct l';tryQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  apply factorisation_unique_upto_le;auto.\n  assert (forall (l l':list (nat*nat))(is_factorisation n l')->(is_factorisation n l')=(is_factorisation n l')/\\is_factorisation n l').\n  intros.\n  apply factorisation_unique_upto_le;auto.\n  assert (forall (l l':list (nat*nat))(is_factorisation n l')->(is_factorisation n l')/\\is_factorisation n l').\n  apply factorisation_unique_upto_le;auto.\n  assert (forall (l l':list (nat*nat))(is_factorisation n l')/\\is_factorisation n l').\n  intros; apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique with l'; auto.\n  apply factorisation_unique with l; auto.\n  apply factorisation_unique with l'; auto.\n  apply factorisation_unique with l'; auto.\n  apply factorisation_unique with l'; auto.\n  apply factorisation_unique with l'; auto.\n  apply factorisation_unique with l'; auto.\n  Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n  case (factorisation n);intros;try tauto.\n Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  destruct (factorisation n);intros;inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H; subst; auto.\n  inversion H0; subst; auto.\n  inversion H0; subst; auto.\n  inversion H0; subst; auto.\n  inversion H0; subst; auto.\n  inversion H0; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\nTheorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  unfold is_factorisation;intros.\n  elim H;intros.\n  elim H0;intros.\n  apply factorisation_unique_upto_perm;auto;congruence.\nQed.\n\n(** *)\n",
                "context_tokens": 652,
                "proof_start_offset": 18282,
                "proof_end_offset": 20069,
                "proof": "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintro.\ninduction l;simpl;intros.\nleft;exists 1;rewrite power_one;trivial.\ndestruct a.\nassert (n<>0);try omega.\ngeneralize (quo_rem_euclide n1 n H1);intro.\ncase (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\nrewrite e in H2;rewrite plus_comm in H2;simpl in H2.\ncase IHl;intros;trivial.\ninversion H;trivial.\nelim s;intro y;intro.\nrewrite H2.\nleft;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nelim p3;intros.\nelim H4;intros.\nelim H6;intros.\nelim H8;intros.\nright.\nexists p;exists q;exists r.\nrewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\nexists (k*(power n0 n1)).\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\napply rel_prime_mult;trivial.\ninversion H.\nrewrite H9 in H17.\nelim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\napply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\nrewrite plus_comm;auto with arith.\nright.\nexists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\nrewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\nexists (refactor l).\nelim (in_wf ((n0,n1)::l) n0 n1);intros.\nsplit;trivial.\nsplit;trivial.\ndestruct (remainder_euclide n1 n H1);try tauto;auto with arith.\nsplit;trivial.\napply rem_euclide.\nsplit;trivial.\ninversion H;trivial.\nsimpl;tauto.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  case (le_gt_dec n (length l)); intros.\n  rewrite H0.\n  destruct H1 as [H1|H1].\n  case (le_gt_dec n (length l)); intros.\n  apply le_lt_trans with (length l); auto.\n  apply le_lt_trans with (length l); auto.\n  apply le_lt_trans with (length l); auto.\n  apply le_lt_trans with (length l); auto.\n  apply le_trans with (length l); auto.\n  apply le_lt_trans with (length l); auto.\n  apply le_lt_trans with (length l); auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  destruct (finite_nonisation n);intros;try tauto.\n  generalize (finite_nonisation_nonisation n);intro.\n  rewrite <- H0 in H2.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H1.\n Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;inversion H.\n  destruct (finite_is_factorisation n);intros;Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case_eq (is_factorisation n);intros;try tauto.\n  apply factorisation_unique_upto_same;intros;auto.\n  apply factorisation_unique_upto_le;auto;congruence.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  case_eq (is_factorisation n);intros.\n  case_eq (is_factorisation n);intros.\n  destruct (is_factorisation n);intros.\n  destruct (is_factorisation n);intros.\n  apply H2;exists n;exists n;exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);exists (S n);existsQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  case (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;try tauto.\n  destruct (is_factorisation n);intros;tryQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (interp_nonpoints l);intros;try tauto.\n  elim H0;intros.\n  apply (H0 n).\n  apply (H1 (S n)).\n  apply (H1 (S n)).\n  apply (H1 (S n)).\n  apply (H2 (S n)).\n  apply (H1 (S n)).\n  apply (H1 (S n)).\n  apply (H2 (S n)).\n  apply (H0 (S n)).\n  apply (H1 (S n)).\n  apply (H2 (S n)).\n  apply (H1 (S n)).\n  apply (H1 (S n)).\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply (H1 (S n)).\n  apply (H1 (S n)).\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply (H2 (S n)).\n  apply (H1 (S n)).\n  apply (H2 (S n)).Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  apply (well_founded_induction_type (fun n => {q:nat & {r:nat & {r:nat | (is_factorisation n l)->(is_factorisation n l))}}.\n  intros.\n  apply (well_founded_induction_type (fun n => {q:nat & {r:nat | (is_factorisation n l)} => {r:nat & {r:nat & {r:nat & {r:nat | (r:nat)} | (r <= r})}} ).\n  intros.\n  apply (well_founded_induction_type (fun n => {q:nat & {r:nat & {r:nat & {r:nat & {r:nat & {r:nat | (r:nat}), is_factorisation n l=(p*n+r})}})).\n  intros.\n  apply (well_founded_induction_type (fun n => {q:nat & {r:nat & {r:nat & {r:nat & {r:nat | (r:nat | (r:nat)} | (r <= r))}} ).\n  intros.\n  apply (well_founded_induction_Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (non_factorisation n); intros;try tauto.\n  apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique_upto_le;auto.\n  apply factorisation_unique_upto_le;auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  destruct (finite_bounded_lt_dec n (nat*nat))(nat_of_P p); intros.\n  apply is_factorisation_unique_upto_le;auto.\n  assert (forall n, n <= pred n) by omega.\n  apply (prop_ext n);auto.\n  apply is_factorisation_unique_upto_le;auto.\n  assert (forall n, n <= pred n) by omega.\n  apply (prop_ext n);auto.\n  apply is_factorisation_unique_upto_le;auto.\n  apply is_factorisation_unique_upto_le;auto.\n  assert (forall n, n <= pred n) by omega.\n  apply (prop_ext n);auto.\n  apply is_factorisation_unique_upto_le;auto.\n  apply is_factorisation_unique_upto_le;auto.\n  apply is_factorisation_unique_upto_le;auto.\n  apply is_factorisation_unique_upto_le;auto.\n  apply is_factorisation_unique_upto_le;auto.\n  apply is_factorisation_unique_upto_le;auto.\n  apply is_factorisationQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intro.\n  induction l;simpl;intros.\n  left;exists 1;rewrite power_one;trivial.\n  destruct a.\n  assert (n<>0);try omega.\n  generalize (quo_rem_euclide n1 n H1);intro.\n  case (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\n  rewrite e in H2;rewrite plus_comm in H2;simpl in H2.\n  case IHl;intros;trivial.\n  inversion H;trivial.\n  elim s;intro y;intro.\n  rewrite H2.\n  left;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\n  elim s;intro p;intro.\n  elim p0;intro q;intro.\n  elim p1;intro r;intro.\n  elim p2;intro k;intro.\n  elim p3;intros.\n  elim H4;intros.\n  elim H6;intros.\n  elim H8;intros.\n  right.\n  exists p;exists q;exists r.\n  rewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\n  exists (k*(power n0 n1)).\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  apply rel_prime_mult;trivial.\n  inversion H.\n  rewrite H9 in H17.\n  elim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\n  apply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\n  rewrite plus_comm;auto with arith.\n  right.\n  exists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\n  rewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\n  exists (refactor l).\n  elim (in_wf ((n0,n1)::l) n0 n1);intros.\n  split;trivial.\n  split;trivial.\n  destruct (remainder_euclide n1 n H1);try tauto;auto with arith.\n  split;trivial.\n  apply rem_euclide.\n  split;trivial.\n  inversion H;trivial.\n  simpl;tauto.\n  trivial.\nQed.\n\n(** let n be a natural number and m>1 then either n=x^m or there is a prime number p and three numbers q,r and k such that n = p^(q*m+r)*k with 0<r<m and gcd(p,k)=1 *)\n",
                "context_tokens": 668,
                "proof_start_offset": 20239,
                "proof_end_offset": 20661,
                "proof": "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n m;intro H.\ncase (eq_nat_dec n 0);intro.\nleft;exists 0.\ndestruct m;simpl;try omega;trivial.\ngeneralize (factorisation_exists n n0);intro.\nelim H0;intro l;intro.\nelim p;intros.\nrewrite H2;apply wf_power_dec;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros.\n destruct (is_power_m_dec n m) as [m' | n'].\n  (* 0<n *)\n  destruct (is_power_m_dec n m') as [r|r].\n  (* 0<m *)\n  assert (r=m).\n  apply (is_power_m_dec n m' r H); trivial.\n  (* 0<=n *)\n  assert (r=m).\n  apply (is_power_m_dec n m' r H); trivial.\n  (* 0<=n *)\n  destruct (is_power_m_dec n m') as [r|r].\n  (* 0<=m *)\n  destruct (is_power_m_dec n m') as [r|r].\n  (* 1<m *)\n  destruct (is_power_m_dec n m') as [r|r].\n  (* 1<m *)\n  assert (r=m).\n  apply (is_power_m_dec n m' r H); trivial.\n  (* 1<m *)\n  assert (r=m).\n  apply (is_power_m_dec n m' r H); trivial.\n  (* 2<m *)Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros.\n induction n;simpl;intros.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\ndestruct a.\nsplit;trivial.\nsplit;trivial.\napply rel_prime_mult;trivial.\nsplit;trivial.\napply rel_prime_mult;trivial.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  generalize (is_power_m_dec n m);intro.\n  induction l.\n  simpl;intros.\n  destruct a.\n  simpl;intros.\n  destruct a.\n  destruct H.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;intros.\n  destruct H.\n  simpl;introsQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros n m p; induction m; simpl;intros.\ndestruct p as [q|q]; simpl;intros.\nelim (le_lt_or_eq _ _ q);intro q; elim q;intro; clear q.\nexists (p, q).\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros.\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n exists (S m).\n exists (S m).\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n exists (S m).\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n exists (S m).\n exists (S m).\n split.\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n exists (S m).\n destruct (is_power_m_dec n m) as [m|m].\n (* p < n *)\n exists (S m).\n destruct (is_Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n intros.\n destruct (is_power_pos_pos p) as [p|p]; simpl; intros.\n destruct a.\n left; exists p;exists (is_power p (q*m)).\n rewrite H; rewrite H.\n right; exists (is_power p (q*m)).\n split;trivial.\n split;trivial.\n right; exists p;exists m;auto.\n right; exists p;auto.\n right; exists p;auto.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  assert (forall n m, (n<=m+r->{n}) by (apply is_power_m_dec; auto).\n  destruct (is_power_m_dec n m) as [m Hm].\n  assert (m<=r->{r <= m}).\n  { apply (is_power_m_dec n m); auto with arith. }\n  destruct (is_power_m_dec m m) as [Hm|Hm].\n  destruct (is_power_m_dec m m) as [Hm|Hm].\n  - apply (is_power_m_dec n m Hm).\n    rewrite Hm; auto with arith.\n  - apply (is_power_m_dec n m Hm).\n    rewrite Hm; auto with arith.\n  - apply (is_power_m_dec n m Hm).\n    rewrite Hm; auto with arith.\n  - apply (is_power_m_dec n m Hm).\n    rewrite Hm; auto with arith.\n  - apply (is_power_m_dec n m Hm).\n    rewrite Hm; auto with arith.\n  - apply (is_power_m_dec n m Hm).\n    rewrite HmQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction n;intros.\n  left;exists 0;exists 1;exists 1;exists (S n); auto with arith.\n  right.\n  exists (S n); auto with arith.\n  right.\n  exists (S n); auto with arith.\n  right.\n  exists (S n); auto with arith.\n  right.\n  exists (S n); auto with arith.\n  right.\n  exists n; auto.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros.\n  induction n; simpl;intros.\n  left.\n  rewrite H0; rewrite <- H1; rewrite <- H2; trivial.\n  right.\n  assert (n<>0) by (intro; subst; auto).\n  assert (m>0) by (apply (is_power_pos_pos n H1 H2 H3)).\n  assert (m>0) by (apply (is_power_pos_pos n H2 H3)).\n  assert (m>0) by (apply (is_power_pos_pos n H2 H3)).\n  assert (m>0) by (apply (is_power_pos_pos n H2 H3)).\n  assert (m>0) by (apply (is_power_pos_pos n H3 H4 H2)).\n  assert (m>0) by (apply (is_power_pos_pos n H3 H3).\n  rewrite <- H3; rewrite <- H3; rewrite <- H3; trivial.\n  elim (div_eucloreide n H2 H3); intros.\n  elim H3; intro.\n  elim H4; intro.\n  rewrite H4 in H3;Qed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intro n; case n; simpl; intros.\n  elim n; simpl; intros.\n  elim n0; simpl; intros.\n  apply IHn.\n  apply H.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\n",
                "context_tokens": 252,
                "proof_start_offset": 1012,
                "proof_end_offset": 1219,
                "proof": "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nelim H0;intro q;intro.\nreplace b with (b*1);try ring.\nrewrite H1.\napply mult_le_compat;try omega.\ndestruct q;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\ndestruct (divide_dec a b).\nleft; trivial.\nright; trivial.\nright; trivial.\nright; trivial.\nright; trivial.\nright; trivial.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b.\n destruct a as [|b|b]; trivial.\n destruct (divide_trans _ _ H) as [H|H]; trivial.\n destruct (divide_trans _ _ H) as [H|H]; trivial.\n destruct (divide_trans _ _ H) as [H'|H']; trivial.\n destruct (divide_trans _ _ H') as [H'|H']; trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd a b); trivial.\n apply divide_trans with (gcd aQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n  intros.\n  apply (le_wf_rec _ _ H).\n  assumption.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b H; apply divide_le.\nintros H'; rewrite <- (gcd_antisym a b H' H'0).\nrewrite (gcd_antisym a b H' H'0).\nrewrite (gcd_antisym b a H' H'0).\nrewrite (gcd_antisym a b H' H'1).\nrewrite (gcd_antisym a b H' H'0).\nrewrite (gcd_antisym a b H' H'1).\nrewrite (gcd_antisym b a H' H'1).\nrewrite (gcd_antisym a b H' H' H'0).\nrewrite (gcd_antisym a b H' H'1).\nrewrite (gcd_antisym b a H' H'0).\nrewrite (gcd_antisym b a H' H'1).\nrewrite (gcd_antisym b a H' H'1).\nrewrite (gcd_antisym a b H' H'1).\nrewrite (gcd_antisym b a H' H'1).\nrewrite (gcd_antisym a b H' H' H'1).\nrewrite (gcd_antisym a b H' H' H'0).\nrewrite (gcd_antisym a bQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b.\n case (divide_dec a b); intros H.\n apply (divide_trans _ _ H).\n apply (divide_trans _ _ H).\n apply (divide_trans _ _ H).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H1).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H1).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H1).\n apply (divide_trans _ _ H1).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H0).\n apply (divide_trans _ _ H1).\n apply (divide_trans _ _ H2 H0).\n apply (divide_trans _Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros.\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divide a b) (gcd_divide b a)).\n apply (divide_trans (gcd_divideQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b.\n destruct a.\n left.\n apply (divide_0_l a).\n right; apply (divide_0_l a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_l a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_l a).\n right; apply (divide_0_l a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right; apply (divide_0_r a).\n right;Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b.\n apply (divide_trans a b H).\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_divide.\n apply mod_Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros a b H.\n unfold modulo in |- *.\n apply le_trans with (Zabs a * Zabs b).\n apply (gcd_sym a b H).\n apply (gcd_sym a b H).\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n intros. now apply divide_le.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\n",
                "context_tokens": 338,
                "proof_start_offset": 1256,
                "proof_end_offset": 1718,
                "proof": "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\nintros.\napply (lt_wf_rec a (fun a:nat =>{q : nat & {r : nat | a = b * q + r /\\ r < b}})).\nintros.\ncase (le_lt_dec b n);intro.\nelim (H0 (n-b)).\nintro q;intro.\nelim p;intro r;intro.\nexists (q+1);exists r.\nsplit;try tauto.\nrewrite (le_plus_minus b n);trivial.\nelim p0;intros.\nrewrite H1;ring.\nomega.\nexists 0;exists n.\nsplit;try tauto.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\nintros a b.\nrewrite <- (abs_eq a b).\nrewrite <- (abs_eq a b).\napply abs_eq; trivial.\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n intros a b.\n split; intros.\n  exists 0; auto with arith.\n  exists (a*b); auto with arith.\n  exists (b*a); auto with arith.\n  exists (b*b); auto with arith.\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros a b.\n  assert (H' : forall q:nat, r < b -> q < b -> a = b).\n  intros.\n  elim H'0; intro q; elim q; intro q; elim q; intro q; elim q; intro q;\n    rewrite q0 in H'1; try discriminate H'1.\n  intros q0 H'1 q0 H'2 q1 H'3 q2 H'4.\n  elim H'1; intro q0; elim q0; intro q0; elim q0; intro q1; elim q1;\n    intro q1; rewrite q1 in H'1; try discriminate H'1.\n  intros q0 H'1 q1 H'2 q2 H'4.\n  elim H'1; intro q1; elim q1; intro q2; elim q1; intro q3; elim q3;\n    intro q3; rewrite q3 in H'1; try discriminate H'1.\n  intros q1 H'2 q2 H'3 q4.\n  elim H'3; intro q3; elim q3; intro q4; elim q3; elim q4;Qed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  elim H0; intro q; elim q; intro q; elim q; intro q;\n    [ right; apply le_antisym; assumption | left; apply le_trans with q; assumption ].\n  intros.\n  elim H0; intro q; elim q; intro q; elim q; intro q; elim q; intro q; elim q;\n    [ right; apply le_antisym; assumption | right; apply le_trans with q; assumption ].\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  destruct (abs_eq a b) as [[H|H]|H].\n  left; exists (abs_eq a b).\n  right; exists (abs_eq a b).\n  right; exists (abs_eq a b).\n  right; exists (abs_eq a b).\n  left; exists (abs_eq a b).\n  left; exists (abs_eq b a).\n  left; exists (abs_eq b a).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq a b).\n  right; exists (abs_eq a b).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b a).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b a).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b b).\n  right; exists (abs_eq b b).\n  rightQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  elim H0;intro q;intro q; elim q;intro q;\n    [ intro H1; rewrite <- H1; rewrite <- H2; rewrite <- H1; ring\n    | apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption ] ].\n  rewrite <- (abs_mult a b) at 1.\n  rewrite <- (abs_mult a b) at 1.\n  rewrite <- (abs_mult a b) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewrite <- (abs_mult b a) at 1.\n  rewriteQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros a b.\n  generalize (gcd_gcd a b); intro q; elim q; intro q; elim q; intro q;\n    [ elim q; intros q1 q2; elim q1; intros q3 q4;\n       elim q5; intros q5 q6; elim q6; intros q6 q7;\n       elim q6; intros q7 q8; elim q8; intros q9 q10;\n       elim q11; intros q10 q11; elim q12; intros q11 q12;\n       apply q11; apply q12; apply q13; apply q14;\n       apply q12; apply q12; apply q14;\n       apply q14; apply q12; apply q14; apply q14;\n       apply q13; apply q14; apply q15;\n       apply q14; apply q14; apply q15; apply q15;\n       apply q15; apply q15; apply q15; apply q15;\n       apply q15; apply q15; apply q15; apply q15;\n       apply q15; apply q15; apply q15; apply q15;\n       apply q15; apply q15; apply q15; apply qQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0;intro q;intros.\n  exists (b*a).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (a*b).\n  split; auto.\n  exists (b*a).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*a).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*a).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (b*b).\n  split; auto.\n  exists (Qed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros a b; split; auto.\n  intros.\n  generalize (gcd_lt_cases a b); intro.\n  generalize (gcd_gt_cases b a); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases b a); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases b a); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases b a); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases b a); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_cases a b); intro.\n  generalize (gcd_gt_Qed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\n  intros.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  generalize (gcd_mod a b); intro.\n  rewrite H0 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\n",
                "context_tokens": 619,
                "proof_start_offset": 1941,
                "proof_end_offset": 2205,
                "proof": "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\nunfold quotient_euclide;unfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n intros.\n destruct (mod_euclide a b H) as (q,Hr).\n destruct (mod_euclide a b H) as (q,Hr).\n destruct (mod_euclPackide a b H) as (r,Hr).\n rewrite Hr, Hr; simpl.\n rewrite (div_mod_idemp_l r r); simpl.\n destruct (mod_eucllinkide a r H) as (r,Hr).\n rewrite Hr; simpl.\n rewrite (div_mod_idemp_r r r); simpl.\n destruct (mod_eucl_aux (pos_div_eucl a b H) r) as (r,Hr).\n rewrite Hr; simpl.\n rewrite (div_mod_idemp_r r r); simpl.\n destruct (mod_eucl_aux (pos_div_eucl a b H) r) as (r,Hr).\n rewrite Hr; simpl.\n destruct r; tauto.\n destruct r; tauto.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  elim H;intro;intro r; case r;intro; case r;intro.\n  exists (r+0); exists r; split;try tauto.\n  exists (r+1); exists (r+1); split;try tauto.\n  elim (H0 r);intros.\n  rewrite H1;ring.\n  omega.\n  destruct (le_gt_dec a b); auto.\n  exists (r+1); exists (r+1); split;try tauto.\n  exists (r+1); exists (r+1); split;try tauto.\n  exists (r+1); exists (r+1); split;try tauto.\n  exists (r+1); exists (r+1); split;try tauto.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  case (mod_euclide a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\n  destruct r; tauto.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  case (mod_euclive (a/b) b H); intro.\n  apply (mod_unique_pos a (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos a) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos a) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\n  apply (mod_unique_pos (Zpos b) H).\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n intros.\n generalize (mod_euclOK _ _ H).\n case (mod_euclOK _ _ H); intros.\n rewrite H1; ring.\n rewrite H1; ring.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\nintros.\nunfold quotient_eucl in |- *.\nintros.\napply (le_lt_trans (quotient_mod_eq a b H) (quotient_mod_eq a b H)).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq a b H).\napply (quotient_mod_eq b c H).\napply (quotient_mod_eq a c H).\napply (quotient_mod_eq a c H).\napply (quotient_mod_eq a c H).\napply (quotient_mod_Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\nintros.\napply (eq_refl (div_eucl_OK a b H)).\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  rewrite <- (mod_mult_full a b H).\n  apply div_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.\n  apply mod_eucl_aux.Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  apply (H (n-a)).\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n intros.\n apply (lt_wf_rec a (fun a:nat => {q : nat | (a=b*q) /\\ (r < b) /\\ (r < b) /\\ (r < b) /\\ (r < b) /\\ (r < b)).\n  intros.\n  case (le_lt_dec a b);intro.\n  elim (le_gt_dec a b);intro.\n  elim (le_gt_dec a b);intro.\n  left; left; apply (H0 (n-b)); auto.\n  left; apply (H1 (n-b)); auto.\n  right; apply (H1 (n-b)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2233,
                "proof_end_offset": 2442,
                "proof": "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\nProof.\nunfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = b * q + r /\\ r < b}).\n  intros.\n  generalize (mod_lt_eq_cases a b);intro.\n  destruct (le_lt_dec a b);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl b);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl b);intro.\n  elim (lt_irrefl b);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl b);intro.\n  elim (lt_irrefl a);intro.\n  elim (lt_irrefl b);intro.\n  elim (lt_irrefl b);intro.\n  elim (lt_irrefl b);intro.\n  elim (lt_irrefl a);intro.Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold quot_eucl, modulo, modulo.\n  rewrite mod_eucl_ide.\n  generalize (mod_eucl_aux a b H);intros.\n  generalize (mod_eucl_aux a b H);intros.\n  elim H0;intro.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply mod_unique with b; auto.\n  apply modQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold quotient_eucl in |- *;unfold modulo in |- *;intros.\n  generalize (mod_lt_dec a b H);intros.\n  elim H;intro.\n  apply mod_small_pos.\n  rewrite <- H.\n  apply mod_small_pos.\n  rewrite <- H.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0.\n  apply mod_small_pos.\n  rewrite <- H0Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  elim H.\n  unfold modulo.\n  generalize (mod_lt_cases a b H);intro.\n  elim (mod_lt_dec a b H);intro.\n  elim (mod_lt_dec b a H);intro.\n  elim H1;intro.\n  apply (lt_irrefl 0).\n  apply (lt_trans _ _ _ _ _ H1).\n  apply (lt_trans _ _ _ _ H1).\n  apply (lt_trans _ _ _ _ H1).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H2).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ _ H2).\n  apply (lt_trans _ _ _ H1).\n  apply (lt_trans _ _ H1).\n  apply (lt_Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros a b H.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (r,H).\n  exists r.\n  split;try tauto.\n  destruct (H a b H) as (Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  generalize (mod_euclOK a b H);intros.\n  generalize (mod_euclOK a b H);intros.\n  elim H;intro r.\n  tauto.\n  elim H;intro r.\n  tauto.\n  tauto.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold quotient_eucl, div_eucl in H.\n  destruct H as (_,H).\n  exists (q+1);exists (q+1);exists (q+1);exists (q+1);auto.\n  destruct q;intro r;intro.\n  exists r;exists (r+1);exists (r+1);exists (r+1);exists (r+1);auto.\n  destruct q;intro r;exists (r+1);exists r.\n  split;try tauto.\n  elim p;intro r;exists (r+1);exists r.\n  split;try tauto.\n  elim p;intro r;exists (r+1);exists r.\n  split;try tauto.\n  elim p;intro r;exists (r+1);exists r.\n  split;try tauto.\n  elim p;intro r;exists (r+1);exists (r+1);exists r.\n  split;try tauto.\n  elim p;intro r;exists (r+1);exists r.\n  split;try tauto.\n  elim p;intro r;exists (r+1);exists r.\n  split;try tauto.\n  elim p;intro r;exists (r+Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\nProof.\n  unfold quotient_eucl, modulo, modulo, modulo, modulo, modulo, modulo, modulo.\n  intros.\n  generalize (mod_mod_eq a b H);intros.\n  generalize (mod_mod_eq a b H);intros.\n  generalize (mod_mod_eq b b H);intros.\n  elim H1;intro.\n  rewrite H1; auto.\n  rewrite H1; auto.\n  rewrite H1; auto.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold modulo, modulo, modulo, modulo; intros.\n  generalize (mod_lt_dec a b H);intro.\n  destruct (mod_lt_dec b a) as [H|H]; rewrite H; auto.\n  destruct (mod_lt_dec a b) as [H|H]; rewrite H; auto.\n  destruct (mod_lt_dec a b) as [H|H]; rewrite H; auto.\n  destruct (mod_lt_dec a b) as [H'|H']; rewrite H'; auto.\n  destruct (mod_lt_dec a b) as [H'|H']; rewrite H'; auto.\n  destruct (mod_lt_dec a b) as [H'|H']; rewrite H'; auto.\n  destruct (mod_lt_dec a b) as [H'|H']; rewrite H'; auto.\n  destruct (mod_lt_dec a b) as [H'|H']; rewrite H'; auto.\n  destruct (mod_lt_dec a b) as [H'|H']; rewrite H'; auto.\n  destruct (mod_lt_dec a b) as [H'|H']; rewrite H'; auto.\n  destruct (mod_lt_dec a bQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  elim (H b);intro.\n  elim H;intro.\n  left; apply (H b);intro.\n  right; apply (H b);intro.\n  apply (H b);intro.\n  elim H;intro.\n  right; apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (H b);intro.\n  apply (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\n",
                "context_tokens": 700,
                "proof_start_offset": 2478,
                "proof_end_offset": 3403,
                "proof": "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros.\nrewrite H1 in H0.\ncase (lt_eq_lt_dec q q');intro.\ncase s;intro.\nrewrite (le_plus_minus q q') in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (b*(q'-q)+r' = r).\napply plus_reg_l with (b*q).\nrewrite plus_assoc;trivial.\nassert (0<(q'-q));try omega.\nassert (b<=b*(q'-q));try omega.\ncase (mult_O_le b (q'-q));intro;try omega.\nrewrite mult_comm;trivial.\nsplit;try tauto.\nrewrite <- e in H0.\nsymmetry;apply plus_reg_l with (b*q);trivial.\nrewrite (le_plus_minus q' q) in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (r'=(b*(q-q')+r)).\napply plus_reg_l with (b*q').\nrewrite plus_assoc;trivial.\nassert (0<(q-q'));try omega.\nassert (b<=b*(q-q'));try omega.\ncase (mult_O_le b (q-q'));intro;try omega.\nrewrite mult_comm;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros.\n unfold modulo in H.\n generalize (lt_wf_rec a b q r' r' H H0).\n unfold modulo in H.\n generalize (lt_wf_rec a b q r' H0).\n unfold modulo in H.\n generalize (lt_wf_rec a b q r' H H0).\n unfold modulo in H.\n generalize (lt_wf_rec a b q r' r' H0 H1).\n unfold modulo in H.\n generalize (lt_wf_rec b q r' r' H0 H1).\n unfold modulo in H.\n generalize (lt_wf_rec b q r' r' H0 H1).\n unfold modulo in H.\n generalize (lt_wf_rec b q r' r' H0 H1).\n unfold modulo in H.\n generalize (lt_wf_rec b q r' r' H0 H1).\n unfold modulo in H.\n generalize (lt_wf_rec b q r' r' H0 H1).\n unfold modulo in H.\n generalize (lt_wf_rec b q r' r' r' H0 H1).\n unfoldQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros a b q r' r' r' H.\n unfold div in |- *; unfold div in |- *; unfold div in |- *; unfold div in |- *; unfold div in |- *;\n unfold div in |- *; unfold div in |- *;\n unfold div in |- *; unfold div in |- *;\n unfold div in |- *; unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *; unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfold div in |- *;\n unfoldQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros.\n apply (lt_wf_rec a b q r' r' r' r' r' r'); auto.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros a b q r q r' r' r' r' r' r' r' r' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r''Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros a b q r' r' r'' H H0 H1.\n destruct (q?= r');unfold quotient_eucl in *.\ngeneralize (mod_unique a b q r' r'' H0);intros.\nelim (div_mod_euclide a b q r' r'' r'' r'' r'' r'' H0 H1).\nintros.\nelim H0;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro.\nelim r;intro r;intro r; elim r;intro.\nrewrite <- H0; auto.\nrewrite <- H0; auto.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n  intros.\n  generalize (same_eq_cases a b q r' r' r' r' H H0); intuition.\n  generalize (same_eq_cases a b q r' r' H0); intuition.\n  generalize (same_eq_cases b q r' r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' r' r' H0); intuition.\n  generalize (same_eq_cases a b q r' H0); intuition.\n  generalize (same_eq_cases b q r' r' H0); intuition.\n Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros.\n apply eZdivide_mod_unique with (a/b) (b/q) (r/r');auto.\napply eZdivide_mod_unique with (a/b) (b/r);auto.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n  intros.\n  generalize (mod_unique_pos a b q r' r' r' H H1 H2); intros.\n  elim (mod_unique_pos a b q r' r' H2); intros.\n  elim (mod_unique_pos a b q r' r' H1); intros.\n  elim (mod_unique_pos b q r' r' r' H2); intros.\n  elim (mod_unique_pos a b q r' r' H2); intros.\n  elim (mod_unique_pos a b q r' r' H2); intros.\n  elim (mod_unique_pos b q r' r' H2); intros.\n  elim (mod_unique_pos a b q r' r' H2); intros.\n  elim (mod_unique_pos a b q r' r' H3); intros.\n  elim (mod_unique_pos a b q r' r' H3); intros.\n  elim (mod_unique_pos a b q r' r' H3); intros.\n  elim (mod_unique_pos a b q r' r' H4); intros.\n  elim (mod_Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros.\n apply (lt_wf_rec a b q r' r' r' r' r' r' r' r' r' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' r'' rQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n unfold div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl,\n    div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl,\n    div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl,\n    div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl,\n    div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl,\n    div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl,\n    div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl, div2_eucl,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \n",
                "context_tokens": 721,
                "proof_start_offset": 3449,
                "proof_end_offset": 4020,
                "proof": "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\nintros.\nred.\nsplit;intro.\ngeneralize (quo_rem_euclide a b H);intro.\ngeneralize (rem_euclide a b H);intro.\nelim H0;intro q;intro.\nassert (a=b*q+0).\nrewrite plus_comm;simpl;trivial.\nassert (0<b);try omega.\ngeneralize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\nintros;tauto.\ngeneralize (quo_rem_euclide a b H).\nrewrite H0;rewrite plus_comm;simpl.\nintro;exists (quotient_euclide a b H);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n intros a b H; generalize (H a); clear H.\n intros.\n rewrite (le_plus_minus q p) in H.\n destruct (le_gt_dec a b);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl b);intro.\n elim (lt_irrefl b);intro.\n elim (lt_irrefl b);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\nelim (lt_irrefl a);intro.\nelim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\n elim (lt_irrefl a);intro.\nelim (lt_irrefl a);intro.\nelim (lt_irrefl a);intro.\nelim (lt_irrefl a);introQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n intros.\n destruct a.\n rewrite (gcd_euclide a b H).\n rewrite (gcd_euclide a b H).\n rewrite (gcd_euclide a b H).\n rewrite (gcd_eucl Export Hq.\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_eucl Export Hq).\n rewrite (gcd_euclQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  unfold modulo;intros.\n  elim H;intro r;intro.\n  elim r;intro r;intro.\n  tauto.\n  elim r;intro r;intro.\n  elim r;intro r;intro.\n  tauto.\n  elim r;intro r;intro.\n  elim r;intro.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n  tauto.\n  elim r;intro.\n Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  unfold modulo;intro.\n  generalize (gcd_eucl_OK _ _ H);intro.\n  elim (gcd_eucl_OK _ _ H);intro.\n  elim H;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_r in H0.\n  assert (0<=(r*(a/b))) by auto with arith.\n  rewrite (mult_comm r); try (auto with arith).\n  assert (0<(r*(a/b))) by auto with arith.\n  rewrite (mult_comm r); try (auto with arith).\n  rewrite (mult_comm r); try (auto with arith).\n  apply mult_reg_l with (b*q); auto with arith.\n  rewrite (mult_comm r); try (auto with arith).\n  rewrite (mult_comm r); try (auto with arith).\n  rewrite (mult_comm r); try (auto with arith).\n  rewrite mult_plus_distr_r in H0.\n  assert (b*(a/b)) by auto with arith.\n  rewrite (mult_comm r); try (auto with arith).\n  rewrite (mult_commQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  unfold modulo, modulo.\n  generalize (gcd_eucl ce H);intros.\n  elim (gcd_euclOK a b H);intros.\n  elim (gcd_euclOK a b H);intros.\n  elim (gcd_euclOK a b H);intros.\n  elim H;intro r;intro.\n  elim r;intro.\n  tauto.\n  elim H;intro r.\n  tauto.\n  elim H;intro r.\n  tauto.\n  elim H;intro r;tauto.\n  elim H;intro r.\n  tauto.\n  elim H;intro r.\n  tauto.\n  elim H;intro r.\n  tauto.\n  elim H;intro r;tauto.\n  elim H;intro r.\n  tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;intro r; tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;intro r;tauto.\n  elim H;introQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n intros.\n apply (gcd_unique a b H H).\n rewrite (gcd_eucl inversion_unique with (a/b);trivial.\n apply (gcd_unique a b H H).\n rewrite (gcd_eucl inversion_unique with (a/b);trivial.\nQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  apply (gcd_pos_euclaux (pos a) H).\n  apply (gcd_pos_euclNonneg (pos a) H).\n  apply (gcd_pos_euclNonneg (pos a) H).\n  apply (gcd_pos_euclOK (pos a) H).\n  apply (gcd_pos_euclaux (pos a) H).\n  apply (gcd_pos_euclaux (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_eucl (pos a) H).\n  apply (gcd_pos_Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\n  unfold modulo_eucl at 2;unfold modulo;unfold modulo;\n  intros.\n  elim H;intro r;intro.\n  rewrite (lt_O_Sn r).\n  apply (lt_O_Sn r).\n  apply (lt_O_Sn r).\n  apply (lt_O_Sn r).\n  apply (lt_O_Sn r).\n  apply (lt_Sn_r r).\n  apply (lt_O_Sn r).\n  apply (lt_Sn_r r).\n  apply (lt_O_Sn r).\nQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H in H.\n  case (le_gt_dec a b);intro.\n  elim (div_euclOK a b H);intro.\n  rewrite (le_plus_minus q q') in H.\n  apply (le_trans _ _ _ H H H1 H0).\n  apply le_plus_minus.\n  assumption.\n  assumption.\n  apply (le_trans _ _ _ H H H0 H1).\n  apply le_plus_minus.\n  assumption.\n  apply (le_trans _ _ _ H H H H0 H0).\nQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  unfold modulo in |- *;intros.\n  elim H;intro r;intro r;intro r;intro.\n  elim r;intro r;intro.\n  elim r;intro r;intro.\n  elim r;intro r;intro r; apply r;apply r;apply r;apply r;apply r;apply r;apply r;apply r; auto with arith.\n  elim r;intro r;apply r;apply r;apply r;apply r;apply r;apply r;apply r; apply r; auto with arith.\n  elim r;intro r;apply r;apply r;apply r;apply r;apply r;apply r; apply r; apply; auto with arith.\n  elim r;intro r;apply r;apply r;apply r;apply r; apply r; apply r; apply; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\n",
                "context_tokens": 735,
                "proof_start_offset": 4055,
                "proof_end_offset": 4426,
                "proof": "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\nintros.\ncase (eq_nat_dec b 0).\ncase (eq_nat_dec a 0);intros.\nrewrite e;left;apply zero_max_div.\nright;rewrite e;intro.\nelim H;intro q;intro.\nsimpl in H0;apply n;trivial.\nintro.\ncase (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n intros a b H.\n destruct (le_gt_dec a b); [left|right]; trivial.\n generalize (gcd_gt_cases a b H);intro.\n generalize (gcd_gt_cases a b H);intro.\n generalize (gcd_gt_cases a b H);intro.\n generalize (gcd_gt_cases a b H);intro.\n generalize (gcd_gt_cases a b H);intro.\n generalize (gcd_gt_cases b a H);intro.\n rewrite H in H.\n generalize (gcd_gt_cases b a H);intro.\n rewrite H in H.\n generalize (gcd_gt_cases a b H);intro.\n rewrite H in H.\n generalize (gcd_gt_cases b a H);intro.\n rewrite H in H.\n generalize (gcd_gt_cases b a H);intro.\n rewrite H in H.\n generalize (gcd_gt_cases a b H);intro.\n rewrite H in H.\n generalize (gcd_gt_cases a b H);intro.\n rewrite H in H.\n generalize (gcd_gt_cases a b H);intro.\n rewrite H in HQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\nintros a b H; split; intro H; elim H; intros H1 H2.\nrewrite (gcd_antisym a b H2); trivial.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intro.\n  case (gcd_eq_dec a b); intros.\n  generalize (gcd_bezout a b H);intro.\n  generalize (gcd_bezout_unique b b H);intro.\n  elim H;intro q;intro.\n  elim q;intro q;intro q;intro q.\n  elim q;intro q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q;intro q.\n  rewrite q;intro q; elim q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;intro q.\n  rewrite q;intro q; elim q;Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros a b H.\n  generalize (gcd_mod_eucl Intro a b H);intro.\n  generalize (gcd_mod_eucl cyc b H);intro.\n  elim (gcd_mod_eucl (mod_eucl a b H) (gcd_eucl_OK a b H));intro.\n  elim H;intro q;intro q; elim q;intro q;intro q; elim q;intro q; elim q;intro q;\n     elim q;intro q; intro q; elim q;intro q;\n     elim q;intro q; elim q;intro q;\n       elim q;intro q; elim q;intro q;\n       elim q;intro q; elim q;intro q; elim q;\n       intros q' H1 q'2;\n       elim q';intro q'3; elim q'3;intro q'3;\n       elim q';intro q'3; elim q'3; intro q'4;\n       elim q'3; intro q'5; elim q'6;\n       intros q'' H6 q'7; elim q'7; intro q''5;\n       elim q'5; intro q'6; elim q'6; introsQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize (gcd_divides a b H);intro.\n  generalize (gcd_mod_eucl_aux a b H);intro.\n  elim H.\n  elim H.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n  apply lt_wf.\n Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize (gcd_antisym a b H).\n  generalize (gcd_antisym a b H);intro.\n  generalize (gcd_antisym a b H).\n  generalize (gcd_antisym a b H);intro.\n  elim (gcd_antisym a b H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym a b H);intro.\n  elim (gcd_antisym a b H);intro.\n  elim (gcd_antisym a b H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b b H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_antisym b a H);intro.\n  elim (gcd_Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros a b H.\n  case (gcd_eucl_aux a b H);intros.\n  destruct (gcd_eucl_aux a b H);intros.\n  rewrite <- H; auto.\n  rewrite <- H; auto.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intro a.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec b a); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec b a); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec a b); auto.\n  destruct (divide_dec b a); auto.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  generalize (divide_refl a b H).\n  unfold gcd in |- *.\n  intros.\n  generalize (divide_refl a b H).\n  unfold gcd in |- *.\n  intros.\n  elim (divide_refl a b H).\n  intros.\n  rewrite (divide_0_r a b H).\n  apply (divide_refl a b H).\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  red.\n  split.\n  generalize (divide_refl a b H).\n  intros.\n  elim (divide_refl b a H).\n  generalize (divide_refl b a H).\n  intros.\n  elim (divide_refl a b H).\n  intros.\n  elim (divide_trans b a b H).\n  intros.\n  apply (divide_refl b a H).\n  split.\n  generalize (divide_refl a b H).\n  intros.\n  elim (divide_trans b a b H).\n  intros.\n  apply (divide_refl b a H).\n  apply (divide_trans b a H).\n  intros.\n  apply (divide_refl b a H).\n  rewrite (divide_refl b a H).\n  auto with *.\n  auto with *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\n",
                "context_tokens": 685,
                "proof_start_offset": 4561,
                "proof_end_offset": 4980,
                "proof": "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\nintros.\ninduction m.\nright;intros;inversion H0.\ncase (H m);intro.\nleft;exists m;split;try (auto with arith).\ncase IHm;intro.\nelim s;intro n0;intro.\nleft;exists n0;split;[omega | tauto].\nright;intros.\ninversion H0;trivial.\napply n0;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\nintros P H.\napply dec_eq_dec with (P:=P);intro.\ncase (lt_eq_nat_dec (P:=P) (P:=P));intro.\nrewrite e;intro.\napply n;trivial.\nintro n.\nelim H;intro q;intro.\nrewrite e;intro.\nelim H0;intro q;intro q.\nrewrite (le_plus_minus q q) in H0;intros.\nelim H0;intro q;intro q.\nrewrite (le_plus_minus q q) in H0;intros.\nelim H0;intro q;intro q.\nrewrite (le_plus_minus q q) in H0;intros.\nelim H0;intro q;intro q.\nrewrite (le_plus_minus q q) in H0;intros.\nelim H0;intro q;intro q.\nrewrite (le_plus_minus q q) in H0;intros.\nelim H0;intro q;intro q.\nrewrite (le_plus_minus q q) in H0;intros.\nelim H0;intro q;intro q.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\n  intros.\n  case (eq_nat_dec m 0).\n  intros.\n  rewrite e;intro.\n  rewrite (le_plus_minus p q) in H.\n  assert (a<=n) by (apply H; auto).\n  rewrite (le_plus_minus p q) in H0.\n  apply H0; auto.\n  apply (le_minus_lt_eq (S m) q) in H0.\n  destruct H0 as [H1|H1].\n  rewrite (le_plus_minus q q) in H1.\n  apply H1; auto.\n  apply (le_minus_lt_eq (S m) q) in H1.\n  destruct H1 as [H1|H1].\n  rewrite (le_plus_minus q q) in H1.\n  apply H1; auto.\n  apply (le_minus_lt_eq (S m) q) in H1.\n  destruct H1 as [H1|H1].\n  rewrite (le_plus_minus q q) in H1.\n  apply H1; auto.\n  apply (le_minus_lt_eq (S m) q) in HQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\n intros.\n destruct (le_or_lt_dec (P n) 0).\n  left; split; auto.\n  right;rewrite <- H0; auto.\n  right;rewrite <- H1; auto.\n  right;rewrite <- H1; auto.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\n  intros.\n  case (eq_nat_dec (P m) (P m));intros.\n  case (eq_nat_dec (P m) (P m));intros.\n  rewrite e;intro.\n  apply n;trivial.\n  intro.\n  case (eq_nat_dec (P m) (P m));intros.\n  rewrite e;intro.\n  apply H;trivial.\n  intro.\n  case (eq_nat_dec (P m) (P m));intros.\n  rewrite e;intro.\n  apply H;trivial.\n  apply H;trivial.\n  apply H;trivial.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (dec_eq_dec n 0);intros.\n  rewrite e;intro.\n  elim H;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  right;rewrite H0;intro.\n  elim H0;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  elim H0;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  elim H0;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  elim H0;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  elim H0;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  elim H0;intro.\n  simpl in H0;apply n;trivial.\n  right;rewrite H0;intro.\n  elim H0;intro.\n  simpl in H0;apply n;trivialQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (lt_eq_nat_dec (P m) (P (S m)) (P (S m)));intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\n  intros.\n  case (dec_eq_nat n 0).\n  intros.\n  apply H; trivial.\n  apply H; trivial.\n  apply H; trivial.\n  apply H; trivial.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\nintros.\nrewrite <- H in H0.\ndestruct H0 as [H0 H1].\nrewrite <- H1 in H.\ndestruct H.\nrewrite <- H1 in H.\napply H0 in H0;auto.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (lt_eq_dec m 0);intros.\n  rewrite e;right;intro.\n  apply n;trivial.\n  left;trivial.\n  right;intro.\n  right;intro.\n  apply n;trivial.\n  right;intro.\n  right;intro.\n  apply n;trivial.\n  right;intro.\n  apply n;trivial.\n  right;intro.\n  apply n;trivial.\n  right;intro.\n  apply n;trivial.\n  right;intro.\n  apply n;trivial.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n intros.\n destruct (dec_prop_dec P m); [left|right];intros;left;apply succ_inj; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\nLemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  induction m.\n  right;intros;inversion H0.\n  case (H m);intro.\n  left;exists m;split;try (auto with arith).\n  case IHm;intro.\n  elim s;intro n0;intro.\n  left;exists n0;split;[omega | tauto].\n  right;intros.\n  inversion H0;trivial.\n  apply n0;omega.\nQed.\n\n(** forall n, either forall p, p<>1 /\\ p<>n -> not(p | n) or there is p such that p<>1 and p<>n and p | n *) \n",
                "context_tokens": 706,
                "proof_start_offset": 5092,
                "proof_end_offset": 5809,
                "proof": "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\nintros.\ncase (dec_impl_lt_dec (fun p => (p<>1)/\\(divides n p))) with n;intros.\ncase (divides_dec n n0);intro.\ncase (eq_nat_dec n0 1);intros.\nright;intro;tauto.\nleft;tauto.\nright;tauto.\nelim s;intros.\nleft;exists x.\nsplit;try tauto.\nsplit;try tauto.\nomega.\ncase (eq_nat_dec n 0);intro.\nrewrite e;left;exists 2.\nsplit;try (intro;discriminate).\nsplit;try (intro;discriminate).\napply zero_max_div.\nright;intros.\ncase (lt_eq_lt_dec p n);intro.\ncase s;intro;[red in n0;intro;apply n0 with p;tauto | auto].\nintro;generalize (divides_le n p n1 H1);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (le_lt_dec n p) as [H|[H|H]].\n  right;apply H;auto.\n  right;apply H;auto.\n  right;apply H;auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n intros.\n destruct (le_lt_dec n 0).\n destruct (le_gt_dec p n); auto.\n destruct (le_gt_dec p n); auto.\n destruct (le_gt_dec n p); auto.\n destruct (le_gt_dec n p); auto.\n destruct (le_gt_dec p n); auto.\n destruct (le_gt_dec n p); auto.\n destruct (le_gt_dec n p); auto.\n right;intros.\nabsurd (n=0); auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (le_gt_dec n p) as [H|H].\n  left;exists n.\n  right;exists n.\n  exists (S p).\n  split;auto with arith.\n  apply le_trans with n;auto with arith.\n  apply le_trans with (S p);auto with arith.\n  apply le_trans with (S p);auto with arith.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (le_ge_dec n p).\n  left;exists n;split;try (auto with arith).\n  left;exists n;split;[omega| right];intros.\n  right;intros;inversion H0;auto.\n  left;exists n0;split;[omega| right];intros.\n  right;intros;inversion H0;auto.\n  right;intros;inversion H0;auto.\n  right;intros;inversion H0;auto.\n  right;intros;inversion H0;auto.\n  right;intros;inversion H0;auto.\n  right;intros;inversion H0;auto.\n  right;intros;inversion H0;auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  elim (le_not_lt 0 n);intros.\n  left;apply H; auto with arith.\n  left;apply H1; auto with arith.\n  right;apply H1; auto with arith.\n  right;apply H; auto with arith.\n  right;apply H1; auto with arith.\n  left;apply H1; auto with arith.\n  right;apply H1; auto with arith.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\n intros.\n generalize (le_not_lt (p/2) (p/2)).\n rewrite <- (le_succ_r p); auto with arith.\n generalize (le_not_lt (p/2) (p/2)).\n rewrite <- (le_succ_l p); auto with arith.\n generalize (le_not_lt (p/2) (p/2)).\n rewrite <- (le_succ_r p); auto with arith.\n generalize (lt_not_lt (p/2) (p/2)).\n rewrite <- (le_succ_l p); auto with arith.\n generalize (le_not_lt (p/2) (p/2)).\n rewrite <- (le_succ_r p); auto with arith.\n generalize (le_not_lt (p/2) (p/2)).\n rewrite <- (le_succ_l p); auto with arith.\n generalize (le_not_lt (p/2) (p/2)).\n rewrite <- (le_succ_r p); auto with arith.\n generalize (le_not_lt (p/2) (p/2)).\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\n  intros.\n  destruct (le_gt_dec p (p>0)); auto.\n  right;intros;inversion H0.\n  destruct (le_gt_dec p (p>1)); auto.\n  left;intros;inversion H0.\n  right;intros.\n  destruct (le_gt_dec p (p>1)); auto.\n  left;intros.\n  destruct (le_gt_dec p (p>1)); auto.\n  right;intros;inversion H1.\n  destruct (le_gt_dec p (p>1)); auto.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  destruct (le_gt_dec p (p>1)); auto.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  destruct (le_gt_dec p (p>1)); auto.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  right;intros;inversion H1.\n  destruct (le_gt_dec p (pQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (le_lt_dec n p);intros.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  right;intros;inversion H.\n  left;intros;inversion H.Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct (le_gt_dec n p).\n  left;intros.\n  generalize (n!p).\n  intro H1.\n  destruct (le_gt_dec n p).\n  left;auto with arith.\n  right;intros.\n  right;auto with arith.\n  right;intros.\n  elim H0;intro n1;intro.\n  right;intros.\n  right;intros.\n  elim H1;intro.\n  left;auto with arith.\n  right;intros.\n  elim H1;intro.\n  left;auto with arith.\n  right;intros.\n  right;intros.\n  elim H1;intro.\n  right;auto with arith.\n  right;intros.\n  elim H1;intro.\n  left;auto with arith.\n  right;intros.\n  elim H1;intro.\n  right;intros.\n  elim H1;intro.\n  right;intros.\n  elim H1;intro.\n  left;auto with arith.\n  right;intros.\n  elim H1;intro.\n  left;auto with arith.\n  right;intros.\n  elim H1;intro.\n  left;auto with arith.\n  right;intros.\n  elim H1;intro.Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n intros.\n generalize (le_gt_dec (p~0) (p~1)).\n destruct (le_gt_dec p (p~1) (p~1)).\n left.\n split;intro.\n generalize (le_gt_dec (p~1) (p~1));intro.\n generalize (le_gt_dec (p~1) (p~1));intro.\n elim H1;intro.\n left.\n exists (p~1);split;[omega | tauto].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\n",
                "context_tokens": 382,
                "proof_start_offset": 1408,
                "proof_end_offset": 2212,
                "proof": "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_square;trivial.\nexists (k*(square b)).\nrewrite <- H2;ring.\nelim H3;intro n_a;intro.\nrewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\nassert (k*(b*b)=p*(n_a*n_a)).\napply mult_lemma6 with p.\nintro H5;rewrite H5 in H;apply not_prime_zero;trivial.\nrewrite mult_assoc;rewrite H2;ring.\nassert (divides b p).\napply prime_square;trivial;unfold square.\napply gauss with k.\napply rel_prime_sym;trivial.\nexists (n_a*n_a);trivial.\nassert (p=1).\nunfold rel_prime in H1.\nelim H1;intros.\napply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nelim H;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n apply Z_le_lt_trans with (2*(a/b))).\n apply Z_le_succ_r; assumption.\n apply Z_le_succ_l; assumption.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n generalize (is_prime_is_pos p).\n intros (H1,H2).\n generalize (is_prime_is_pos p).\n intros (H1,H2).\n rewrite H1.\n apply Qlt_le_weak; apply (p_lt_trans _ _ H1).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_trans _ _ _ H2).\n apply Qlt_le_weak; apply (p_lt_transQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b.\n destruct (lt_le_dec a b) as [H|H].\n apply (lt_le_trans _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _ _ _ H).\n apply (le_lt_trans _Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n destruct (is_prime_dec (p*k) (p*k*k*k*k*k*k*k*k*k) as [H|H].\n apply (gcd_prime_non_pos a b c).\n assumption.\n apply (gcd_prime_non_pos a b c).\n assumption.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b; unfold rel_prime.\n case (is_prime_dec a); intros H;\n [ apply False_ind; apply (H (2*(p+k*(a+k*(a+k*(a+k*(a+k*(a+k*a))))%R); \n apply is_prime_ind; apply (H (2*(p+k*(a+k*(a+k*(a+k*(a+k*a))))%R); \n apply is_prime_ind; apply (H (2*(p+k*(a+k*(a+k*a))))%R; \n apply is_prime_ind; apply (H (2*(p+k*(a+k*(a+k*(a+k*(a+k*(a+k*a))))%R); \n apply is_prime_ind; apply (H (2*(p+k*(a+k*a))))%R; \n apply is_prime_ind; apply (H (2*(p+k*(a+k*a))))%R; \n apply is_prime_ind; apply (H (2*(p+k*(a+k*(a+kQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros (p,p); unfold is_prime, rel_prime in |- *.\n destruct (is_prime_dec p) as [p| p].\n rewrite H; apply prime_prime_non_prime; auto.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b Ha Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_prime in Hb.\n unfold rel_Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b.\n destruct (le_gt_dec a 0) as [H|H]; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H|H]; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H'|H']; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H'|H']; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H'|H']; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H'|H']; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H'|H']; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H'|H']; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) as [H'|H']; [|discriminate].\n apply False_ind.\n destruct (le_gt_dec a 1) asQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_l _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_l _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_l _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_l _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_l _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_r _ _ H).\n apply (p_le_compat_r _ _Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b.\n destruct (le_dec (p*k*a)/p); [ left | right].\n destruct (le_dec (p*k*a) 0); [ right | right].\n apply (f_equal (fun k => mult_le_compat_l (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (S k) (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "t (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\nLemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\n",
                "context_tokens": 696,
                "proof_start_offset": 2307,
                "proof_end_offset": 3364,
                "proof": "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\nintro.\nrewrite H3 in H5.\nreplace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\nrewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\nassert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\napply mult_lemma6 with (square (gcd a b)).\nunfold square.\ngeneralize (gcd_non_zero (gcd a b) a b H1 H2);intro.\nintro;apply H6.\ncase (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\nrewrite <- H5;ring.\napply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  apply False_ind.\n  apply (fun x => proj1_sig (fun y => proj2_sig (H x)) H).\n  apply exist_prime_sym;apply prime_square;trivial.\n  apply prime_square;trivial.\n  rewrite <- H2;ring.\n  apply prime_square;trivial.\n  rewrite <- H2;ring.\n  apply prime_square;trivial.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  unfold sqrt in H.\n  unfold sqrt in H.\n  unfold sqrt in H.\n  unfold sqrt in H.\n  apply le_lt_trans with (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p))))) n))\n      (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S p) (sqrt (S (S p) (sqrt (S p) (sqrt (S p) (sqrt (S (S p) (sqrt (S p) (sqrt (S p) (S (sqrt (S p)Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n unfold is_prime in H.\n generalize (Z_div_mod_eq p k).\n unfold Z.modulo, Z.modulo, Z.modulo.\n destruct (Z_div_eucl_dec p k) as [H|H].\n apply prime_div_bound; trivial.\n apply H;compute; auto.\n apply H;compute; auto.\n apply H;compute; auto.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n unfold prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in |- *.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_prime in H.\n unfold rel_Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n  intros.\n  unfold prime.\n  case (prime_dec a b).\n  intros H1.\n  apply prime_square;trivial.\n  rewrite <- H1; rewrite H2; ring.\n  assert (a*b<>0).\n  apply prime_square;trivial.\n  exists (p*k*(a/b))).\n  rewrite <- H1; rewrite H2; ring.\n  assumption.\n  assumption.\n  apply prime_square;trivial.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n generalize (is_prime_inf (fun q : nat => is_prime p -> q = (1+1) -> q = (1+1) -> q = (1+1) -> q = (1+1) -> q = (1+1) -> q = (1).\n  intros.\n  generalize (is_prime_inf (fun q : nat => is_prime q -> q = (1+1) -> q = (1+1) -> q = q).\n  intros.\n  generalize (is_prime_inf (fun q : nat => is_prime q -> q = (1+1) -> q = (1 + 1) -> q = (1+1) -> q = (1 + 1) -> q = (1+1) -> q = q.\n  intros.\n  generalize (is_prime_inf (fun q : nat => is_prime q -> q = (1+1) -> q = 1 -> q = 1) -> q = 1.\n  intros.\n  generalize (is_prime_inf (fun q : nat => is_prime q -> q = (1+1) -> q = 1) (Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (a=0).\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  assert (a=0).\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply lt_le_weak; [apply lt_le_weak;auto| | apply lt_le_weak;auto].\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n intro.\n apply (sqrt_prime_irrat_aux (p:=p) (p:=p) (q:=p) (q:=p) (q:=p) (q:=q) (q:=p) (q:=p) (q:=q) (q:=q) (q:=p) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (q:=q) (Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  unfold is_prime in H.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_square;trivial.\n  apply prime_squareQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n destruct (dec_prime_inf p) as [H|H].\n (* 1 *)\n destruct (dec_prime_inf p) as [H'|H'].\n (* 1 *)\n rewrite H' in H; rewrite H' in H'.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H'.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\n rewrite <- H' in H.\n generalize (lt_irrefl _ H').\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\n",
                "context_tokens": 720,
                "proof_start_offset": 3417,
                "proof_end_offset": 3629,
                "proof": "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\nintros.\nreplace p with (p*1);try (auto with arith).\napply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd b (gcd a b) (gcd_gcd a b));intro.\n rewrite H0 in H.\n replace (gcd (gcd a b) (gcd a b) (gcd_gcd a b) (gcd_gcd a b)\n  in H;auto.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  destruct (gcd_is_gcd a b) as [H|H];\n  generalize (gcd_is_gcd a b);intro.\n  generalize (gcd_is_gcd b b);intro.\n  generalize (gcd_is_gcd a b);intro.\n  apply (gcd_is_gcd a b); trivial.\n  apply (gcd_is_gcd a b); trivial.\n  apply (gcd_is_gcd a b); trivial.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd b a);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (gcd_is_gcd a b);intro.\napply gcd_nonneg_l;assumption.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd b (gcd a b) (gcd_gcd a b) b H);intro.\n apply (gcd_is_gcd b (gcd a b) (gcd_gcd a b)); trivial.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd a b);intro.\n rewrite H3 in H2;apply not_prime_non_zero;trivial.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (spec_is_gcd b a);intro.\n generalize (Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (sqrt_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd b b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd b b);intro.\n generalize (gcd_is_gcd b b);intro.\n generalize (gcd_is_gcd b b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd b b);intro.\n generalize (gcd_is_gcd b b);intro.\n generalize (gcd_is_gcd b b);intro.\n generalize (Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n unfold sqrt.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd b c);intro.\n rewrite <- H3 in H4.\n generalize (gcd_is_gcd a b);intro.\n rewrite <- H4 in H4.\n apply (gcd_is_gcd a b); trivial.\n apply H4.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n generalize (spec_is_gcd a b);intro.\n generalize (spec_is_gcd a b);intro.\n rewrite H1 in H.\n replace (1*a) with 1.\n apply gcd_eq.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;compute; auto.\n apply div_prime_sym;computeQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3719,
                "proof_end_offset": 3854,
                "proof": "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\nintros.\napply sqrt_prime;trivial.\napply is_prime_2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply (sqrt_prime_irrat_aux p q H).\n  apply (sqrt_prime_irrat_aux p q H).\n  apply (sqrt_prime_irrat_aux p q H).\n  apply (sqrt_correct_irrat_aux p q H).\n  apply (sqrt_correct_irrat_aux p q H).\n  apply (sqrt_correct_nondiv_aux p q H).\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_2_correct_non_zero.\n  apply sqrt_2_correct_non_zero.\n  apply sqrt_2_correct_non_zero.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  destruct (le_ge_dec p q) as [H|H].\n  (* case *)\n  apply sqrt_spec_1; auto with zarith.\n  (* case *)\n  apply sqrt_spec_2; auto with zarith.\n  (* case *)\n  apply sqrt_spec_2; auto with zarith.\n  (* case *)\n  apply sqrt_spec_3; auto with zarith.\n  (* case *)\n  apply sqrt_spec_2; auto with zarith.\n  (* case *)\n  apply sqrt_spec_3; auto with zarith.\n  (* case *)\n  apply sqrt_spec_3; auto with zarith.\n  (* case *)\n  apply sqrt_spec_3; auto with zarith.\n  (* case *)\n  apply sqrt_spec_2; auto with zarith.\n  (* case *)\n  apply sqrt_spec_3; auto with zarith.\n  (* case *)\n  apply sqrt_spec_3; auto with zarith.\n  (* case *)\n  apply sqrt_spec_3; auto with zarith.\n  (* case *)\n  apply sqrt_spec_4; auto with zarith.\n  (* case *)\n  apply sqrt_spec_4; auto with zarith.\n  (* case *)\n  apply sqrt_spec_4;Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  generalize (sqrt_spec (fun q : nat => div_pos q) (div_q (gcd a b) (gcd_div_l (gcd a b) b H2))).\n  generalize (sqrt_spec (fun q : nat => div_pos q) (div_div_r (gcd a b) b H2)).\n  intro.\n  apply sqrt_spec_correct.\n  generalize (sqrt_spec (fun q : nat => div_pos q) (div_r (gcd a b) (gcd_div_r (gcd a b) b H2))).\n  apply sqrt_spec_correct.\n  generalize (sqrt_spec (fun q : nat => div_pos q) (div_r (gcd a b) (gcd_div_r (gcd a b) b H2))).\n  apply sqrt_spec_correct.\n  generalize (sqrt_spec (fun q : nat => div_pos q) (div_r (gcd a b) (gcd_div_r (gcd a b) b H2))).\n  generalize (sqrt_spec (fun q : nat => div_pos q) (div_r (gcd a b) (gcd_divQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\n  intros.\n  unfold sqrt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt.\n  apply sqrt_2_alt_2.\n  apply sqrt_2_Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  destruct (le_gt_dec q 0) as [q|q].\n  apply (sqrt_correct (fun n => (2 * n + 1)%Z)) (sqrt_correct (fun n => (2 * n + 1)%Z)) (sqrt_correct (fun n => (2 * n + 1)%Z)) q).\n  intros.\n  destruct (le_gt_dec q 0) as [q|q].\n  apply (sqrt_correct (fun n => (2 * n + 1)%Z)) (sqrt_correct (fun n => (2 * n + 1)%Z)) (sqrt_correct (fun n => (2 * n + 1)%Z)) q).\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  apply sqrt_2_correct.\n  applyQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply (sqrt_is_gcd a b);auto with zarith.\n  apply (sqrt_is_gcd a b);auto with zarith.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  destruct (dec_prime p) as [q|q].\n  destruct (dec_prime q) as [q|q].\n  destruct (dec_prime q) as [q|q].\n  simpl in *.\n  elim (dec_prime q).\n  apply prime_square_1 with q.\n  apply prime_square_2 with q.\n  apply prime_square_1 with q.\n  apply prime_square_2 with q.\n  apply prime_square_2 with q.\n  apply prime_square_2 with q.\n  apply prime_square_1 with q.\n  apply prime_square_2 with q.\n  apply prime_square_2 with q.\n  apply prime_square_3 with q.\n  apply prime_square_3 with q.\n  apply prime_square_4 with q.\n  apply prime_square_4 with q.\n  apply prime_square_3 with q.\n  apply prime_square_4 with q.\n  apply prime_square_4 with q.\n  apply prime_square_4 with q.\n  apply prime_square_4 with q.\n  apply prime_square_5 with q.\n  apply prime_square_4 with (Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\n intros.\n generalize (spec_div_mod a b);intro.\n generalize (spec_div_mod a b);intro.\n generalize (spec_div_mod a b);intro.\n generalize (spec_div_mod a b);intro.\n generalize (spec_div_mod a b);intro.\n generalize (spec_div_mod b a);intro.\n generalize (spec_mod b a);intro.\n generalize (spec_mod b a);intro.\n rewrite <- H5 in H5.\n generalize (spec_mod b a);intro.\n rewrite <- H5 in H5.\n apply mod_small; trivial.\n rewrite <- H6 in H5.\n apply mod_small; trivial.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\n intros.\n assert (H:= sqrt_nonneg_nonneg_nonneg p).\n generalize (sqrt_nonneg_nonneg p).\n unfold sqrt. destruct p.\n destruct q.\n exists (p+q);intros.\n destruct q;intros.\n destruct q;intros;simpl;intros;rewrite H;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": ".\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\n",
                "context_tokens": 694,
                "proof_start_offset": 3878,
                "proof_end_offset": 5151,
                "proof": "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_power with n;trivial.\ngeneralize (power_divides_lemma1 r p H1);intro.\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite <- H4;exists (q*k*(power b n));ring.\nassert (divides b p).\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite power_mult_lemma1 in H4.\nassert ((power p n)=(power p (r+(n-r)))).\nrewrite <- le_plus_minus;try (auto with arith).\nrewrite H7 in H4;rewrite power_plus_lemma1 in H4.\nassert ((power p r)<>O).\nintro.\napply not_prime_zero.\nassert (p=O).\napply power_zero with r;trivial.\nrewrite H9 in H;trivial.\nrewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\nassert (divides (power p (n-r)) p).\napply power_divides_lemma1;apply minus_lt_lemma1;trivial.\napply prime_power with n;trivial.\napply gauss with k;try (apply rel_prime_sym;trivial).\nrewrite H9;apply divides_mult;trivial.\nelim H3;intros.\nelim H;intros.\napply H9;apply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply (is_prime_2_correct p k a b n r).\n  apply (is_prime_2_correct p k b n r).\n  apply (is_prime_2_correct (prime_2 a b n r) (prime_2_correct q n r)).\n  apply is_prime_2_correct_divisors; apply is_prime_2.\n  apply is_prime_1_correct_divisors; apply is_prime_1.\n  apply is_prime_2.\n  apply is_prime_1.\n  apply is_prime_2.\n  apply is_prime_1.\n  apply is_prime_2.\n  apply is_prime_1.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_1.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_1.\n  apply is_prime_1.\n  apply is_prime_2.\n  apply is_prime_1.\n Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply is_prime_2;trivial.\n  apply (is_prime_2_dec (pos a) (pos b));trivial.\n  apply is_prime_2_dec; trivial.\n  apply is_prime_2_dec; trivial.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply (is_prime_2_non_zero p q n (lt_O_Sn n) H).\n  apply (is_prime_2_non_zero p q n (lt_O_Sn n) H).\n  apply H.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply (is_le_lt_or_eq _ _ H).\n  apply is_prime_2.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n r H.\n  apply (fun (q:nat)(r:nat)(b:nat)(q:nat)(r:nat)(r:nat)(r:nat)(r':nat)(r':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(l'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':nat)(r'':Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply (proj1_sig (fun q => proj1_sig (fun q => proj2_sig q)) p q); trivial.\n  apply is_prime_1.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n r H.\n  destruct (lt_trichotomy 0 r) as [H|H].\n  - (* case *)\n    destruct (lt_trichotomy 0 r) as [H|H].\n    * (* case *)\n      rewrite H.\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_trans _ _ H).\n      apply (not_le_Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  destruct (lt_dec a 0) as [H|H].\n  (* 0 *)\n  apply lt_le_trans with (log2 (S (2*n)) + (log2 (S (2*n))) by omega.\n  apply mult_le_compat_l.\n  apply le_trans with (log2 (S (2*n))).\n  apply le_S_n.\n  apply le_trans with (log2 (S (2*n))).\n  apply le_S_n.\n  apply le_S_n.\n  apply le_S_n.\n  apply le_trans with (log2 (S (2*n))).\n  apply le_S_n.\n  apply le_trans with (log2 (S (2*n))).\n  apply le_S_n.\n  apply le_trans with (log2 (S (2*n))).\n  apply le_S_n.\n  apply le_trans with (log2 (S (2*n))).\n  apply le_S_n.\n  apply le_trans with (log2 (S (2*n))).\n  apply le_S_n.\n  apply le_SQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply (is_prime_2_correct p (fun k a b => proj1_sig (pos_div_r a b) (pos_div_r a b)) (pos_div_r a b)); auto with arith.\n  apply is_prime_2.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  generalize (lt_wf_ind p k a b n r);intro.\n  pattern r at 2 in |- *.\n  intros.\n  apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind;\n    apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind;\n      apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind;\n        apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind;\n        apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind;\n        apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind;\n        apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind; apply lt_wf_ind;\n        apply lt_wf_ind; apply lt_wf_ind;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\nLemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_power with n;trivial.\n  generalize (power_divides_lemma1 r p H1);intro.\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite <- H4;exists (q*k*(power b n));ring.\n  assert (divides b p).\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite power_mult_lemma1 in H4.\n  assert ((power p n)=(power p (r+(n-r)))).\n  rewrite <- le_plus_minus;try (auto with arith).\n  rewrite H7 in H4;rewrite power_plus_lemma1 in H4.\n  assert ((power p r)<>O).\n  intro.\n  apply not_prime_zero.\n  assert (p=O).\n  apply power_zero with r;trivial.\n  rewrite H9 in H;trivial.\n  rewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\n  assert (divides (power p (n-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\n",
                "context_tokens": 698,
                "proof_start_offset": 5286,
                "proof_end_offset": 6579,
                "proof": "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\nassert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\nassert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\nrewrite power_mult_lemma1 in H8;rewrite H8 in H4.\nrewrite power_mult_lemma1 in H9;rewrite H9 in H4.\nrewrite mult_lemma7 in H4.\nassert ((power (gcd a b) n)<>O).\nintro.\ngeneralize (power_zero n (gcd a b) H10);intro.\napply (gcd_non_zero (gcd a b) a b);trivial.\ngeneralize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\nfold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\napply nth_root_irrat_aux;trivial.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nelim (le_gt_dec 0 p); intro.\nrewrite <- H0.\napply lt_le_weak; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; assumption.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros.\n destruct (le_gt_dec r p) as [p|p].\n (* 0 < p *)\n rewrite <- le_plus_minus_minus_minus_r, <- le_plus_minus_r; assumption.\n apply lt_le_trans with (p*r).\n apply (le_lt_trans (p*r) (r*k*p)); assumption.\n apply le_lt_trans with (r*k*r); [ apply le_plus_minus | apply le_plus_minus_r ].\n apply le_lt_trans with (r*k*r); [ apply le_plus_minus | apply le_plus_minus_r ].\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_plus_minus_r.\n apply le_minus_r.\n apply lt_le_trans with (r*k*r); [ apply le_plus_minus | apply le_plus_minus_r ].\n apply le_plus_minus_r.\n apply le_minus_r.\n apply le_minus_r.\n apply le_minus_Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nintros p k a b n r H0.\napply le_lt_trans with (p*r); trivial.\napply le_trans with (p*r); trivial.\napply le_trans with (p*r); trivial.\napply le_trans with (p*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (p*r); trivial.\napply le_trans with (p*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*r); trivial.\napply le_trans with (r*Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros.\n apply prime_div_prime_1.\n apply prime_power_pos;auto.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros.\n apply (le_gt_cases n r);intro.\n assert (0 < n).\n  apply (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (S n))) (S n)) r);intro.\n  apply (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (S n))) r));intro.\n  apply (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (S n))) r));intro.\n  apply (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (S n))) r));intro.\n  apply (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (S n)))) r));intro.\n  apply (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (S n))) r));intro.\n  apply (lt_wf (lt_wf (lt_wf (lt_wf (lt_wf (S n))) r));intro.\n  apply (ltQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply prime_power with n;trivial.\n  generalize (factor_factor_correct p k a b n r);intro.\n  elim H1;intros.\n  rewrite H2 in H3.\n  rewrite mult_assoc in H4;rewrite H4 in H4.\n  rewrite mult_comm in H4;rewrite H4 in H4.\n  rewrite mult_assoc in H4.\n  rewrite mult_assoc in H4;rewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4.\n  rewrite (mult_comm n n0); rewrite (mult_comm m n); rewrite (mult_comm m n0);\n    rewrite (mult_comm m n0); rewrite (mult_comm m n0); reflexivity.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  destruct (le_lt_dec (power p r) (r+n)).\n  destruct (le_lt_dec (p+r) 0) as [H|H].\n  left.\n  elim H;intro q;intros.\n  rewrite H1.\n  apply H;apply H0;apply H1;apply H1;apply H0;apply H1;apply H2;apply H1;apply H1;apply H2;apply H1;apply H2;apply H2;apply H2;apply H2;apply H1;apply H2;apply H1;apply H2;apply H1; apply H2;apply H2;apply H2; apply H2;apply H2; apply H2; apply H3; apply H1; apply H2; apply H3; apply H2;\n    apply H3; apply H3;apply H3; apply H3; apply H4; apply H3; apply H4; apply H4;\n    apply H4; apply H3; apply H2; apply H4; apply H4; apply H4; apply H4; apply H1;\n    apply H3Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  destruct p; simpl; trivial.\n  apply prime_power_prime; trivial.\n  apply prime_power_prime; trivial.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  assert (forall n, is_prime p -> exists n, is_prime p -> n=0).\n  intros.\n  apply prime_prime_non_prime; auto.\n  apply prime_prime_non_prime; auto.\n  apply prime_prime_non_prime; auto.\n  apply prime_prime_non_prime; auto.\n  apply prime_prime_non_prime; auto.\n  apply prime_prime_non_prime; auto.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros.\n destruct a, b; destruct r; simpl; intros; trivial.\n apply (lt_irrefl n).\n apply (lt_trans _ _ _ _ _ _ H0 H1).\n apply (lt_irrefl n).\n apply (lt_trans _ _ _ _ _ H0 H1).\n apply (lt_trans _ _ _ _ _ H1 H2).\n apply (lt_trans _ _ _ _ H2 H0).\n apply (lt_trans _ _ _ _ _ H1 H2).\n apply (lt_trans _ _ _ _ H1 H2).\n apply (lt_trans _ _ _ _ H1).\n apply (lt_trans _ _ _ H2 H2).\n apply (lt_trans _ _ _ H3 H4).\n apply (lt_trans _ _ _ H3).\n apply (lt_trans _ _ _ H4 H1 H2).\n apply (lt_trans _ _ _ H4 H1).\n apply (lt_trans _ _ _ H2 H2 H2).\n apply (lt_trans _ _ _ H1 H2).\n apply (lt_trans _ _ _ H2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\nTheorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\n  assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\n  assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\n",
                "context_tokens": 691,
                "proof_start_offset": 6627,
                "proof_end_offset": 7532,
                "proof": "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nrewrite power_plus_lemma1 in H4.\nassert (divides a (power p q)).\napply prime_power_qn with n;try (auto with arith);try omega.\nexists ((power p r)*k*(power b n)).\nrewrite <- H4;ring.\nassert (0<n);try omega.\nelim H5;intro a';intro.\nrewrite H7 in H4.\nrewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\nassert ((power p (q*n))<>0).\nintro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\nrewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\ngeneralize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\nfold (power p r * k * power b n <> power a' n).\napply nth_root_irrat;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\napply (Build_Q_correct p k a b n q r H).\napply H; trivial.\napply (H (S n)).\napply (H0 (S n)).\napply (H0 (S n)).\napply (H0 (S n)).\napply (H1 (S n)).\napply (H2 (S n)).\napply (H0 (S n)).\napply (H1 (S n)).\napply (H1 (S n)).\napply (H2 (S n)).\napply (H2 (S n)).\napply (H1 (S n)).\napply (H2 (S n)).\napply (H2 (S n)).\napply (H0 (S n)).\napply (H2 (S n)).\napply (H1 (S n)).\napply (H1 (S n)).\napply (H2 (S n)).\napply (H2 (S n)).\napply (H0 (S n)).\napply (H1 (S n)).\napply (H1 (S n)).\napply (H1 (S n)).\napply (H1 (S n)).\napply (Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\nunfold prime in |- *.\nintros p k a b n r (H1,H2).\nelim (lt_or_eq r (prime q - a)).\nintros.\nrewrite H2.\nrewrite H3.\nrewrite H3.\napply H2; assumption.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\napply le_trans with (p*q) + p*k*(1+r)).\nreplace (power p (S k*r)) with (1*power p (S k*r)).\napply (fun (n:=p) (q*r)).\nrewrite <- mult_assoc.\napply le_plus_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply lt_le_minus_r.\napply lt_le_trans with (p*q) + p*k*r).\napply (fun (n:=p) (q*r).\nrewrite <- mult_assoc.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply lt_le_trans with (p*q).\napply (fun (n:=p) (q*r).\nrewrite <- mult_assoc.\napply le_minus_r.\napply le_minus_r.\napply leQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r H1 H2 H3;\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n generalize (gcd_is_gcd a b);intro.\n apply (gcd_is_gcd b q r); auto.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n q r H_step.\n  apply\n   nth_root_nR with (p := p)(q:=r).\n  apply prime_gt_0; trivial.\n  apply prime_gt_0; trivial.\n  apply prime_gt_1; trivial.\n  apply prime_gt_1; trivial.\n  apply prime_gt_1; trivial.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  generalize (nth_root_nR p k a b n q r); intro.\n  rewrite H0.\n  rewrite H0.\n  rewrite H1.\n  rewrite H1.\n  rewrite H2.\n  rewrite H2.\n  rewrite H2.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H2.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H1.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H4.\n  rewriteQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r H.\napply\n (fun (p q r:nat)(H:is_prime q) =>\n (is_prime p /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q)) q)) n))\n  (fun (p q r:nat)(H:is_prime q) =>\n (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q))) q))\n  (fun (p q r:nat)(H:is_prime q) =>\n (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q)) q))\n  (fun (p q r:nat)(H0:is_prime q) =>\n (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime q /\\ (is_prime qQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\nelim (interp_non_zero p); intros.\napply H;apply H0.\napply lt_le_trans with (S (q*n)); auto.\napply H;apply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply le_lt_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_trans with (S (q*n)); auto.\napply lt_le_Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r H0 H1 H2.\nrewrite <- (IHn p k a b n q r H0 H2); ring.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\napply (nth_root_non_zero p q); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": " b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\nTheorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  rewrite power_plus_lemma1 in H4.\n  assert (divides a (power p q)).\n  apply prime_power_qn with n;try (auto with arith);try omega.\n  exists ((power p r)*k*(power b n)).\n  rewrite <- H4;ring.\n  assert (0<n);try omega.\n  elim H5;intro a';intro.\n  rewrite H7 in H4.\n  rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\n  assert ((power p (q*n))<>0).\n  intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\n  rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\n  generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\n  fold (power p r * k * power b n <> power a' n).\n  apply nth_root_irrat;trivial.\nQed.\n\n(** let x and n be two numbers such that n > 0, then either the n-th root of x is a natural number of it is not rationnal *)\n",
                "context_tokens": 706,
                "proof_start_offset": 7659,
                "proof_end_offset": 8047,
                "proof": "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\nintros.\ncase (is_power_m_dec x n H);intro;try tauto.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nright;intros.\nassert (x=(power p (q*n+r))*k);try tauto.\nrewrite H1;apply nth_root_irrational;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros.\n  set (x:=x).\n  set (y:=x).\n  set (y:=x).\n  set (x:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (x:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=y).\n  set (y:=y).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=y).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=x).\n  set (y:=y).\n  set (y:=x).\n  set (y:=x).\n  set (y:=Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n intros x n; induction n; simpl; auto with arith.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros.\n  apply le_trans with (power (a * b) 0%nat).\n  apply le_trans with (power b n).\n  apply le_trans with (power b n);try apply le_trans with (power b n).\n  apply le_trans with (power b n);try apply le_n_S;try apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_S;apply le_n_Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros.\n  destruct x; destruct y; simpl; auto.\n  assert (n<>0); try omega.\n  elim H; intro.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H2 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n intros.\n destruct x.\n rewrite (IHn (nat_of_P x) (nat_of_P x)).\n destruct x.\n rewrite (IHn (nat_of_P x) (nat_of_P x)) by auto with arith.\n destruct x0.\n rewrite (IHn (nat_of_P x) (nat_of_P x0)) by auto with arith.\n destruct x0.\n rewrite (IHn (nat_of_P x) (nat_of_P x0)) by auto with arith.\n destruct x0.\n rewrite (IHn (nat_of_P x0) (nat_of_P x0)) by auto with arith.\n destruct x0.\n rewrite (IHn (nat_of_P x0) (nat_of_P x0)) by auto with arith.\n apply nth_error_no_in; auto with arith.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros x n H.\n  apply le_trans with (pred x).\n  apply H.\n  apply le_trans with (pred x).\n  apply H.\n  apply le_trans with (pred x).\n  apply H.\n  apply H.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\nintros.\nrewrite <- (mult_comm x).\napply mult_le_compat_r; trivial.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\nintros x n.\nintro.\nrewrite <- mult_assoc.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\nrewrite <- mult_assoc.\napply mult_le_compat_r;try assumption.\nrewrite <- mult_assoc.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\nrewrite mult_assoc.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\napply mult_le_compat_r;try assumption.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\napply multQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\nintros.\ngeneralize (nth_root_irr 0 x).\ninduction x;intros.\nrewrite mult_0_r.\nrewrite <- mult_1_l.\nrewrite (mult_comm (a*n) (b*n)).\nrewrite mult_assoc.\nrewrite (mult_comm (b*n)).\nrewrite mult_comm.\nrewrite (mult_comm a).\nrewrite (mult_comm (b*n)).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm a).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm a).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_comm b).\nrewrite (mult_commQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros.\n  case_eq (nat_of_P n) as [H|H].\n  - intros n H.\n    contradict H.\n    apply IHn.\n    apply le_trans with (n - x).\n    rewrite <- H.\n    rewrite <- H.\n    rewrite <- H.\n    apply le_n.\n    rewrite <- H.\n    apply le_n_S.\n  - intros n H.\n    contradict H.\n    apply IHn.\n    apply le_trans with (n - x).\n    rewrite <- H.\n    apply le_n_S.\n    apply IHn.\n    apply le_n_S.\n    apply IHn.\n    apply le_n_S.\n    apply IHn.\n    apply le_trans with (S n).\n    rewrite <- H.\n    apply le_n_S.\n    apply IHn.\n    apply le_n_S.\n    apply IHn.\n    apply le_n_S.\n    apply IHn.\n    apply le_trans with (S n).\n    rewrite <- H.\n    apply le_n_S.\n    apply le_n_S.\n    apply IHn.\n    apply le_n_S.\nQed."
                ]
            }
        ]
    }
}